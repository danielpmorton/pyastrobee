{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Pyastrobee: A space robotics simulation environment in Python Documentation The full documentation can be accessed here The \"helpful notes\" pages can be found on the sidebar of this site, as well as in this readme. For the code documentation, expand the Reference section in the sidebar and explore each module in the drop-down menus. Alternatively, search for a specific keyword with the searchbar above. We use Portray to build the documentation. Note: if you'd like a local copy of the documentation with the most up-to-date information, run portray in_browser in the main repo folder. Helpful notes: Getting Started : Setting up the repository Additional Installs : Additional installs important for working with the project Loading ISS Meshes : Dealing with complex meshes and textures in Pybullet Re-texturing : How to modify Astrobee meshes to load the URDF with a single texture file Meshing : Tips on creating new (triangular) meshes to load into Pybullet Tetrahedral Meshing : How to generate and modify tetrahedral meshes for soft bodies Bag Dynamics : Some notes on defining mass/inertia values of the cargo bag Using NASA's simulator : Helpful commands and installation debugging (optional) Assorted Pybullet tips : Important notes that might not be clear from the quickstart guide References : Links to hepful resources","title":"Home"},{"location":"#pyastrobee-a-space-robotics-simulation-environment-in-python","text":"","title":"Pyastrobee: A space robotics simulation environment in Python"},{"location":"#documentation","text":"The full documentation can be accessed here The \"helpful notes\" pages can be found on the sidebar of this site, as well as in this readme. For the code documentation, expand the Reference section in the sidebar and explore each module in the drop-down menus. Alternatively, search for a specific keyword with the searchbar above. We use Portray to build the documentation. Note: if you'd like a local copy of the documentation with the most up-to-date information, run portray in_browser in the main repo folder.","title":"Documentation"},{"location":"#helpful-notes","text":"Getting Started : Setting up the repository Additional Installs : Additional installs important for working with the project Loading ISS Meshes : Dealing with complex meshes and textures in Pybullet Re-texturing : How to modify Astrobee meshes to load the URDF with a single texture file Meshing : Tips on creating new (triangular) meshes to load into Pybullet Tetrahedral Meshing : How to generate and modify tetrahedral meshes for soft bodies Bag Dynamics : Some notes on defining mass/inertia values of the cargo bag Using NASA's simulator : Helpful commands and installation debugging (optional) Assorted Pybullet tips : Important notes that might not be clear from the quickstart guide References : Links to hepful resources","title":"Helpful notes:"},{"location":"docs/additional_installs/","text":"Installing additional software Prerequisites: Ubuntu >= 20.04 cmake sudo apt install cmake numpy pip install numpy Notes If you're installing things on a low-memory machine, cmake may fail during the build process for Astrobee or Bullet. If this happens, try building it again with a -j1 flag Root access is required for both the ROS install and the Astrobee install. Pyenv This is what I use to manage my virtual environments and python versions ( uv , conda , and more also work) curl https://pyenv.run | bash Then, set up ~/.bashrc -- Make sure the following lines are included export PYENV_ROOT = \"$HOME/.pyenv\" command - v pyenv >/ dev / null || export PATH = \"$PYENV_ROOT/bin:$PATH\" eval \"$(pyenv init -)\" eval \"$(pyenv virtualenv-init -)\" If the Pyenv Python install fails and warns about things not being installed, run this command to make sure the dependencies are up to date. (Then, retry the command that failed) sudo apt-get update; sudo apt-get install --no-install-recommends make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-dev ROS Noetic wget -c https://raw.githubusercontent.com/qboticslabs/ros_install_noetic/master/ros_install_noetic.sh && chmod +x ./ros_install_noetic.sh && ./ros_install_noetic.sh Refer to http://wiki.ros.org/noetic/Installation/Ubuntu for more info OpenGL This can sometimes be necessary when building Bullet from source sudo apt-get install libglu1-mesa-dev freeglut3-dev mesa-common-dev Blender sudo snap install blender --classic If snap is not available, Go to https://www.blender.org/download/ Download the Linux file Extract the file to $HOME/software Run via the blender executable file in the blender folder ( chmod u+x blender if it's not executable) V-HACD cd $HOME/software git clone https://github.com/kmammou/v-hacd cd v-hacd/app cmake -S . -B build -DCMAKE_BUILD_TYPE=Release cmake --build build Meshlab Go to https://www.meshlab.net/#download Download the Linux AppImage Move the file to $HOME/software chmod u+x the AppImage to make it executable Assimp This is only required if you'll be modifying/converting meshes outside of Blender sudo apt install libassimp-dev sudo apt install assimp-utils GMSH This is needed for modifying/creating tetrahedral meshes 1. Go to https://gmsh.info/ and click on the Linux download link 2. Extract the contents to $HOME/software or your preferred location","title":"Additional Installs"},{"location":"docs/additional_installs/#installing-additional-software","text":"","title":"Installing additional software"},{"location":"docs/additional_installs/#prerequisites","text":"Ubuntu >= 20.04 cmake sudo apt install cmake numpy pip install numpy","title":"Prerequisites:"},{"location":"docs/additional_installs/#notes","text":"If you're installing things on a low-memory machine, cmake may fail during the build process for Astrobee or Bullet. If this happens, try building it again with a -j1 flag Root access is required for both the ROS install and the Astrobee install.","title":"Notes"},{"location":"docs/additional_installs/#pyenv","text":"This is what I use to manage my virtual environments and python versions ( uv , conda , and more also work) curl https://pyenv.run | bash Then, set up ~/.bashrc -- Make sure the following lines are included export PYENV_ROOT = \"$HOME/.pyenv\" command - v pyenv >/ dev / null || export PATH = \"$PYENV_ROOT/bin:$PATH\" eval \"$(pyenv init -)\" eval \"$(pyenv virtualenv-init -)\" If the Pyenv Python install fails and warns about things not being installed, run this command to make sure the dependencies are up to date. (Then, retry the command that failed) sudo apt-get update; sudo apt-get install --no-install-recommends make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-dev","title":"Pyenv"},{"location":"docs/additional_installs/#ros-noetic","text":"wget -c https://raw.githubusercontent.com/qboticslabs/ros_install_noetic/master/ros_install_noetic.sh && chmod +x ./ros_install_noetic.sh && ./ros_install_noetic.sh Refer to http://wiki.ros.org/noetic/Installation/Ubuntu for more info","title":"ROS Noetic"},{"location":"docs/additional_installs/#opengl","text":"This can sometimes be necessary when building Bullet from source sudo apt-get install libglu1-mesa-dev freeglut3-dev mesa-common-dev","title":"OpenGL"},{"location":"docs/additional_installs/#blender","text":"sudo snap install blender --classic If snap is not available, Go to https://www.blender.org/download/ Download the Linux file Extract the file to $HOME/software Run via the blender executable file in the blender folder ( chmod u+x blender if it's not executable)","title":"Blender"},{"location":"docs/additional_installs/#v-hacd","text":"cd $HOME/software git clone https://github.com/kmammou/v-hacd cd v-hacd/app cmake -S . -B build -DCMAKE_BUILD_TYPE=Release cmake --build build","title":"V-HACD"},{"location":"docs/additional_installs/#meshlab","text":"Go to https://www.meshlab.net/#download Download the Linux AppImage Move the file to $HOME/software chmod u+x the AppImage to make it executable","title":"Meshlab"},{"location":"docs/additional_installs/#assimp","text":"This is only required if you'll be modifying/converting meshes outside of Blender sudo apt install libassimp-dev sudo apt install assimp-utils","title":"Assimp"},{"location":"docs/additional_installs/#gmsh","text":"This is needed for modifying/creating tetrahedral meshes 1. Go to https://gmsh.info/ and click on the Linux download link 2. Extract the contents to $HOME/software or your preferred location","title":"GMSH"},{"location":"docs/bag_dynamics/","text":"Bag Dynamics Geometry The coordinate frame below indicates the orientation of the bag when it is loaded into Pybullet as a rigid object. The origin of the bag is at the center of the rectangular prism. . +------+ Z . ' | .' | | y +---+--+ ' | | / | | | | |/----> x H | .+--+---+ |.' | . ' W +------+' L The CAD model (and the mesh) has the following dimensions: L = 50 cm (0.50 m) W = 25 cm (0.25 m) H = 42 cm (0.42 m) Inertia If we assume any effects from the handle are negligible, that the bag is perfectly rectangular, and that the distribution of mass inside the bag is uniform, the inertia tensor is as follows: $$ I = \\begin{bmatrix} I_{xx} & 0 & 0\\ 0 & I_{yy} & 0\\ 0 & 0 & I_{zz} \\end{bmatrix} $$ where (in the coordinate frame shown above) $I_{xx} = \\frac{1}{12}m(W^2 + H^2)$ $I_{yy} = \\frac{1}{12}m(L^2 + H^2)$ $I_{zz} = \\frac{1}{12}m(L^2 + W^2)$ If we want to add a nonuniform distribution of the mass in the future, we will most likely have to do something weird, because Pybullet's changeDynamics function seems to only handle the diagonal inertia entries. But, there also seems to be more fine-tuned control of inertia matrices in URDFs. If we set $m = 10$ (as an example), this gives us the following inertia tensor: $$ I = \\begin{bmatrix} 0.19990833 & 0 & 0\\ 0 & 0.35533333 & 0\\ 0 & 0 & 0.26041666 \\end{bmatrix} $$ Pybullet notes Rigid body dynamics and origin location I originally wondered if it would be easier to make the URDF if we had the bag mesh defined with the origin centered at the handle. However, after loading this mesh into Pybullet, I noticed it had very odd dynamics. It seemed that the center of mass was way off - near the handle. Originally, I was wondering if this was because the mesh was denser in this area, but the same mesh with a different origin didn't have this issue. So, it seems that Pybullet defines the center of mass for an imported mesh by its origin! This is quite important to remember - especially when we are loading a mesh outside of a URDF (which may specifically define the inertial frame and the moments of inertia). I suppose with the changeDynamics function we might be able to get around this, but for now, we can just remember to create all of the CAD with this in mind. Softbody dynamics Position and orientation of the softbody are relatively accurate with Pybullet's getBasePositionAndOrientation function, but getBaseVelocity does not seem to provide an accurate measurement. I've written a function get_bag_frame to determine a local reference frame for the bag based on the corners of the main compartment, which may be useful because getBasePositionAndOrientation is slightly unclear in how this is actually calculated. From preliminary tests, it looks like both frames (from my method and pybullet's) are roughly the same. However, this does not solve the velocity issue (a future TODO). We may be able to track the position/orientation across multiple timesteps and calculate the velocity that way, if it comes down to it and we need that info.","title":"Bag Dynamics"},{"location":"docs/bag_dynamics/#bag-dynamics","text":"","title":"Bag Dynamics"},{"location":"docs/bag_dynamics/#geometry","text":"The coordinate frame below indicates the orientation of the bag when it is loaded into Pybullet as a rigid object. The origin of the bag is at the center of the rectangular prism. . +------+ Z . ' | .' | | y +---+--+ ' | | / | | | | |/----> x H | .+--+---+ |.' | . ' W +------+' L The CAD model (and the mesh) has the following dimensions: L = 50 cm (0.50 m) W = 25 cm (0.25 m) H = 42 cm (0.42 m)","title":"Geometry"},{"location":"docs/bag_dynamics/#inertia","text":"If we assume any effects from the handle are negligible, that the bag is perfectly rectangular, and that the distribution of mass inside the bag is uniform, the inertia tensor is as follows: $$ I = \\begin{bmatrix} I_{xx} & 0 & 0\\ 0 & I_{yy} & 0\\ 0 & 0 & I_{zz} \\end{bmatrix} $$ where (in the coordinate frame shown above) $I_{xx} = \\frac{1}{12}m(W^2 + H^2)$ $I_{yy} = \\frac{1}{12}m(L^2 + H^2)$ $I_{zz} = \\frac{1}{12}m(L^2 + W^2)$ If we want to add a nonuniform distribution of the mass in the future, we will most likely have to do something weird, because Pybullet's changeDynamics function seems to only handle the diagonal inertia entries. But, there also seems to be more fine-tuned control of inertia matrices in URDFs. If we set $m = 10$ (as an example), this gives us the following inertia tensor: $$ I = \\begin{bmatrix} 0.19990833 & 0 & 0\\ 0 & 0.35533333 & 0\\ 0 & 0 & 0.26041666 \\end{bmatrix} $$","title":"Inertia"},{"location":"docs/bag_dynamics/#pybullet-notes","text":"","title":"Pybullet notes"},{"location":"docs/bag_dynamics/#rigid-body-dynamics-and-origin-location","text":"I originally wondered if it would be easier to make the URDF if we had the bag mesh defined with the origin centered at the handle. However, after loading this mesh into Pybullet, I noticed it had very odd dynamics. It seemed that the center of mass was way off - near the handle. Originally, I was wondering if this was because the mesh was denser in this area, but the same mesh with a different origin didn't have this issue. So, it seems that Pybullet defines the center of mass for an imported mesh by its origin! This is quite important to remember - especially when we are loading a mesh outside of a URDF (which may specifically define the inertial frame and the moments of inertia). I suppose with the changeDynamics function we might be able to get around this, but for now, we can just remember to create all of the CAD with this in mind.","title":"Rigid body dynamics and origin location"},{"location":"docs/bag_dynamics/#softbody-dynamics","text":"Position and orientation of the softbody are relatively accurate with Pybullet's getBasePositionAndOrientation function, but getBaseVelocity does not seem to provide an accurate measurement. I've written a function get_bag_frame to determine a local reference frame for the bag based on the corners of the main compartment, which may be useful because getBasePositionAndOrientation is slightly unclear in how this is actually calculated. From preliminary tests, it looks like both frames (from my method and pybullet's) are roughly the same. However, this does not solve the velocity issue (a future TODO). We may be able to track the position/orientation across multiple timesteps and calculate the velocity that way, if it comes down to it and we need that info.","title":"Softbody dynamics"},{"location":"docs/getting_started/","text":"Getting started An overview of how to set up the repository, virtual environment, and pip dependencies Prerequisites Information on installing software prerequisites can be found here Once these are installled, continue with the setup process Cloning the repo cd $HOME git clone https://github.com/danielpmorton/pyastrobee Virtual environment A virtual environment is optional, but highly recommended. Pyenv was found to work a bit better than conda here. # pyenv install 3 . 10 . 8 ( if not already installed ) pyenv virtualenv 3 . 10 . 8 astrobee pyenv shell astrobee Install dependencies Install all packages except for pybullet: cd $HOME/pyastrobee pip install -e . Install pybullet from source: export BULLET_DIR =$ HOME / software / bullet3 # Can change this install location as desired git clone https : // github . com / danielpmorton / bullet3 $ BULLET_DIR cd $ BULLET_DIR git remote add upstream https : // github . com / bulletphysics / bullet3 ./ build_cmake_pybullet_double . sh # Locally build Bullet/Pybullet pip install . After doing this, open a python interpreter and run the following commands: import pybullet pybullet . isNumpyEnabled () The isNumpyEnabled() line should return 1 . If not, pip uninstall pybullet , then make sure that numpy is installed in your current environment, and retry the pip installation seen above. Interacting with the Astrobee With everything installed, confirm that things are loading properly: For an interactive keyboard-based demo of the Astrobee inside the ISS, run pyastrobee/control/keyboard_controller.py Alternatively, check out pyastrobee/scripts/demo.py for an example of how to control the Astrobee in a script","title":"Getting Started"},{"location":"docs/getting_started/#getting-started","text":"An overview of how to set up the repository, virtual environment, and pip dependencies","title":"Getting started"},{"location":"docs/getting_started/#prerequisites","text":"Information on installing software prerequisites can be found here Once these are installled, continue with the setup process","title":"Prerequisites"},{"location":"docs/getting_started/#cloning-the-repo","text":"cd $HOME git clone https://github.com/danielpmorton/pyastrobee","title":"Cloning the repo"},{"location":"docs/getting_started/#virtual-environment","text":"A virtual environment is optional, but highly recommended. Pyenv was found to work a bit better than conda here. # pyenv install 3 . 10 . 8 ( if not already installed ) pyenv virtualenv 3 . 10 . 8 astrobee pyenv shell astrobee","title":"Virtual environment"},{"location":"docs/getting_started/#install-dependencies","text":"Install all packages except for pybullet: cd $HOME/pyastrobee pip install -e . Install pybullet from source: export BULLET_DIR =$ HOME / software / bullet3 # Can change this install location as desired git clone https : // github . com / danielpmorton / bullet3 $ BULLET_DIR cd $ BULLET_DIR git remote add upstream https : // github . com / bulletphysics / bullet3 ./ build_cmake_pybullet_double . sh # Locally build Bullet/Pybullet pip install . After doing this, open a python interpreter and run the following commands: import pybullet pybullet . isNumpyEnabled () The isNumpyEnabled() line should return 1 . If not, pip uninstall pybullet , then make sure that numpy is installed in your current environment, and retry the pip installation seen above.","title":"Install dependencies"},{"location":"docs/getting_started/#interacting-with-the-astrobee","text":"With everything installed, confirm that things are loading properly: For an interactive keyboard-based demo of the Astrobee inside the ISS, run pyastrobee/control/keyboard_controller.py Alternatively, check out pyastrobee/scripts/demo.py for an example of how to control the Astrobee in a script","title":"Interacting with the Astrobee"},{"location":"docs/loading_iss_meshes/","text":"Loading ISS meshes into Pybullet Dealing with Pybullet's quirks Loading complex meshes with lots of textures into pybullet is tricky. Ideally, we'd be able to just load a URDF and call it a day, but that just doesn't seem to be possible if you want all of the textures to appear. So, we have to resort to loading multiple OBJs. If you load an OBJ file through createVisualShape() , this will look for an MTL file in the same directory and apply it to the OBJ. However, if the OBJ has multiple bodies each with different textures, pybullet will mess this up and apply only one of the textures to every body in the OBJ. To fix this problem, we have to separate the complex mesh into multiple OBJs, with each OBJ corresponding to a single texture. We can use Erwin's obj2sdf tool for this, even if we're not using an SDF. For the collision side of things, if we just import an ISS module into pybullet, the collision body will not be the mesh itself, but rather the convex hull of the entire body (which is not useful for us, since we need to go inside the ISS). Running VHACD is the solution here - this will give us a decomposition of the module into multiple convex hulls and allow for it to be hollow. VHACD should be run on each module, not each part within a module, because each part is complex and oddly shaped (for instance, all of the handles in a module are it's own OBJ, since all handles have the same texture) Once we have the OBJs for each texture, and the VHACD OBJ for collision info, we can start loading these into pybullet. We now have some number n different obj files which represent the visual components of the ISS module, but we only have 1 VHACD file for the module. So, we'll load the first visual component paired with the VHACD collision information, and for the remainder of the bodies, we'll load them strictly as visual elements by setting the collision ID in the multibody as -1. Note: it does not appear to be possible to create an \"invisible\" collision body, because if you set the visual ID in the multibody as -1, it will still visualize the collision mesh but in a bunch of random colors. A full workflow of the steps required to go from the NASA-provided DAE meshes to a correct pybullet environment can be found below: 0. Folder structure This is what the directory will look like at the end of the process: meshes \u251c\u2500\u2500 dae \u2502 \u251c\u2500\u2500 cupola \u2502 \u2502 \u251c\u2500\u2500 *. png # From Blender DAE export \u2502 \u2502 \u2514\u2500\u2500 cupola . dae # From Blender DAE export \u2502 \u251c\u2500\u2500 eu_lab \u2502 \u251c\u2500\u2500 iss \u2502 \u251c\u2500\u2500 jpm \u2502 \u251c\u2500\u2500 node_1 \u2502 \u251c\u2500\u2500 node_2 \u2502 \u251c\u2500\u2500 node_3 \u2502 \u2514\u2500\u2500 us_lab \u2514\u2500\u2500 obj \u251c\u2500\u2500 cupola \u2502 \u251c\u2500\u2500 cupola . mtl # From Blender OBJ export \u2502 \u251c\u2500\u2500 cupola . obj # From Blender OBJ export \u2502 \u251c\u2500\u2500 decomp . mtl # From vhacd: Unused \u2502 \u251c\u2500\u2500 decomp . obj # From vhacd: Collision body \u2502 \u251c\u2500\u2500 decomp . stl # From vhacd: Unused \u2502 \u251c\u2500\u2500 newsdf . sdf # From obj2sdf: Unused \u2502 \u2514\u2500\u2500 part *. obj # From obj2sdf: One obj per texture \u251c\u2500\u2500 eu_lab \u251c\u2500\u2500 iss \u251c\u2500\u2500 jpm \u251c\u2500\u2500 node_1 \u251c\u2500\u2500 node_2 \u251c\u2500\u2500 node_3 \u251c\u2500\u2500 us_lab \u2514\u2500\u2500 textures \u2514\u2500\u2500 *. png # From astrobee_media textures folder 1. Fix problematic texture images Certain texture PNG images are unable to be loaded into pybullet. After some debugging, this appears to be an issue with the PNG filetype - some were exported as PNG8 whereas others are PNG16/24. Pybullet seems to need PNGs to be 8-bit, so these need to be converted. To do so, import each problematic PNG into Gimp and then export/overwrite the image to the same location, with the pixelformat dropdown set to 8bpc RGBA Problematic images: Generic_Intersection.png Node2_Interior_Racks.png Node2_Bulkheads.png 2. Blender The meshes for the ISS were loaded in crazy locations and orientations because NASA didn't do the best job of exporting them in the correct positions when they made the files. (This is why in the URDF, each module has its own position, orientation, and even scale). So, I just re-organized all of the components in Blender and then exported them with the correct properties. Open blender Import each dae file from the astrobee_media repo Position each component to match the true ISS layout - confirm this against the ROS/Gazebo result Make sure everything is deselected, then export the full ISS DAE and OBJ Click to select each module, and for each one, export the DAE and the OBJ If exporting DAE, select the following options: Selection Only Include Children If exporting OBJ, select the following options: Grouping -> Material Groups This will add (module).obj and (module).mtl into the obj/(module) folder. The dae folder is a backup in case this is needed later. (2.5) A script for running both OBJ2SDF and VHACD Prior to running steps 3 and 4, consider using the script at pyastrobee/scripts/manage_objs.sh , which will loop through the directory structure and automatically run these commands on the files. The only requirement is that the directory containing the OBJs is set up so each folder corresponds to an ISS module, containing that module's multi-texture OBJ inside it (with the same name). See the Folder Structure section above for reference. If you use this script, and it runs without issue, you can safely skip steps 3 and 4. 3. OBJ2SDF (Ensure that the C++ version of Bullet is locally built first) For each module OBJ in its respective folder (i.e. obj/(module)/(module).obj ), run obj2sdf as follows: For example: cd ~/pyastrobee/pyastrobee/assets/meshes/iss/obj/cupola ./../../../software/bullet3/build_cmake/Extras/obj2sdf/App_obj2sdf --fileName=\"cupola.obj\" This will add newsdf.sdf and multiple part*.obj files, one per texture, into the obj/(module) folder. 4. VHACD For each module OBJ in its respective folder (i.e. obj/(module)/(module).obj ), run VHACD as follows: For example: cd ~/pyastrobee/pyastrobee/assets/meshes/iss/obj/cupola ./../../../software/v-hacd-4.1.0/app/build/TestVHACD cupola.obj This will add decomp.obj , decomp.mtl , and decomp.stl to the obj/(module) folder. 5. Final adjustments Refine VHACD - The VHACD output will most likely not be perfect. There seems to be no exact combination of parameters that leads to an exact decomposition of the ISS (see the vhacd readme for more info on these). In particular, VHACD tends to poorly represent the corridors between the modules, leading to a very tight pathway. So, to fix this, open the decomp.obj VHACD result for each module in Blender and update the file manually (as in, replace any \"bad\" convex hulls with simple objects in Blender, like rectangular prisms). Update the paths The paths at the top of the OBJ/MTL files from this output ( part0 , part1 , ...) will be absolute paths, but pybullet works best with these as relative paths. These will need to be manually modified with a quick directory search/replace. For MTL files especially, ensure that these are pointing to files inside the obj/textures directory 6. Importing into Pybullet For each module, For the first OBJ file, load it as a visual shape. Pybullet will see the associated MTL file in the same directory and apply the texture. For the collision body, load the full VHACD result for the entire module. For each other OBJ file, load the visual shape as before, but set the collision body to -1 , so that it doesn't load any collision info The ISS should be fully loaded at this point! \ud83d\ude03","title":"Loading Iss Meshes"},{"location":"docs/loading_iss_meshes/#loading-iss-meshes-into-pybullet","text":"Dealing with Pybullet's quirks Loading complex meshes with lots of textures into pybullet is tricky. Ideally, we'd be able to just load a URDF and call it a day, but that just doesn't seem to be possible if you want all of the textures to appear. So, we have to resort to loading multiple OBJs. If you load an OBJ file through createVisualShape() , this will look for an MTL file in the same directory and apply it to the OBJ. However, if the OBJ has multiple bodies each with different textures, pybullet will mess this up and apply only one of the textures to every body in the OBJ. To fix this problem, we have to separate the complex mesh into multiple OBJs, with each OBJ corresponding to a single texture. We can use Erwin's obj2sdf tool for this, even if we're not using an SDF. For the collision side of things, if we just import an ISS module into pybullet, the collision body will not be the mesh itself, but rather the convex hull of the entire body (which is not useful for us, since we need to go inside the ISS). Running VHACD is the solution here - this will give us a decomposition of the module into multiple convex hulls and allow for it to be hollow. VHACD should be run on each module, not each part within a module, because each part is complex and oddly shaped (for instance, all of the handles in a module are it's own OBJ, since all handles have the same texture) Once we have the OBJs for each texture, and the VHACD OBJ for collision info, we can start loading these into pybullet. We now have some number n different obj files which represent the visual components of the ISS module, but we only have 1 VHACD file for the module. So, we'll load the first visual component paired with the VHACD collision information, and for the remainder of the bodies, we'll load them strictly as visual elements by setting the collision ID in the multibody as -1. Note: it does not appear to be possible to create an \"invisible\" collision body, because if you set the visual ID in the multibody as -1, it will still visualize the collision mesh but in a bunch of random colors. A full workflow of the steps required to go from the NASA-provided DAE meshes to a correct pybullet environment can be found below:","title":"Loading ISS meshes into Pybullet"},{"location":"docs/loading_iss_meshes/#0-folder-structure","text":"This is what the directory will look like at the end of the process: meshes \u251c\u2500\u2500 dae \u2502 \u251c\u2500\u2500 cupola \u2502 \u2502 \u251c\u2500\u2500 *. png # From Blender DAE export \u2502 \u2502 \u2514\u2500\u2500 cupola . dae # From Blender DAE export \u2502 \u251c\u2500\u2500 eu_lab \u2502 \u251c\u2500\u2500 iss \u2502 \u251c\u2500\u2500 jpm \u2502 \u251c\u2500\u2500 node_1 \u2502 \u251c\u2500\u2500 node_2 \u2502 \u251c\u2500\u2500 node_3 \u2502 \u2514\u2500\u2500 us_lab \u2514\u2500\u2500 obj \u251c\u2500\u2500 cupola \u2502 \u251c\u2500\u2500 cupola . mtl # From Blender OBJ export \u2502 \u251c\u2500\u2500 cupola . obj # From Blender OBJ export \u2502 \u251c\u2500\u2500 decomp . mtl # From vhacd: Unused \u2502 \u251c\u2500\u2500 decomp . obj # From vhacd: Collision body \u2502 \u251c\u2500\u2500 decomp . stl # From vhacd: Unused \u2502 \u251c\u2500\u2500 newsdf . sdf # From obj2sdf: Unused \u2502 \u2514\u2500\u2500 part *. obj # From obj2sdf: One obj per texture \u251c\u2500\u2500 eu_lab \u251c\u2500\u2500 iss \u251c\u2500\u2500 jpm \u251c\u2500\u2500 node_1 \u251c\u2500\u2500 node_2 \u251c\u2500\u2500 node_3 \u251c\u2500\u2500 us_lab \u2514\u2500\u2500 textures \u2514\u2500\u2500 *. png # From astrobee_media textures folder","title":"0. Folder structure"},{"location":"docs/loading_iss_meshes/#1-fix-problematic-texture-images","text":"Certain texture PNG images are unable to be loaded into pybullet. After some debugging, this appears to be an issue with the PNG filetype - some were exported as PNG8 whereas others are PNG16/24. Pybullet seems to need PNGs to be 8-bit, so these need to be converted. To do so, import each problematic PNG into Gimp and then export/overwrite the image to the same location, with the pixelformat dropdown set to 8bpc RGBA Problematic images: Generic_Intersection.png Node2_Interior_Racks.png Node2_Bulkheads.png","title":"1. Fix problematic texture images"},{"location":"docs/loading_iss_meshes/#2-blender","text":"The meshes for the ISS were loaded in crazy locations and orientations because NASA didn't do the best job of exporting them in the correct positions when they made the files. (This is why in the URDF, each module has its own position, orientation, and even scale). So, I just re-organized all of the components in Blender and then exported them with the correct properties. Open blender Import each dae file from the astrobee_media repo Position each component to match the true ISS layout - confirm this against the ROS/Gazebo result Make sure everything is deselected, then export the full ISS DAE and OBJ Click to select each module, and for each one, export the DAE and the OBJ If exporting DAE, select the following options: Selection Only Include Children If exporting OBJ, select the following options: Grouping -> Material Groups This will add (module).obj and (module).mtl into the obj/(module) folder. The dae folder is a backup in case this is needed later.","title":"2. Blender"},{"location":"docs/loading_iss_meshes/#25-a-script-for-running-both-obj2sdf-and-vhacd","text":"Prior to running steps 3 and 4, consider using the script at pyastrobee/scripts/manage_objs.sh , which will loop through the directory structure and automatically run these commands on the files. The only requirement is that the directory containing the OBJs is set up so each folder corresponds to an ISS module, containing that module's multi-texture OBJ inside it (with the same name). See the Folder Structure section above for reference. If you use this script, and it runs without issue, you can safely skip steps 3 and 4.","title":"(2.5) A script for running both OBJ2SDF and VHACD"},{"location":"docs/loading_iss_meshes/#3-obj2sdf","text":"(Ensure that the C++ version of Bullet is locally built first) For each module OBJ in its respective folder (i.e. obj/(module)/(module).obj ), run obj2sdf as follows: For example: cd ~/pyastrobee/pyastrobee/assets/meshes/iss/obj/cupola ./../../../software/bullet3/build_cmake/Extras/obj2sdf/App_obj2sdf --fileName=\"cupola.obj\" This will add newsdf.sdf and multiple part*.obj files, one per texture, into the obj/(module) folder.","title":"3. OBJ2SDF"},{"location":"docs/loading_iss_meshes/#4-vhacd","text":"For each module OBJ in its respective folder (i.e. obj/(module)/(module).obj ), run VHACD as follows: For example: cd ~/pyastrobee/pyastrobee/assets/meshes/iss/obj/cupola ./../../../software/v-hacd-4.1.0/app/build/TestVHACD cupola.obj This will add decomp.obj , decomp.mtl , and decomp.stl to the obj/(module) folder.","title":"4. VHACD"},{"location":"docs/loading_iss_meshes/#5-final-adjustments","text":"Refine VHACD - The VHACD output will most likely not be perfect. There seems to be no exact combination of parameters that leads to an exact decomposition of the ISS (see the vhacd readme for more info on these). In particular, VHACD tends to poorly represent the corridors between the modules, leading to a very tight pathway. So, to fix this, open the decomp.obj VHACD result for each module in Blender and update the file manually (as in, replace any \"bad\" convex hulls with simple objects in Blender, like rectangular prisms). Update the paths The paths at the top of the OBJ/MTL files from this output ( part0 , part1 , ...) will be absolute paths, but pybullet works best with these as relative paths. These will need to be manually modified with a quick directory search/replace. For MTL files especially, ensure that these are pointing to files inside the obj/textures directory","title":"5. Final adjustments"},{"location":"docs/loading_iss_meshes/#6-importing-into-pybullet","text":"For each module, For the first OBJ file, load it as a visual shape. Pybullet will see the associated MTL file in the same directory and apply the texture. For the collision body, load the full VHACD result for the entire module. For each other OBJ file, load the visual shape as before, but set the collision body to -1 , so that it doesn't load any collision info The ISS should be fully loaded at this point! \ud83d\ude03","title":"6. Importing into Pybullet"},{"location":"docs/meshing/","text":"Meshing tips and notes This document will refer mainly to triangular meshes (OBJ), as opposed to tetrahedral meshes (VTK). For more info on tet meshes, see here . Steps Create CAD model (in whatever software works best) If round corners are desired over a purely rectangular body, use Fusion (they have a simple freeform modeler that works well for cargo-bag-like bodies) Try to design the part so that the center of mass lies at the origin. This is because if you load a (rigid) OBJ into Pybullet, it will specify its center of mass wherever the origin of the mesh is (which may be undesirable behavior depending on the part's geometry). Export the CAD body as an OBJ If there is a \"mesh refinement\" parameter in the export options, this should generally be at the lowest value such that no significant detail is lost Import the OBJ into MeshMixer This is generally the best software for remeshing that I've found, though MeshLab theoretically has similar tools (and works on more than just Windows) Remesh the OBJ to increase uniformity All of the mesh elements in the final mesh should be about the same size, and the actually geometry of the mesh should not be significantly degraded during the remeshing In general, you will want to decrease the mesh density, but in some cases (such as if you have a large rectangular face), you will need to increase the mesh density by linear subdivision of the faces first. The handle of the cargo bag should generally be handled separately from the rest of the body. To do this, select all of the faces on the handle, remesh this, invert the selection so the rest of the bag is selected, and then remesh that Export the OBJ This will also (most likely) create a MTL file with the same name. However, the MTL is fairly useless at this point, because we haven't associated a texture with the OBJ yet. We can ignore this for now Load the OBJ into Blender and add a texture to the mesh This is detailed in-depth here for the Astrobee meshes, but this general process also applies for any mesh. Debugging Does the mesh... Seem to be collapsing/shrinking in on itself? This could be an issue with self-collision. Try turning this to False Look like it's vibrating all over the place? Try increasing the physics frequency - 240 Hz might be too low, so try 350 or 500 Hz Explode outwards when you click+drag on it? Make sure you've specified the elastic parameters of the softbody General tips Sparser meshes tend to be more computationally cheap than dense meshes (intuitively, this makes sense) You can have non-manifold elements for an OBJ-type softbody (e.g. a part of the mesh that is not a boundary of a closed volume) If you want to do this, delete any faces to create the non-manifold areas in Meshmixer, (if needed) fill any unwanted holes in Blender, and (if needed) remesh in Meshmixer again If you are modeling fabric, use OBJ. If you are modeling a \"squishy\" object, use VTK. Future TODOs We still need to understand how varying mesh parameters (such as number of mesh elements, mesh density variations, ...) and CAD parameters (handle geometry/size, main compartment geometry/size, ...) affect the inertial properties of the object in Pybullet. This info will likely be coming soon","title":"Meshing"},{"location":"docs/meshing/#meshing-tips-and-notes","text":"This document will refer mainly to triangular meshes (OBJ), as opposed to tetrahedral meshes (VTK). For more info on tet meshes, see here .","title":"Meshing tips and notes"},{"location":"docs/meshing/#steps","text":"Create CAD model (in whatever software works best) If round corners are desired over a purely rectangular body, use Fusion (they have a simple freeform modeler that works well for cargo-bag-like bodies) Try to design the part so that the center of mass lies at the origin. This is because if you load a (rigid) OBJ into Pybullet, it will specify its center of mass wherever the origin of the mesh is (which may be undesirable behavior depending on the part's geometry). Export the CAD body as an OBJ If there is a \"mesh refinement\" parameter in the export options, this should generally be at the lowest value such that no significant detail is lost Import the OBJ into MeshMixer This is generally the best software for remeshing that I've found, though MeshLab theoretically has similar tools (and works on more than just Windows) Remesh the OBJ to increase uniformity All of the mesh elements in the final mesh should be about the same size, and the actually geometry of the mesh should not be significantly degraded during the remeshing In general, you will want to decrease the mesh density, but in some cases (such as if you have a large rectangular face), you will need to increase the mesh density by linear subdivision of the faces first. The handle of the cargo bag should generally be handled separately from the rest of the body. To do this, select all of the faces on the handle, remesh this, invert the selection so the rest of the bag is selected, and then remesh that Export the OBJ This will also (most likely) create a MTL file with the same name. However, the MTL is fairly useless at this point, because we haven't associated a texture with the OBJ yet. We can ignore this for now Load the OBJ into Blender and add a texture to the mesh This is detailed in-depth here for the Astrobee meshes, but this general process also applies for any mesh.","title":"Steps"},{"location":"docs/meshing/#debugging","text":"Does the mesh... Seem to be collapsing/shrinking in on itself? This could be an issue with self-collision. Try turning this to False Look like it's vibrating all over the place? Try increasing the physics frequency - 240 Hz might be too low, so try 350 or 500 Hz Explode outwards when you click+drag on it? Make sure you've specified the elastic parameters of the softbody","title":"Debugging"},{"location":"docs/meshing/#general-tips","text":"Sparser meshes tend to be more computationally cheap than dense meshes (intuitively, this makes sense) You can have non-manifold elements for an OBJ-type softbody (e.g. a part of the mesh that is not a boundary of a closed volume) If you want to do this, delete any faces to create the non-manifold areas in Meshmixer, (if needed) fill any unwanted holes in Blender, and (if needed) remesh in Meshmixer again If you are modeling fabric, use OBJ. If you are modeling a \"squishy\" object, use VTK.","title":"General tips"},{"location":"docs/meshing/#future-todos","text":"We still need to understand how varying mesh parameters (such as number of mesh elements, mesh density variations, ...) and CAD parameters (handle geometry/size, main compartment geometry/size, ...) affect the inertial properties of the object in Pybullet. This info will likely be coming soon","title":"Future TODOs"},{"location":"docs/nasa_sim/","text":"Notes on NASA's simulation environment pyastrobee is an easier-to-use version of NASA's Astrobee simulator, and installing NASA's sim is not required. But, if you would additionally like to experiment with the full simulator, I've written some notes below. Build/Install The go-to link here is the Non-NASA Astrobee Install Guide , which contains pretty much everything you need to set up their code. Unfortunately, there are a lot of random bugs you might encounter along the way When installing this, you'll want to be on a machine with: Ubuntu 20.04 No prior install of OpenCV No prior install of ROS No Stanford AFS software Sudo and root access ... Basically, as close as you can get to a completely \"blank-slate\" machine Ros Noetic will be installed during this process. However, let their build scripts install ROS -- don't install it ahead of time! After the step where you clone their repository, you may want to cd $ASTROBEE_WS/src and git checkout develop , which has the most up-to-date code. I had to do this, but NASA updated their master branch and this may no longer be needed. They mention this very briefly, but make sure you sudo apt-get update and sudp apt-get upgrade (this is quite important and easy to miss) If everything goes well during the \"Install Dependencies\" step (where most of the bugs are encountered), you'll get to the \"Building the Code\" section. If cmake fails at this step, try re-building it again with a -j1 flag. This will take longer to build, but it is more reliable on low-memory machines. To test if this install worked, run the following: cd $ HOME / astrobee # Or ASTROBEE_WS , if installed in a different location source devel / setup . bash roslaunch astrobee sim . launch dds := false robot := sim_pub rviz := true sviz := true This should bring up both a Gazebo and an RVIZ window displaying the astrobee inside the ISS If this stil isn't working: Check that you don't have any virtual environments currently active Try anothere re-build Delete the repo and start over, paying really close attention to any warnings that pop up in the terminal (some dependencies might not actually get installed when they should have, and then you have to manually install them with apt ) Docker Alternatively, you can use Docker. This means there won't be a local build of the code on the machine, but you can probably get away with this if you're not using ROS much (and this repo doesn't rely on it currently). If this is the case, check out the following resources: Install Docker Engine on Ubuntu Linux post-installation steps for Docker Engine nasa/astrobee Installation page (see the Docker option) The Docker build worked on the first try for us, which was a pleasant surprise. To run Gazebo/RViz with Docker, include the args as follows: ./run.sh --remote --args \"rviz:=true sviz:=true\" (where run.sh is inside the docker/ directory). Originally, Docker only worked on the develop branch, but that bug should be fixed now. Using the simulator First, start up the simulator cd $ HOME / astrobee # Or ASTROBEE_WS , if installed in a different location source devel / setup . bash roslaunch astrobee sim . launch dds := false robot := sim_pub rviz := true sviz := true There may be some errors that show up at the start of the program from the graph_localizer and the imu_integration , but I found that these can be safely ignored and it seems to work fine. If the robot is not visible but all of the frames are, un-check and then re-check the Debug \u2192 / checkbox under the Rviz Displays section in the bottom left corner. If the robot is randomly floating around the ISS upoin starting the simulation, this is not good (the localizer is totally busted). I've only seen this when starting the simulation and the processes in two separate terminal windows. The roslaunch one-liner in the code block above should hopefully work. Interacting with the simulation is via the teleop_tool , for example: rosrun executive teleop_tool - undock rosrun executive teleop_tool - get_pose rosrun executive teleop_tool - get_state rosrun executive teleop_tool - move - relative - pos \"1 2 0.5\" We've only been using a few flags like rviz and sviz so far, but there are more you can include on launch. If not specified, enable with flag:=true . See the Running the Sim page for more info pose : Starting pose. For example, pose:=\"x y z qx qy qz qw\" gds : Starts the Ground Data System rviz : Starts RVIZ sviz : Starts Gazebo gviz : Starts the GNC visualizer dds : Starts communication nodes speed : Simulation speed multiplier (1 = real time) ns : Namespace (for using multiple robots) robot : Which robot config file to use (leave this as sim_pub for now) default_robot : If you want to launch the world without a robot, set this false perch : Starts astrobee in a perch-ready position world : \"iss\" (default) or \"granite\" debug : node name to debug, For example, \"executive\" The GNC visualizer (see the gviz flag above) is a cool way to see some of the localization info, but it's super slow and crashes a lot. The gds flag will not work until you have the RTI libraries / communication nodes directly from NASA.","title":"Nasa Sim"},{"location":"docs/nasa_sim/#notes-on-nasas-simulation-environment","text":"pyastrobee is an easier-to-use version of NASA's Astrobee simulator, and installing NASA's sim is not required. But, if you would additionally like to experiment with the full simulator, I've written some notes below.","title":"Notes on NASA's simulation environment"},{"location":"docs/nasa_sim/#buildinstall","text":"The go-to link here is the Non-NASA Astrobee Install Guide , which contains pretty much everything you need to set up their code. Unfortunately, there are a lot of random bugs you might encounter along the way When installing this, you'll want to be on a machine with: Ubuntu 20.04 No prior install of OpenCV No prior install of ROS No Stanford AFS software Sudo and root access ... Basically, as close as you can get to a completely \"blank-slate\" machine Ros Noetic will be installed during this process. However, let their build scripts install ROS -- don't install it ahead of time! After the step where you clone their repository, you may want to cd $ASTROBEE_WS/src and git checkout develop , which has the most up-to-date code. I had to do this, but NASA updated their master branch and this may no longer be needed. They mention this very briefly, but make sure you sudo apt-get update and sudp apt-get upgrade (this is quite important and easy to miss) If everything goes well during the \"Install Dependencies\" step (where most of the bugs are encountered), you'll get to the \"Building the Code\" section. If cmake fails at this step, try re-building it again with a -j1 flag. This will take longer to build, but it is more reliable on low-memory machines. To test if this install worked, run the following: cd $ HOME / astrobee # Or ASTROBEE_WS , if installed in a different location source devel / setup . bash roslaunch astrobee sim . launch dds := false robot := sim_pub rviz := true sviz := true This should bring up both a Gazebo and an RVIZ window displaying the astrobee inside the ISS If this stil isn't working: Check that you don't have any virtual environments currently active Try anothere re-build Delete the repo and start over, paying really close attention to any warnings that pop up in the terminal (some dependencies might not actually get installed when they should have, and then you have to manually install them with apt )","title":"Build/Install"},{"location":"docs/nasa_sim/#docker","text":"Alternatively, you can use Docker. This means there won't be a local build of the code on the machine, but you can probably get away with this if you're not using ROS much (and this repo doesn't rely on it currently). If this is the case, check out the following resources: Install Docker Engine on Ubuntu Linux post-installation steps for Docker Engine nasa/astrobee Installation page (see the Docker option) The Docker build worked on the first try for us, which was a pleasant surprise. To run Gazebo/RViz with Docker, include the args as follows: ./run.sh --remote --args \"rviz:=true sviz:=true\" (where run.sh is inside the docker/ directory). Originally, Docker only worked on the develop branch, but that bug should be fixed now.","title":"Docker"},{"location":"docs/nasa_sim/#using-the-simulator","text":"First, start up the simulator cd $ HOME / astrobee # Or ASTROBEE_WS , if installed in a different location source devel / setup . bash roslaunch astrobee sim . launch dds := false robot := sim_pub rviz := true sviz := true There may be some errors that show up at the start of the program from the graph_localizer and the imu_integration , but I found that these can be safely ignored and it seems to work fine. If the robot is not visible but all of the frames are, un-check and then re-check the Debug \u2192 / checkbox under the Rviz Displays section in the bottom left corner. If the robot is randomly floating around the ISS upoin starting the simulation, this is not good (the localizer is totally busted). I've only seen this when starting the simulation and the processes in two separate terminal windows. The roslaunch one-liner in the code block above should hopefully work. Interacting with the simulation is via the teleop_tool , for example: rosrun executive teleop_tool - undock rosrun executive teleop_tool - get_pose rosrun executive teleop_tool - get_state rosrun executive teleop_tool - move - relative - pos \"1 2 0.5\" We've only been using a few flags like rviz and sviz so far, but there are more you can include on launch. If not specified, enable with flag:=true . See the Running the Sim page for more info pose : Starting pose. For example, pose:=\"x y z qx qy qz qw\" gds : Starts the Ground Data System rviz : Starts RVIZ sviz : Starts Gazebo gviz : Starts the GNC visualizer dds : Starts communication nodes speed : Simulation speed multiplier (1 = real time) ns : Namespace (for using multiple robots) robot : Which robot config file to use (leave this as sim_pub for now) default_robot : If you want to launch the world without a robot, set this false perch : Starts astrobee in a perch-ready position world : \"iss\" (default) or \"granite\" debug : node name to debug, For example, \"executive\" The GNC visualizer (see the gviz flag above) is a cool way to see some of the localization info, but it's super slow and crashes a lot. The gds flag will not work until you have the RTI libraries / communication nodes directly from NASA.","title":"Using the simulator"},{"location":"docs/pybullet_tips/","text":"Assorted Pybullet notes to remember Timesteps Pybullet's timestep (via setTimeStep ) is currently set to 350 Hz ( dt = 1 / 350 ) (Check our initialize_pybullet() function to confirm this in case it changed). Pybullet's default timestep is 240 Hz, and the quickstart guide gives some reasons why this should be left at 240 Hz (based on solver iterations and error reduction parameters, which we might need to experiment with), but we increased this value because it improved the stability of deformable objects. Importantly, this timestep dictates how velocities are defined. If we calculate velocities assuming a dt of anything other than our current timestep ( pybullet.getPhysicsEngineParameters()[\"fixedTimeStep\"] ), the values will be off! Note that if you just call pybullet.connect() , the timestep will default to 240 Hz. So, initialize_pybullet is the better way to approach this to avoid bugs.","title":"Pybullet Tips"},{"location":"docs/pybullet_tips/#assorted-pybullet-notes-to-remember","text":"","title":"Assorted Pybullet notes to remember"},{"location":"docs/pybullet_tips/#timesteps","text":"Pybullet's timestep (via setTimeStep ) is currently set to 350 Hz ( dt = 1 / 350 ) (Check our initialize_pybullet() function to confirm this in case it changed). Pybullet's default timestep is 240 Hz, and the quickstart guide gives some reasons why this should be left at 240 Hz (based on solver iterations and error reduction parameters, which we might need to experiment with), but we increased this value because it improved the stability of deformable objects. Importantly, this timestep dictates how velocities are defined. If we calculate velocities assuming a dt of anything other than our current timestep ( pybullet.getPhysicsEngineParameters()[\"fixedTimeStep\"] ), the values will be off! Note that if you just call pybullet.connect() , the timestep will default to 240 Hz. So, initialize_pybullet is the better way to approach this to avoid bugs.","title":"Timesteps"},{"location":"docs/references/","text":"References Control Orientation planning in task space using quaternion polynomials A general construction scheme for unit quaternion curves with simple high order derivatives Sola: Quaternion kinematics for the error-state Kalman filter Shuster: A survey of attitude representations Optimization Tobia/Boyd: Fast Path Planning Through Large Collections of Safe Boxes Astrobee/Spheres A Brief Guide to Astrobee Somrita: NNGusto: Learning-based warm-starting for fast sequential convex programming and trajectory optimization The ReSWARM Microgravity Flight Experiments: Planning, Control, and Model Estimation for On-Orbit Close Proximity Operations Geometric methods for the planning, control, and estimation of free-flying autonomous systems Smooth trajectory generation on SE3 for a free flying space robot Two-stage path planning approach for designing multiple spacecraft reconfiguration maneuvers and application to SPHERES onboard ISS Simulation Rika: DEDO - Dynamic Environments with Deformable Objects Dynamics Mitiguy: Advanced Dynamics and Motion Simulation Robotics Khatib: Introduction to Robotics: Lecture Notes, CS223A, Winter 2023 Khatib: Advanced Robotic Manipulation: Lecture Notes, CS327A, Spring 2023 Python See the setup.py file for dependencies, cite packages as needed Not currently using, but possibly useful in the future: Full quaternion based attitude control for a quadrotor Richard Murray: Optimization-based control Learning end-to-end robotic manipulation of deformable objects Controlling Ocean One Linear quaternion differential equations: basic theory and fundamental results Dynamic movement primitives Quaternion-Based Control Architecture for Determining Controllability/Maneuverability Limits Spacecraft robust attitude tracking design: PID control approach A tuning method of multi variable PID gains using Jacobian Helpful Links nasa/astrobee Github nasa/astrobee_media Github Non-NASA Astrobee Install Guide A Brief Guide to Astrobee Pybullet Quickstart Guide Pybullet Keyboard Shortcuts","title":"References"},{"location":"docs/references/#references","text":"Control Orientation planning in task space using quaternion polynomials A general construction scheme for unit quaternion curves with simple high order derivatives Sola: Quaternion kinematics for the error-state Kalman filter Shuster: A survey of attitude representations Optimization Tobia/Boyd: Fast Path Planning Through Large Collections of Safe Boxes Astrobee/Spheres A Brief Guide to Astrobee Somrita: NNGusto: Learning-based warm-starting for fast sequential convex programming and trajectory optimization The ReSWARM Microgravity Flight Experiments: Planning, Control, and Model Estimation for On-Orbit Close Proximity Operations Geometric methods for the planning, control, and estimation of free-flying autonomous systems Smooth trajectory generation on SE3 for a free flying space robot Two-stage path planning approach for designing multiple spacecraft reconfiguration maneuvers and application to SPHERES onboard ISS Simulation Rika: DEDO - Dynamic Environments with Deformable Objects Dynamics Mitiguy: Advanced Dynamics and Motion Simulation Robotics Khatib: Introduction to Robotics: Lecture Notes, CS223A, Winter 2023 Khatib: Advanced Robotic Manipulation: Lecture Notes, CS327A, Spring 2023 Python See the setup.py file for dependencies, cite packages as needed Not currently using, but possibly useful in the future: Full quaternion based attitude control for a quadrotor Richard Murray: Optimization-based control Learning end-to-end robotic manipulation of deformable objects Controlling Ocean One Linear quaternion differential equations: basic theory and fundamental results Dynamic movement primitives Quaternion-Based Control Architecture for Determining Controllability/Maneuverability Limits Spacecraft robust attitude tracking design: PID control approach A tuning method of multi variable PID gains using Jacobian","title":"References"},{"location":"docs/references/#helpful-links","text":"nasa/astrobee Github nasa/astrobee_media Github Non-NASA Astrobee Install Guide A Brief Guide to Astrobee Pybullet Quickstart Guide Pybullet Keyboard Shortcuts","title":"Helpful Links"},{"location":"docs/retexturing/","text":"How to modify the textures on the Astrobee Since Pybullet prefers to load a URDF with a single texture applied to all meshes, we have to do some manual modification to both the meshes and the texture to get things to look right. First, we have to understand how texture images are mapped to a mesh. Inside the mesh file (OBJ/DAE/...), there is an embedding of a UV map, which dictates where the faces of the mesh fall on a texture image. Since we have a complex mesh and a 2D image, the mapping from the mesh faces to the image can often look very complicated, because of the \"unwrapping\" of the mesh that needs to happen. So, when Pybullet loads a URDF and applies the same image to everything, one part will look correct (the one where the UV map lines up with the texture as expected), and the rest of them will be totally messed up, because their UV maps are pointing to arbitrary parts of this texture. To solve this problem, we need to modify the meshes so that the UV maps of all of the parts are designed around a single texture PNG. This is where Blender comes in. However, before we use Blender, we have to make our texture file. Making a texture (Disclaimer: There are almost certainly better ways to make a texture than this, but this was the easiest solution I could figure out without needing to learn all of the intricacies of Blender and texture unpacking/baking) The Astrobee has pretty much just one component with a real texture (the skin on the side of the PMC), with a few other solid-color parts (the arm is black, the body is light gray with a few colored elements, ...). So, the approach I went for was that I added all of the solid colors I needed to the skin texture, right in the middle of the image (which is an unused area). This way, we can keep the UV map for the skin the same, but take all of the solid-color mesh elements and map them all to the respective color blocks in the image. Blender workflow A quick note: I ended up making two Blender files - one for the body of the Astrobee, and one for everything else. The reasoning for this is that the body is comprised of 31 different little components, all separate meshes, whereas all of the other links on the Astrobee are single-mesh parts. It was easier for exporting purposes to deal with things in separate files. The only difference between these is that in the Body file, all of the meshes need to be exported to a single OBJ file, whereas in the \"Everything Else\" file, each mesh needed to be clicked on and exported as its own separate OBJ (for example, one of the gripper finger meshes). Open Blender and import the original DAE file(s) from the astrobee_media repo It's helpful to rename the imported parts with their actual mesh names (for example, base_link ), because the generic names make it difficult to distinguish between multiple loaded parts Click on the Viewport Shading button in the top right of the 3D Viewport to view the texture applied to the object. This button looks like a slightly-shaded circle Click on UV editing in the Workspaces bar at the top of the window Click on Image -> Open at the top of the UV editing area, and select the new texture ( astrobee_texture.png ) Click on the part in the 3D VIewport's Object mode If you have multiple parts in the Blender file, the fastest way to go about this process is to select all of the parts you want to be the same color, and then continue with this process Switch the 3D Viewport to Edit mode to make the mesh visible (press Tab to activate, or use the dropdown at the top left of the 3D Viewport) Click on the Material Properties tab in the Properties panel in the bottom right side (it looks like a red 3D version of the centroid symbol) Rename the material to something more useful, like astrobee_texture Click on the dropdown next to Base Color , and switch the image to the desired texture image you loaded earlier If the image dropdown doesn't exist, you'll need to click the yellow dot next to Base Color and switch it to Image Texture In Edit mode in the 3D Viewport, press A to select all faces (this should bring up the UV map in the UV Editor area) Click inside the UV Editor area, then press A to select all of the mesh faces (Optional) Click on UV -> Unwrap -> Smart UV Project to get the mesh elements into a slightly better layout (or U -> S -> Enter ) Don't do this if you want to retain the UV mapping pattern (for instance, for the Astrobee skin, I did not unwrap the UV because it already lined up well with my texture file) With these UV mesh elements selected, move them to the correct place in the texture according to their desired color Press G to grab Press R to rotate Press S to scale Once you have at least one part done, we need to make sure that all of the parts in the file are associated with the same texture/material. To do this, Click on the part that has the new texture applied, then select all of the other parts in the file (by pressing A or with Shift + Click) Press Ctrl + L together Click on Link Materials All parts should now have the same texture/material. The other parts may look totally wrong if you haven't modified their UV maps yet, but that's fine for now Repeat for the remaining parts Exporting meshes Pybullet seems to prefer OBJ to DAE when it comes to applying textures, so we'll use this as our preferred mesh format. If this is a Blender file with multiple URDF links loaded, you'll need to select them in the 3D Viewport in Object mode, and then File -> Export -> Wavefront (.obj) , with the Selected Only checkbox marked. If this is a Blender file where multiple meshes correspond to a single URDF link (like the body file), there's no need to select the parts, you can just export with this checkbox deactivated. Important note : The default export orientation for DAE and OBJ is different! So, for any OBJ being exported, ensure that Forward Axis is Y and Up Axis is Z . This will match the DAE defaults and the way that NASA specified the original URDF with the DAE meshes. Loading into Pybullet If you just call loadURDF() , the Astrobee may show up totally black. It seems that this isn't actually a problem with the texture, it's moreso that there is a unset alpha channel. So, loop through all of the link indices and set the rgbaColor to be [1, 1, 1, 1] using changeVisualShape() , and this should fix the problem Another way of fixing this issue is that you can add a default material into the URDF with this alpha channel set. For instance, add the following block inside the <visual> block, after <geometry> : <material name= \"default_material\" > <color rgba= \"1 1 1 1\" /> </material>","title":"Retexturing"},{"location":"docs/retexturing/#how-to-modify-the-textures-on-the-astrobee","text":"Since Pybullet prefers to load a URDF with a single texture applied to all meshes, we have to do some manual modification to both the meshes and the texture to get things to look right. First, we have to understand how texture images are mapped to a mesh. Inside the mesh file (OBJ/DAE/...), there is an embedding of a UV map, which dictates where the faces of the mesh fall on a texture image. Since we have a complex mesh and a 2D image, the mapping from the mesh faces to the image can often look very complicated, because of the \"unwrapping\" of the mesh that needs to happen. So, when Pybullet loads a URDF and applies the same image to everything, one part will look correct (the one where the UV map lines up with the texture as expected), and the rest of them will be totally messed up, because their UV maps are pointing to arbitrary parts of this texture. To solve this problem, we need to modify the meshes so that the UV maps of all of the parts are designed around a single texture PNG. This is where Blender comes in. However, before we use Blender, we have to make our texture file.","title":"How to modify the textures on the Astrobee"},{"location":"docs/retexturing/#making-a-texture","text":"(Disclaimer: There are almost certainly better ways to make a texture than this, but this was the easiest solution I could figure out without needing to learn all of the intricacies of Blender and texture unpacking/baking) The Astrobee has pretty much just one component with a real texture (the skin on the side of the PMC), with a few other solid-color parts (the arm is black, the body is light gray with a few colored elements, ...). So, the approach I went for was that I added all of the solid colors I needed to the skin texture, right in the middle of the image (which is an unused area). This way, we can keep the UV map for the skin the same, but take all of the solid-color mesh elements and map them all to the respective color blocks in the image.","title":"Making a texture"},{"location":"docs/retexturing/#blender-workflow","text":"A quick note: I ended up making two Blender files - one for the body of the Astrobee, and one for everything else. The reasoning for this is that the body is comprised of 31 different little components, all separate meshes, whereas all of the other links on the Astrobee are single-mesh parts. It was easier for exporting purposes to deal with things in separate files. The only difference between these is that in the Body file, all of the meshes need to be exported to a single OBJ file, whereas in the \"Everything Else\" file, each mesh needed to be clicked on and exported as its own separate OBJ (for example, one of the gripper finger meshes). Open Blender and import the original DAE file(s) from the astrobee_media repo It's helpful to rename the imported parts with their actual mesh names (for example, base_link ), because the generic names make it difficult to distinguish between multiple loaded parts Click on the Viewport Shading button in the top right of the 3D Viewport to view the texture applied to the object. This button looks like a slightly-shaded circle Click on UV editing in the Workspaces bar at the top of the window Click on Image -> Open at the top of the UV editing area, and select the new texture ( astrobee_texture.png ) Click on the part in the 3D VIewport's Object mode If you have multiple parts in the Blender file, the fastest way to go about this process is to select all of the parts you want to be the same color, and then continue with this process Switch the 3D Viewport to Edit mode to make the mesh visible (press Tab to activate, or use the dropdown at the top left of the 3D Viewport) Click on the Material Properties tab in the Properties panel in the bottom right side (it looks like a red 3D version of the centroid symbol) Rename the material to something more useful, like astrobee_texture Click on the dropdown next to Base Color , and switch the image to the desired texture image you loaded earlier If the image dropdown doesn't exist, you'll need to click the yellow dot next to Base Color and switch it to Image Texture In Edit mode in the 3D Viewport, press A to select all faces (this should bring up the UV map in the UV Editor area) Click inside the UV Editor area, then press A to select all of the mesh faces (Optional) Click on UV -> Unwrap -> Smart UV Project to get the mesh elements into a slightly better layout (or U -> S -> Enter ) Don't do this if you want to retain the UV mapping pattern (for instance, for the Astrobee skin, I did not unwrap the UV because it already lined up well with my texture file) With these UV mesh elements selected, move them to the correct place in the texture according to their desired color Press G to grab Press R to rotate Press S to scale Once you have at least one part done, we need to make sure that all of the parts in the file are associated with the same texture/material. To do this, Click on the part that has the new texture applied, then select all of the other parts in the file (by pressing A or with Shift + Click) Press Ctrl + L together Click on Link Materials All parts should now have the same texture/material. The other parts may look totally wrong if you haven't modified their UV maps yet, but that's fine for now Repeat for the remaining parts","title":"Blender workflow"},{"location":"docs/retexturing/#exporting-meshes","text":"Pybullet seems to prefer OBJ to DAE when it comes to applying textures, so we'll use this as our preferred mesh format. If this is a Blender file with multiple URDF links loaded, you'll need to select them in the 3D Viewport in Object mode, and then File -> Export -> Wavefront (.obj) , with the Selected Only checkbox marked. If this is a Blender file where multiple meshes correspond to a single URDF link (like the body file), there's no need to select the parts, you can just export with this checkbox deactivated. Important note : The default export orientation for DAE and OBJ is different! So, for any OBJ being exported, ensure that Forward Axis is Y and Up Axis is Z . This will match the DAE defaults and the way that NASA specified the original URDF with the DAE meshes.","title":"Exporting meshes"},{"location":"docs/retexturing/#loading-into-pybullet","text":"If you just call loadURDF() , the Astrobee may show up totally black. It seems that this isn't actually a problem with the texture, it's moreso that there is a unset alpha channel. So, loop through all of the link indices and set the rgbaColor to be [1, 1, 1, 1] using changeVisualShape() , and this should fix the problem Another way of fixing this issue is that you can add a default material into the URDF with this alpha channel set. For instance, add the following block inside the <visual> block, after <geometry> : <material name= \"default_material\" > <color rgba= \"1 1 1 1\" /> </material>","title":"Loading into Pybullet"},{"location":"docs/testing/","text":"Testing Test cases can be found in /test , and can be run using ./run_tests.sh from the upper-level directory. (If this file is not executable, run chmod u+x run_tests.sh ) Current test cases cover: Rotations Transformations Testing pytransform3d conventions Poses CI/CD TODO","title":"Testing"},{"location":"docs/testing/#testing","text":"Test cases can be found in /test , and can be run using ./run_tests.sh from the upper-level directory. (If this file is not executable, run chmod u+x run_tests.sh ) Current test cases cover: Rotations Transformations Testing pytransform3d conventions Poses","title":"Testing"},{"location":"docs/testing/#cicd","text":"TODO","title":"CI/CD"},{"location":"docs/tet_meshing/","text":"Working with tetrahedral meshes in Pybullet Loading OBJ files for deformables is great for objects that are \"floppy\" or \"thin\" in nature, such as a tote bag, but not so good for objects that are more \"squishy\", like a sponge. This is because files such as .OBJ or .STL are surface (triangular) meshes, so they have no volumetric information to them. So, instead we'll need to use a tetrahedral mesh in .VTK format Using GMSH Open the GMSH GUI ( ./gmsh within the bin/ directory of your GMSH install) File -> Open -> Click on the STL file to load. Note: In theory GMSH should be able to open an OBJ, but OBJs tend to lead to import errors. If this is the case, use a STL of the same mesh instead. Geometry -> Elementary entities -> Add -> Volume When prompted with \"Select volume boundary\", click on the mesh If a popup mentions \"A scripting command is going to be appended to a non-geo file\", click on \"Create new .geo file\" When prompted with \"Select hole boundaries\", press 'e' since there are no holes in the cargo bag Click on Mesh -> 3D to view and enable the tetrahedral mesh Save the file File -> Export -> Specify the filename with a .VTK extension. If a VTK options window shows up, keep it in ASCII format. The \"save all elements\" checkbox does not seem to make a difference This .VTK file will look something like: # vtk DataFile Version 2.0 bag_remesh, Created by Gmsh 4.11.1 ASCII DATASET UNSTRUCTURED_GRID POINTS 518 double 0.125 -0.125 -0.0250000003725 0.107393302023 -0.139757603407 -0.0250000003725 ... 0.06279948249067006 -0.07503616573439448 0.09226952087427626 CELLS 2577 12107 3 0 1 2 3 0 37 1 ... 3 384 385 382 4 308 427 121 442 4 188 405 186 422 ... 4 424 468 357 481 CELL_TYPES 2577 5 5 ... 5 10 10 ... 10 Modifying the VTK Pybullet will not be able to load this file right now, because it is a combination of surface (triangle) meshes and volume (tetrahedral) meshes. But, it is not too difficult to modify this file to remove the surface mesh and just leave behind the tet mesh. Before this, we need to understand the file format: The line starting with CELLS has two values corresponding to NUM_CELLS : The total number of (surface + volume) cells in the mesh LIST_SIZE : The number of values in the CELLS list. This is equal to 4*NUM_TRIS + 5*NUM_TETS Each line in the CELLS list starting with 3 corresponds to a triangular cell, and any line starting with 4 is a tetrahedral cell. The CELL_TYPES line contains the same value ( NUM_CELLS ) as was seen in CELLS Each line in CELL_TYPES is a 5 for a triangular cell and 10 for a tetrahedral cell. To delete the surface (triangular) mesh, Count the number of triangular cells ( NUM_TRIS ) Update the counts: NUM_CELLS -= NUM_TRIS LIST_SIZE -= 4*NUM_TRIS Delete the lines in CELLS starting with 3 , and all 5 s in the CELL_TYPES Update the CELLS and CELL_TYPES lines with the new counts After these modifications, Pybullet should be able to successfully import the mesh. Texturing To texture a tetrahedral mesh, there are two options: Generate the tetrahedral mesh from an OBJ which already has the correct UV mapping for a specified texture file, then apply the texture with loadTexture / changeVisualShape This should work given some preliminary tests with a VTK with a random UV mapping. But, this hasn't been fully tested yet (as of 4/10/23) Use the texture from an OBJ by loading both the OBJ and VTK together The OBJ and the VTK should have the exact same geometry Load the OBJ file through the main filename parameter, but pass the VTK file in through simFileName . The resulting softbody will have the physical properties you'd expect from a tetrahedral mesh, but the same texture as the OBJ This has been tested and works. Note: if you removeBody using the ID returned from loadSoftBody , it will leave a \"ghost\" visual of the OBJ. There may be a separate ID attached to the visual, but it is unclear what it is right now Future TODOs Apparently, there is a way to export just the tetrahedral mesh elements via Physical groups -- see this thread for info. For now though, this manual modification process works.","title":"Tet Meshing"},{"location":"docs/tet_meshing/#working-with-tetrahedral-meshes-in-pybullet","text":"Loading OBJ files for deformables is great for objects that are \"floppy\" or \"thin\" in nature, such as a tote bag, but not so good for objects that are more \"squishy\", like a sponge. This is because files such as .OBJ or .STL are surface (triangular) meshes, so they have no volumetric information to them. So, instead we'll need to use a tetrahedral mesh in .VTK format","title":"Working with tetrahedral meshes in Pybullet"},{"location":"docs/tet_meshing/#using-gmsh","text":"Open the GMSH GUI ( ./gmsh within the bin/ directory of your GMSH install) File -> Open -> Click on the STL file to load. Note: In theory GMSH should be able to open an OBJ, but OBJs tend to lead to import errors. If this is the case, use a STL of the same mesh instead. Geometry -> Elementary entities -> Add -> Volume When prompted with \"Select volume boundary\", click on the mesh If a popup mentions \"A scripting command is going to be appended to a non-geo file\", click on \"Create new .geo file\" When prompted with \"Select hole boundaries\", press 'e' since there are no holes in the cargo bag Click on Mesh -> 3D to view and enable the tetrahedral mesh Save the file File -> Export -> Specify the filename with a .VTK extension. If a VTK options window shows up, keep it in ASCII format. The \"save all elements\" checkbox does not seem to make a difference This .VTK file will look something like: # vtk DataFile Version 2.0 bag_remesh, Created by Gmsh 4.11.1 ASCII DATASET UNSTRUCTURED_GRID POINTS 518 double 0.125 -0.125 -0.0250000003725 0.107393302023 -0.139757603407 -0.0250000003725 ... 0.06279948249067006 -0.07503616573439448 0.09226952087427626 CELLS 2577 12107 3 0 1 2 3 0 37 1 ... 3 384 385 382 4 308 427 121 442 4 188 405 186 422 ... 4 424 468 357 481 CELL_TYPES 2577 5 5 ... 5 10 10 ... 10","title":"Using GMSH"},{"location":"docs/tet_meshing/#modifying-the-vtk","text":"Pybullet will not be able to load this file right now, because it is a combination of surface (triangle) meshes and volume (tetrahedral) meshes. But, it is not too difficult to modify this file to remove the surface mesh and just leave behind the tet mesh. Before this, we need to understand the file format: The line starting with CELLS has two values corresponding to NUM_CELLS : The total number of (surface + volume) cells in the mesh LIST_SIZE : The number of values in the CELLS list. This is equal to 4*NUM_TRIS + 5*NUM_TETS Each line in the CELLS list starting with 3 corresponds to a triangular cell, and any line starting with 4 is a tetrahedral cell. The CELL_TYPES line contains the same value ( NUM_CELLS ) as was seen in CELLS Each line in CELL_TYPES is a 5 for a triangular cell and 10 for a tetrahedral cell. To delete the surface (triangular) mesh, Count the number of triangular cells ( NUM_TRIS ) Update the counts: NUM_CELLS -= NUM_TRIS LIST_SIZE -= 4*NUM_TRIS Delete the lines in CELLS starting with 3 , and all 5 s in the CELL_TYPES Update the CELLS and CELL_TYPES lines with the new counts After these modifications, Pybullet should be able to successfully import the mesh.","title":"Modifying the VTK"},{"location":"docs/tet_meshing/#texturing","text":"To texture a tetrahedral mesh, there are two options: Generate the tetrahedral mesh from an OBJ which already has the correct UV mapping for a specified texture file, then apply the texture with loadTexture / changeVisualShape This should work given some preliminary tests with a VTK with a random UV mapping. But, this hasn't been fully tested yet (as of 4/10/23) Use the texture from an OBJ by loading both the OBJ and VTK together The OBJ and the VTK should have the exact same geometry Load the OBJ file through the main filename parameter, but pass the VTK file in through simFileName . The resulting softbody will have the physical properties you'd expect from a tetrahedral mesh, but the same texture as the OBJ This has been tested and works. Note: if you removeBody using the ID returned from loadSoftBody , it will leave a \"ghost\" visual of the OBJ. There may be a separate ID attached to the visual, but it is unclear what it is right now","title":"Texturing"},{"location":"docs/tet_meshing/#future-todos","text":"Apparently, there is a way to export just the tetrahedral mesh elements via Physical groups -- see this thread for info. For now though, this manual modification process works.","title":"Future TODOs"},{"location":"reference/pyastrobee/","text":"Module pyastrobee .. include:: ../README.md View Source \"\" \" .. include:: ../README.md \"\" \" Sub-modules pyastrobee.config pyastrobee.control pyastrobee.core pyastrobee.trajectories pyastrobee.utils","title":"Index"},{"location":"reference/pyastrobee/#module-pyastrobee","text":".. include:: ../README.md View Source \"\" \" .. include:: ../README.md \"\" \"","title":"Module pyastrobee"},{"location":"reference/pyastrobee/#sub-modules","text":"pyastrobee.config pyastrobee.control pyastrobee.core pyastrobee.trajectories pyastrobee.utils","title":"Sub-modules"},{"location":"reference/pyastrobee/config/","text":"Module pyastrobee.config Sub-modules pyastrobee.config.astrobee_geom pyastrobee.config.astrobee_motion pyastrobee.config.astrobee_transforms pyastrobee.config.bag_properties pyastrobee.config.iss_paths pyastrobee.config.iss_safe_boxes","title":"Index"},{"location":"reference/pyastrobee/config/#module-pyastrobeeconfig","text":"","title":"Module pyastrobee.config"},{"location":"reference/pyastrobee/config/#sub-modules","text":"pyastrobee.config.astrobee_geom pyastrobee.config.astrobee_motion pyastrobee.config.astrobee_transforms pyastrobee.config.bag_properties pyastrobee.config.iss_paths pyastrobee.config.iss_safe_boxes","title":"Sub-modules"},{"location":"reference/pyastrobee/config/astrobee_geom/","text":"Module pyastrobee.config.astrobee_geom Constants associated with the geometry of the Astrobee View Source \"\"\"Constants associated with the geometry of the Astrobee\"\"\" import numpy as np # This is useful for modeling drag forces CROSS_SECTION_AREA = 0.092903 # Defines the bounding sphere for collision modeling. Based on URDF collision geometry COLLISION_RADIUS = np . linalg . norm ([ 0.319199 / 2 , 0.117546 + 0.083962 / 2 , 0.319588 / 2 ]) Variables COLLISION_RADIUS CROSS_SECTION_AREA","title":"Astrobee Geom"},{"location":"reference/pyastrobee/config/astrobee_geom/#module-pyastrobeeconfigastrobee_geom","text":"Constants associated with the geometry of the Astrobee View Source \"\"\"Constants associated with the geometry of the Astrobee\"\"\" import numpy as np # This is useful for modeling drag forces CROSS_SECTION_AREA = 0.092903 # Defines the bounding sphere for collision modeling. Based on URDF collision geometry COLLISION_RADIUS = np . linalg . norm ([ 0.319199 / 2 , 0.117546 + 0.083962 / 2 , 0.319588 / 2 ])","title":"Module pyastrobee.config.astrobee_geom"},{"location":"reference/pyastrobee/config/astrobee_geom/#variables","text":"COLLISION_RADIUS CROSS_SECTION_AREA","title":"Variables"},{"location":"reference/pyastrobee/config/astrobee_motion/","text":"Module pyastrobee.config.astrobee_motion Astrobee constants associated with motion planning and control Note: The nominal operating mode is good for most operations. Astrobee is in general very slow, so it is sometimes interesting to use the higher limits on velocity and acceleration. But, Astrobee is also pretty limited in the amount of force/torque it can provide, so if we're operating in a faster mode, this can lead to some highly dynamic motions that are hard to recover from. Sourced from: - astrobee/gds_configs/AllOperatingLimitsConfig.json - A Brief Guide to Astrobee View Source \"\"\"Astrobee constants associated with motion planning and control Note: The nominal operating mode is good for most operations. Astrobee is in general very slow, so it is sometimes interesting to use the higher limits on velocity and acceleration. But, Astrobee is also pretty limited in the amount of force/torque it can provide, so if we're operating in a faster mode, this can lead to some highly dynamic motions that are hard to recover from. Sourced from: - astrobee/gds_configs/AllOperatingLimitsConfig.json - A Brief Guide to Astrobee \"\"\" # TODO make flight mode an input somewhere, rather than a hardcoded variable here? # TODO improve force/torque magnitude handling from enum import Enum import numpy as np class FlightModes ( Enum ): # Standard flight modes specified in the NASA codebase QUIET = 0 DIFFICULT = 1 NOMINAL = 2 LOMO = 3 # (not entirely sure what this mode means. locomotion?) # Custom flight modes MAXED_OUT = - 1 # TODO: Update this parameter if testing a different mode FLIGHT_MODE = FlightModes . NOMINAL if FLIGHT_MODE == FlightModes . QUIET : LINEAR_SPEED_LIMIT = 0.02 # m/s LINEAR_ACCEL_LIMIT = 0.002 # m/s^2 ANGULAR_SPEED_LIMIT = 0.0174 # rad/s ANGULAR_ACCEL_LIMIT = 0.0174 # rad/s^2 elif FLIGHT_MODE == FlightModes . DIFFICULT : LINEAR_SPEED_LIMIT = 0.4 # m/s LINEAR_ACCEL_LIMIT = 0.02 # m/s^2 ANGULAR_SPEED_LIMIT = 0.5236 # rad/s ANGULAR_ACCEL_LIMIT = 0.2500 # rad/s^2 elif FLIGHT_MODE == FlightModes . NOMINAL : LINEAR_SPEED_LIMIT = 0.2 # m/s LINEAR_ACCEL_LIMIT = 0.0175 # m/s^2 ANGULAR_SPEED_LIMIT = 0.1745 # rad/s ANGULAR_ACCEL_LIMIT = 0.1745 # rad/s^2 elif FLIGHT_MODE == FlightModes . LOMO : LINEAR_SPEED_LIMIT = 0.15 # m/s LINEAR_ACCEL_LIMIT = 0.0175 # m/s^2 ANGULAR_SPEED_LIMIT = 0.0873 # rad/s ANGULAR_ACCEL_LIMIT = 0.1745 # rad/s^2 elif FLIGHT_MODE == FlightModes . MAXED_OUT : # Use the absolute maximum values that our actuators can provide # Acceleration limits are calculated using standard rigid body dynamics (F=ma, t=Ia) # with the Astrobee's mass and inertia properties # Speed limits are left the same as the ISS_DIFFICULT profile LINEAR_SPEED_LIMIT = 0.4 # m/s LINEAR_ACCEL_LIMIT = 0.042 # m/s^2 ANGULAR_SPEED_LIMIT = 0.5236 # rad/s ANGULAR_ACCEL_LIMIT = 0.2840 # rad/s^2 else : raise NotImplementedError ( \"Flight mode has not been implemented\" ) # For forces/torques, assume we can operate at up to the max motor speed in RPM # See the Astrobee guide for more values if this is not the case MAX_FORCE = np . array ([ 0.849 , 0.406 , 0.486 ]) # Max force applied in local xyz axes MAX_TORQUE = MAX_FORCE / 10 # Max torques about local xyz axes # NOTE: The torque values are an approximation. See guide for reasoning # Slightly hacky force/torque magnitude values... In theory the world-frame force values depend on the orientation # of Astrobee, but we'll ignore this for now MAX_FORCE_MAGNITUDE = 0.849 MAX_TORQUE_MAGNITUDE = 0.849 / 10 Variables ANGULAR_ACCEL_LIMIT ANGULAR_SPEED_LIMIT FLIGHT_MODE LINEAR_ACCEL_LIMIT LINEAR_SPEED_LIMIT MAX_FORCE MAX_FORCE_MAGNITUDE MAX_TORQUE MAX_TORQUE_MAGNITUDE Classes FlightModes class FlightModes ( / , * args , ** kwargs ) An enumeration. View Source class FlightModes ( Enum ): # Standard flight modes specified in the NASA codebase QUIET = 0 DIFFICULT = 1 NOMINAL = 2 LOMO = 3 # (not entirely sure what this mode means. locomotion?) # Custom flight modes MAXED_OUT = - 1 Ancestors (in MRO) enum.Enum Class variables DIFFICULT LOMO MAXED_OUT NOMINAL QUIET name value","title":"Astrobee Motion"},{"location":"reference/pyastrobee/config/astrobee_motion/#module-pyastrobeeconfigastrobee_motion","text":"Astrobee constants associated with motion planning and control Note: The nominal operating mode is good for most operations. Astrobee is in general very slow, so it is sometimes interesting to use the higher limits on velocity and acceleration. But, Astrobee is also pretty limited in the amount of force/torque it can provide, so if we're operating in a faster mode, this can lead to some highly dynamic motions that are hard to recover from. Sourced from: - astrobee/gds_configs/AllOperatingLimitsConfig.json - A Brief Guide to Astrobee View Source \"\"\"Astrobee constants associated with motion planning and control Note: The nominal operating mode is good for most operations. Astrobee is in general very slow, so it is sometimes interesting to use the higher limits on velocity and acceleration. But, Astrobee is also pretty limited in the amount of force/torque it can provide, so if we're operating in a faster mode, this can lead to some highly dynamic motions that are hard to recover from. Sourced from: - astrobee/gds_configs/AllOperatingLimitsConfig.json - A Brief Guide to Astrobee \"\"\" # TODO make flight mode an input somewhere, rather than a hardcoded variable here? # TODO improve force/torque magnitude handling from enum import Enum import numpy as np class FlightModes ( Enum ): # Standard flight modes specified in the NASA codebase QUIET = 0 DIFFICULT = 1 NOMINAL = 2 LOMO = 3 # (not entirely sure what this mode means. locomotion?) # Custom flight modes MAXED_OUT = - 1 # TODO: Update this parameter if testing a different mode FLIGHT_MODE = FlightModes . NOMINAL if FLIGHT_MODE == FlightModes . QUIET : LINEAR_SPEED_LIMIT = 0.02 # m/s LINEAR_ACCEL_LIMIT = 0.002 # m/s^2 ANGULAR_SPEED_LIMIT = 0.0174 # rad/s ANGULAR_ACCEL_LIMIT = 0.0174 # rad/s^2 elif FLIGHT_MODE == FlightModes . DIFFICULT : LINEAR_SPEED_LIMIT = 0.4 # m/s LINEAR_ACCEL_LIMIT = 0.02 # m/s^2 ANGULAR_SPEED_LIMIT = 0.5236 # rad/s ANGULAR_ACCEL_LIMIT = 0.2500 # rad/s^2 elif FLIGHT_MODE == FlightModes . NOMINAL : LINEAR_SPEED_LIMIT = 0.2 # m/s LINEAR_ACCEL_LIMIT = 0.0175 # m/s^2 ANGULAR_SPEED_LIMIT = 0.1745 # rad/s ANGULAR_ACCEL_LIMIT = 0.1745 # rad/s^2 elif FLIGHT_MODE == FlightModes . LOMO : LINEAR_SPEED_LIMIT = 0.15 # m/s LINEAR_ACCEL_LIMIT = 0.0175 # m/s^2 ANGULAR_SPEED_LIMIT = 0.0873 # rad/s ANGULAR_ACCEL_LIMIT = 0.1745 # rad/s^2 elif FLIGHT_MODE == FlightModes . MAXED_OUT : # Use the absolute maximum values that our actuators can provide # Acceleration limits are calculated using standard rigid body dynamics (F=ma, t=Ia) # with the Astrobee's mass and inertia properties # Speed limits are left the same as the ISS_DIFFICULT profile LINEAR_SPEED_LIMIT = 0.4 # m/s LINEAR_ACCEL_LIMIT = 0.042 # m/s^2 ANGULAR_SPEED_LIMIT = 0.5236 # rad/s ANGULAR_ACCEL_LIMIT = 0.2840 # rad/s^2 else : raise NotImplementedError ( \"Flight mode has not been implemented\" ) # For forces/torques, assume we can operate at up to the max motor speed in RPM # See the Astrobee guide for more values if this is not the case MAX_FORCE = np . array ([ 0.849 , 0.406 , 0.486 ]) # Max force applied in local xyz axes MAX_TORQUE = MAX_FORCE / 10 # Max torques about local xyz axes # NOTE: The torque values are an approximation. See guide for reasoning # Slightly hacky force/torque magnitude values... In theory the world-frame force values depend on the orientation # of Astrobee, but we'll ignore this for now MAX_FORCE_MAGNITUDE = 0.849 MAX_TORQUE_MAGNITUDE = 0.849 / 10","title":"Module pyastrobee.config.astrobee_motion"},{"location":"reference/pyastrobee/config/astrobee_motion/#variables","text":"ANGULAR_ACCEL_LIMIT ANGULAR_SPEED_LIMIT FLIGHT_MODE LINEAR_ACCEL_LIMIT LINEAR_SPEED_LIMIT MAX_FORCE MAX_FORCE_MAGNITUDE MAX_TORQUE MAX_TORQUE_MAGNITUDE","title":"Variables"},{"location":"reference/pyastrobee/config/astrobee_motion/#classes","text":"","title":"Classes"},{"location":"reference/pyastrobee/config/astrobee_motion/#flightmodes","text":"class FlightModes ( / , * args , ** kwargs ) An enumeration. View Source class FlightModes ( Enum ): # Standard flight modes specified in the NASA codebase QUIET = 0 DIFFICULT = 1 NOMINAL = 2 LOMO = 3 # (not entirely sure what this mode means. locomotion?) # Custom flight modes MAXED_OUT = - 1","title":"FlightModes"},{"location":"reference/pyastrobee/config/astrobee_motion/#ancestors-in-mro","text":"enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/pyastrobee/config/astrobee_motion/#class-variables","text":"DIFFICULT LOMO MAXED_OUT NOMINAL QUIET name value","title":"Class variables"},{"location":"reference/pyastrobee/config/astrobee_transforms/","text":"Module pyastrobee.config.astrobee_transforms Transformation values for the Astrobee These are either hand-calibrated or directly from NASA's code We store these as transformation matrices Sourced from: - astrobee/config/geometry.config - astrobee/config/robots/honey.config View Source \"\"\"Transformation values for the Astrobee These are either hand-calibrated or directly from NASA's code We store these as transformation matrices Sourced from: - astrobee/config/geometry.config - astrobee/config/robots/honey.config \"\"\" # TODO # - Delete / comment any transforms that aren't used? # - Deal with placeholder for gripper to arm distal !!! import numpy as np from pyastrobee.utils.transformations import make_transform_mat , invert_transform_mat from pyastrobee.utils.rotations import quat_to_rmat , fixed_xyz_to_rmat # Transformation between the arm's distal link frame and the center of the grasp point # See the calibration script for more info GRIPPER_TO_ARM_DISTAL = make_transform_mat ( np . eye ( 3 ), [ - 0.08240211 , 0 , - 0.04971851 ]) ARM_DISTAL_TO_GRIPPER = invert_transform_mat ( GRIPPER_TO_ARM_DISTAL ) # Camera to robot for 3rd person view of the robot as it moves OBSERVATION_CAM = make_transform_mat ( fixed_xyz_to_rmat ([ 0 , - np . pi / 4 , 0 ]), [ - 0.7 , 0 , 0.5 ] ) # Camera # TODO need to verify these. They said these are placeholders and are not valid! PERCH_CAM = make_transform_mat ( quat_to_rmat ([ 0 , - 0.70710678118 , 0 , 0.70710678118 ]), [ - 0.1331 , 0.0509 , - 0.0166 ] ) HAZ_CAM = make_transform_mat ( quat_to_rmat ([ - 0.500 , 0.500 , - 0.500 , 0.500 ]), [ 0.1328 , 0.0362 , - 0.0826 ] ) NAV_CAM = make_transform_mat ( quat_to_rmat ([ 0.500 , 0.500 , 0.500 , 0.500 ]), [ 0.1157 + 0.002 , - 0.0422 , - 0.0826 ] ) DOCK_CAM = make_transform_mat ( quat_to_rmat ([ 0.500 , - 0.500 , - 0.500 , 0.500 ]), [ - 0.1032 - 0.0029 , - 0.0540 , - 0.0064 ] ) SCI_CAM = make_transform_mat ( quat_to_rmat ([ 0.500 , 0.500 , 0.500 , 0.500 ]), [ 0.118 , 0.0 , - 0.096 ] ) IMU = make_transform_mat ( quat_to_rmat ([ 0.000 , 0.000 , 0.70710678118 , 0.70710678118 ]), [ 0.0247 , 0.0183 , 0.0094 ] ) # These camera transforms below are unclear as to why they are needed NAV_CAM_TO_HAZ_CAM = make_transform_mat ( quat_to_rmat ([ - 0.0030431141 , 0.0092646368 , 0.99993195 , 0.0064039206 ]), [ 0.071421481 , - 0.00030319673 , 0.0018058249 ], ) NAV_CAM_TO_SCI_CAM = make_transform_mat ( quat_to_rmat ([ - 0.0035414316 , 0.0048089362 , - 0.0071515076 , 0.99995659 ]), [ - 0.076526224 , 0.011869553 , 0.045409155 ], ) # This transform I will assume is a valid transformation matrix, but it should probably be checked (TODO) # I am also unsure what this refers to HAZ_CAM_DEPTH_TO_IMAGE = np . array ( [ [ 0.91602851 , - 0.00031586647 , - 0.0028485861 , 0.0029767338 ], [ 0.00032189197 , 0.91603089 , 0.0019373744 , - 0.0020741879 ], [ 0.0028479115 , - 0.0019383659 , 0.91602652 , - 0.0042296964 ], [ 0 , 0 , 0 , 1 ], ] ) Variables ARM_DISTAL_TO_GRIPPER DOCK_CAM GRIPPER_TO_ARM_DISTAL HAZ_CAM HAZ_CAM_DEPTH_TO_IMAGE IMU NAV_CAM NAV_CAM_TO_HAZ_CAM NAV_CAM_TO_SCI_CAM OBSERVATION_CAM PERCH_CAM SCI_CAM","title":"Astrobee Transforms"},{"location":"reference/pyastrobee/config/astrobee_transforms/#module-pyastrobeeconfigastrobee_transforms","text":"Transformation values for the Astrobee These are either hand-calibrated or directly from NASA's code We store these as transformation matrices Sourced from: - astrobee/config/geometry.config - astrobee/config/robots/honey.config View Source \"\"\"Transformation values for the Astrobee These are either hand-calibrated or directly from NASA's code We store these as transformation matrices Sourced from: - astrobee/config/geometry.config - astrobee/config/robots/honey.config \"\"\" # TODO # - Delete / comment any transforms that aren't used? # - Deal with placeholder for gripper to arm distal !!! import numpy as np from pyastrobee.utils.transformations import make_transform_mat , invert_transform_mat from pyastrobee.utils.rotations import quat_to_rmat , fixed_xyz_to_rmat # Transformation between the arm's distal link frame and the center of the grasp point # See the calibration script for more info GRIPPER_TO_ARM_DISTAL = make_transform_mat ( np . eye ( 3 ), [ - 0.08240211 , 0 , - 0.04971851 ]) ARM_DISTAL_TO_GRIPPER = invert_transform_mat ( GRIPPER_TO_ARM_DISTAL ) # Camera to robot for 3rd person view of the robot as it moves OBSERVATION_CAM = make_transform_mat ( fixed_xyz_to_rmat ([ 0 , - np . pi / 4 , 0 ]), [ - 0.7 , 0 , 0.5 ] ) # Camera # TODO need to verify these. They said these are placeholders and are not valid! PERCH_CAM = make_transform_mat ( quat_to_rmat ([ 0 , - 0.70710678118 , 0 , 0.70710678118 ]), [ - 0.1331 , 0.0509 , - 0.0166 ] ) HAZ_CAM = make_transform_mat ( quat_to_rmat ([ - 0.500 , 0.500 , - 0.500 , 0.500 ]), [ 0.1328 , 0.0362 , - 0.0826 ] ) NAV_CAM = make_transform_mat ( quat_to_rmat ([ 0.500 , 0.500 , 0.500 , 0.500 ]), [ 0.1157 + 0.002 , - 0.0422 , - 0.0826 ] ) DOCK_CAM = make_transform_mat ( quat_to_rmat ([ 0.500 , - 0.500 , - 0.500 , 0.500 ]), [ - 0.1032 - 0.0029 , - 0.0540 , - 0.0064 ] ) SCI_CAM = make_transform_mat ( quat_to_rmat ([ 0.500 , 0.500 , 0.500 , 0.500 ]), [ 0.118 , 0.0 , - 0.096 ] ) IMU = make_transform_mat ( quat_to_rmat ([ 0.000 , 0.000 , 0.70710678118 , 0.70710678118 ]), [ 0.0247 , 0.0183 , 0.0094 ] ) # These camera transforms below are unclear as to why they are needed NAV_CAM_TO_HAZ_CAM = make_transform_mat ( quat_to_rmat ([ - 0.0030431141 , 0.0092646368 , 0.99993195 , 0.0064039206 ]), [ 0.071421481 , - 0.00030319673 , 0.0018058249 ], ) NAV_CAM_TO_SCI_CAM = make_transform_mat ( quat_to_rmat ([ - 0.0035414316 , 0.0048089362 , - 0.0071515076 , 0.99995659 ]), [ - 0.076526224 , 0.011869553 , 0.045409155 ], ) # This transform I will assume is a valid transformation matrix, but it should probably be checked (TODO) # I am also unsure what this refers to HAZ_CAM_DEPTH_TO_IMAGE = np . array ( [ [ 0.91602851 , - 0.00031586647 , - 0.0028485861 , 0.0029767338 ], [ 0.00032189197 , 0.91603089 , 0.0019373744 , - 0.0020741879 ], [ 0.0028479115 , - 0.0019383659 , 0.91602652 , - 0.0042296964 ], [ 0 , 0 , 0 , 1 ], ] )","title":"Module pyastrobee.config.astrobee_transforms"},{"location":"reference/pyastrobee/config/astrobee_transforms/#variables","text":"ARM_DISTAL_TO_GRIPPER DOCK_CAM GRIPPER_TO_ARM_DISTAL HAZ_CAM HAZ_CAM_DEPTH_TO_IMAGE IMU NAV_CAM NAV_CAM_TO_HAZ_CAM NAV_CAM_TO_SCI_CAM OBSERVATION_CAM PERCH_CAM SCI_CAM","title":"Variables"},{"location":"reference/pyastrobee/config/bag_properties/","text":"Module pyastrobee.config.bag_properties Cargo bag properties (including softbody info, geometry, ...) View Source \"\"\"Cargo bag properties (including softbody info, geometry, ...)\"\"\" import numpy as np from pyastrobee.utils.transformations import make_transform_mat from pyastrobee.utils.rotations import Rx , Ry , Rz # Transformation matrices (\"handle-to-bag\"). These are defined so that the Astrobee gripper frame will be able # to grasp the handle (z pointing along the handle, and x pointing out of the bag). \"Bag frame\" refers to the # center of mass frame of the bag (what pybullet returns when you query the bag's position/orientation) # Note: These need to be updated if the CAD changes FRONT_HANDLE_TRANSFORM = make_transform_mat ( Ry ( - np . pi / 2 ) @ Rz ( - np . pi / 2 ), [ 0 , - 0.16 , 0 ] ) BACK_HANDLE_TRANSFORM = make_transform_mat ( Rz ( np . pi / 2 ) @ Rx ( - np . pi / 2 ), [ 0 , 0.16 , 0 ]) LEFT_HANDLE_TRANSFORM = make_transform_mat ( Rz ( np . pi ), [ - 0.285 , 0 , 0 ]) RIGHT_HANDLE_TRANSFORM = make_transform_mat ( np . eye ( 3 ), [ 0.285 , 0 , 0 ]) TOP_HANDLE_TRANSFORM = make_transform_mat ( Ry ( - np . pi / 2 ), [ 0 , 0 , 0.245 ]) BOTTOM_HANDLE_TRANSFORM = make_transform_mat ( Ry ( np . pi / 2 ) @ Rx ( np . pi ), [ 0 , 0 , - 0.245 ]) # Softbody parameters (TODO: these may need to be refined) # Note: setting bending/elastic stiffness to 100 seems to work well too MASS = 1.0 BENDING_STIFFNESS = 50.0 DAMPING_STIFFNESS = 0.1 ELASTIC_STIFFNESS = 50.0 FRICTION_COEFF = 0.1 # Indices of the mesh vertices closest to the corners of the bags # These vertices are ordered as follows: # 0. Right back top # 1. Right back bottom # 2. Right front top # 3. Right front bottom # 4. Left back top # 5. Left back bottom # 6. Left front top # 7. Left front bottom FRONT_HANDLE_BAG_CORNERS = [ 289 , 371 , 241 , 207 , 330 , 338 , 359 , 225 ] RIGHT_HANDLE_BAG_CORNERS = [ 314 , 412 , 276 , 216 , 294 , 355 , 327 , 243 ] TOP_HANDLE_BAG_CORNERS = [ 296 , 243 , 281 , 99 , 237 , 151 , 171 , 262 ] FRONT_BACK_HANDLE_BAG_CORNERS = [ 438 , 431 , 319 , 290 , 347 , 392 , 311 , 305 ] RIGHT_LEFT_HANDLE_BAG_CORNERS = [ 461 , 609 , 410 , 611 , 444 , 518 , 395 , 502 ] TOP_BOTTOM_HANDLE_BAG_CORNERS = [ 356 , 359 , 333 , 322 , 346 , 331 , 214 , 316 ] # Dimensions of the bounding box around the main compartment of the bag (meters) BOX_LENGTH = 0.50 # X dimension BOX_WIDTH = 0.25 # Y dimension BOX_HEIGHT = 0.42 # Z dimension Variables BACK_HANDLE_TRANSFORM BENDING_STIFFNESS BOTTOM_HANDLE_TRANSFORM BOX_HEIGHT BOX_LENGTH BOX_WIDTH DAMPING_STIFFNESS ELASTIC_STIFFNESS FRICTION_COEFF FRONT_BACK_HANDLE_BAG_CORNERS FRONT_HANDLE_BAG_CORNERS FRONT_HANDLE_TRANSFORM LEFT_HANDLE_TRANSFORM MASS RIGHT_HANDLE_BAG_CORNERS RIGHT_HANDLE_TRANSFORM RIGHT_LEFT_HANDLE_BAG_CORNERS TOP_BOTTOM_HANDLE_BAG_CORNERS TOP_HANDLE_BAG_CORNERS TOP_HANDLE_TRANSFORM","title":"Bag Properties"},{"location":"reference/pyastrobee/config/bag_properties/#module-pyastrobeeconfigbag_properties","text":"Cargo bag properties (including softbody info, geometry, ...) View Source \"\"\"Cargo bag properties (including softbody info, geometry, ...)\"\"\" import numpy as np from pyastrobee.utils.transformations import make_transform_mat from pyastrobee.utils.rotations import Rx , Ry , Rz # Transformation matrices (\"handle-to-bag\"). These are defined so that the Astrobee gripper frame will be able # to grasp the handle (z pointing along the handle, and x pointing out of the bag). \"Bag frame\" refers to the # center of mass frame of the bag (what pybullet returns when you query the bag's position/orientation) # Note: These need to be updated if the CAD changes FRONT_HANDLE_TRANSFORM = make_transform_mat ( Ry ( - np . pi / 2 ) @ Rz ( - np . pi / 2 ), [ 0 , - 0.16 , 0 ] ) BACK_HANDLE_TRANSFORM = make_transform_mat ( Rz ( np . pi / 2 ) @ Rx ( - np . pi / 2 ), [ 0 , 0.16 , 0 ]) LEFT_HANDLE_TRANSFORM = make_transform_mat ( Rz ( np . pi ), [ - 0.285 , 0 , 0 ]) RIGHT_HANDLE_TRANSFORM = make_transform_mat ( np . eye ( 3 ), [ 0.285 , 0 , 0 ]) TOP_HANDLE_TRANSFORM = make_transform_mat ( Ry ( - np . pi / 2 ), [ 0 , 0 , 0.245 ]) BOTTOM_HANDLE_TRANSFORM = make_transform_mat ( Ry ( np . pi / 2 ) @ Rx ( np . pi ), [ 0 , 0 , - 0.245 ]) # Softbody parameters (TODO: these may need to be refined) # Note: setting bending/elastic stiffness to 100 seems to work well too MASS = 1.0 BENDING_STIFFNESS = 50.0 DAMPING_STIFFNESS = 0.1 ELASTIC_STIFFNESS = 50.0 FRICTION_COEFF = 0.1 # Indices of the mesh vertices closest to the corners of the bags # These vertices are ordered as follows: # 0. Right back top # 1. Right back bottom # 2. Right front top # 3. Right front bottom # 4. Left back top # 5. Left back bottom # 6. Left front top # 7. Left front bottom FRONT_HANDLE_BAG_CORNERS = [ 289 , 371 , 241 , 207 , 330 , 338 , 359 , 225 ] RIGHT_HANDLE_BAG_CORNERS = [ 314 , 412 , 276 , 216 , 294 , 355 , 327 , 243 ] TOP_HANDLE_BAG_CORNERS = [ 296 , 243 , 281 , 99 , 237 , 151 , 171 , 262 ] FRONT_BACK_HANDLE_BAG_CORNERS = [ 438 , 431 , 319 , 290 , 347 , 392 , 311 , 305 ] RIGHT_LEFT_HANDLE_BAG_CORNERS = [ 461 , 609 , 410 , 611 , 444 , 518 , 395 , 502 ] TOP_BOTTOM_HANDLE_BAG_CORNERS = [ 356 , 359 , 333 , 322 , 346 , 331 , 214 , 316 ] # Dimensions of the bounding box around the main compartment of the bag (meters) BOX_LENGTH = 0.50 # X dimension BOX_WIDTH = 0.25 # Y dimension BOX_HEIGHT = 0.42 # Z dimension","title":"Module pyastrobee.config.bag_properties"},{"location":"reference/pyastrobee/config/bag_properties/#variables","text":"BACK_HANDLE_TRANSFORM BENDING_STIFFNESS BOTTOM_HANDLE_TRANSFORM BOX_HEIGHT BOX_LENGTH BOX_WIDTH DAMPING_STIFFNESS ELASTIC_STIFFNESS FRICTION_COEFF FRONT_BACK_HANDLE_BAG_CORNERS FRONT_HANDLE_BAG_CORNERS FRONT_HANDLE_TRANSFORM LEFT_HANDLE_TRANSFORM MASS RIGHT_HANDLE_BAG_CORNERS RIGHT_HANDLE_TRANSFORM RIGHT_LEFT_HANDLE_BAG_CORNERS TOP_BOTTOM_HANDLE_BAG_CORNERS TOP_HANDLE_BAG_CORNERS TOP_HANDLE_TRANSFORM","title":"Variables"},{"location":"reference/pyastrobee/config/iss_paths/","text":"Module pyastrobee.config.iss_paths Alternative method for searching the graph of safe sets in the ISS The safe-set of boxes in the ISS is pretty small, so it's not too hard to just enumerate all of the paths between different boxes and use a lookup table. PATHS[start][end] will yield a list of safe boxes from start to end As compared with depth-first-search, the lookup table is about 10x faster using timeit To recompute the lookup table, re-run the script, copy the output here, and autoformat the file with Black View Source \"\"\"Alternative method for searching the graph of safe sets in the ISS The safe-set of boxes in the ISS is pretty small, so it's not too hard to just enumerate all of the paths between different boxes and use a lookup table. PATHS[start][end] will yield a list of safe boxes from start to end As compared with depth-first-search, the lookup table is about 10x faster using timeit To recompute the lookup table, re-run the script, copy the output here, and autoformat the file with Black \"\"\" from pprint import pprint from collections import defaultdict from pyastrobee.config.iss_safe_boxes import compute_iss_graph from pyastrobee.utils.algos import dfs # Slightly hacky but it works def _dp_dfs ( graph : dict [ str , list [ str ]]) -> dict [ str , dict [ str , list [ str ]]]: dp = defaultdict ( dict ) for start in graph : for end in graph : if start in dp and end in dp [ start ]: continue else : path = dfs ( graph , start , end ) for i in range ( len ( path )): for j in range ( i , len ( path )): dp [ path [ i ]][ path [ j ]] = path [ i : j + 1 ] return dp def print_path_lookup_table (): graph = compute_iss_graph () all_paths = _dp_dfs ( graph ) pprint ( dict ( all_paths ), indent = 0 , compact = True , width = 200 ) def print_graph (): graph = compute_iss_graph () pprint ( graph , indent = 0 , compact = True , width = 200 ) GRAPH = { \"cupola\" : [ \"n3_cupola_corridor\" ], \"eu_lab\" : [ \"n2_eu_corridor\" ], \"jpm\" : [ \"jpm_n2_corridor\" ], \"jpm_n2_corridor\" : [ \"jpm\" , \"node_2\" ], \"n1_n3_corridor\" : [ \"node_1\" , \"node_3_a\" ], \"n2_eu_corridor\" : [ \"node_2\" , \"eu_lab\" ], \"n2_us_corridor\" : [ \"node_2\" , \"us_lab\" ], \"n3_cupola_corridor\" : [ \"node_3_b\" , \"cupola\" ], \"node_1\" : [ \"us_n1_corridor\" , \"n1_n3_corridor\" ], \"node_2\" : [ \"jpm_n2_corridor\" , \"n2_eu_corridor\" , \"n2_us_corridor\" ], \"node_3_a\" : [ \"node_3_b\" , \"n1_n3_corridor\" ], \"node_3_b\" : [ \"node_3_a\" , \"n3_cupola_corridor\" ], \"us_lab\" : [ \"n2_us_corridor\" , \"us_n1_corridor\" ], \"us_n1_corridor\" : [ \"us_lab\" , \"node_1\" ], } PATHS = { \"cupola\" : { \"cupola\" : [ \"cupola\" ], \"eu_lab\" : [ \"cupola\" , \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"n2_eu_corridor\" , \"eu_lab\" , ], \"jpm\" : [ \"cupola\" , \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"jpm_n2_corridor\" , \"jpm\" , ], \"jpm_n2_corridor\" : [ \"cupola\" , \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"jpm_n2_corridor\" , ], \"n1_n3_corridor\" : [ \"cupola\" , \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , ], \"n2_eu_corridor\" : [ \"cupola\" , \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"n2_eu_corridor\" , ], \"n2_us_corridor\" : [ \"cupola\" , \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , ], \"n3_cupola_corridor\" : [ \"cupola\" , \"n3_cupola_corridor\" ], \"node_1\" : [ \"cupola\" , \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , ], \"node_2\" : [ \"cupola\" , \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , ], \"node_3_a\" : [ \"cupola\" , \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" ], \"node_3_b\" : [ \"cupola\" , \"n3_cupola_corridor\" , \"node_3_b\" ], \"us_lab\" : [ \"cupola\" , \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , ], \"us_n1_corridor\" : [ \"cupola\" , \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , ], }, \"eu_lab\" : { \"cupola\" : [ \"eu_lab\" , \"n2_eu_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , \"cupola\" , ], \"eu_lab\" : [ \"eu_lab\" ], \"jpm\" : [ \"eu_lab\" , \"n2_eu_corridor\" , \"node_2\" , \"jpm_n2_corridor\" , \"jpm\" ], \"jpm_n2_corridor\" : [ \"eu_lab\" , \"n2_eu_corridor\" , \"node_2\" , \"jpm_n2_corridor\" ], \"n1_n3_corridor\" : [ \"eu_lab\" , \"n2_eu_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , ], \"n2_eu_corridor\" : [ \"eu_lab\" , \"n2_eu_corridor\" ], \"n2_us_corridor\" : [ \"eu_lab\" , \"n2_eu_corridor\" , \"node_2\" , \"n2_us_corridor\" ], \"n3_cupola_corridor\" : [ \"eu_lab\" , \"n2_eu_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , ], \"node_1\" : [ \"eu_lab\" , \"n2_eu_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , ], \"node_2\" : [ \"eu_lab\" , \"n2_eu_corridor\" , \"node_2\" ], \"node_3_a\" : [ \"eu_lab\" , \"n2_eu_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , ], \"node_3_b\" : [ \"eu_lab\" , \"n2_eu_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , ], \"us_lab\" : [ \"eu_lab\" , \"n2_eu_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" ], \"us_n1_corridor\" : [ \"eu_lab\" , \"n2_eu_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , ], }, \"jpm\" : { \"cupola\" : [ \"jpm\" , \"jpm_n2_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , \"cupola\" , ], \"eu_lab\" : [ \"jpm\" , \"jpm_n2_corridor\" , \"node_2\" , \"n2_eu_corridor\" , \"eu_lab\" ], \"jpm\" : [ \"jpm\" ], \"jpm_n2_corridor\" : [ \"jpm\" , \"jpm_n2_corridor\" ], \"n1_n3_corridor\" : [ \"jpm\" , \"jpm_n2_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , ], \"n2_eu_corridor\" : [ \"jpm\" , \"jpm_n2_corridor\" , \"node_2\" , \"n2_eu_corridor\" ], \"n2_us_corridor\" : [ \"jpm\" , \"jpm_n2_corridor\" , \"node_2\" , \"n2_us_corridor\" ], \"n3_cupola_corridor\" : [ \"jpm\" , \"jpm_n2_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , ], \"node_1\" : [ \"jpm\" , \"jpm_n2_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , ], \"node_2\" : [ \"jpm\" , \"jpm_n2_corridor\" , \"node_2\" ], \"node_3_a\" : [ \"jpm\" , \"jpm_n2_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , ], \"node_3_b\" : [ \"jpm\" , \"jpm_n2_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , ], \"us_lab\" : [ \"jpm\" , \"jpm_n2_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" ], \"us_n1_corridor\" : [ \"jpm\" , \"jpm_n2_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , ], }, \"jpm_n2_corridor\" : { \"cupola\" : [ \"jpm_n2_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , \"cupola\" , ], \"eu_lab\" : [ \"jpm_n2_corridor\" , \"node_2\" , \"n2_eu_corridor\" , \"eu_lab\" ], \"jpm\" : [ \"jpm_n2_corridor\" , \"jpm\" ], \"jpm_n2_corridor\" : [ \"jpm_n2_corridor\" ], \"n1_n3_corridor\" : [ \"jpm_n2_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , ], \"n2_eu_corridor\" : [ \"jpm_n2_corridor\" , \"node_2\" , \"n2_eu_corridor\" ], \"n2_us_corridor\" : [ \"jpm_n2_corridor\" , \"node_2\" , \"n2_us_corridor\" ], \"n3_cupola_corridor\" : [ \"jpm_n2_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , ], \"node_1\" : [ \"jpm_n2_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , ], \"node_2\" : [ \"jpm_n2_corridor\" , \"node_2\" ], \"node_3_a\" : [ \"jpm_n2_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , ], \"node_3_b\" : [ \"jpm_n2_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , ], \"us_lab\" : [ \"jpm_n2_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" ], \"us_n1_corridor\" : [ \"jpm_n2_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , ], }, \"n1_n3_corridor\" : { \"cupola\" : [ \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , \"cupola\" , ], \"eu_lab\" : [ \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"n2_eu_corridor\" , \"eu_lab\" , ], \"jpm\" : [ \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"jpm_n2_corridor\" , \"jpm\" , ], \"jpm_n2_corridor\" : [ \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"jpm_n2_corridor\" , ], \"n1_n3_corridor\" : [ \"n1_n3_corridor\" ], \"n2_eu_corridor\" : [ \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"n2_eu_corridor\" , ], \"n2_us_corridor\" : [ \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , ], \"n3_cupola_corridor\" : [ \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , ], \"node_1\" : [ \"n1_n3_corridor\" , \"node_1\" ], \"node_2\" : [ \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , ], \"node_3_a\" : [ \"n1_n3_corridor\" , \"node_3_a\" ], \"node_3_b\" : [ \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" ], \"us_lab\" : [ \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" ], \"us_n1_corridor\" : [ \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" ], }, \"n2_eu_corridor\" : { \"cupola\" : [ \"n2_eu_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , \"cupola\" , ], \"eu_lab\" : [ \"n2_eu_corridor\" , \"eu_lab\" ], \"jpm\" : [ \"n2_eu_corridor\" , \"node_2\" , \"jpm_n2_corridor\" , \"jpm\" ], \"jpm_n2_corridor\" : [ \"n2_eu_corridor\" , \"node_2\" , \"jpm_n2_corridor\" ], \"n1_n3_corridor\" : [ \"n2_eu_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , ], \"n2_eu_corridor\" : [ \"n2_eu_corridor\" ], \"n2_us_corridor\" : [ \"n2_eu_corridor\" , \"node_2\" , \"n2_us_corridor\" ], \"n3_cupola_corridor\" : [ \"n2_eu_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , ], \"node_1\" : [ \"n2_eu_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , ], \"node_2\" : [ \"n2_eu_corridor\" , \"node_2\" ], \"node_3_a\" : [ \"n2_eu_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , ], \"node_3_b\" : [ \"n2_eu_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , ], \"us_lab\" : [ \"n2_eu_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" ], \"us_n1_corridor\" : [ \"n2_eu_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , ], }, \"n2_us_corridor\" : { \"cupola\" : [ \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , \"cupola\" , ], \"eu_lab\" : [ \"n2_us_corridor\" , \"node_2\" , \"n2_eu_corridor\" , \"eu_lab\" ], \"jpm\" : [ \"n2_us_corridor\" , \"node_2\" , \"jpm_n2_corridor\" , \"jpm\" ], \"jpm_n2_corridor\" : [ \"n2_us_corridor\" , \"node_2\" , \"jpm_n2_corridor\" ], \"n1_n3_corridor\" : [ \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , ], \"n2_eu_corridor\" : [ \"n2_us_corridor\" , \"node_2\" , \"n2_eu_corridor\" ], \"n2_us_corridor\" : [ \"n2_us_corridor\" ], \"n3_cupola_corridor\" : [ \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , ], \"node_1\" : [ \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" ], \"node_2\" : [ \"n2_us_corridor\" , \"node_2\" ], \"node_3_a\" : [ \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , ], \"node_3_b\" : [ \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , ], \"us_lab\" : [ \"n2_us_corridor\" , \"us_lab\" ], \"us_n1_corridor\" : [ \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" ], }, \"n3_cupola_corridor\" : { \"cupola\" : [ \"n3_cupola_corridor\" , \"cupola\" ], \"eu_lab\" : [ \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"n2_eu_corridor\" , \"eu_lab\" , ], \"jpm\" : [ \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"jpm_n2_corridor\" , \"jpm\" , ], \"jpm_n2_corridor\" : [ \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"jpm_n2_corridor\" , ], \"n1_n3_corridor\" : [ \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , ], \"n2_eu_corridor\" : [ \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"n2_eu_corridor\" , ], \"n2_us_corridor\" : [ \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , ], \"n3_cupola_corridor\" : [ \"n3_cupola_corridor\" ], \"node_1\" : [ \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , ], \"node_2\" : [ \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , ], \"node_3_a\" : [ \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" ], \"node_3_b\" : [ \"n3_cupola_corridor\" , \"node_3_b\" ], \"us_lab\" : [ \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , ], \"us_n1_corridor\" : [ \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , ], }, \"node_1\" : { \"cupola\" : [ \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , \"cupola\" , ], \"eu_lab\" : [ \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"n2_eu_corridor\" , \"eu_lab\" , ], \"jpm\" : [ \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"jpm_n2_corridor\" , \"jpm\" , ], \"jpm_n2_corridor\" : [ \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"jpm_n2_corridor\" , ], \"n1_n3_corridor\" : [ \"node_1\" , \"n1_n3_corridor\" ], \"n2_eu_corridor\" : [ \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"n2_eu_corridor\" , ], \"n2_us_corridor\" : [ \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" ], \"n3_cupola_corridor\" : [ \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , ], \"node_1\" : [ \"node_1\" ], \"node_2\" : [ \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" ], \"node_3_a\" : [ \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" ], \"node_3_b\" : [ \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" ], \"us_lab\" : [ \"node_1\" , \"us_n1_corridor\" , \"us_lab\" ], \"us_n1_corridor\" : [ \"node_1\" , \"us_n1_corridor\" ], }, \"node_2\" : { \"cupola\" : [ \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , \"cupola\" , ], \"eu_lab\" : [ \"node_2\" , \"n2_eu_corridor\" , \"eu_lab\" ], \"jpm\" : [ \"node_2\" , \"jpm_n2_corridor\" , \"jpm\" ], \"jpm_n2_corridor\" : [ \"node_2\" , \"jpm_n2_corridor\" ], \"n1_n3_corridor\" : [ \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , ], \"n2_eu_corridor\" : [ \"node_2\" , \"n2_eu_corridor\" ], \"n2_us_corridor\" : [ \"node_2\" , \"n2_us_corridor\" ], \"n3_cupola_corridor\" : [ \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , ], \"node_1\" : [ \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" ], \"node_2\" : [ \"node_2\" ], \"node_3_a\" : [ \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , ], \"node_3_b\" : [ \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , ], \"us_lab\" : [ \"node_2\" , \"n2_us_corridor\" , \"us_lab\" ], \"us_n1_corridor\" : [ \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" ], }, \"node_3_a\" : { \"cupola\" : [ \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , \"cupola\" ], \"eu_lab\" : [ \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"n2_eu_corridor\" , \"eu_lab\" , ], \"jpm\" : [ \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"jpm_n2_corridor\" , \"jpm\" , ], \"jpm_n2_corridor\" : [ \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"jpm_n2_corridor\" , ], \"n1_n3_corridor\" : [ \"node_3_a\" , \"n1_n3_corridor\" ], \"n2_eu_corridor\" : [ \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"n2_eu_corridor\" , ], \"n2_us_corridor\" : [ \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , ], \"n3_cupola_corridor\" : [ \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" ], \"node_1\" : [ \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" ], \"node_2\" : [ \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , ], \"node_3_a\" : [ \"node_3_a\" ], \"node_3_b\" : [ \"node_3_a\" , \"node_3_b\" ], \"us_lab\" : [ \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" ], \"us_n1_corridor\" : [ \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" ], }, \"node_3_b\" : { \"cupola\" : [ \"node_3_b\" , \"n3_cupola_corridor\" , \"cupola\" ], \"eu_lab\" : [ \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"n2_eu_corridor\" , \"eu_lab\" , ], \"jpm\" : [ \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"jpm_n2_corridor\" , \"jpm\" , ], \"jpm_n2_corridor\" : [ \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"jpm_n2_corridor\" , ], \"n1_n3_corridor\" : [ \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" ], \"n2_eu_corridor\" : [ \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"n2_eu_corridor\" , ], \"n2_us_corridor\" : [ \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , ], \"n3_cupola_corridor\" : [ \"node_3_b\" , \"n3_cupola_corridor\" ], \"node_1\" : [ \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" ], \"node_2\" : [ \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , ], \"node_3_a\" : [ \"node_3_b\" , \"node_3_a\" ], \"node_3_b\" : [ \"node_3_b\" ], \"us_lab\" : [ \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , ], \"us_n1_corridor\" : [ \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , ], }, \"us_lab\" : { \"cupola\" : [ \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , \"cupola\" , ], \"eu_lab\" : [ \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"n2_eu_corridor\" , \"eu_lab\" ], \"jpm\" : [ \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"jpm_n2_corridor\" , \"jpm\" ], \"jpm_n2_corridor\" : [ \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"jpm_n2_corridor\" ], \"n1_n3_corridor\" : [ \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" ], \"n2_eu_corridor\" : [ \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"n2_eu_corridor\" ], \"n2_us_corridor\" : [ \"us_lab\" , \"n2_us_corridor\" ], \"n3_cupola_corridor\" : [ \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , ], \"node_1\" : [ \"us_lab\" , \"us_n1_corridor\" , \"node_1\" ], \"node_2\" : [ \"us_lab\" , \"n2_us_corridor\" , \"node_2\" ], \"node_3_a\" : [ \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , ], \"node_3_b\" : [ \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , ], \"us_lab\" : [ \"us_lab\" ], \"us_n1_corridor\" : [ \"us_lab\" , \"us_n1_corridor\" ], }, \"us_n1_corridor\" : { \"cupola\" : [ \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , \"cupola\" , ], \"eu_lab\" : [ \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"n2_eu_corridor\" , \"eu_lab\" , ], \"jpm\" : [ \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"jpm_n2_corridor\" , \"jpm\" , ], \"jpm_n2_corridor\" : [ \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"jpm_n2_corridor\" , ], \"n1_n3_corridor\" : [ \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" ], \"n2_eu_corridor\" : [ \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"n2_eu_corridor\" , ], \"n2_us_corridor\" : [ \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" ], \"n3_cupola_corridor\" : [ \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , ], \"node_1\" : [ \"us_n1_corridor\" , \"node_1\" ], \"node_2\" : [ \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" ], \"node_3_a\" : [ \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" ], \"node_3_b\" : [ \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , ], \"us_lab\" : [ \"us_n1_corridor\" , \"us_lab\" ], \"us_n1_corridor\" : [ \"us_n1_corridor\" ], }, } if __name__ == \"__main__\" : print_path_lookup_table () print ( \" \\n -------------------------- \\n \" ) print_graph () Variables GRAPH PATHS Functions print_graph def print_graph ( ) View Source def print_graph(): graph = compute_iss_graph() pprint(graph, indent=0, compact=True, width=200) print_path_lookup_table def print_path_lookup_table ( ) View Source def print_path_lookup_table(): graph = compute_iss_graph() all_paths = _dp_dfs(graph) pprint(dict(all_paths), indent=0, compact=True, width=200)","title":"Iss Paths"},{"location":"reference/pyastrobee/config/iss_paths/#module-pyastrobeeconfigiss_paths","text":"Alternative method for searching the graph of safe sets in the ISS The safe-set of boxes in the ISS is pretty small, so it's not too hard to just enumerate all of the paths between different boxes and use a lookup table. PATHS[start][end] will yield a list of safe boxes from start to end As compared with depth-first-search, the lookup table is about 10x faster using timeit To recompute the lookup table, re-run the script, copy the output here, and autoformat the file with Black View Source \"\"\"Alternative method for searching the graph of safe sets in the ISS The safe-set of boxes in the ISS is pretty small, so it's not too hard to just enumerate all of the paths between different boxes and use a lookup table. PATHS[start][end] will yield a list of safe boxes from start to end As compared with depth-first-search, the lookup table is about 10x faster using timeit To recompute the lookup table, re-run the script, copy the output here, and autoformat the file with Black \"\"\" from pprint import pprint from collections import defaultdict from pyastrobee.config.iss_safe_boxes import compute_iss_graph from pyastrobee.utils.algos import dfs # Slightly hacky but it works def _dp_dfs ( graph : dict [ str , list [ str ]]) -> dict [ str , dict [ str , list [ str ]]]: dp = defaultdict ( dict ) for start in graph : for end in graph : if start in dp and end in dp [ start ]: continue else : path = dfs ( graph , start , end ) for i in range ( len ( path )): for j in range ( i , len ( path )): dp [ path [ i ]][ path [ j ]] = path [ i : j + 1 ] return dp def print_path_lookup_table (): graph = compute_iss_graph () all_paths = _dp_dfs ( graph ) pprint ( dict ( all_paths ), indent = 0 , compact = True , width = 200 ) def print_graph (): graph = compute_iss_graph () pprint ( graph , indent = 0 , compact = True , width = 200 ) GRAPH = { \"cupola\" : [ \"n3_cupola_corridor\" ], \"eu_lab\" : [ \"n2_eu_corridor\" ], \"jpm\" : [ \"jpm_n2_corridor\" ], \"jpm_n2_corridor\" : [ \"jpm\" , \"node_2\" ], \"n1_n3_corridor\" : [ \"node_1\" , \"node_3_a\" ], \"n2_eu_corridor\" : [ \"node_2\" , \"eu_lab\" ], \"n2_us_corridor\" : [ \"node_2\" , \"us_lab\" ], \"n3_cupola_corridor\" : [ \"node_3_b\" , \"cupola\" ], \"node_1\" : [ \"us_n1_corridor\" , \"n1_n3_corridor\" ], \"node_2\" : [ \"jpm_n2_corridor\" , \"n2_eu_corridor\" , \"n2_us_corridor\" ], \"node_3_a\" : [ \"node_3_b\" , \"n1_n3_corridor\" ], \"node_3_b\" : [ \"node_3_a\" , \"n3_cupola_corridor\" ], \"us_lab\" : [ \"n2_us_corridor\" , \"us_n1_corridor\" ], \"us_n1_corridor\" : [ \"us_lab\" , \"node_1\" ], } PATHS = { \"cupola\" : { \"cupola\" : [ \"cupola\" ], \"eu_lab\" : [ \"cupola\" , \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"n2_eu_corridor\" , \"eu_lab\" , ], \"jpm\" : [ \"cupola\" , \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"jpm_n2_corridor\" , \"jpm\" , ], \"jpm_n2_corridor\" : [ \"cupola\" , \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"jpm_n2_corridor\" , ], \"n1_n3_corridor\" : [ \"cupola\" , \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , ], \"n2_eu_corridor\" : [ \"cupola\" , \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"n2_eu_corridor\" , ], \"n2_us_corridor\" : [ \"cupola\" , \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , ], \"n3_cupola_corridor\" : [ \"cupola\" , \"n3_cupola_corridor\" ], \"node_1\" : [ \"cupola\" , \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , ], \"node_2\" : [ \"cupola\" , \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , ], \"node_3_a\" : [ \"cupola\" , \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" ], \"node_3_b\" : [ \"cupola\" , \"n3_cupola_corridor\" , \"node_3_b\" ], \"us_lab\" : [ \"cupola\" , \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , ], \"us_n1_corridor\" : [ \"cupola\" , \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , ], }, \"eu_lab\" : { \"cupola\" : [ \"eu_lab\" , \"n2_eu_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , \"cupola\" , ], \"eu_lab\" : [ \"eu_lab\" ], \"jpm\" : [ \"eu_lab\" , \"n2_eu_corridor\" , \"node_2\" , \"jpm_n2_corridor\" , \"jpm\" ], \"jpm_n2_corridor\" : [ \"eu_lab\" , \"n2_eu_corridor\" , \"node_2\" , \"jpm_n2_corridor\" ], \"n1_n3_corridor\" : [ \"eu_lab\" , \"n2_eu_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , ], \"n2_eu_corridor\" : [ \"eu_lab\" , \"n2_eu_corridor\" ], \"n2_us_corridor\" : [ \"eu_lab\" , \"n2_eu_corridor\" , \"node_2\" , \"n2_us_corridor\" ], \"n3_cupola_corridor\" : [ \"eu_lab\" , \"n2_eu_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , ], \"node_1\" : [ \"eu_lab\" , \"n2_eu_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , ], \"node_2\" : [ \"eu_lab\" , \"n2_eu_corridor\" , \"node_2\" ], \"node_3_a\" : [ \"eu_lab\" , \"n2_eu_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , ], \"node_3_b\" : [ \"eu_lab\" , \"n2_eu_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , ], \"us_lab\" : [ \"eu_lab\" , \"n2_eu_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" ], \"us_n1_corridor\" : [ \"eu_lab\" , \"n2_eu_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , ], }, \"jpm\" : { \"cupola\" : [ \"jpm\" , \"jpm_n2_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , \"cupola\" , ], \"eu_lab\" : [ \"jpm\" , \"jpm_n2_corridor\" , \"node_2\" , \"n2_eu_corridor\" , \"eu_lab\" ], \"jpm\" : [ \"jpm\" ], \"jpm_n2_corridor\" : [ \"jpm\" , \"jpm_n2_corridor\" ], \"n1_n3_corridor\" : [ \"jpm\" , \"jpm_n2_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , ], \"n2_eu_corridor\" : [ \"jpm\" , \"jpm_n2_corridor\" , \"node_2\" , \"n2_eu_corridor\" ], \"n2_us_corridor\" : [ \"jpm\" , \"jpm_n2_corridor\" , \"node_2\" , \"n2_us_corridor\" ], \"n3_cupola_corridor\" : [ \"jpm\" , \"jpm_n2_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , ], \"node_1\" : [ \"jpm\" , \"jpm_n2_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , ], \"node_2\" : [ \"jpm\" , \"jpm_n2_corridor\" , \"node_2\" ], \"node_3_a\" : [ \"jpm\" , \"jpm_n2_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , ], \"node_3_b\" : [ \"jpm\" , \"jpm_n2_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , ], \"us_lab\" : [ \"jpm\" , \"jpm_n2_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" ], \"us_n1_corridor\" : [ \"jpm\" , \"jpm_n2_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , ], }, \"jpm_n2_corridor\" : { \"cupola\" : [ \"jpm_n2_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , \"cupola\" , ], \"eu_lab\" : [ \"jpm_n2_corridor\" , \"node_2\" , \"n2_eu_corridor\" , \"eu_lab\" ], \"jpm\" : [ \"jpm_n2_corridor\" , \"jpm\" ], \"jpm_n2_corridor\" : [ \"jpm_n2_corridor\" ], \"n1_n3_corridor\" : [ \"jpm_n2_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , ], \"n2_eu_corridor\" : [ \"jpm_n2_corridor\" , \"node_2\" , \"n2_eu_corridor\" ], \"n2_us_corridor\" : [ \"jpm_n2_corridor\" , \"node_2\" , \"n2_us_corridor\" ], \"n3_cupola_corridor\" : [ \"jpm_n2_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , ], \"node_1\" : [ \"jpm_n2_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , ], \"node_2\" : [ \"jpm_n2_corridor\" , \"node_2\" ], \"node_3_a\" : [ \"jpm_n2_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , ], \"node_3_b\" : [ \"jpm_n2_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , ], \"us_lab\" : [ \"jpm_n2_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" ], \"us_n1_corridor\" : [ \"jpm_n2_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , ], }, \"n1_n3_corridor\" : { \"cupola\" : [ \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , \"cupola\" , ], \"eu_lab\" : [ \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"n2_eu_corridor\" , \"eu_lab\" , ], \"jpm\" : [ \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"jpm_n2_corridor\" , \"jpm\" , ], \"jpm_n2_corridor\" : [ \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"jpm_n2_corridor\" , ], \"n1_n3_corridor\" : [ \"n1_n3_corridor\" ], \"n2_eu_corridor\" : [ \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"n2_eu_corridor\" , ], \"n2_us_corridor\" : [ \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , ], \"n3_cupola_corridor\" : [ \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , ], \"node_1\" : [ \"n1_n3_corridor\" , \"node_1\" ], \"node_2\" : [ \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , ], \"node_3_a\" : [ \"n1_n3_corridor\" , \"node_3_a\" ], \"node_3_b\" : [ \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" ], \"us_lab\" : [ \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" ], \"us_n1_corridor\" : [ \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" ], }, \"n2_eu_corridor\" : { \"cupola\" : [ \"n2_eu_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , \"cupola\" , ], \"eu_lab\" : [ \"n2_eu_corridor\" , \"eu_lab\" ], \"jpm\" : [ \"n2_eu_corridor\" , \"node_2\" , \"jpm_n2_corridor\" , \"jpm\" ], \"jpm_n2_corridor\" : [ \"n2_eu_corridor\" , \"node_2\" , \"jpm_n2_corridor\" ], \"n1_n3_corridor\" : [ \"n2_eu_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , ], \"n2_eu_corridor\" : [ \"n2_eu_corridor\" ], \"n2_us_corridor\" : [ \"n2_eu_corridor\" , \"node_2\" , \"n2_us_corridor\" ], \"n3_cupola_corridor\" : [ \"n2_eu_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , ], \"node_1\" : [ \"n2_eu_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , ], \"node_2\" : [ \"n2_eu_corridor\" , \"node_2\" ], \"node_3_a\" : [ \"n2_eu_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , ], \"node_3_b\" : [ \"n2_eu_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , ], \"us_lab\" : [ \"n2_eu_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" ], \"us_n1_corridor\" : [ \"n2_eu_corridor\" , \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , ], }, \"n2_us_corridor\" : { \"cupola\" : [ \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , \"cupola\" , ], \"eu_lab\" : [ \"n2_us_corridor\" , \"node_2\" , \"n2_eu_corridor\" , \"eu_lab\" ], \"jpm\" : [ \"n2_us_corridor\" , \"node_2\" , \"jpm_n2_corridor\" , \"jpm\" ], \"jpm_n2_corridor\" : [ \"n2_us_corridor\" , \"node_2\" , \"jpm_n2_corridor\" ], \"n1_n3_corridor\" : [ \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , ], \"n2_eu_corridor\" : [ \"n2_us_corridor\" , \"node_2\" , \"n2_eu_corridor\" ], \"n2_us_corridor\" : [ \"n2_us_corridor\" ], \"n3_cupola_corridor\" : [ \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , ], \"node_1\" : [ \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" ], \"node_2\" : [ \"n2_us_corridor\" , \"node_2\" ], \"node_3_a\" : [ \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , ], \"node_3_b\" : [ \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , ], \"us_lab\" : [ \"n2_us_corridor\" , \"us_lab\" ], \"us_n1_corridor\" : [ \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" ], }, \"n3_cupola_corridor\" : { \"cupola\" : [ \"n3_cupola_corridor\" , \"cupola\" ], \"eu_lab\" : [ \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"n2_eu_corridor\" , \"eu_lab\" , ], \"jpm\" : [ \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"jpm_n2_corridor\" , \"jpm\" , ], \"jpm_n2_corridor\" : [ \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"jpm_n2_corridor\" , ], \"n1_n3_corridor\" : [ \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , ], \"n2_eu_corridor\" : [ \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"n2_eu_corridor\" , ], \"n2_us_corridor\" : [ \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , ], \"n3_cupola_corridor\" : [ \"n3_cupola_corridor\" ], \"node_1\" : [ \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , ], \"node_2\" : [ \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , ], \"node_3_a\" : [ \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" ], \"node_3_b\" : [ \"n3_cupola_corridor\" , \"node_3_b\" ], \"us_lab\" : [ \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , ], \"us_n1_corridor\" : [ \"n3_cupola_corridor\" , \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , ], }, \"node_1\" : { \"cupola\" : [ \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , \"cupola\" , ], \"eu_lab\" : [ \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"n2_eu_corridor\" , \"eu_lab\" , ], \"jpm\" : [ \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"jpm_n2_corridor\" , \"jpm\" , ], \"jpm_n2_corridor\" : [ \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"jpm_n2_corridor\" , ], \"n1_n3_corridor\" : [ \"node_1\" , \"n1_n3_corridor\" ], \"n2_eu_corridor\" : [ \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"n2_eu_corridor\" , ], \"n2_us_corridor\" : [ \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" ], \"n3_cupola_corridor\" : [ \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , ], \"node_1\" : [ \"node_1\" ], \"node_2\" : [ \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" ], \"node_3_a\" : [ \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" ], \"node_3_b\" : [ \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" ], \"us_lab\" : [ \"node_1\" , \"us_n1_corridor\" , \"us_lab\" ], \"us_n1_corridor\" : [ \"node_1\" , \"us_n1_corridor\" ], }, \"node_2\" : { \"cupola\" : [ \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , \"cupola\" , ], \"eu_lab\" : [ \"node_2\" , \"n2_eu_corridor\" , \"eu_lab\" ], \"jpm\" : [ \"node_2\" , \"jpm_n2_corridor\" , \"jpm\" ], \"jpm_n2_corridor\" : [ \"node_2\" , \"jpm_n2_corridor\" ], \"n1_n3_corridor\" : [ \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , ], \"n2_eu_corridor\" : [ \"node_2\" , \"n2_eu_corridor\" ], \"n2_us_corridor\" : [ \"node_2\" , \"n2_us_corridor\" ], \"n3_cupola_corridor\" : [ \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , ], \"node_1\" : [ \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" ], \"node_2\" : [ \"node_2\" ], \"node_3_a\" : [ \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , ], \"node_3_b\" : [ \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , ], \"us_lab\" : [ \"node_2\" , \"n2_us_corridor\" , \"us_lab\" ], \"us_n1_corridor\" : [ \"node_2\" , \"n2_us_corridor\" , \"us_lab\" , \"us_n1_corridor\" ], }, \"node_3_a\" : { \"cupola\" : [ \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , \"cupola\" ], \"eu_lab\" : [ \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"n2_eu_corridor\" , \"eu_lab\" , ], \"jpm\" : [ \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"jpm_n2_corridor\" , \"jpm\" , ], \"jpm_n2_corridor\" : [ \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"jpm_n2_corridor\" , ], \"n1_n3_corridor\" : [ \"node_3_a\" , \"n1_n3_corridor\" ], \"n2_eu_corridor\" : [ \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"n2_eu_corridor\" , ], \"n2_us_corridor\" : [ \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , ], \"n3_cupola_corridor\" : [ \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" ], \"node_1\" : [ \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" ], \"node_2\" : [ \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , ], \"node_3_a\" : [ \"node_3_a\" ], \"node_3_b\" : [ \"node_3_a\" , \"node_3_b\" ], \"us_lab\" : [ \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" ], \"us_n1_corridor\" : [ \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" ], }, \"node_3_b\" : { \"cupola\" : [ \"node_3_b\" , \"n3_cupola_corridor\" , \"cupola\" ], \"eu_lab\" : [ \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"n2_eu_corridor\" , \"eu_lab\" , ], \"jpm\" : [ \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"jpm_n2_corridor\" , \"jpm\" , ], \"jpm_n2_corridor\" : [ \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"jpm_n2_corridor\" , ], \"n1_n3_corridor\" : [ \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" ], \"n2_eu_corridor\" : [ \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"n2_eu_corridor\" , ], \"n2_us_corridor\" : [ \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , ], \"n3_cupola_corridor\" : [ \"node_3_b\" , \"n3_cupola_corridor\" ], \"node_1\" : [ \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" ], \"node_2\" : [ \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , ], \"node_3_a\" : [ \"node_3_b\" , \"node_3_a\" ], \"node_3_b\" : [ \"node_3_b\" ], \"us_lab\" : [ \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , \"us_lab\" , ], \"us_n1_corridor\" : [ \"node_3_b\" , \"node_3_a\" , \"n1_n3_corridor\" , \"node_1\" , \"us_n1_corridor\" , ], }, \"us_lab\" : { \"cupola\" : [ \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , \"cupola\" , ], \"eu_lab\" : [ \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"n2_eu_corridor\" , \"eu_lab\" ], \"jpm\" : [ \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"jpm_n2_corridor\" , \"jpm\" ], \"jpm_n2_corridor\" : [ \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"jpm_n2_corridor\" ], \"n1_n3_corridor\" : [ \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" ], \"n2_eu_corridor\" : [ \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"n2_eu_corridor\" ], \"n2_us_corridor\" : [ \"us_lab\" , \"n2_us_corridor\" ], \"n3_cupola_corridor\" : [ \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , ], \"node_1\" : [ \"us_lab\" , \"us_n1_corridor\" , \"node_1\" ], \"node_2\" : [ \"us_lab\" , \"n2_us_corridor\" , \"node_2\" ], \"node_3_a\" : [ \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , ], \"node_3_b\" : [ \"us_lab\" , \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , ], \"us_lab\" : [ \"us_lab\" ], \"us_n1_corridor\" : [ \"us_lab\" , \"us_n1_corridor\" ], }, \"us_n1_corridor\" : { \"cupola\" : [ \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , \"cupola\" , ], \"eu_lab\" : [ \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"n2_eu_corridor\" , \"eu_lab\" , ], \"jpm\" : [ \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"jpm_n2_corridor\" , \"jpm\" , ], \"jpm_n2_corridor\" : [ \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"jpm_n2_corridor\" , ], \"n1_n3_corridor\" : [ \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" ], \"n2_eu_corridor\" : [ \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" , \"n2_eu_corridor\" , ], \"n2_us_corridor\" : [ \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" ], \"n3_cupola_corridor\" : [ \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , \"n3_cupola_corridor\" , ], \"node_1\" : [ \"us_n1_corridor\" , \"node_1\" ], \"node_2\" : [ \"us_n1_corridor\" , \"us_lab\" , \"n2_us_corridor\" , \"node_2\" ], \"node_3_a\" : [ \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" ], \"node_3_b\" : [ \"us_n1_corridor\" , \"node_1\" , \"n1_n3_corridor\" , \"node_3_a\" , \"node_3_b\" , ], \"us_lab\" : [ \"us_n1_corridor\" , \"us_lab\" ], \"us_n1_corridor\" : [ \"us_n1_corridor\" ], }, } if __name__ == \"__main__\" : print_path_lookup_table () print ( \" \\n -------------------------- \\n \" ) print_graph ()","title":"Module pyastrobee.config.iss_paths"},{"location":"reference/pyastrobee/config/iss_paths/#variables","text":"GRAPH PATHS","title":"Variables"},{"location":"reference/pyastrobee/config/iss_paths/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/config/iss_paths/#print_graph","text":"def print_graph ( ) View Source def print_graph(): graph = compute_iss_graph() pprint(graph, indent=0, compact=True, width=200)","title":"print_graph"},{"location":"reference/pyastrobee/config/iss_paths/#print_path_lookup_table","text":"def print_path_lookup_table ( ) View Source def print_path_lookup_table(): graph = compute_iss_graph() all_paths = _dp_dfs(graph) pprint(dict(all_paths), indent=0, compact=True, width=200)","title":"print_path_lookup_table"},{"location":"reference/pyastrobee/config/iss_safe_boxes/","text":"Module pyastrobee.config.iss_safe_boxes Description of the free space within the ISS as a collection of safe boxes View Source \"\"\"Description of the free space within the ISS as a collection of safe boxes\"\"\" from pyastrobee.config.astrobee_geom import COLLISION_RADIUS from pyastrobee.utils.boxes import Box , visualize_3D_box , compute_graph , contract_box from pyastrobee.utils.algos import dfs # TODO: # Test cases: # - Avoid 3-way intersections # - Ensure that the graph is connected # (Run these tests when accounting for the collision radius of the Astrobee) # Names of the safe boxes in the ISS # Originally these were an enum but this made indexing in the graph search weird # Strings are easier so we'll assign them to constants here just for reduced chance of error JPM = \"jpm\" NODE_2 = \"node_2\" EU_LAB = \"eu_lab\" US_LAB = \"us_lab\" NODE_1 = \"node_1\" # Node 3 has two boxes since there is a toilet blocking an area NODE_3_A = \"node_3_a\" NODE_3_B = \"node_3_b\" CUPOLA = \"cupola\" # Corridors between modules JPM_N2_CORRIDOR = \"jpm_n2_corridor\" N2_EU_CORRIDOR = \"n2_eu_corridor\" N2_US_CORRIDOR = \"n2_us_corridor\" US_N1_CORRIDOR = \"us_n1_corridor\" N1_N3_CORRIDOR = \"n1_n3_corridor\" N3_CUPOLA_CORRIDOR = \"n3_cupola_corridor\" # Full description of free space within the ISS (Manually calibrated from simulation) FULL_SAFE_SET = { JPM : Box ([ 3.200 , - 0.775 , - 1.000 ], [ 10.500 , 0.912 , 1.000 ]), NODE_2 : Box ([ - 1.000 , - 2.458 , - 1.100 ], [ 1.100 , 1.091 , 0.924 ]), EU_LAB : Box ([ - 7.703 , - 0.866 , - 1.000 ], [ - 3.400 , 0.925 , 1.000 ]), US_LAB : Box ([ - 1.000 , - 11.265 , - 1.000 ], [ 0.874 , - 5.806 , 1.000 ]), NODE_1 : Box ([ - 0.952 , - 17.165 , - 1.000 ], [ 1.000 , - 13.449 , 1.028 ]), NODE_3_A : Box ([ 2.900 , - 15.589 , - 1.000 ], [ 6.322 , - 14.700 , 0.588 ]), NODE_3_B : Box ([ 4.958 , - 15.53 , - 1.000 ], [ 7.646 , - 14.107 , 0.939 ]), CUPOLA : Box ([ 5.900 , - 15.18 , 1.367 ], [ 6.662 , - 14.285 , 3.158 ]), JPM_N2_CORRIDOR : Box ([ 0.100 , - 0.475 , - 0.600 ], [ 4.800 , 0.475 , 0.600 ]), N2_EU_CORRIDOR : Box ([ - 4.800 , - 0.475 , - 0.600 ], [ - 0.100 , 0.475 , 0.600 ]), N2_US_CORRIDOR : Box ([ - 0.600 , - 6.902 , - 0.600 ], [ 0.600 , - 1.348 , 0.600 ]), US_N1_CORRIDOR : Box ([ - 0.600 , - 14.350 , - 0.600 ], [ 0.600 , - 10.200 , 0.600 ]), N1_N3_CORRIDOR : Box ([ - 0.100 , - 15.400 , - 0.600 ], [ 4.18 , - 14.400 , 0.600 ]), N3_CUPOLA_CORRIDOR : Box ([ 5.800 , - 15.421 , 0.119 ], [ 7.000 , - 14.100 , 2.179 ]), } # Locations where the robot base can travel (the full safe set but shrunk by the collision radius) ROBOT_SAFE_SET = { module : contract_box ( box , COLLISION_RADIUS ) for ( module , box ) in FULL_SAFE_SET . items () } def compute_iss_graph () -> dict [ str , list [ str ]]: \"\"\"Computes the graph between the safe sets in the ISS based on intersecting safe boxes Returns: dict[str, list[str]]: Adjacency list / graph dictating safe paths in the ISS. Key/value pair is: (name of the module) -> (list of names of all neighbors of that module) \"\"\" # Use the robot safe set here because it gives a better description of motion # If we use the full safe set there could be some locations with 3-way intersections that don't present themselves # when planning for working with the robot return compute_graph ( ROBOT_SAFE_SET ) def _show_iss_boxes (): \"\"\"Visualize the safe set in Pybullet\"\"\" import pybullet # pylint: disable=import-outside-toplevel pybullet . connect ( pybullet . GUI ) for box in FULL_SAFE_SET . values (): visualize_3D_box ( box , rgba = ( 1 , 0 , 0 , 0.5 )) for box in ROBOT_SAFE_SET . values (): visualize_3D_box ( box , rgba = ( 0 , 0 , 1 , 0.5 )) input ( \"Press Enter to exit\" ) pybullet . disconnect () def _test_graph_search (): \"\"\"Example of computing the path between boxes in the ISS\"\"\" graph = compute_iss_graph () start = JPM end = CUPOLA path = dfs ( graph , start , end ) print ( f \"Box sequence between { start } and { end } : \" ) print ( path ) if __name__ == \"__main__\" : _test_graph_search () _show_iss_boxes () Variables COLLISION_RADIUS CUPOLA EU_LAB FULL_SAFE_SET JPM JPM_N2_CORRIDOR N1_N3_CORRIDOR N2_EU_CORRIDOR N2_US_CORRIDOR N3_CUPOLA_CORRIDOR NODE_1 NODE_2 NODE_3_A NODE_3_B ROBOT_SAFE_SET US_LAB US_N1_CORRIDOR Functions compute_iss_graph def compute_iss_graph ( ) -> dict [ str , list [ str ]] Computes the graph between the safe sets in the ISS based on intersecting safe boxes Returns: Type Description dict[str, list[str]] Adjacency list / graph dictating safe paths in the ISS. Key/value pair is: (name of the module) -> (list of names of all neighbors of that module) View Source def compute_iss_graph () -> dict [ str, list[str ] ]: \"\"\"Computes the graph between the safe sets in the ISS based on intersecting safe boxes Returns: dict[str, list[str]]: Adjacency list / graph dictating safe paths in the ISS. Key/value pair is: (name of the module) -> (list of names of all neighbors of that module) \"\"\" # Use the robot safe set here because it gives a better description of motion # If we use the full safe set there could be some locations with 3 - way intersections that don ' t present themselves # when planning for working with the robot return compute_graph ( ROBOT_SAFE_SET )","title":"Iss Safe Boxes"},{"location":"reference/pyastrobee/config/iss_safe_boxes/#module-pyastrobeeconfigiss_safe_boxes","text":"Description of the free space within the ISS as a collection of safe boxes View Source \"\"\"Description of the free space within the ISS as a collection of safe boxes\"\"\" from pyastrobee.config.astrobee_geom import COLLISION_RADIUS from pyastrobee.utils.boxes import Box , visualize_3D_box , compute_graph , contract_box from pyastrobee.utils.algos import dfs # TODO: # Test cases: # - Avoid 3-way intersections # - Ensure that the graph is connected # (Run these tests when accounting for the collision radius of the Astrobee) # Names of the safe boxes in the ISS # Originally these were an enum but this made indexing in the graph search weird # Strings are easier so we'll assign them to constants here just for reduced chance of error JPM = \"jpm\" NODE_2 = \"node_2\" EU_LAB = \"eu_lab\" US_LAB = \"us_lab\" NODE_1 = \"node_1\" # Node 3 has two boxes since there is a toilet blocking an area NODE_3_A = \"node_3_a\" NODE_3_B = \"node_3_b\" CUPOLA = \"cupola\" # Corridors between modules JPM_N2_CORRIDOR = \"jpm_n2_corridor\" N2_EU_CORRIDOR = \"n2_eu_corridor\" N2_US_CORRIDOR = \"n2_us_corridor\" US_N1_CORRIDOR = \"us_n1_corridor\" N1_N3_CORRIDOR = \"n1_n3_corridor\" N3_CUPOLA_CORRIDOR = \"n3_cupola_corridor\" # Full description of free space within the ISS (Manually calibrated from simulation) FULL_SAFE_SET = { JPM : Box ([ 3.200 , - 0.775 , - 1.000 ], [ 10.500 , 0.912 , 1.000 ]), NODE_2 : Box ([ - 1.000 , - 2.458 , - 1.100 ], [ 1.100 , 1.091 , 0.924 ]), EU_LAB : Box ([ - 7.703 , - 0.866 , - 1.000 ], [ - 3.400 , 0.925 , 1.000 ]), US_LAB : Box ([ - 1.000 , - 11.265 , - 1.000 ], [ 0.874 , - 5.806 , 1.000 ]), NODE_1 : Box ([ - 0.952 , - 17.165 , - 1.000 ], [ 1.000 , - 13.449 , 1.028 ]), NODE_3_A : Box ([ 2.900 , - 15.589 , - 1.000 ], [ 6.322 , - 14.700 , 0.588 ]), NODE_3_B : Box ([ 4.958 , - 15.53 , - 1.000 ], [ 7.646 , - 14.107 , 0.939 ]), CUPOLA : Box ([ 5.900 , - 15.18 , 1.367 ], [ 6.662 , - 14.285 , 3.158 ]), JPM_N2_CORRIDOR : Box ([ 0.100 , - 0.475 , - 0.600 ], [ 4.800 , 0.475 , 0.600 ]), N2_EU_CORRIDOR : Box ([ - 4.800 , - 0.475 , - 0.600 ], [ - 0.100 , 0.475 , 0.600 ]), N2_US_CORRIDOR : Box ([ - 0.600 , - 6.902 , - 0.600 ], [ 0.600 , - 1.348 , 0.600 ]), US_N1_CORRIDOR : Box ([ - 0.600 , - 14.350 , - 0.600 ], [ 0.600 , - 10.200 , 0.600 ]), N1_N3_CORRIDOR : Box ([ - 0.100 , - 15.400 , - 0.600 ], [ 4.18 , - 14.400 , 0.600 ]), N3_CUPOLA_CORRIDOR : Box ([ 5.800 , - 15.421 , 0.119 ], [ 7.000 , - 14.100 , 2.179 ]), } # Locations where the robot base can travel (the full safe set but shrunk by the collision radius) ROBOT_SAFE_SET = { module : contract_box ( box , COLLISION_RADIUS ) for ( module , box ) in FULL_SAFE_SET . items () } def compute_iss_graph () -> dict [ str , list [ str ]]: \"\"\"Computes the graph between the safe sets in the ISS based on intersecting safe boxes Returns: dict[str, list[str]]: Adjacency list / graph dictating safe paths in the ISS. Key/value pair is: (name of the module) -> (list of names of all neighbors of that module) \"\"\" # Use the robot safe set here because it gives a better description of motion # If we use the full safe set there could be some locations with 3-way intersections that don't present themselves # when planning for working with the robot return compute_graph ( ROBOT_SAFE_SET ) def _show_iss_boxes (): \"\"\"Visualize the safe set in Pybullet\"\"\" import pybullet # pylint: disable=import-outside-toplevel pybullet . connect ( pybullet . GUI ) for box in FULL_SAFE_SET . values (): visualize_3D_box ( box , rgba = ( 1 , 0 , 0 , 0.5 )) for box in ROBOT_SAFE_SET . values (): visualize_3D_box ( box , rgba = ( 0 , 0 , 1 , 0.5 )) input ( \"Press Enter to exit\" ) pybullet . disconnect () def _test_graph_search (): \"\"\"Example of computing the path between boxes in the ISS\"\"\" graph = compute_iss_graph () start = JPM end = CUPOLA path = dfs ( graph , start , end ) print ( f \"Box sequence between { start } and { end } : \" ) print ( path ) if __name__ == \"__main__\" : _test_graph_search () _show_iss_boxes ()","title":"Module pyastrobee.config.iss_safe_boxes"},{"location":"reference/pyastrobee/config/iss_safe_boxes/#variables","text":"COLLISION_RADIUS CUPOLA EU_LAB FULL_SAFE_SET JPM JPM_N2_CORRIDOR N1_N3_CORRIDOR N2_EU_CORRIDOR N2_US_CORRIDOR N3_CUPOLA_CORRIDOR NODE_1 NODE_2 NODE_3_A NODE_3_B ROBOT_SAFE_SET US_LAB US_N1_CORRIDOR","title":"Variables"},{"location":"reference/pyastrobee/config/iss_safe_boxes/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/config/iss_safe_boxes/#compute_iss_graph","text":"def compute_iss_graph ( ) -> dict [ str , list [ str ]] Computes the graph between the safe sets in the ISS based on intersecting safe boxes Returns: Type Description dict[str, list[str]] Adjacency list / graph dictating safe paths in the ISS. Key/value pair is: (name of the module) -> (list of names of all neighbors of that module) View Source def compute_iss_graph () -> dict [ str, list[str ] ]: \"\"\"Computes the graph between the safe sets in the ISS based on intersecting safe boxes Returns: dict[str, list[str]]: Adjacency list / graph dictating safe paths in the ISS. Key/value pair is: (name of the module) -> (list of names of all neighbors of that module) \"\"\" # Use the robot safe set here because it gives a better description of motion # If we use the full safe set there could be some locations with 3 - way intersections that don ' t present themselves # when planning for working with the robot return compute_graph ( ROBOT_SAFE_SET )","title":"compute_iss_graph"},{"location":"reference/pyastrobee/control/","text":"Module pyastrobee.control Sub-modules pyastrobee.control.constraint_controller pyastrobee.control.force_torque_control pyastrobee.control.keyboard_controller pyastrobee.control.metrics pyastrobee.control.multi_robot pyastrobee.control.sampling_mpc pyastrobee.control.sampling_mpc_multithreaded","title":"Index"},{"location":"reference/pyastrobee/control/#module-pyastrobeecontrol","text":"","title":"Module pyastrobee.control"},{"location":"reference/pyastrobee/control/#sub-modules","text":"pyastrobee.control.constraint_controller pyastrobee.control.force_torque_control pyastrobee.control.keyboard_controller pyastrobee.control.metrics pyastrobee.control.multi_robot pyastrobee.control.sampling_mpc pyastrobee.control.sampling_mpc_multithreaded","title":"Sub-modules"},{"location":"reference/pyastrobee/control/constraint_controller/","text":"Module pyastrobee.control.constraint_controller Constraint controller: Simple, non-physically-realistic position control with Pybullet soft constraints Useful for debugging, but not for real control View Source \"\"\"Constraint controller: Simple, non-physically-realistic position control with Pybullet soft constraints Useful for debugging, but not for real control \"\"\" import time from typing import Optional import pybullet import numpy as np import numpy.typing as npt from pyastrobee.core.astrobee import Astrobee from pyastrobee.trajectories.simple_trajectories import point_and_move_pose_traj class ConstraintController : \"\"\"A non-physically-realistic controller for Astrobee using Pybullet soft constraints Args: robot (Astrobee): The Astrobee being controlled \"\"\" def __init__ ( self , robot : Astrobee ): self . robot = robot self . _pose_command = None self . constraint_id = pybullet . createConstraint ( self . robot . id , - 1 , - 1 , - 1 , pybullet . JOINT_FIXED , None , ( 0 , 0 , 0 ), ( 0 , 0 , 0 ) ) @property def pose_command ( self ) -> np . ndarray : \"\"\"Position and xyzw quaternion pose\"\"\" return self . _pose_command @pose_command . setter def pose_command ( self , cmd : npt . ArrayLike ) -> np . ndarray : if not len ( cmd ) == 7 : raise ValueError ( f \"Invalid pose. Got: { cmd } \" ) self . _pose_command = cmd def go_to_pose ( self , pose : npt . ArrayLike , pos_stepsize : float = 0.01 , orn_stepsize : float = 0.01 , max_force : float = 500 , sleep : Optional [ float ] = None , ) -> None : \"\"\"Navigates to a new pose Current method (nothing fancy at the moment): - Orient towards the goal position - Move along a straight line to the goal position - Orient towards the goal orientation Args: pose (npt.ArrayLike): Desired new pose (position + quaternion) for the astrobee pos_stepsize (float, optional): Stepsize for consecutive points in the straight-line motion part of the trajectory. Defaults to 0.01 orn_stepsize (float, optional): Stepsize for consecutive points in the orientation parts of the trajectory. Defaults to 0.01 max_force (float, optional): Maximum force to apply to the constraint. Defaults to 500. sleep (float, optional): Time to sleep between each step. Defaults to None. \"\"\" assert isinstance ( pos_stepsize , ( float , int )) and pos_stepsize > 0 assert isinstance ( orn_stepsize , ( float , int )) and orn_stepsize > 0 assert isinstance ( max_force , ( float , int )) and max_force > 0 assert isinstance ( sleep , (( float , int ), type ( None ))) and ( sleep is None or sleep > 0 ) traj = point_and_move_pose_traj ( self . robot . pose , pose , pos_stepsize , orn_stepsize ) for i in range ( traj . shape [ 0 ]): pybullet . changeConstraint ( self . constraint_id , traj [ i , : 3 ], traj [ i , 3 :], maxForce = max_force ) pybullet . stepSimulation () if sleep is not None : time . sleep ( sleep ) def delete_constraint ( self ) -> None : \"\"\"Deletes the constraint between the Astrobee and the world\"\"\" pybullet . removeConstraint ( self . constraint_id ) def main (): # Simple controller test pybullet . connect ( pybullet . GUI ) robot = Astrobee () constraint_controller = ConstraintController ( robot ) constraint_controller . go_to_pose ( [ 0.446 , - 1.338 , 0.446 , 0.088 , 0.067 , - 0.787 , 0.606 ], sleep = 1 / 240 ) print ( \"Position control complete\" ) input ( \"Press enter to exit\" ) pybullet . disconnect () if __name__ == \"__main__\" : main () Functions main def main ( ) View Source def main (): # Simple controller test pybullet . connect ( pybullet . GUI ) robot = Astrobee () constraint_controller = ConstraintController ( robot ) constraint_controller . go_to_pose ( [ 0.446 , - 1.338 , 0.446 , 0.088 , 0.067 , - 0.787 , 0.606 ], sleep = 1 / 240 ) print ( \"Position control complete\" ) input ( \"Press enter to exit\" ) pybullet . disconnect () Classes ConstraintController class ConstraintController ( robot : pyastrobee . core . astrobee . Astrobee ) A non-physically-realistic controller for Astrobee using Pybullet soft constraints Attributes Name Type Description Default robot Astrobee The Astrobee being controlled None View Source class ConstraintController : \"\"\"A non-physically-realistic controller for Astrobee using Pybullet soft constraints Args: robot (Astrobee): The Astrobee being controlled \"\"\" def __init__ ( self , robot : Astrobee ) : self . robot = robot self . _pose_command = None self . constraint_id = pybullet . createConstraint ( self . robot . id , - 1 , - 1 , - 1 , pybullet . JOINT_FIXED , None , ( 0 , 0 , 0 ), ( 0 , 0 , 0 ) ) @property def pose_command ( self ) -> np . ndarray : \"\"\"Position and xyzw quaternion pose\"\"\" return self . _pose_command @pose_command . setter def pose_command ( self , cmd : npt . ArrayLike ) -> np . ndarray : if not len ( cmd ) == 7 : raise ValueError ( f \"Invalid pose. Got: {cmd}\" ) self . _pose_command = cmd def go_to_pose ( self , pose : npt . ArrayLike , pos_stepsize : float = 0.01 , orn_stepsize : float = 0.01 , max_force : float = 500 , sleep : Optional [ float ] = None , ) -> None : \"\"\"Navigates to a new pose Current method (nothing fancy at the moment): - Orient towards the goal position - Move along a straight line to the goal position - Orient towards the goal orientation Args: pose (npt.ArrayLike): Desired new pose (position + quaternion) for the astrobee pos_stepsize (float, optional): Stepsize for consecutive points in the straight-line motion part of the trajectory. Defaults to 0.01 orn_stepsize (float, optional): Stepsize for consecutive points in the orientation parts of the trajectory. Defaults to 0.01 max_force (float, optional): Maximum force to apply to the constraint. Defaults to 500. sleep (float, optional): Time to sleep between each step. Defaults to None. \"\"\" assert isinstance ( pos_stepsize , ( float , int )) and pos_stepsize > 0 assert isinstance ( orn_stepsize , ( float , int )) and orn_stepsize > 0 assert isinstance ( max_force , ( float , int )) and max_force > 0 assert isinstance ( sleep , (( float , int ), type ( None ))) and ( sleep is None or sleep > 0 ) traj = point_and_move_pose_traj ( self . robot . pose , pose , pos_stepsize , orn_stepsize ) for i in range ( traj . shape [ 0 ] ) : pybullet . changeConstraint ( self . constraint_id , traj [ i, :3 ] , traj [ i, 3: ] , maxForce = max_force ) pybullet . stepSimulation () if sleep is not None : time . sleep ( sleep ) def delete_constraint ( self ) -> None : \"\"\"Deletes the constraint between the Astrobee and the world\"\"\" pybullet . removeConstraint ( self . constraint_id ) Instance variables pose_command Position and xyzw quaternion pose Methods delete_constraint def delete_constraint ( self ) -> None Deletes the constraint between the Astrobee and the world View Source def delete_constraint ( self ) -> None : \"\"\"Deletes the constraint between the Astrobee and the world\"\"\" pybullet . removeConstraint ( self . constraint_id ) go_to_pose def go_to_pose ( self , pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pos_stepsize : float = 0.01 , orn_stepsize : float = 0.01 , max_force : float = 500 , sleep : Optional [ float ] = None ) -> None Navigates to a new pose Current method (nothing fancy at the moment): - Orient towards the goal position - Move along a straight line to the goal position - Orient towards the goal orientation Parameters: Name Type Description Default pose npt.ArrayLike Desired new pose (position + quaternion) for the astrobee None pos_stepsize float Stepsize for consecutive points in the straight-line motion part of the trajectory. Defaults to 0.01 None orn_stepsize float Stepsize for consecutive points in the orientation parts of the trajectory. Defaults to 0.01 None max_force float Maximum force to apply to the constraint. Defaults to 500. 500 sleep float Time to sleep between each step. Defaults to None. None View Source def go_to_pose ( self , pose : npt . ArrayLike , pos_stepsize : float = 0.01 , orn_stepsize : float = 0.01 , max_force : float = 500 , sleep : Optional [ float ] = None , ) -> None : \"\"\"Navigates to a new pose Current method (nothing fancy at the moment): - Orient towards the goal position - Move along a straight line to the goal position - Orient towards the goal orientation Args: pose (npt.ArrayLike): Desired new pose (position + quaternion) for the astrobee pos_stepsize (float, optional): Stepsize for consecutive points in the straight-line motion part of the trajectory. Defaults to 0.01 orn_stepsize (float, optional): Stepsize for consecutive points in the orientation parts of the trajectory. Defaults to 0.01 max_force (float, optional): Maximum force to apply to the constraint. Defaults to 500. sleep (float, optional): Time to sleep between each step. Defaults to None. \"\"\" assert isinstance ( pos_stepsize , ( float , int )) and pos_stepsize > 0 assert isinstance ( orn_stepsize , ( float , int )) and orn_stepsize > 0 assert isinstance ( max_force , ( float , int )) and max_force > 0 assert isinstance ( sleep , (( float , int ), type ( None ))) and ( sleep is None or sleep > 0 ) traj = point_and_move_pose_traj ( self . robot . pose , pose , pos_stepsize , orn_stepsize ) for i in range ( traj . shape [ 0 ] ) : pybullet . changeConstraint ( self . constraint_id , traj [ i, :3 ] , traj [ i, 3: ] , maxForce = max_force ) pybullet . stepSimulation () if sleep is not None : time . sleep ( sleep )","title":"Constraint Controller"},{"location":"reference/pyastrobee/control/constraint_controller/#module-pyastrobeecontrolconstraint_controller","text":"Constraint controller: Simple, non-physically-realistic position control with Pybullet soft constraints Useful for debugging, but not for real control View Source \"\"\"Constraint controller: Simple, non-physically-realistic position control with Pybullet soft constraints Useful for debugging, but not for real control \"\"\" import time from typing import Optional import pybullet import numpy as np import numpy.typing as npt from pyastrobee.core.astrobee import Astrobee from pyastrobee.trajectories.simple_trajectories import point_and_move_pose_traj class ConstraintController : \"\"\"A non-physically-realistic controller for Astrobee using Pybullet soft constraints Args: robot (Astrobee): The Astrobee being controlled \"\"\" def __init__ ( self , robot : Astrobee ): self . robot = robot self . _pose_command = None self . constraint_id = pybullet . createConstraint ( self . robot . id , - 1 , - 1 , - 1 , pybullet . JOINT_FIXED , None , ( 0 , 0 , 0 ), ( 0 , 0 , 0 ) ) @property def pose_command ( self ) -> np . ndarray : \"\"\"Position and xyzw quaternion pose\"\"\" return self . _pose_command @pose_command . setter def pose_command ( self , cmd : npt . ArrayLike ) -> np . ndarray : if not len ( cmd ) == 7 : raise ValueError ( f \"Invalid pose. Got: { cmd } \" ) self . _pose_command = cmd def go_to_pose ( self , pose : npt . ArrayLike , pos_stepsize : float = 0.01 , orn_stepsize : float = 0.01 , max_force : float = 500 , sleep : Optional [ float ] = None , ) -> None : \"\"\"Navigates to a new pose Current method (nothing fancy at the moment): - Orient towards the goal position - Move along a straight line to the goal position - Orient towards the goal orientation Args: pose (npt.ArrayLike): Desired new pose (position + quaternion) for the astrobee pos_stepsize (float, optional): Stepsize for consecutive points in the straight-line motion part of the trajectory. Defaults to 0.01 orn_stepsize (float, optional): Stepsize for consecutive points in the orientation parts of the trajectory. Defaults to 0.01 max_force (float, optional): Maximum force to apply to the constraint. Defaults to 500. sleep (float, optional): Time to sleep between each step. Defaults to None. \"\"\" assert isinstance ( pos_stepsize , ( float , int )) and pos_stepsize > 0 assert isinstance ( orn_stepsize , ( float , int )) and orn_stepsize > 0 assert isinstance ( max_force , ( float , int )) and max_force > 0 assert isinstance ( sleep , (( float , int ), type ( None ))) and ( sleep is None or sleep > 0 ) traj = point_and_move_pose_traj ( self . robot . pose , pose , pos_stepsize , orn_stepsize ) for i in range ( traj . shape [ 0 ]): pybullet . changeConstraint ( self . constraint_id , traj [ i , : 3 ], traj [ i , 3 :], maxForce = max_force ) pybullet . stepSimulation () if sleep is not None : time . sleep ( sleep ) def delete_constraint ( self ) -> None : \"\"\"Deletes the constraint between the Astrobee and the world\"\"\" pybullet . removeConstraint ( self . constraint_id ) def main (): # Simple controller test pybullet . connect ( pybullet . GUI ) robot = Astrobee () constraint_controller = ConstraintController ( robot ) constraint_controller . go_to_pose ( [ 0.446 , - 1.338 , 0.446 , 0.088 , 0.067 , - 0.787 , 0.606 ], sleep = 1 / 240 ) print ( \"Position control complete\" ) input ( \"Press enter to exit\" ) pybullet . disconnect () if __name__ == \"__main__\" : main ()","title":"Module pyastrobee.control.constraint_controller"},{"location":"reference/pyastrobee/control/constraint_controller/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/control/constraint_controller/#main","text":"def main ( ) View Source def main (): # Simple controller test pybullet . connect ( pybullet . GUI ) robot = Astrobee () constraint_controller = ConstraintController ( robot ) constraint_controller . go_to_pose ( [ 0.446 , - 1.338 , 0.446 , 0.088 , 0.067 , - 0.787 , 0.606 ], sleep = 1 / 240 ) print ( \"Position control complete\" ) input ( \"Press enter to exit\" ) pybullet . disconnect ()","title":"main"},{"location":"reference/pyastrobee/control/constraint_controller/#classes","text":"","title":"Classes"},{"location":"reference/pyastrobee/control/constraint_controller/#constraintcontroller","text":"class ConstraintController ( robot : pyastrobee . core . astrobee . Astrobee ) A non-physically-realistic controller for Astrobee using Pybullet soft constraints","title":"ConstraintController"},{"location":"reference/pyastrobee/control/constraint_controller/#attributes","text":"Name Type Description Default robot Astrobee The Astrobee being controlled None View Source class ConstraintController : \"\"\"A non-physically-realistic controller for Astrobee using Pybullet soft constraints Args: robot (Astrobee): The Astrobee being controlled \"\"\" def __init__ ( self , robot : Astrobee ) : self . robot = robot self . _pose_command = None self . constraint_id = pybullet . createConstraint ( self . robot . id , - 1 , - 1 , - 1 , pybullet . JOINT_FIXED , None , ( 0 , 0 , 0 ), ( 0 , 0 , 0 ) ) @property def pose_command ( self ) -> np . ndarray : \"\"\"Position and xyzw quaternion pose\"\"\" return self . _pose_command @pose_command . setter def pose_command ( self , cmd : npt . ArrayLike ) -> np . ndarray : if not len ( cmd ) == 7 : raise ValueError ( f \"Invalid pose. Got: {cmd}\" ) self . _pose_command = cmd def go_to_pose ( self , pose : npt . ArrayLike , pos_stepsize : float = 0.01 , orn_stepsize : float = 0.01 , max_force : float = 500 , sleep : Optional [ float ] = None , ) -> None : \"\"\"Navigates to a new pose Current method (nothing fancy at the moment): - Orient towards the goal position - Move along a straight line to the goal position - Orient towards the goal orientation Args: pose (npt.ArrayLike): Desired new pose (position + quaternion) for the astrobee pos_stepsize (float, optional): Stepsize for consecutive points in the straight-line motion part of the trajectory. Defaults to 0.01 orn_stepsize (float, optional): Stepsize for consecutive points in the orientation parts of the trajectory. Defaults to 0.01 max_force (float, optional): Maximum force to apply to the constraint. Defaults to 500. sleep (float, optional): Time to sleep between each step. Defaults to None. \"\"\" assert isinstance ( pos_stepsize , ( float , int )) and pos_stepsize > 0 assert isinstance ( orn_stepsize , ( float , int )) and orn_stepsize > 0 assert isinstance ( max_force , ( float , int )) and max_force > 0 assert isinstance ( sleep , (( float , int ), type ( None ))) and ( sleep is None or sleep > 0 ) traj = point_and_move_pose_traj ( self . robot . pose , pose , pos_stepsize , orn_stepsize ) for i in range ( traj . shape [ 0 ] ) : pybullet . changeConstraint ( self . constraint_id , traj [ i, :3 ] , traj [ i, 3: ] , maxForce = max_force ) pybullet . stepSimulation () if sleep is not None : time . sleep ( sleep ) def delete_constraint ( self ) -> None : \"\"\"Deletes the constraint between the Astrobee and the world\"\"\" pybullet . removeConstraint ( self . constraint_id )","title":"Attributes"},{"location":"reference/pyastrobee/control/constraint_controller/#instance-variables","text":"pose_command Position and xyzw quaternion pose","title":"Instance variables"},{"location":"reference/pyastrobee/control/constraint_controller/#methods","text":"","title":"Methods"},{"location":"reference/pyastrobee/control/constraint_controller/#delete_constraint","text":"def delete_constraint ( self ) -> None Deletes the constraint between the Astrobee and the world View Source def delete_constraint ( self ) -> None : \"\"\"Deletes the constraint between the Astrobee and the world\"\"\" pybullet . removeConstraint ( self . constraint_id )","title":"delete_constraint"},{"location":"reference/pyastrobee/control/constraint_controller/#go_to_pose","text":"def go_to_pose ( self , pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pos_stepsize : float = 0.01 , orn_stepsize : float = 0.01 , max_force : float = 500 , sleep : Optional [ float ] = None ) -> None Navigates to a new pose Current method (nothing fancy at the moment): - Orient towards the goal position - Move along a straight line to the goal position - Orient towards the goal orientation Parameters: Name Type Description Default pose npt.ArrayLike Desired new pose (position + quaternion) for the astrobee None pos_stepsize float Stepsize for consecutive points in the straight-line motion part of the trajectory. Defaults to 0.01 None orn_stepsize float Stepsize for consecutive points in the orientation parts of the trajectory. Defaults to 0.01 None max_force float Maximum force to apply to the constraint. Defaults to 500. 500 sleep float Time to sleep between each step. Defaults to None. None View Source def go_to_pose ( self , pose : npt . ArrayLike , pos_stepsize : float = 0.01 , orn_stepsize : float = 0.01 , max_force : float = 500 , sleep : Optional [ float ] = None , ) -> None : \"\"\"Navigates to a new pose Current method (nothing fancy at the moment): - Orient towards the goal position - Move along a straight line to the goal position - Orient towards the goal orientation Args: pose (npt.ArrayLike): Desired new pose (position + quaternion) for the astrobee pos_stepsize (float, optional): Stepsize for consecutive points in the straight-line motion part of the trajectory. Defaults to 0.01 orn_stepsize (float, optional): Stepsize for consecutive points in the orientation parts of the trajectory. Defaults to 0.01 max_force (float, optional): Maximum force to apply to the constraint. Defaults to 500. sleep (float, optional): Time to sleep between each step. Defaults to None. \"\"\" assert isinstance ( pos_stepsize , ( float , int )) and pos_stepsize > 0 assert isinstance ( orn_stepsize , ( float , int )) and orn_stepsize > 0 assert isinstance ( max_force , ( float , int )) and max_force > 0 assert isinstance ( sleep , (( float , int ), type ( None ))) and ( sleep is None or sleep > 0 ) traj = point_and_move_pose_traj ( self . robot . pose , pose , pos_stepsize , orn_stepsize ) for i in range ( traj . shape [ 0 ] ) : pybullet . changeConstraint ( self . constraint_id , traj [ i, :3 ] , traj [ i, 3: ] , maxForce = max_force ) pybullet . stepSimulation () if sleep is not None : time . sleep ( sleep )","title":"go_to_pose"},{"location":"reference/pyastrobee/control/force_torque_control/","text":"Module pyastrobee.control.force_torque_control Force + torque PID control of the Astrobee body Note: Forces and torques are currently applied in world frame View Source \"\"\"Force + torque PID control of the Astrobee body Note: Forces and torques are currently applied in world frame \"\"\" # TODO: Add better handling of body-frame forces and torques (more aligned with how Astrobee's thrusters operate) # TODO: Operational space control from typing import Optional import pybullet from pybullet_utils.bullet_client import BulletClient import numpy as np import numpy.typing as npt import matplotlib.pyplot as plt from matplotlib.figure import Figure from pyastrobee.trajectories.trajectory import ( Trajectory , TrajectoryLogger , stopping_criteria , ) from pyastrobee.utils.quaternions import quaternion_angular_error from pyastrobee.utils.rotations import quat_to_rmat class ForceTorqueController : \"\"\"PID-style force/torque control Args: robot_id (int): Pybullet ID of the robot to control mass (float): Mass of the robot inertia (np.ndarray): Inertia tensor for the robot, shape (3, 3) kp (float): Gain for position error kv (float): Gain for velocity error kq (float): Gain for orientation (quaternion) error kw (float): Gain for angular velocity (omega) error dt (float): Timestep pos_tol (float, optional): Stopping tolerance on position error magnitude. Defaults to 1e-2. orn_tol (float, optional): Stopping tolerance on quaternion distance between cur/des. Defaults to 1e-2. vel_tol (float, optional): Stopping tolerance on linear velocity error magnitude. Defaults to 1e-2. ang_vel_tol (float, optional): Stopping tolerance on angular velocity error magnitude. Defaults to 5e-3. max_force (Optional[float]): Limit on the applied force magnitude. Defaults to None (no limit) max_torque (Optional[float]): Limit on the applied torque magnitude. Defaults to None (no limit) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" def __init__ ( self , robot_id : int , mass : float , inertia : np . ndarray , kp : float , kv : float , kq : float , kw : float , dt : float , pos_tol : float = 1e-2 , orn_tol : float = 1e-2 , vel_tol : float = 1e-2 , ang_vel_tol : float = 5e-3 , max_force : Optional [ float ] = None , max_torque : Optional [ float ] = None , client : Optional [ BulletClient ] = None , ): self . id = robot_id self . mass = mass self . inertia = inertia self . kp = kp self . kv = kv self . kq = kq self . kw = kw self . dt = dt self . pos_tol = pos_tol self . orn_tol = orn_tol self . vel_tol = vel_tol self . ang_vel_tol = ang_vel_tol self . max_force = max_force self . max_torque = max_torque self . traj_log = TrajectoryLogger () self . control_log = ControlLogger () self . client : pybullet = pybullet if client is None else client # Parameters for checking if there was a quaternion sign flip self . last_quat = np . array ( self . client . getBasePositionAndOrientation ( self . id )[ 1 ]) self . quat_sign = 1 # TODO figure out how world/robot frame should be handled def get_force ( self , cur_pos : npt . ArrayLike , cur_vel : npt . ArrayLike , des_pos : npt . ArrayLike , des_vel : npt . ArrayLike , des_accel : npt . ArrayLike , ) -> np . ndarray : \"\"\"Calculates the required force to achieve a desired pos/vel/accel Args: cur_pos (npt.ArrayLike): Current position, shape (3,) cur_vel (npt.ArrayLike): Current velocity, shape (3,) des_pos (npt.ArrayLike): Desired position, shape (3,) des_vel (npt.ArrayLike): Desired velocity, shape (3,) des_accel (npt.ArrayLike): Desired acceleration, shape (3,) Returns: np.ndarray: Force, (Fx, Fy, Fz), shape (3,) \"\"\" M = self . mass * np . eye ( 3 ) pos_err = np . subtract ( cur_pos , des_pos ) vel_err = np . subtract ( cur_vel , des_vel ) return M @ np . asarray ( des_accel ) - self . kv * vel_err - self . kp * pos_err def get_torque ( self , cur_q : npt . ArrayLike , cur_w : npt . ArrayLike , des_q : npt . ArrayLike , des_w : npt . ArrayLike , des_a : npt . ArrayLike , ) -> np . ndarray : \"\"\"Calculates the required torque to achieve a desired orientation/ang vel/ang accel Args: cur_q (npt.ArrayLike): Current orientation (XYZW quaternion), shape (4,) cur_w (npt.ArrayLike): Current angular velocity (omega), shape (3,) des_q (npt.ArrayLike): Desired orientation (XYZW quaternion), shape (4,) des_w (npt.ArrayLike): Desired angular velocity (omega), shape (3,) des_a (npt.ArrayLike): Desired angular acceleration (alpha), shape (3,) Returns: np.ndarray: Torque, (Tx, Ty, Tz), shape (3,) \"\"\" if np . allclose ( cur_q , - 1 * self . last_quat , atol = 1e-3 ): print ( \"Quaternion flip detected\" ) self . quat_sign *= - 1 ang_err = quaternion_angular_error ( cur_q * self . quat_sign , des_q ) self . last_quat = cur_q ang_vel_err = cur_w - des_w R = quat_to_rmat ( cur_q ) world_inertia = R @ self . inertia @ R . T # Standard 3D free-body torque equation based on desired ang. accel and current ang. vel # Note: this ignores the m * r x a term torque = world_inertia @ des_a + np . cross ( cur_w , world_inertia @ cur_w ) # Add in the proportional and derivative terms return torque - self . kw * ang_vel_err - self . kq * ang_err def follow_traj ( self , traj : Trajectory , stop_at_end : bool = True , max_stop_iters : Optional [ int ] = None , ) -> None : \"\"\"Use PID force/torque control to follow a trajectory Args: traj (Trajectory): Trajectory with position, orientation, and derivative info across time stop_at_end (bool, optional): Whether or not to command the robot to come to a stop at the last pose in the trajectory. Defaults to True max_stop_iters (int, optional): If stop_at_end is True, this gives a maximum number of iterations to allow for stopping. Defaults to None (keep controlling until stopped) \"\"\" for i in range ( traj . num_timesteps ): pos , orn , lin_vel , ang_vel = self . get_current_state () self . step ( pos , lin_vel , orn , ang_vel , traj . positions [ i , :], traj . linear_velocities [ i , :], traj . linear_accels [ i , :], traj . quaternions [ i , :], traj . angular_velocities [ i , :], traj . angular_accels [ i , :], ) if stop_at_end : self . stop ( traj . positions [ - 1 , :], traj . quaternions [ - 1 , :], max_stop_iters ) def stop ( self , des_pos : npt . ArrayLike , des_quat : npt . ArrayLike , max_iters : Optional [ int ] = None , ) -> None : \"\"\"Controls the robot to stop at a desired position/orientation Args: des_pos (npt.ArrayLike): Desired position, shape (3,) des_quat (npt.ArrayLike): Desired orientation (XYZW quaternion), shape (4,) max_iters (int, optional): Maximum number of control iterations to allow for stopping. Defaults to None (keep controlling until stopped) \"\"\" des_vel = np . zeros ( 3 ) des_accel = np . zeros ( 3 ) des_omega = np . zeros ( 3 ) des_alpha = np . zeros ( 3 ) iters = 0 while True : pos , orn , lin_vel , ang_vel = self . get_current_state () if stopping_criteria ( pos , orn , lin_vel , ang_vel , des_pos , des_quat , self . pos_tol , self . orn_tol , self . vel_tol , self . ang_vel_tol , ): return if max_iters is not None and iters >= max_iters : print ( \"Maximum iterations reached, stopping unsuccessful\" ) return self . step ( pos , lin_vel , orn , ang_vel , des_pos , des_vel , des_accel , des_quat , des_omega , des_alpha , ) iters += 1 def step ( self , pos : npt . ArrayLike , vel : npt . ArrayLike , orn : npt . ArrayLike , omega : npt . ArrayLike , des_pos : npt . ArrayLike , des_vel : npt . ArrayLike , des_accel : npt . ArrayLike , des_orn : npt . ArrayLike , des_omega : npt . ArrayLike , des_alpha : npt . ArrayLike , step_sim : bool = True , ) -> None : \"\"\"Steps the controller and the simulation Args: pos (npt.ArrayLike): Current position, shape (3,) vel (npt.ArrayLike): Current linear velocity, shape (3,) orn (npt.ArrayLike): Current orientation (XYZW quaternion), shape (4,) omega (npt.ArrayLike): Current angular velocity, shape (3,) des_pos (npt.ArrayLike): Desired position, shape (3,) des_vel (npt.ArrayLike): Desired linear velocity, shape (3,) des_accel (npt.ArrayLike): Desired linear acceleration, shape (3,) des_orn (npt.ArrayLike): Desired orientation (XYZW quaternion), shape (4,) des_omega (npt.ArrayLike): Desired angular velocity, shape (3,) des_alpha (npt.ArrayLike): Desired angular acceleration, shape (3,) step_sim (bool, optional): Whether to step the sim or not (This should almost always be true except for if there are multiple active controllers in the simulation. In that case, the sim must be stepped manually with this flag as False on each controller). Defaults to True. \"\"\" force = self . get_force ( pos , vel , des_pos , des_vel , des_accel ) torque = self . get_torque ( orn , omega , des_orn , des_omega , des_alpha ) # Clamp the maximum force/torque if needed if self . max_force is not None : force_mag = np . linalg . norm ( force ) if force_mag > self . max_force : force = self . max_force * ( force / force_mag ) if self . max_torque is not None : torque_mag = np . linalg . norm ( torque ) if torque_mag > self . max_torque : torque = self . max_torque * ( torque / torque_mag ) self . control_log . log_control ( force , torque , self . dt ) self . client . applyExternalForce ( self . id , - 1 , force , list ( pos ), pybullet . WORLD_FRAME ) self . client . applyExternalTorque ( self . id , - 1 , list ( torque ), pybullet . WORLD_FRAME ) if step_sim : self . client . stepSimulation () def get_current_state ( self , ) -> tuple [ np . ndarray , np . ndarray , np . ndarray , np . ndarray ]: \"\"\"Determines the current dynamics state of the robot Returns: tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: np.ndarray: Current position, shape (3,) np.ndarray: Current orientation (XYZW quaternion), shape (4,) np.ndarray: Current linear velocity, shape (3,) np.ndarray: Current angular velocity, shape (3,) \"\"\" pos , quat = self . client . getBasePositionAndOrientation ( self . id ) lin_vel , ang_vel = self . client . getBaseVelocity ( self . id ) self . traj_log . log_state ( pos , quat , lin_vel , ang_vel , self . dt ) # These are originally tuples, so convert to numpy return np . array ( pos ), np . array ( quat ), np . array ( lin_vel ), np . array ( ang_vel ) class ControlLogger : \"\"\"Class for maintaining a history of control inputs for plottting or further analysis Any conversions between world frame / robot frame should be done before storing the force/torque data, depending on what is of interest \"\"\" def __init__ ( self ): self . _forces = [] self . _torques = [] self . _times = [] @property def forces ( self ) -> np . ndarray : return np . atleast_2d ( self . _forces ) @property def torques ( self ) -> np . ndarray : return np . atleast_2d ( self . _torques ) @property def times ( self ) -> np . ndarray : return np . array ( self . _times ) def log_control ( self , force : npt . ArrayLike , torque : npt . ArrayLike , dt : Optional [ float ] = None ) -> None : \"\"\"Logs the forces and torques applied in a simulation step Args: force (npt.ArrayLike): Applied force (Fx, Fy, Fz), shape (3,) torque (npt.ArrayLike): Applied torque (Tx, Ty, Tz), shape (3,) dt (Optional[float]): Time elapsed since the previous step. Defaults to None. \"\"\" self . _forces . append ( force ) self . _torques . append ( torque ) if dt is not None and len ( self . _times ) == 0 : self . _times . append ( 0.0 ) elif dt is not None : self . _times . append ( self . _times [ - 1 ] + dt ) def plot ( self , max_force : Optional [ npt . ArrayLike ] = None , max_torque : Optional [ npt . ArrayLike ] = None , show : bool = True , ) -> Figure : \"\"\"Plot the stored history of control inputs Args: max_force (Optional[npt.ArrayLike]): Applied force limits (Fx_max, Fy_max, Fz_max), shape (3,) Defaults to None (Don't indicate the limit on the plots) max_torque (Optional[npt.ArrayLike]): Applied torque limits (Tx_max, Ty_max, Tz_max), shape (3,) Defaults to None (Don't indicate the limit on the plots) show (bool, optional): Whether or not to show the plot. Defaults to True Returns: Figure: Matplotlib figure containing the plots \"\"\" return plot_control ( self . forces , self . torques , self . times , max_force , max_torque , show ) def plot_control ( forces : np . ndarray , torques : np . ndarray , times : Optional [ np . ndarray ] = None , max_force : Optional [ npt . ArrayLike ] = None , max_torque : Optional [ npt . ArrayLike ] = None , show : bool = True , fmt : str = \"k-\" , ) -> Figure : \"\"\"Plots a recorded history of force/torque control inputs Args: forces (np.ndarray): Sequence of force inputs (Fx, Fy, Fz), shape (n, 3) torques (np.ndarray): Sequence of torque inputs (Tx, Ty, Tz), shape (n, 3) times (Optional[np.ndarray], optional): Times corresponding to control inputs, shape (n,). Defaults to None, in which case control inputs will be plotted against timesteps max_force (Optional[npt.ArrayLike]): Applied force limits (Fx_max, Fy_max, Fz_max), shape (3,) Defaults to None (Don't indicate the limit on the plots) max_torque (Optional[npt.ArrayLike]): Applied torque limits (Tx_max, Ty_max, Tz_max), shape (3,) Defaults to None (Don't indicate the limit on the plots) show (bool, optional): Whether or not to display the plot. Defaults to True. fmt (str, optional): Matplotlib line specification. Defaults to \"k-\" Returns: Figure: Matplotlib figure containing the plots \"\"\" fig = plt . figure () if times is not None : x_axis = times x_label = \"Time, s\" else : x_axis = np . arange ( forces . shape [ 0 ]) x_label = \"Timesteps\" subfigs = fig . subfigures ( 2 , 1 ) top_axes = subfigs [ 0 ] . subplots ( 1 , 3 ) bot_axes = subfigs [ 1 ] . subplots ( 1 , 3 ) force_labels = [ \"Fx\" , \"Fy\" , \"Fz\" ] torque_labels = [ \"Tx\" , \"Ty\" , \"Tz\" ] # Plot force info on the top axes for i , ax in enumerate ( top_axes ): ax . plot ( x_axis , forces [:, i ], fmt ) if max_force is not None : ax . plot ( x_axis , max_force [ i ] * np . ones_like ( x_axis ), \"--\" ) ax . set_title ( force_labels [ i ]) ax . set_xlabel ( x_label ) # Plot torque info on the bottom axes for i , ax in enumerate ( bot_axes ): ax . plot ( x_axis , torques [:, i ], fmt ) if max_torque is not None : ax . plot ( x_axis , max_torque [ i ] * np . ones_like ( x_axis ), \"--\" ) ax . set_title ( torque_labels [ i ]) ax . set_xlabel ( x_label ) if show : plt . show () return fig Functions plot_control def plot_control ( forces : numpy . ndarray , torques : numpy . ndarray , times : Optional [ numpy . ndarray ] = None , max_force : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , max_torque : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , show : bool = True , fmt : str = 'k-' ) -> matplotlib . figure . Figure Plots a recorded history of force/torque control inputs Parameters: Name Type Description Default forces np.ndarray Sequence of force inputs (Fx, Fy, Fz), shape (n, 3) None torques np.ndarray Sequence of torque inputs (Tx, Ty, Tz), shape (n, 3) None times Optional[np.ndarray] Times corresponding to control inputs, shape (n,). Defaults to None, in which case control inputs will be plotted against timesteps None max_force Optional[npt.ArrayLike] Applied force limits (Fx_max, Fy_max, Fz_max), shape (3,) Defaults to None (Don't indicate the limit on the plots) None max_torque Optional[npt.ArrayLike] Applied torque limits (Tx_max, Ty_max, Tz_max), shape (3,) Defaults to None (Don't indicate the limit on the plots) None show bool Whether or not to display the plot. Defaults to True. True fmt str Matplotlib line specification. Defaults to \"k-\" None Returns: Type Description Figure Matplotlib figure containing the plots View Source def plot_control ( forces : np . ndarray , torques : np . ndarray , times : Optional [ np.ndarray ] = None , max_force : Optional [ npt.ArrayLike ] = None , max_torque : Optional [ npt.ArrayLike ] = None , show : bool = True , fmt : str = \"k-\" , ) -> Figure : \"\"\"Plots a recorded history of force/torque control inputs Args: forces (np.ndarray): Sequence of force inputs (Fx, Fy, Fz), shape (n, 3) torques (np.ndarray): Sequence of torque inputs (Tx, Ty, Tz), shape (n, 3) times (Optional[np.ndarray], optional): Times corresponding to control inputs, shape (n,). Defaults to None, in which case control inputs will be plotted against timesteps max_force (Optional[npt.ArrayLike]): Applied force limits (Fx_max, Fy_max, Fz_max), shape (3,) Defaults to None (Don't indicate the limit on the plots) max_torque (Optional[npt.ArrayLike]): Applied torque limits (Tx_max, Ty_max, Tz_max), shape (3,) Defaults to None (Don't indicate the limit on the plots) show (bool, optional): Whether or not to display the plot. Defaults to True. fmt (str, optional): Matplotlib line specification. Defaults to \" k - \" Returns: Figure: Matplotlib figure containing the plots \"\"\" fig = plt . figure () if times is not None : x_axis = times x_label = \"Time, s\" else : x_axis = np . arange ( forces . shape [ 0 ] ) x_label = \"Timesteps\" subfigs = fig . subfigures ( 2 , 1 ) top_axes = subfigs [ 0 ] . subplots ( 1 , 3 ) bot_axes = subfigs [ 1 ] . subplots ( 1 , 3 ) force_labels = [ \"Fx\", \"Fy\", \"Fz\" ] torque_labels = [ \"Tx\", \"Ty\", \"Tz\" ] # Plot force info on the top axes for i , ax in enumerate ( top_axes ) : ax . plot ( x_axis , forces [ :, i ] , fmt ) if max_force is not None : ax . plot ( x_axis , max_force [ i ] * np . ones_like ( x_axis ), \"--\" ) ax . set_title ( force_labels [ i ] ) ax . set_xlabel ( x_label ) # Plot torque info on the bottom axes for i , ax in enumerate ( bot_axes ) : ax . plot ( x_axis , torques [ :, i ] , fmt ) if max_torque is not None : ax . plot ( x_axis , max_torque [ i ] * np . ones_like ( x_axis ), \"--\" ) ax . set_title ( torque_labels [ i ] ) ax . set_xlabel ( x_label ) if show : plt . show () return fig Classes ControlLogger class ControlLogger ( ) Class for maintaining a history of control inputs for plottting or further analysis Any conversions between world frame / robot frame should be done before storing the force/torque data, depending on what is of interest View Source class ControlLogger : \"\"\"Class for maintaining a history of control inputs for plottting or further analysis Any conversions between world frame / robot frame should be done before storing the force/torque data, depending on what is of interest \"\"\" def __init__ ( self ) : self . _forces = [] self . _torques = [] self . _times = [] @property def forces ( self ) -> np . ndarray : return np . atleast_2d ( self . _forces ) @property def torques ( self ) -> np . ndarray : return np . atleast_2d ( self . _torques ) @property def times ( self ) -> np . ndarray : return np . array ( self . _times ) def log_control ( self , force : npt . ArrayLike , torque : npt . ArrayLike , dt : Optional [ float ] = None ) -> None : \"\"\"Logs the forces and torques applied in a simulation step Args: force (npt.ArrayLike): Applied force (Fx, Fy, Fz), shape (3,) torque (npt.ArrayLike): Applied torque (Tx, Ty, Tz), shape (3,) dt (Optional[float]): Time elapsed since the previous step. Defaults to None. \"\"\" self . _forces . append ( force ) self . _torques . append ( torque ) if dt is not None and len ( self . _times ) == 0 : self . _times . append ( 0.0 ) elif dt is not None : self . _times . append ( self . _times [ -1 ] + dt ) def plot ( self , max_force : Optional [ npt.ArrayLike ] = None , max_torque : Optional [ npt.ArrayLike ] = None , show : bool = True , ) -> Figure : \"\"\"Plot the stored history of control inputs Args: max_force (Optional[npt.ArrayLike]): Applied force limits (Fx_max, Fy_max, Fz_max), shape (3,) Defaults to None (Don't indicate the limit on the plots) max_torque (Optional[npt.ArrayLike]): Applied torque limits (Tx_max, Ty_max, Tz_max), shape (3,) Defaults to None (Don't indicate the limit on the plots) show (bool, optional): Whether or not to show the plot. Defaults to True Returns: Figure: Matplotlib figure containing the plots \"\"\" return plot_control ( self . forces , self . torques , self . times , max_force , max_torque , show ) Instance variables forces times torques Methods log_control def log_control ( self , force : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], torque : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], dt : Optional [ float ] = None ) -> None Logs the forces and torques applied in a simulation step Parameters: Name Type Description Default force npt.ArrayLike Applied force (Fx, Fy, Fz), shape (3,) None torque npt.ArrayLike Applied torque (Tx, Ty, Tz), shape (3,) None dt Optional[float] Time elapsed since the previous step. Defaults to None. None View Source def log_control ( self , force : npt . ArrayLike , torque : npt . ArrayLike , dt : Optional [ float ] = None ) -> None : \"\"\"Logs the forces and torques applied in a simulation step Args: force (npt.ArrayLike): Applied force (Fx, Fy, Fz), shape (3,) torque (npt.ArrayLike): Applied torque (Tx, Ty, Tz), shape (3,) dt (Optional[float]): Time elapsed since the previous step. Defaults to None. \"\"\" self . _forces . append ( force ) self . _torques . append ( torque ) if dt is not None and len ( self . _times ) == 0 : self . _times . append ( 0.0 ) elif dt is not None : self . _times . append ( self . _times [ -1 ] + dt ) plot def plot ( self , max_force : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , max_torque : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , show : bool = True ) -> matplotlib . figure . Figure Plot the stored history of control inputs Parameters: Name Type Description Default max_force Optional[npt.ArrayLike] Applied force limits (Fx_max, Fy_max, Fz_max), shape (3,) Defaults to None (Don't indicate the limit on the plots) None max_torque Optional[npt.ArrayLike] Applied torque limits (Tx_max, Ty_max, Tz_max), shape (3,) Defaults to None (Don't indicate the limit on the plots) None show bool Whether or not to show the plot. Defaults to True None Returns: Type Description Figure Matplotlib figure containing the plots View Source def plot ( self , max_force : Optional [ npt . ArrayLike ] = None , max_torque : Optional [ npt . ArrayLike ] = None , show : bool = True , ) -> Figure : \"\"\"Plot the stored history of control inputs Args: max_force (Optional[npt.ArrayLike]): Applied force limits (Fx_max, Fy_max, Fz_max), shape (3,) Defaults to None (Don' t indicate the limit on the plots ) max_torque ( Optional [ npt . ArrayLike ]) : Applied torque limits ( Tx_max , Ty_max , Tz_max ), shape ( 3 ,) Defaults to None ( Don 't indicate the limit on the plots) show (bool, optional): Whether or not to show the plot. Defaults to True Returns: Figure: Matplotlib figure containing the plots \"\"\" return plot_control ( self . forces , self . torques , self . times , max_force , max_torque , show ) ForceTorqueController class ForceTorqueController ( robot_id : int , mass : float , inertia : numpy . ndarray , kp : float , kv : float , kq : float , kw : float , dt : float , pos_tol : float = 0.01 , orn_tol : float = 0.01 , vel_tol : float = 0.01 , ang_vel_tol : float = 0.005 , max_force : Optional [ float ] = None , max_torque : Optional [ float ] = None , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) PID-style force/torque control Attributes Name Type Description Default robot_id int Pybullet ID of the robot to control None mass float Mass of the robot None inertia np.ndarray Inertia tensor for the robot, shape (3, 3) None kp float Gain for position error None kv float Gain for velocity error None kq float Gain for orientation (quaternion) error None kw float Gain for angular velocity (omega) error None dt float Timestep None pos_tol float Stopping tolerance on position error magnitude. Defaults to 1e-2. 1e-2 orn_tol float Stopping tolerance on quaternion distance between cur/des. Defaults to 1e-2. 1e-2 vel_tol float Stopping tolerance on linear velocity error magnitude. Defaults to 1e-2. 1e-2 ang_vel_tol float Stopping tolerance on angular velocity error magnitude. Defaults to 5e-3. 5e-3 max_force Optional[float] Limit on the applied force magnitude. Defaults to None (no limit) None max_torque Optional[float] Limit on the applied torque magnitude. Defaults to None (no limit) None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None View Source class ForceTorqueController : \"\"\"PID-style force/torque control Args: robot_id (int): Pybullet ID of the robot to control mass (float): Mass of the robot inertia (np.ndarray): Inertia tensor for the robot, shape (3, 3) kp (float): Gain for position error kv (float): Gain for velocity error kq (float): Gain for orientation (quaternion) error kw (float): Gain for angular velocity (omega) error dt (float): Timestep pos_tol (float, optional): Stopping tolerance on position error magnitude. Defaults to 1e-2. orn_tol (float, optional): Stopping tolerance on quaternion distance between cur/des. Defaults to 1e-2. vel_tol (float, optional): Stopping tolerance on linear velocity error magnitude. Defaults to 1e-2. ang_vel_tol (float, optional): Stopping tolerance on angular velocity error magnitude. Defaults to 5e-3. max_force (Optional[float]): Limit on the applied force magnitude. Defaults to None (no limit) max_torque (Optional[float]): Limit on the applied torque magnitude. Defaults to None (no limit) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" def __init__ ( self , robot_id : int , mass : float , inertia : np . ndarray , kp : float , kv : float , kq : float , kw : float , dt : float , pos_tol : float = 1e-2 , orn_tol : float = 1e-2 , vel_tol : float = 1e-2 , ang_vel_tol : float = 5e-3 , max_force : Optional [ float ] = None , max_torque : Optional [ float ] = None , client : Optional [ BulletClient ] = None , ) : self . id = robot_id self . mass = mass self . inertia = inertia self . kp = kp self . kv = kv self . kq = kq self . kw = kw self . dt = dt self . pos_tol = pos_tol self . orn_tol = orn_tol self . vel_tol = vel_tol self . ang_vel_tol = ang_vel_tol self . max_force = max_force self . max_torque = max_torque self . traj_log = TrajectoryLogger () self . control_log = ControlLogger () self . client : pybullet = pybullet if client is None else client # Parameters for checking if there was a quaternion sign flip self . last_quat = np . array ( self . client . getBasePositionAndOrientation ( self . id ) [ 1 ] ) self . quat_sign = 1 # TODO figure out how world / robot frame should be handled def get_force ( self , cur_pos : npt . ArrayLike , cur_vel : npt . ArrayLike , des_pos : npt . ArrayLike , des_vel : npt . ArrayLike , des_accel : npt . ArrayLike , ) -> np . ndarray : \"\"\"Calculates the required force to achieve a desired pos/vel/accel Args: cur_pos (npt.ArrayLike): Current position, shape (3,) cur_vel (npt.ArrayLike): Current velocity, shape (3,) des_pos (npt.ArrayLike): Desired position, shape (3,) des_vel (npt.ArrayLike): Desired velocity, shape (3,) des_accel (npt.ArrayLike): Desired acceleration, shape (3,) Returns: np.ndarray: Force, (Fx, Fy, Fz), shape (3,) \"\"\" M = self . mass * np . eye ( 3 ) pos_err = np . subtract ( cur_pos , des_pos ) vel_err = np . subtract ( cur_vel , des_vel ) return M @ np . asarray ( des_accel ) - self . kv * vel_err - self . kp * pos_err def get_torque ( self , cur_q : npt . ArrayLike , cur_w : npt . ArrayLike , des_q : npt . ArrayLike , des_w : npt . ArrayLike , des_a : npt . ArrayLike , ) -> np . ndarray : \"\"\"Calculates the required torque to achieve a desired orientation/ang vel/ang accel Args: cur_q (npt.ArrayLike): Current orientation (XYZW quaternion), shape (4,) cur_w (npt.ArrayLike): Current angular velocity (omega), shape (3,) des_q (npt.ArrayLike): Desired orientation (XYZW quaternion), shape (4,) des_w (npt.ArrayLike): Desired angular velocity (omega), shape (3,) des_a (npt.ArrayLike): Desired angular acceleration (alpha), shape (3,) Returns: np.ndarray: Torque, (Tx, Ty, Tz), shape (3,) \"\"\" if np . allclose ( cur_q , - 1 * self . last_quat , atol = 1e-3 ) : print ( \"Quaternion flip detected\" ) self . quat_sign *= - 1 ang_err = quaternion_angular_error ( cur_q * self . quat_sign , des_q ) self . last_quat = cur_q ang_vel_err = cur_w - des_w R = quat_to_rmat ( cur_q ) world_inertia = R @ self . inertia @ R . T # Standard 3 D free - body torque equation based on desired ang . accel and current ang . vel # Note : this ignores the m * r x a term torque = world_inertia @ des_a + np . cross ( cur_w , world_inertia @ cur_w ) # Add in the proportional and derivative terms return torque - self . kw * ang_vel_err - self . kq * ang_err def follow_traj ( self , traj : Trajectory , stop_at_end : bool = True , max_stop_iters : Optional [ int ] = None , ) -> None : \"\"\"Use PID force/torque control to follow a trajectory Args: traj (Trajectory): Trajectory with position, orientation, and derivative info across time stop_at_end (bool, optional): Whether or not to command the robot to come to a stop at the last pose in the trajectory. Defaults to True max_stop_iters (int, optional): If stop_at_end is True, this gives a maximum number of iterations to allow for stopping. Defaults to None (keep controlling until stopped) \"\"\" for i in range ( traj . num_timesteps ) : pos , orn , lin_vel , ang_vel = self . get_current_state () self . step ( pos , lin_vel , orn , ang_vel , traj . positions [ i, : ] , traj . linear_velocities [ i, : ] , traj . linear_accels [ i, : ] , traj . quaternions [ i, : ] , traj . angular_velocities [ i, : ] , traj . angular_accels [ i, : ] , ) if stop_at_end : self . stop ( traj . positions [ -1, : ] , traj . quaternions [ -1, : ] , max_stop_iters ) def stop ( self , des_pos : npt . ArrayLike , des_quat : npt . ArrayLike , max_iters : Optional [ int ] = None , ) -> None : \"\"\"Controls the robot to stop at a desired position/orientation Args: des_pos (npt.ArrayLike): Desired position, shape (3,) des_quat (npt.ArrayLike): Desired orientation (XYZW quaternion), shape (4,) max_iters (int, optional): Maximum number of control iterations to allow for stopping. Defaults to None (keep controlling until stopped) \"\"\" des_vel = np . zeros ( 3 ) des_accel = np . zeros ( 3 ) des_omega = np . zeros ( 3 ) des_alpha = np . zeros ( 3 ) iters = 0 while True : pos , orn , lin_vel , ang_vel = self . get_current_state () if stopping_criteria ( pos , orn , lin_vel , ang_vel , des_pos , des_quat , self . pos_tol , self . orn_tol , self . vel_tol , self . ang_vel_tol , ) : return if max_iters is not None and iters >= max_iters : print ( \"Maximum iterations reached, stopping unsuccessful\" ) return self . step ( pos , lin_vel , orn , ang_vel , des_pos , des_vel , des_accel , des_quat , des_omega , des_alpha , ) iters += 1 def step ( self , pos : npt . ArrayLike , vel : npt . ArrayLike , orn : npt . ArrayLike , omega : npt . ArrayLike , des_pos : npt . ArrayLike , des_vel : npt . ArrayLike , des_accel : npt . ArrayLike , des_orn : npt . ArrayLike , des_omega : npt . ArrayLike , des_alpha : npt . ArrayLike , step_sim : bool = True , ) -> None : \"\"\"Steps the controller and the simulation Args: pos (npt.ArrayLike): Current position, shape (3,) vel (npt.ArrayLike): Current linear velocity, shape (3,) orn (npt.ArrayLike): Current orientation (XYZW quaternion), shape (4,) omega (npt.ArrayLike): Current angular velocity, shape (3,) des_pos (npt.ArrayLike): Desired position, shape (3,) des_vel (npt.ArrayLike): Desired linear velocity, shape (3,) des_accel (npt.ArrayLike): Desired linear acceleration, shape (3,) des_orn (npt.ArrayLike): Desired orientation (XYZW quaternion), shape (4,) des_omega (npt.ArrayLike): Desired angular velocity, shape (3,) des_alpha (npt.ArrayLike): Desired angular acceleration, shape (3,) step_sim (bool, optional): Whether to step the sim or not (This should almost always be true except for if there are multiple active controllers in the simulation. In that case, the sim must be stepped manually with this flag as False on each controller). Defaults to True. \"\"\" force = self . get_force ( pos , vel , des_pos , des_vel , des_accel ) torque = self . get_torque ( orn , omega , des_orn , des_omega , des_alpha ) # Clamp the maximum force / torque if needed if self . max_force is not None : force_mag = np . linalg . norm ( force ) if force_mag > self . max_force : force = self . max_force * ( force / force_mag ) if self . max_torque is not None : torque_mag = np . linalg . norm ( torque ) if torque_mag > self . max_torque : torque = self . max_torque * ( torque / torque_mag ) self . control_log . log_control ( force , torque , self . dt ) self . client . applyExternalForce ( self . id , - 1 , force , list ( pos ), pybullet . WORLD_FRAME ) self . client . applyExternalTorque ( self . id , - 1 , list ( torque ), pybullet . WORLD_FRAME ) if step_sim : self . client . stepSimulation () def get_current_state ( self , ) -> tuple [ np.ndarray, np.ndarray, np.ndarray, np.ndarray ] : \"\"\"Determines the current dynamics state of the robot Returns: tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: np.ndarray: Current position, shape (3,) np.ndarray: Current orientation (XYZW quaternion), shape (4,) np.ndarray: Current linear velocity, shape (3,) np.ndarray: Current angular velocity, shape (3,) \"\"\" pos , quat = self . client . getBasePositionAndOrientation ( self . id ) lin_vel , ang_vel = self . client . getBaseVelocity ( self . id ) self . traj_log . log_state ( pos , quat , lin_vel , ang_vel , self . dt ) # These are originally tuples , so convert to numpy return np . array ( pos ), np . array ( quat ), np . array ( lin_vel ), np . array ( ang_vel ) Methods follow_traj def follow_traj ( self , traj : pyastrobee . trajectories . trajectory . Trajectory , stop_at_end : bool = True , max_stop_iters : Optional [ int ] = None ) -> None Use PID force/torque control to follow a trajectory Parameters: Name Type Description Default traj Trajectory Trajectory with position, orientation, and derivative info across time None stop_at_end bool Whether or not to command the robot to come to a stop at the last pose in the trajectory. Defaults to True None max_stop_iters int If stop_at_end is True, this gives a maximum number of iterations to allow for stopping. Defaults to None (keep controlling until stopped) None View Source def follow_traj ( self , traj : Trajectory , stop_at_end : bool = True , max_stop_iters : Optional [ int ] = None , ) -> None : \"\"\"Use PID force/torque control to follow a trajectory Args: traj (Trajectory): Trajectory with position, orientation, and derivative info across time stop_at_end (bool, optional): Whether or not to command the robot to come to a stop at the last pose in the trajectory. Defaults to True max_stop_iters (int, optional): If stop_at_end is True, this gives a maximum number of iterations to allow for stopping. Defaults to None (keep controlling until stopped) \"\"\" for i in range ( traj . num_timesteps ) : pos , orn , lin_vel , ang_vel = self . get_current_state () self . step ( pos , lin_vel , orn , ang_vel , traj . positions [ i, : ] , traj . linear_velocities [ i, : ] , traj . linear_accels [ i, : ] , traj . quaternions [ i, : ] , traj . angular_velocities [ i, : ] , traj . angular_accels [ i, : ] , ) if stop_at_end : self . stop ( traj . positions [ -1, : ] , traj . quaternions [ -1, : ] , max_stop_iters ) get_current_state def get_current_state ( self ) -> tuple [ numpy . ndarray , numpy . ndarray , numpy . ndarray , numpy . ndarray ] Determines the current dynamics state of the robot Returns: Type Description tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray] np.ndarray: Current position, shape (3,) np.ndarray: Current orientation (XYZW quaternion), shape (4,) np.ndarray: Current linear velocity, shape (3,) np.ndarray: Current angular velocity, shape (3,) View Source def get_current_state ( self , ) -> tuple [ np . ndarray , np . ndarray , np . ndarray , np . ndarray ] : \"\"\"Determines the current dynamics state of the robot Returns: tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: np.ndarray: Current position, shape (3,) np.ndarray: Current orientation (XYZW quaternion), shape (4,) np.ndarray: Current linear velocity, shape (3,) np.ndarray: Current angular velocity, shape (3,) \"\"\" pos , quat = self . client . getBasePositionAndOrientation ( self . id ) lin_vel , ang_vel = self . client . getBaseVelocity ( self . id ) self . traj_log . log_state ( pos , quat , lin_vel , ang_vel , self . dt ) # These are originally tuples , so convert to numpy return np . array ( pos ), np . array ( quat ), np . array ( lin_vel ), np . array ( ang_vel ) get_force def get_force ( self , cur_pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], cur_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], des_pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], des_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], des_accel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Calculates the required force to achieve a desired pos/vel/accel Parameters: Name Type Description Default cur_pos npt.ArrayLike Current position, shape (3,) None cur_vel npt.ArrayLike Current velocity, shape (3,) None des_pos npt.ArrayLike Desired position, shape (3,) None des_vel npt.ArrayLike Desired velocity, shape (3,) None des_accel npt.ArrayLike Desired acceleration, shape (3,) None Returns: Type Description np.ndarray Force, (Fx, Fy, Fz), shape (3,) View Source def get_force( self, cur_pos: npt.ArrayLike, cur_vel: npt.ArrayLike, des_pos: npt.ArrayLike, des_vel: npt.ArrayLike, des_accel: npt.ArrayLike, ) -> np.ndarray: \"\"\"Calculates the required force to achieve a desired pos/vel/accel Args: cur_pos (npt.ArrayLike): Current position, shape (3,) cur_vel (npt.ArrayLike): Current velocity, shape (3,) des_pos (npt.ArrayLike): Desired position, shape (3,) des_vel (npt.ArrayLike): Desired velocity, shape (3,) des_accel (npt.ArrayLike): Desired acceleration, shape (3,) Returns: np.ndarray: Force, (Fx, Fy, Fz), shape (3,) \"\"\" M = self.mass * np.eye(3) pos_err = np.subtract(cur_pos, des_pos) vel_err = np.subtract(cur_vel, des_vel) return M @ np.asarray(des_accel) - self.kv * vel_err - self.kp * pos_err get_torque def get_torque ( self , cur_q : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], cur_w : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], des_q : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], des_w : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], des_a : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Calculates the required torque to achieve a desired orientation/ang vel/ang accel Parameters: Name Type Description Default cur_q npt.ArrayLike Current orientation (XYZW quaternion), shape (4,) None cur_w npt.ArrayLike Current angular velocity (omega), shape (3,) None des_q npt.ArrayLike Desired orientation (XYZW quaternion), shape (4,) None des_w npt.ArrayLike Desired angular velocity (omega), shape (3,) None des_a npt.ArrayLike Desired angular acceleration (alpha), shape (3,) None Returns: Type Description np.ndarray Torque, (Tx, Ty, Tz), shape (3,) View Source def get_torque( self, cur_q: npt.ArrayLike, cur_w: npt.ArrayLike, des_q: npt.ArrayLike, des_w: npt.ArrayLike, des_a: npt.ArrayLike, ) -> np.ndarray: \"\"\"Calculates the required torque to achieve a desired orientation/ang vel/ang accel Args: cur_q (npt.ArrayLike): Current orientation (XYZW quaternion), shape (4,) cur_w (npt.ArrayLike): Current angular velocity (omega), shape (3,) des_q (npt.ArrayLike): Desired orientation (XYZW quaternion), shape (4,) des_w (npt.ArrayLike): Desired angular velocity (omega), shape (3,) des_a (npt.ArrayLike): Desired angular acceleration (alpha), shape (3,) Returns: np.ndarray: Torque, (Tx, Ty, Tz), shape (3,) \"\"\" if np.allclose(cur_q, -1 * self.last_quat, atol=1e-3): print(\"Quaternion flip detected\") self.quat_sign * = -1 ang_err = quaternion_angular_error(cur_q * self.quat_sign, des_q) self.last_quat = cur_q ang_vel_err = cur_w - des_w R = quat_to_rmat(cur_q) world_inertia = R @ self.inertia @ R.T # Standard 3D free-body torque equation based on desired ang. accel and current ang. vel # Note: this ignores the m * r x a term torque = world_inertia @ des_a + np.cross(cur_w, world_inertia @ cur_w) # Add in the proportional and derivative terms return torque - self.kw * ang_vel_err - self.kq * ang_err step def step ( self , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], omega : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], des_pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], des_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], des_accel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], des_orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], des_omega : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], des_alpha : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], step_sim : bool = True ) -> None Steps the controller and the simulation Parameters: Name Type Description Default pos npt.ArrayLike Current position, shape (3,) None vel npt.ArrayLike Current linear velocity, shape (3,) None orn npt.ArrayLike Current orientation (XYZW quaternion), shape (4,) None omega npt.ArrayLike Current angular velocity, shape (3,) None des_pos npt.ArrayLike Desired position, shape (3,) None des_vel npt.ArrayLike Desired linear velocity, shape (3,) None des_accel npt.ArrayLike Desired linear acceleration, shape (3,) None des_orn npt.ArrayLike Desired orientation (XYZW quaternion), shape (4,) None des_omega npt.ArrayLike Desired angular velocity, shape (3,) None des_alpha npt.ArrayLike Desired angular acceleration, shape (3,) None step_sim bool Whether to step the sim or not (This should almost always be true except for if there are multiple active controllers in the simulation. In that case, the sim must be stepped manually with this flag as False on each controller). Defaults to True. None View Source def step( self, pos: npt.ArrayLike, vel: npt.ArrayLike, orn: npt.ArrayLike, omega: npt.ArrayLike, des_pos: npt.ArrayLike, des_vel: npt.ArrayLike, des_accel: npt.ArrayLike, des_orn: npt.ArrayLike, des_omega: npt.ArrayLike, des_alpha: npt.ArrayLike, step_sim: bool = True, ) -> None: \"\"\"Steps the controller and the simulation Args: pos (npt.ArrayLike): Current position, shape (3,) vel (npt.ArrayLike): Current linear velocity, shape (3,) orn (npt.ArrayLike): Current orientation (XYZW quaternion), shape (4,) omega (npt.ArrayLike): Current angular velocity, shape (3,) des_pos (npt.ArrayLike): Desired position, shape (3,) des_vel (npt.ArrayLike): Desired linear velocity, shape (3,) des_accel (npt.ArrayLike): Desired linear acceleration, shape (3,) des_orn (npt.ArrayLike): Desired orientation (XYZW quaternion), shape (4,) des_omega (npt.ArrayLike): Desired angular velocity, shape (3,) des_alpha (npt.ArrayLike): Desired angular acceleration, shape (3,) step_sim (bool, optional): Whether to step the sim or not (This should almost always be true except for if there are multiple active controllers in the simulation. In that case, the sim must be stepped manually with this flag as False on each controller). Defaults to True. \"\"\" force = self.get_force(pos, vel, des_pos, des_vel, des_accel) torque = self.get_torque(orn, omega, des_orn, des_omega, des_alpha) # Clamp the maximum force/torque if needed if self.max_force is not None: force_mag = np.linalg.norm(force) if force_mag > self.max_force: force = self.max_force * (force / force_mag) if self.max_torque is not None: torque_mag = np.linalg.norm(torque) if torque_mag > self.max_torque: torque = self.max_torque * (torque / torque_mag) self.control_log.log_control(force, torque, self.dt) self.client.applyExternalForce( self.id, -1, force, list(pos), pybullet.WORLD_FRAME ) self.client.applyExternalTorque(self.id, -1, list(torque), pybullet.WORLD_FRAME) if step_sim: self.client.stepSimulation() stop def stop ( self , des_pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], des_quat : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], max_iters : Optional [ int ] = None ) -> None Controls the robot to stop at a desired position/orientation Parameters: Name Type Description Default des_pos npt.ArrayLike Desired position, shape (3,) None des_quat npt.ArrayLike Desired orientation (XYZW quaternion), shape (4,) None max_iters int Maximum number of control iterations to allow for stopping. Defaults to None (keep controlling until stopped) None View Source def stop ( self , des_pos : npt . ArrayLike , des_quat : npt . ArrayLike , max_iters : Optional [ int ] = None , ) -> None : \"\"\"Controls the robot to stop at a desired position/orientation Args: des_pos (npt.ArrayLike): Desired position, shape (3,) des_quat (npt.ArrayLike): Desired orientation (XYZW quaternion), shape (4,) max_iters (int, optional): Maximum number of control iterations to allow for stopping. Defaults to None (keep controlling until stopped) \"\"\" des_vel = np . zeros ( 3 ) des_accel = np . zeros ( 3 ) des_omega = np . zeros ( 3 ) des_alpha = np . zeros ( 3 ) iters = 0 while True : pos , orn , lin_vel , ang_vel = self . get_current_state () if stopping_criteria ( pos , orn , lin_vel , ang_vel , des_pos , des_quat , self . pos_tol , self . orn_tol , self . vel_tol , self . ang_vel_tol , ) : return if max_iters is not None and iters >= max_iters : print ( \"Maximum iterations reached, stopping unsuccessful\" ) return self . step ( pos , lin_vel , orn , ang_vel , des_pos , des_vel , des_accel , des_quat , des_omega , des_alpha , ) iters += 1","title":"Force Torque Control"},{"location":"reference/pyastrobee/control/force_torque_control/#module-pyastrobeecontrolforce_torque_control","text":"Force + torque PID control of the Astrobee body Note: Forces and torques are currently applied in world frame View Source \"\"\"Force + torque PID control of the Astrobee body Note: Forces and torques are currently applied in world frame \"\"\" # TODO: Add better handling of body-frame forces and torques (more aligned with how Astrobee's thrusters operate) # TODO: Operational space control from typing import Optional import pybullet from pybullet_utils.bullet_client import BulletClient import numpy as np import numpy.typing as npt import matplotlib.pyplot as plt from matplotlib.figure import Figure from pyastrobee.trajectories.trajectory import ( Trajectory , TrajectoryLogger , stopping_criteria , ) from pyastrobee.utils.quaternions import quaternion_angular_error from pyastrobee.utils.rotations import quat_to_rmat class ForceTorqueController : \"\"\"PID-style force/torque control Args: robot_id (int): Pybullet ID of the robot to control mass (float): Mass of the robot inertia (np.ndarray): Inertia tensor for the robot, shape (3, 3) kp (float): Gain for position error kv (float): Gain for velocity error kq (float): Gain for orientation (quaternion) error kw (float): Gain for angular velocity (omega) error dt (float): Timestep pos_tol (float, optional): Stopping tolerance on position error magnitude. Defaults to 1e-2. orn_tol (float, optional): Stopping tolerance on quaternion distance between cur/des. Defaults to 1e-2. vel_tol (float, optional): Stopping tolerance on linear velocity error magnitude. Defaults to 1e-2. ang_vel_tol (float, optional): Stopping tolerance on angular velocity error magnitude. Defaults to 5e-3. max_force (Optional[float]): Limit on the applied force magnitude. Defaults to None (no limit) max_torque (Optional[float]): Limit on the applied torque magnitude. Defaults to None (no limit) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" def __init__ ( self , robot_id : int , mass : float , inertia : np . ndarray , kp : float , kv : float , kq : float , kw : float , dt : float , pos_tol : float = 1e-2 , orn_tol : float = 1e-2 , vel_tol : float = 1e-2 , ang_vel_tol : float = 5e-3 , max_force : Optional [ float ] = None , max_torque : Optional [ float ] = None , client : Optional [ BulletClient ] = None , ): self . id = robot_id self . mass = mass self . inertia = inertia self . kp = kp self . kv = kv self . kq = kq self . kw = kw self . dt = dt self . pos_tol = pos_tol self . orn_tol = orn_tol self . vel_tol = vel_tol self . ang_vel_tol = ang_vel_tol self . max_force = max_force self . max_torque = max_torque self . traj_log = TrajectoryLogger () self . control_log = ControlLogger () self . client : pybullet = pybullet if client is None else client # Parameters for checking if there was a quaternion sign flip self . last_quat = np . array ( self . client . getBasePositionAndOrientation ( self . id )[ 1 ]) self . quat_sign = 1 # TODO figure out how world/robot frame should be handled def get_force ( self , cur_pos : npt . ArrayLike , cur_vel : npt . ArrayLike , des_pos : npt . ArrayLike , des_vel : npt . ArrayLike , des_accel : npt . ArrayLike , ) -> np . ndarray : \"\"\"Calculates the required force to achieve a desired pos/vel/accel Args: cur_pos (npt.ArrayLike): Current position, shape (3,) cur_vel (npt.ArrayLike): Current velocity, shape (3,) des_pos (npt.ArrayLike): Desired position, shape (3,) des_vel (npt.ArrayLike): Desired velocity, shape (3,) des_accel (npt.ArrayLike): Desired acceleration, shape (3,) Returns: np.ndarray: Force, (Fx, Fy, Fz), shape (3,) \"\"\" M = self . mass * np . eye ( 3 ) pos_err = np . subtract ( cur_pos , des_pos ) vel_err = np . subtract ( cur_vel , des_vel ) return M @ np . asarray ( des_accel ) - self . kv * vel_err - self . kp * pos_err def get_torque ( self , cur_q : npt . ArrayLike , cur_w : npt . ArrayLike , des_q : npt . ArrayLike , des_w : npt . ArrayLike , des_a : npt . ArrayLike , ) -> np . ndarray : \"\"\"Calculates the required torque to achieve a desired orientation/ang vel/ang accel Args: cur_q (npt.ArrayLike): Current orientation (XYZW quaternion), shape (4,) cur_w (npt.ArrayLike): Current angular velocity (omega), shape (3,) des_q (npt.ArrayLike): Desired orientation (XYZW quaternion), shape (4,) des_w (npt.ArrayLike): Desired angular velocity (omega), shape (3,) des_a (npt.ArrayLike): Desired angular acceleration (alpha), shape (3,) Returns: np.ndarray: Torque, (Tx, Ty, Tz), shape (3,) \"\"\" if np . allclose ( cur_q , - 1 * self . last_quat , atol = 1e-3 ): print ( \"Quaternion flip detected\" ) self . quat_sign *= - 1 ang_err = quaternion_angular_error ( cur_q * self . quat_sign , des_q ) self . last_quat = cur_q ang_vel_err = cur_w - des_w R = quat_to_rmat ( cur_q ) world_inertia = R @ self . inertia @ R . T # Standard 3D free-body torque equation based on desired ang. accel and current ang. vel # Note: this ignores the m * r x a term torque = world_inertia @ des_a + np . cross ( cur_w , world_inertia @ cur_w ) # Add in the proportional and derivative terms return torque - self . kw * ang_vel_err - self . kq * ang_err def follow_traj ( self , traj : Trajectory , stop_at_end : bool = True , max_stop_iters : Optional [ int ] = None , ) -> None : \"\"\"Use PID force/torque control to follow a trajectory Args: traj (Trajectory): Trajectory with position, orientation, and derivative info across time stop_at_end (bool, optional): Whether or not to command the robot to come to a stop at the last pose in the trajectory. Defaults to True max_stop_iters (int, optional): If stop_at_end is True, this gives a maximum number of iterations to allow for stopping. Defaults to None (keep controlling until stopped) \"\"\" for i in range ( traj . num_timesteps ): pos , orn , lin_vel , ang_vel = self . get_current_state () self . step ( pos , lin_vel , orn , ang_vel , traj . positions [ i , :], traj . linear_velocities [ i , :], traj . linear_accels [ i , :], traj . quaternions [ i , :], traj . angular_velocities [ i , :], traj . angular_accels [ i , :], ) if stop_at_end : self . stop ( traj . positions [ - 1 , :], traj . quaternions [ - 1 , :], max_stop_iters ) def stop ( self , des_pos : npt . ArrayLike , des_quat : npt . ArrayLike , max_iters : Optional [ int ] = None , ) -> None : \"\"\"Controls the robot to stop at a desired position/orientation Args: des_pos (npt.ArrayLike): Desired position, shape (3,) des_quat (npt.ArrayLike): Desired orientation (XYZW quaternion), shape (4,) max_iters (int, optional): Maximum number of control iterations to allow for stopping. Defaults to None (keep controlling until stopped) \"\"\" des_vel = np . zeros ( 3 ) des_accel = np . zeros ( 3 ) des_omega = np . zeros ( 3 ) des_alpha = np . zeros ( 3 ) iters = 0 while True : pos , orn , lin_vel , ang_vel = self . get_current_state () if stopping_criteria ( pos , orn , lin_vel , ang_vel , des_pos , des_quat , self . pos_tol , self . orn_tol , self . vel_tol , self . ang_vel_tol , ): return if max_iters is not None and iters >= max_iters : print ( \"Maximum iterations reached, stopping unsuccessful\" ) return self . step ( pos , lin_vel , orn , ang_vel , des_pos , des_vel , des_accel , des_quat , des_omega , des_alpha , ) iters += 1 def step ( self , pos : npt . ArrayLike , vel : npt . ArrayLike , orn : npt . ArrayLike , omega : npt . ArrayLike , des_pos : npt . ArrayLike , des_vel : npt . ArrayLike , des_accel : npt . ArrayLike , des_orn : npt . ArrayLike , des_omega : npt . ArrayLike , des_alpha : npt . ArrayLike , step_sim : bool = True , ) -> None : \"\"\"Steps the controller and the simulation Args: pos (npt.ArrayLike): Current position, shape (3,) vel (npt.ArrayLike): Current linear velocity, shape (3,) orn (npt.ArrayLike): Current orientation (XYZW quaternion), shape (4,) omega (npt.ArrayLike): Current angular velocity, shape (3,) des_pos (npt.ArrayLike): Desired position, shape (3,) des_vel (npt.ArrayLike): Desired linear velocity, shape (3,) des_accel (npt.ArrayLike): Desired linear acceleration, shape (3,) des_orn (npt.ArrayLike): Desired orientation (XYZW quaternion), shape (4,) des_omega (npt.ArrayLike): Desired angular velocity, shape (3,) des_alpha (npt.ArrayLike): Desired angular acceleration, shape (3,) step_sim (bool, optional): Whether to step the sim or not (This should almost always be true except for if there are multiple active controllers in the simulation. In that case, the sim must be stepped manually with this flag as False on each controller). Defaults to True. \"\"\" force = self . get_force ( pos , vel , des_pos , des_vel , des_accel ) torque = self . get_torque ( orn , omega , des_orn , des_omega , des_alpha ) # Clamp the maximum force/torque if needed if self . max_force is not None : force_mag = np . linalg . norm ( force ) if force_mag > self . max_force : force = self . max_force * ( force / force_mag ) if self . max_torque is not None : torque_mag = np . linalg . norm ( torque ) if torque_mag > self . max_torque : torque = self . max_torque * ( torque / torque_mag ) self . control_log . log_control ( force , torque , self . dt ) self . client . applyExternalForce ( self . id , - 1 , force , list ( pos ), pybullet . WORLD_FRAME ) self . client . applyExternalTorque ( self . id , - 1 , list ( torque ), pybullet . WORLD_FRAME ) if step_sim : self . client . stepSimulation () def get_current_state ( self , ) -> tuple [ np . ndarray , np . ndarray , np . ndarray , np . ndarray ]: \"\"\"Determines the current dynamics state of the robot Returns: tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: np.ndarray: Current position, shape (3,) np.ndarray: Current orientation (XYZW quaternion), shape (4,) np.ndarray: Current linear velocity, shape (3,) np.ndarray: Current angular velocity, shape (3,) \"\"\" pos , quat = self . client . getBasePositionAndOrientation ( self . id ) lin_vel , ang_vel = self . client . getBaseVelocity ( self . id ) self . traj_log . log_state ( pos , quat , lin_vel , ang_vel , self . dt ) # These are originally tuples, so convert to numpy return np . array ( pos ), np . array ( quat ), np . array ( lin_vel ), np . array ( ang_vel ) class ControlLogger : \"\"\"Class for maintaining a history of control inputs for plottting or further analysis Any conversions between world frame / robot frame should be done before storing the force/torque data, depending on what is of interest \"\"\" def __init__ ( self ): self . _forces = [] self . _torques = [] self . _times = [] @property def forces ( self ) -> np . ndarray : return np . atleast_2d ( self . _forces ) @property def torques ( self ) -> np . ndarray : return np . atleast_2d ( self . _torques ) @property def times ( self ) -> np . ndarray : return np . array ( self . _times ) def log_control ( self , force : npt . ArrayLike , torque : npt . ArrayLike , dt : Optional [ float ] = None ) -> None : \"\"\"Logs the forces and torques applied in a simulation step Args: force (npt.ArrayLike): Applied force (Fx, Fy, Fz), shape (3,) torque (npt.ArrayLike): Applied torque (Tx, Ty, Tz), shape (3,) dt (Optional[float]): Time elapsed since the previous step. Defaults to None. \"\"\" self . _forces . append ( force ) self . _torques . append ( torque ) if dt is not None and len ( self . _times ) == 0 : self . _times . append ( 0.0 ) elif dt is not None : self . _times . append ( self . _times [ - 1 ] + dt ) def plot ( self , max_force : Optional [ npt . ArrayLike ] = None , max_torque : Optional [ npt . ArrayLike ] = None , show : bool = True , ) -> Figure : \"\"\"Plot the stored history of control inputs Args: max_force (Optional[npt.ArrayLike]): Applied force limits (Fx_max, Fy_max, Fz_max), shape (3,) Defaults to None (Don't indicate the limit on the plots) max_torque (Optional[npt.ArrayLike]): Applied torque limits (Tx_max, Ty_max, Tz_max), shape (3,) Defaults to None (Don't indicate the limit on the plots) show (bool, optional): Whether or not to show the plot. Defaults to True Returns: Figure: Matplotlib figure containing the plots \"\"\" return plot_control ( self . forces , self . torques , self . times , max_force , max_torque , show ) def plot_control ( forces : np . ndarray , torques : np . ndarray , times : Optional [ np . ndarray ] = None , max_force : Optional [ npt . ArrayLike ] = None , max_torque : Optional [ npt . ArrayLike ] = None , show : bool = True , fmt : str = \"k-\" , ) -> Figure : \"\"\"Plots a recorded history of force/torque control inputs Args: forces (np.ndarray): Sequence of force inputs (Fx, Fy, Fz), shape (n, 3) torques (np.ndarray): Sequence of torque inputs (Tx, Ty, Tz), shape (n, 3) times (Optional[np.ndarray], optional): Times corresponding to control inputs, shape (n,). Defaults to None, in which case control inputs will be plotted against timesteps max_force (Optional[npt.ArrayLike]): Applied force limits (Fx_max, Fy_max, Fz_max), shape (3,) Defaults to None (Don't indicate the limit on the plots) max_torque (Optional[npt.ArrayLike]): Applied torque limits (Tx_max, Ty_max, Tz_max), shape (3,) Defaults to None (Don't indicate the limit on the plots) show (bool, optional): Whether or not to display the plot. Defaults to True. fmt (str, optional): Matplotlib line specification. Defaults to \"k-\" Returns: Figure: Matplotlib figure containing the plots \"\"\" fig = plt . figure () if times is not None : x_axis = times x_label = \"Time, s\" else : x_axis = np . arange ( forces . shape [ 0 ]) x_label = \"Timesteps\" subfigs = fig . subfigures ( 2 , 1 ) top_axes = subfigs [ 0 ] . subplots ( 1 , 3 ) bot_axes = subfigs [ 1 ] . subplots ( 1 , 3 ) force_labels = [ \"Fx\" , \"Fy\" , \"Fz\" ] torque_labels = [ \"Tx\" , \"Ty\" , \"Tz\" ] # Plot force info on the top axes for i , ax in enumerate ( top_axes ): ax . plot ( x_axis , forces [:, i ], fmt ) if max_force is not None : ax . plot ( x_axis , max_force [ i ] * np . ones_like ( x_axis ), \"--\" ) ax . set_title ( force_labels [ i ]) ax . set_xlabel ( x_label ) # Plot torque info on the bottom axes for i , ax in enumerate ( bot_axes ): ax . plot ( x_axis , torques [:, i ], fmt ) if max_torque is not None : ax . plot ( x_axis , max_torque [ i ] * np . ones_like ( x_axis ), \"--\" ) ax . set_title ( torque_labels [ i ]) ax . set_xlabel ( x_label ) if show : plt . show () return fig","title":"Module pyastrobee.control.force_torque_control"},{"location":"reference/pyastrobee/control/force_torque_control/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/control/force_torque_control/#plot_control","text":"def plot_control ( forces : numpy . ndarray , torques : numpy . ndarray , times : Optional [ numpy . ndarray ] = None , max_force : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , max_torque : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , show : bool = True , fmt : str = 'k-' ) -> matplotlib . figure . Figure Plots a recorded history of force/torque control inputs Parameters: Name Type Description Default forces np.ndarray Sequence of force inputs (Fx, Fy, Fz), shape (n, 3) None torques np.ndarray Sequence of torque inputs (Tx, Ty, Tz), shape (n, 3) None times Optional[np.ndarray] Times corresponding to control inputs, shape (n,). Defaults to None, in which case control inputs will be plotted against timesteps None max_force Optional[npt.ArrayLike] Applied force limits (Fx_max, Fy_max, Fz_max), shape (3,) Defaults to None (Don't indicate the limit on the plots) None max_torque Optional[npt.ArrayLike] Applied torque limits (Tx_max, Ty_max, Tz_max), shape (3,) Defaults to None (Don't indicate the limit on the plots) None show bool Whether or not to display the plot. Defaults to True. True fmt str Matplotlib line specification. Defaults to \"k-\" None Returns: Type Description Figure Matplotlib figure containing the plots View Source def plot_control ( forces : np . ndarray , torques : np . ndarray , times : Optional [ np.ndarray ] = None , max_force : Optional [ npt.ArrayLike ] = None , max_torque : Optional [ npt.ArrayLike ] = None , show : bool = True , fmt : str = \"k-\" , ) -> Figure : \"\"\"Plots a recorded history of force/torque control inputs Args: forces (np.ndarray): Sequence of force inputs (Fx, Fy, Fz), shape (n, 3) torques (np.ndarray): Sequence of torque inputs (Tx, Ty, Tz), shape (n, 3) times (Optional[np.ndarray], optional): Times corresponding to control inputs, shape (n,). Defaults to None, in which case control inputs will be plotted against timesteps max_force (Optional[npt.ArrayLike]): Applied force limits (Fx_max, Fy_max, Fz_max), shape (3,) Defaults to None (Don't indicate the limit on the plots) max_torque (Optional[npt.ArrayLike]): Applied torque limits (Tx_max, Ty_max, Tz_max), shape (3,) Defaults to None (Don't indicate the limit on the plots) show (bool, optional): Whether or not to display the plot. Defaults to True. fmt (str, optional): Matplotlib line specification. Defaults to \" k - \" Returns: Figure: Matplotlib figure containing the plots \"\"\" fig = plt . figure () if times is not None : x_axis = times x_label = \"Time, s\" else : x_axis = np . arange ( forces . shape [ 0 ] ) x_label = \"Timesteps\" subfigs = fig . subfigures ( 2 , 1 ) top_axes = subfigs [ 0 ] . subplots ( 1 , 3 ) bot_axes = subfigs [ 1 ] . subplots ( 1 , 3 ) force_labels = [ \"Fx\", \"Fy\", \"Fz\" ] torque_labels = [ \"Tx\", \"Ty\", \"Tz\" ] # Plot force info on the top axes for i , ax in enumerate ( top_axes ) : ax . plot ( x_axis , forces [ :, i ] , fmt ) if max_force is not None : ax . plot ( x_axis , max_force [ i ] * np . ones_like ( x_axis ), \"--\" ) ax . set_title ( force_labels [ i ] ) ax . set_xlabel ( x_label ) # Plot torque info on the bottom axes for i , ax in enumerate ( bot_axes ) : ax . plot ( x_axis , torques [ :, i ] , fmt ) if max_torque is not None : ax . plot ( x_axis , max_torque [ i ] * np . ones_like ( x_axis ), \"--\" ) ax . set_title ( torque_labels [ i ] ) ax . set_xlabel ( x_label ) if show : plt . show () return fig","title":"plot_control"},{"location":"reference/pyastrobee/control/force_torque_control/#classes","text":"","title":"Classes"},{"location":"reference/pyastrobee/control/force_torque_control/#controllogger","text":"class ControlLogger ( ) Class for maintaining a history of control inputs for plottting or further analysis Any conversions between world frame / robot frame should be done before storing the force/torque data, depending on what is of interest View Source class ControlLogger : \"\"\"Class for maintaining a history of control inputs for plottting or further analysis Any conversions between world frame / robot frame should be done before storing the force/torque data, depending on what is of interest \"\"\" def __init__ ( self ) : self . _forces = [] self . _torques = [] self . _times = [] @property def forces ( self ) -> np . ndarray : return np . atleast_2d ( self . _forces ) @property def torques ( self ) -> np . ndarray : return np . atleast_2d ( self . _torques ) @property def times ( self ) -> np . ndarray : return np . array ( self . _times ) def log_control ( self , force : npt . ArrayLike , torque : npt . ArrayLike , dt : Optional [ float ] = None ) -> None : \"\"\"Logs the forces and torques applied in a simulation step Args: force (npt.ArrayLike): Applied force (Fx, Fy, Fz), shape (3,) torque (npt.ArrayLike): Applied torque (Tx, Ty, Tz), shape (3,) dt (Optional[float]): Time elapsed since the previous step. Defaults to None. \"\"\" self . _forces . append ( force ) self . _torques . append ( torque ) if dt is not None and len ( self . _times ) == 0 : self . _times . append ( 0.0 ) elif dt is not None : self . _times . append ( self . _times [ -1 ] + dt ) def plot ( self , max_force : Optional [ npt.ArrayLike ] = None , max_torque : Optional [ npt.ArrayLike ] = None , show : bool = True , ) -> Figure : \"\"\"Plot the stored history of control inputs Args: max_force (Optional[npt.ArrayLike]): Applied force limits (Fx_max, Fy_max, Fz_max), shape (3,) Defaults to None (Don't indicate the limit on the plots) max_torque (Optional[npt.ArrayLike]): Applied torque limits (Tx_max, Ty_max, Tz_max), shape (3,) Defaults to None (Don't indicate the limit on the plots) show (bool, optional): Whether or not to show the plot. Defaults to True Returns: Figure: Matplotlib figure containing the plots \"\"\" return plot_control ( self . forces , self . torques , self . times , max_force , max_torque , show )","title":"ControlLogger"},{"location":"reference/pyastrobee/control/force_torque_control/#instance-variables","text":"forces times torques","title":"Instance variables"},{"location":"reference/pyastrobee/control/force_torque_control/#methods","text":"","title":"Methods"},{"location":"reference/pyastrobee/control/force_torque_control/#log_control","text":"def log_control ( self , force : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], torque : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], dt : Optional [ float ] = None ) -> None Logs the forces and torques applied in a simulation step Parameters: Name Type Description Default force npt.ArrayLike Applied force (Fx, Fy, Fz), shape (3,) None torque npt.ArrayLike Applied torque (Tx, Ty, Tz), shape (3,) None dt Optional[float] Time elapsed since the previous step. Defaults to None. None View Source def log_control ( self , force : npt . ArrayLike , torque : npt . ArrayLike , dt : Optional [ float ] = None ) -> None : \"\"\"Logs the forces and torques applied in a simulation step Args: force (npt.ArrayLike): Applied force (Fx, Fy, Fz), shape (3,) torque (npt.ArrayLike): Applied torque (Tx, Ty, Tz), shape (3,) dt (Optional[float]): Time elapsed since the previous step. Defaults to None. \"\"\" self . _forces . append ( force ) self . _torques . append ( torque ) if dt is not None and len ( self . _times ) == 0 : self . _times . append ( 0.0 ) elif dt is not None : self . _times . append ( self . _times [ -1 ] + dt )","title":"log_control"},{"location":"reference/pyastrobee/control/force_torque_control/#plot","text":"def plot ( self , max_force : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , max_torque : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , show : bool = True ) -> matplotlib . figure . Figure Plot the stored history of control inputs Parameters: Name Type Description Default max_force Optional[npt.ArrayLike] Applied force limits (Fx_max, Fy_max, Fz_max), shape (3,) Defaults to None (Don't indicate the limit on the plots) None max_torque Optional[npt.ArrayLike] Applied torque limits (Tx_max, Ty_max, Tz_max), shape (3,) Defaults to None (Don't indicate the limit on the plots) None show bool Whether or not to show the plot. Defaults to True None Returns: Type Description Figure Matplotlib figure containing the plots View Source def plot ( self , max_force : Optional [ npt . ArrayLike ] = None , max_torque : Optional [ npt . ArrayLike ] = None , show : bool = True , ) -> Figure : \"\"\"Plot the stored history of control inputs Args: max_force (Optional[npt.ArrayLike]): Applied force limits (Fx_max, Fy_max, Fz_max), shape (3,) Defaults to None (Don' t indicate the limit on the plots ) max_torque ( Optional [ npt . ArrayLike ]) : Applied torque limits ( Tx_max , Ty_max , Tz_max ), shape ( 3 ,) Defaults to None ( Don 't indicate the limit on the plots) show (bool, optional): Whether or not to show the plot. Defaults to True Returns: Figure: Matplotlib figure containing the plots \"\"\" return plot_control ( self . forces , self . torques , self . times , max_force , max_torque , show )","title":"plot"},{"location":"reference/pyastrobee/control/force_torque_control/#forcetorquecontroller","text":"class ForceTorqueController ( robot_id : int , mass : float , inertia : numpy . ndarray , kp : float , kv : float , kq : float , kw : float , dt : float , pos_tol : float = 0.01 , orn_tol : float = 0.01 , vel_tol : float = 0.01 , ang_vel_tol : float = 0.005 , max_force : Optional [ float ] = None , max_torque : Optional [ float ] = None , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) PID-style force/torque control","title":"ForceTorqueController"},{"location":"reference/pyastrobee/control/force_torque_control/#attributes","text":"Name Type Description Default robot_id int Pybullet ID of the robot to control None mass float Mass of the robot None inertia np.ndarray Inertia tensor for the robot, shape (3, 3) None kp float Gain for position error None kv float Gain for velocity error None kq float Gain for orientation (quaternion) error None kw float Gain for angular velocity (omega) error None dt float Timestep None pos_tol float Stopping tolerance on position error magnitude. Defaults to 1e-2. 1e-2 orn_tol float Stopping tolerance on quaternion distance between cur/des. Defaults to 1e-2. 1e-2 vel_tol float Stopping tolerance on linear velocity error magnitude. Defaults to 1e-2. 1e-2 ang_vel_tol float Stopping tolerance on angular velocity error magnitude. Defaults to 5e-3. 5e-3 max_force Optional[float] Limit on the applied force magnitude. Defaults to None (no limit) None max_torque Optional[float] Limit on the applied torque magnitude. Defaults to None (no limit) None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None View Source class ForceTorqueController : \"\"\"PID-style force/torque control Args: robot_id (int): Pybullet ID of the robot to control mass (float): Mass of the robot inertia (np.ndarray): Inertia tensor for the robot, shape (3, 3) kp (float): Gain for position error kv (float): Gain for velocity error kq (float): Gain for orientation (quaternion) error kw (float): Gain for angular velocity (omega) error dt (float): Timestep pos_tol (float, optional): Stopping tolerance on position error magnitude. Defaults to 1e-2. orn_tol (float, optional): Stopping tolerance on quaternion distance between cur/des. Defaults to 1e-2. vel_tol (float, optional): Stopping tolerance on linear velocity error magnitude. Defaults to 1e-2. ang_vel_tol (float, optional): Stopping tolerance on angular velocity error magnitude. Defaults to 5e-3. max_force (Optional[float]): Limit on the applied force magnitude. Defaults to None (no limit) max_torque (Optional[float]): Limit on the applied torque magnitude. Defaults to None (no limit) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" def __init__ ( self , robot_id : int , mass : float , inertia : np . ndarray , kp : float , kv : float , kq : float , kw : float , dt : float , pos_tol : float = 1e-2 , orn_tol : float = 1e-2 , vel_tol : float = 1e-2 , ang_vel_tol : float = 5e-3 , max_force : Optional [ float ] = None , max_torque : Optional [ float ] = None , client : Optional [ BulletClient ] = None , ) : self . id = robot_id self . mass = mass self . inertia = inertia self . kp = kp self . kv = kv self . kq = kq self . kw = kw self . dt = dt self . pos_tol = pos_tol self . orn_tol = orn_tol self . vel_tol = vel_tol self . ang_vel_tol = ang_vel_tol self . max_force = max_force self . max_torque = max_torque self . traj_log = TrajectoryLogger () self . control_log = ControlLogger () self . client : pybullet = pybullet if client is None else client # Parameters for checking if there was a quaternion sign flip self . last_quat = np . array ( self . client . getBasePositionAndOrientation ( self . id ) [ 1 ] ) self . quat_sign = 1 # TODO figure out how world / robot frame should be handled def get_force ( self , cur_pos : npt . ArrayLike , cur_vel : npt . ArrayLike , des_pos : npt . ArrayLike , des_vel : npt . ArrayLike , des_accel : npt . ArrayLike , ) -> np . ndarray : \"\"\"Calculates the required force to achieve a desired pos/vel/accel Args: cur_pos (npt.ArrayLike): Current position, shape (3,) cur_vel (npt.ArrayLike): Current velocity, shape (3,) des_pos (npt.ArrayLike): Desired position, shape (3,) des_vel (npt.ArrayLike): Desired velocity, shape (3,) des_accel (npt.ArrayLike): Desired acceleration, shape (3,) Returns: np.ndarray: Force, (Fx, Fy, Fz), shape (3,) \"\"\" M = self . mass * np . eye ( 3 ) pos_err = np . subtract ( cur_pos , des_pos ) vel_err = np . subtract ( cur_vel , des_vel ) return M @ np . asarray ( des_accel ) - self . kv * vel_err - self . kp * pos_err def get_torque ( self , cur_q : npt . ArrayLike , cur_w : npt . ArrayLike , des_q : npt . ArrayLike , des_w : npt . ArrayLike , des_a : npt . ArrayLike , ) -> np . ndarray : \"\"\"Calculates the required torque to achieve a desired orientation/ang vel/ang accel Args: cur_q (npt.ArrayLike): Current orientation (XYZW quaternion), shape (4,) cur_w (npt.ArrayLike): Current angular velocity (omega), shape (3,) des_q (npt.ArrayLike): Desired orientation (XYZW quaternion), shape (4,) des_w (npt.ArrayLike): Desired angular velocity (omega), shape (3,) des_a (npt.ArrayLike): Desired angular acceleration (alpha), shape (3,) Returns: np.ndarray: Torque, (Tx, Ty, Tz), shape (3,) \"\"\" if np . allclose ( cur_q , - 1 * self . last_quat , atol = 1e-3 ) : print ( \"Quaternion flip detected\" ) self . quat_sign *= - 1 ang_err = quaternion_angular_error ( cur_q * self . quat_sign , des_q ) self . last_quat = cur_q ang_vel_err = cur_w - des_w R = quat_to_rmat ( cur_q ) world_inertia = R @ self . inertia @ R . T # Standard 3 D free - body torque equation based on desired ang . accel and current ang . vel # Note : this ignores the m * r x a term torque = world_inertia @ des_a + np . cross ( cur_w , world_inertia @ cur_w ) # Add in the proportional and derivative terms return torque - self . kw * ang_vel_err - self . kq * ang_err def follow_traj ( self , traj : Trajectory , stop_at_end : bool = True , max_stop_iters : Optional [ int ] = None , ) -> None : \"\"\"Use PID force/torque control to follow a trajectory Args: traj (Trajectory): Trajectory with position, orientation, and derivative info across time stop_at_end (bool, optional): Whether or not to command the robot to come to a stop at the last pose in the trajectory. Defaults to True max_stop_iters (int, optional): If stop_at_end is True, this gives a maximum number of iterations to allow for stopping. Defaults to None (keep controlling until stopped) \"\"\" for i in range ( traj . num_timesteps ) : pos , orn , lin_vel , ang_vel = self . get_current_state () self . step ( pos , lin_vel , orn , ang_vel , traj . positions [ i, : ] , traj . linear_velocities [ i, : ] , traj . linear_accels [ i, : ] , traj . quaternions [ i, : ] , traj . angular_velocities [ i, : ] , traj . angular_accels [ i, : ] , ) if stop_at_end : self . stop ( traj . positions [ -1, : ] , traj . quaternions [ -1, : ] , max_stop_iters ) def stop ( self , des_pos : npt . ArrayLike , des_quat : npt . ArrayLike , max_iters : Optional [ int ] = None , ) -> None : \"\"\"Controls the robot to stop at a desired position/orientation Args: des_pos (npt.ArrayLike): Desired position, shape (3,) des_quat (npt.ArrayLike): Desired orientation (XYZW quaternion), shape (4,) max_iters (int, optional): Maximum number of control iterations to allow for stopping. Defaults to None (keep controlling until stopped) \"\"\" des_vel = np . zeros ( 3 ) des_accel = np . zeros ( 3 ) des_omega = np . zeros ( 3 ) des_alpha = np . zeros ( 3 ) iters = 0 while True : pos , orn , lin_vel , ang_vel = self . get_current_state () if stopping_criteria ( pos , orn , lin_vel , ang_vel , des_pos , des_quat , self . pos_tol , self . orn_tol , self . vel_tol , self . ang_vel_tol , ) : return if max_iters is not None and iters >= max_iters : print ( \"Maximum iterations reached, stopping unsuccessful\" ) return self . step ( pos , lin_vel , orn , ang_vel , des_pos , des_vel , des_accel , des_quat , des_omega , des_alpha , ) iters += 1 def step ( self , pos : npt . ArrayLike , vel : npt . ArrayLike , orn : npt . ArrayLike , omega : npt . ArrayLike , des_pos : npt . ArrayLike , des_vel : npt . ArrayLike , des_accel : npt . ArrayLike , des_orn : npt . ArrayLike , des_omega : npt . ArrayLike , des_alpha : npt . ArrayLike , step_sim : bool = True , ) -> None : \"\"\"Steps the controller and the simulation Args: pos (npt.ArrayLike): Current position, shape (3,) vel (npt.ArrayLike): Current linear velocity, shape (3,) orn (npt.ArrayLike): Current orientation (XYZW quaternion), shape (4,) omega (npt.ArrayLike): Current angular velocity, shape (3,) des_pos (npt.ArrayLike): Desired position, shape (3,) des_vel (npt.ArrayLike): Desired linear velocity, shape (3,) des_accel (npt.ArrayLike): Desired linear acceleration, shape (3,) des_orn (npt.ArrayLike): Desired orientation (XYZW quaternion), shape (4,) des_omega (npt.ArrayLike): Desired angular velocity, shape (3,) des_alpha (npt.ArrayLike): Desired angular acceleration, shape (3,) step_sim (bool, optional): Whether to step the sim or not (This should almost always be true except for if there are multiple active controllers in the simulation. In that case, the sim must be stepped manually with this flag as False on each controller). Defaults to True. \"\"\" force = self . get_force ( pos , vel , des_pos , des_vel , des_accel ) torque = self . get_torque ( orn , omega , des_orn , des_omega , des_alpha ) # Clamp the maximum force / torque if needed if self . max_force is not None : force_mag = np . linalg . norm ( force ) if force_mag > self . max_force : force = self . max_force * ( force / force_mag ) if self . max_torque is not None : torque_mag = np . linalg . norm ( torque ) if torque_mag > self . max_torque : torque = self . max_torque * ( torque / torque_mag ) self . control_log . log_control ( force , torque , self . dt ) self . client . applyExternalForce ( self . id , - 1 , force , list ( pos ), pybullet . WORLD_FRAME ) self . client . applyExternalTorque ( self . id , - 1 , list ( torque ), pybullet . WORLD_FRAME ) if step_sim : self . client . stepSimulation () def get_current_state ( self , ) -> tuple [ np.ndarray, np.ndarray, np.ndarray, np.ndarray ] : \"\"\"Determines the current dynamics state of the robot Returns: tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: np.ndarray: Current position, shape (3,) np.ndarray: Current orientation (XYZW quaternion), shape (4,) np.ndarray: Current linear velocity, shape (3,) np.ndarray: Current angular velocity, shape (3,) \"\"\" pos , quat = self . client . getBasePositionAndOrientation ( self . id ) lin_vel , ang_vel = self . client . getBaseVelocity ( self . id ) self . traj_log . log_state ( pos , quat , lin_vel , ang_vel , self . dt ) # These are originally tuples , so convert to numpy return np . array ( pos ), np . array ( quat ), np . array ( lin_vel ), np . array ( ang_vel )","title":"Attributes"},{"location":"reference/pyastrobee/control/force_torque_control/#methods_1","text":"","title":"Methods"},{"location":"reference/pyastrobee/control/force_torque_control/#follow_traj","text":"def follow_traj ( self , traj : pyastrobee . trajectories . trajectory . Trajectory , stop_at_end : bool = True , max_stop_iters : Optional [ int ] = None ) -> None Use PID force/torque control to follow a trajectory Parameters: Name Type Description Default traj Trajectory Trajectory with position, orientation, and derivative info across time None stop_at_end bool Whether or not to command the robot to come to a stop at the last pose in the trajectory. Defaults to True None max_stop_iters int If stop_at_end is True, this gives a maximum number of iterations to allow for stopping. Defaults to None (keep controlling until stopped) None View Source def follow_traj ( self , traj : Trajectory , stop_at_end : bool = True , max_stop_iters : Optional [ int ] = None , ) -> None : \"\"\"Use PID force/torque control to follow a trajectory Args: traj (Trajectory): Trajectory with position, orientation, and derivative info across time stop_at_end (bool, optional): Whether or not to command the robot to come to a stop at the last pose in the trajectory. Defaults to True max_stop_iters (int, optional): If stop_at_end is True, this gives a maximum number of iterations to allow for stopping. Defaults to None (keep controlling until stopped) \"\"\" for i in range ( traj . num_timesteps ) : pos , orn , lin_vel , ang_vel = self . get_current_state () self . step ( pos , lin_vel , orn , ang_vel , traj . positions [ i, : ] , traj . linear_velocities [ i, : ] , traj . linear_accels [ i, : ] , traj . quaternions [ i, : ] , traj . angular_velocities [ i, : ] , traj . angular_accels [ i, : ] , ) if stop_at_end : self . stop ( traj . positions [ -1, : ] , traj . quaternions [ -1, : ] , max_stop_iters )","title":"follow_traj"},{"location":"reference/pyastrobee/control/force_torque_control/#get_current_state","text":"def get_current_state ( self ) -> tuple [ numpy . ndarray , numpy . ndarray , numpy . ndarray , numpy . ndarray ] Determines the current dynamics state of the robot Returns: Type Description tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray] np.ndarray: Current position, shape (3,) np.ndarray: Current orientation (XYZW quaternion), shape (4,) np.ndarray: Current linear velocity, shape (3,) np.ndarray: Current angular velocity, shape (3,) View Source def get_current_state ( self , ) -> tuple [ np . ndarray , np . ndarray , np . ndarray , np . ndarray ] : \"\"\"Determines the current dynamics state of the robot Returns: tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: np.ndarray: Current position, shape (3,) np.ndarray: Current orientation (XYZW quaternion), shape (4,) np.ndarray: Current linear velocity, shape (3,) np.ndarray: Current angular velocity, shape (3,) \"\"\" pos , quat = self . client . getBasePositionAndOrientation ( self . id ) lin_vel , ang_vel = self . client . getBaseVelocity ( self . id ) self . traj_log . log_state ( pos , quat , lin_vel , ang_vel , self . dt ) # These are originally tuples , so convert to numpy return np . array ( pos ), np . array ( quat ), np . array ( lin_vel ), np . array ( ang_vel )","title":"get_current_state"},{"location":"reference/pyastrobee/control/force_torque_control/#get_force","text":"def get_force ( self , cur_pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], cur_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], des_pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], des_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], des_accel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Calculates the required force to achieve a desired pos/vel/accel Parameters: Name Type Description Default cur_pos npt.ArrayLike Current position, shape (3,) None cur_vel npt.ArrayLike Current velocity, shape (3,) None des_pos npt.ArrayLike Desired position, shape (3,) None des_vel npt.ArrayLike Desired velocity, shape (3,) None des_accel npt.ArrayLike Desired acceleration, shape (3,) None Returns: Type Description np.ndarray Force, (Fx, Fy, Fz), shape (3,) View Source def get_force( self, cur_pos: npt.ArrayLike, cur_vel: npt.ArrayLike, des_pos: npt.ArrayLike, des_vel: npt.ArrayLike, des_accel: npt.ArrayLike, ) -> np.ndarray: \"\"\"Calculates the required force to achieve a desired pos/vel/accel Args: cur_pos (npt.ArrayLike): Current position, shape (3,) cur_vel (npt.ArrayLike): Current velocity, shape (3,) des_pos (npt.ArrayLike): Desired position, shape (3,) des_vel (npt.ArrayLike): Desired velocity, shape (3,) des_accel (npt.ArrayLike): Desired acceleration, shape (3,) Returns: np.ndarray: Force, (Fx, Fy, Fz), shape (3,) \"\"\" M = self.mass * np.eye(3) pos_err = np.subtract(cur_pos, des_pos) vel_err = np.subtract(cur_vel, des_vel) return M @ np.asarray(des_accel) - self.kv * vel_err - self.kp * pos_err","title":"get_force"},{"location":"reference/pyastrobee/control/force_torque_control/#get_torque","text":"def get_torque ( self , cur_q : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], cur_w : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], des_q : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], des_w : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], des_a : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Calculates the required torque to achieve a desired orientation/ang vel/ang accel Parameters: Name Type Description Default cur_q npt.ArrayLike Current orientation (XYZW quaternion), shape (4,) None cur_w npt.ArrayLike Current angular velocity (omega), shape (3,) None des_q npt.ArrayLike Desired orientation (XYZW quaternion), shape (4,) None des_w npt.ArrayLike Desired angular velocity (omega), shape (3,) None des_a npt.ArrayLike Desired angular acceleration (alpha), shape (3,) None Returns: Type Description np.ndarray Torque, (Tx, Ty, Tz), shape (3,) View Source def get_torque( self, cur_q: npt.ArrayLike, cur_w: npt.ArrayLike, des_q: npt.ArrayLike, des_w: npt.ArrayLike, des_a: npt.ArrayLike, ) -> np.ndarray: \"\"\"Calculates the required torque to achieve a desired orientation/ang vel/ang accel Args: cur_q (npt.ArrayLike): Current orientation (XYZW quaternion), shape (4,) cur_w (npt.ArrayLike): Current angular velocity (omega), shape (3,) des_q (npt.ArrayLike): Desired orientation (XYZW quaternion), shape (4,) des_w (npt.ArrayLike): Desired angular velocity (omega), shape (3,) des_a (npt.ArrayLike): Desired angular acceleration (alpha), shape (3,) Returns: np.ndarray: Torque, (Tx, Ty, Tz), shape (3,) \"\"\" if np.allclose(cur_q, -1 * self.last_quat, atol=1e-3): print(\"Quaternion flip detected\") self.quat_sign * = -1 ang_err = quaternion_angular_error(cur_q * self.quat_sign, des_q) self.last_quat = cur_q ang_vel_err = cur_w - des_w R = quat_to_rmat(cur_q) world_inertia = R @ self.inertia @ R.T # Standard 3D free-body torque equation based on desired ang. accel and current ang. vel # Note: this ignores the m * r x a term torque = world_inertia @ des_a + np.cross(cur_w, world_inertia @ cur_w) # Add in the proportional and derivative terms return torque - self.kw * ang_vel_err - self.kq * ang_err","title":"get_torque"},{"location":"reference/pyastrobee/control/force_torque_control/#step","text":"def step ( self , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], omega : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], des_pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], des_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], des_accel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], des_orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], des_omega : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], des_alpha : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], step_sim : bool = True ) -> None Steps the controller and the simulation Parameters: Name Type Description Default pos npt.ArrayLike Current position, shape (3,) None vel npt.ArrayLike Current linear velocity, shape (3,) None orn npt.ArrayLike Current orientation (XYZW quaternion), shape (4,) None omega npt.ArrayLike Current angular velocity, shape (3,) None des_pos npt.ArrayLike Desired position, shape (3,) None des_vel npt.ArrayLike Desired linear velocity, shape (3,) None des_accel npt.ArrayLike Desired linear acceleration, shape (3,) None des_orn npt.ArrayLike Desired orientation (XYZW quaternion), shape (4,) None des_omega npt.ArrayLike Desired angular velocity, shape (3,) None des_alpha npt.ArrayLike Desired angular acceleration, shape (3,) None step_sim bool Whether to step the sim or not (This should almost always be true except for if there are multiple active controllers in the simulation. In that case, the sim must be stepped manually with this flag as False on each controller). Defaults to True. None View Source def step( self, pos: npt.ArrayLike, vel: npt.ArrayLike, orn: npt.ArrayLike, omega: npt.ArrayLike, des_pos: npt.ArrayLike, des_vel: npt.ArrayLike, des_accel: npt.ArrayLike, des_orn: npt.ArrayLike, des_omega: npt.ArrayLike, des_alpha: npt.ArrayLike, step_sim: bool = True, ) -> None: \"\"\"Steps the controller and the simulation Args: pos (npt.ArrayLike): Current position, shape (3,) vel (npt.ArrayLike): Current linear velocity, shape (3,) orn (npt.ArrayLike): Current orientation (XYZW quaternion), shape (4,) omega (npt.ArrayLike): Current angular velocity, shape (3,) des_pos (npt.ArrayLike): Desired position, shape (3,) des_vel (npt.ArrayLike): Desired linear velocity, shape (3,) des_accel (npt.ArrayLike): Desired linear acceleration, shape (3,) des_orn (npt.ArrayLike): Desired orientation (XYZW quaternion), shape (4,) des_omega (npt.ArrayLike): Desired angular velocity, shape (3,) des_alpha (npt.ArrayLike): Desired angular acceleration, shape (3,) step_sim (bool, optional): Whether to step the sim or not (This should almost always be true except for if there are multiple active controllers in the simulation. In that case, the sim must be stepped manually with this flag as False on each controller). Defaults to True. \"\"\" force = self.get_force(pos, vel, des_pos, des_vel, des_accel) torque = self.get_torque(orn, omega, des_orn, des_omega, des_alpha) # Clamp the maximum force/torque if needed if self.max_force is not None: force_mag = np.linalg.norm(force) if force_mag > self.max_force: force = self.max_force * (force / force_mag) if self.max_torque is not None: torque_mag = np.linalg.norm(torque) if torque_mag > self.max_torque: torque = self.max_torque * (torque / torque_mag) self.control_log.log_control(force, torque, self.dt) self.client.applyExternalForce( self.id, -1, force, list(pos), pybullet.WORLD_FRAME ) self.client.applyExternalTorque(self.id, -1, list(torque), pybullet.WORLD_FRAME) if step_sim: self.client.stepSimulation()","title":"step"},{"location":"reference/pyastrobee/control/force_torque_control/#stop","text":"def stop ( self , des_pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], des_quat : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], max_iters : Optional [ int ] = None ) -> None Controls the robot to stop at a desired position/orientation Parameters: Name Type Description Default des_pos npt.ArrayLike Desired position, shape (3,) None des_quat npt.ArrayLike Desired orientation (XYZW quaternion), shape (4,) None max_iters int Maximum number of control iterations to allow for stopping. Defaults to None (keep controlling until stopped) None View Source def stop ( self , des_pos : npt . ArrayLike , des_quat : npt . ArrayLike , max_iters : Optional [ int ] = None , ) -> None : \"\"\"Controls the robot to stop at a desired position/orientation Args: des_pos (npt.ArrayLike): Desired position, shape (3,) des_quat (npt.ArrayLike): Desired orientation (XYZW quaternion), shape (4,) max_iters (int, optional): Maximum number of control iterations to allow for stopping. Defaults to None (keep controlling until stopped) \"\"\" des_vel = np . zeros ( 3 ) des_accel = np . zeros ( 3 ) des_omega = np . zeros ( 3 ) des_alpha = np . zeros ( 3 ) iters = 0 while True : pos , orn , lin_vel , ang_vel = self . get_current_state () if stopping_criteria ( pos , orn , lin_vel , ang_vel , des_pos , des_quat , self . pos_tol , self . orn_tol , self . vel_tol , self . ang_vel_tol , ) : return if max_iters is not None and iters >= max_iters : print ( \"Maximum iterations reached, stopping unsuccessful\" ) return self . step ( pos , lin_vel , orn , ang_vel , des_pos , des_vel , des_accel , des_quat , des_omega , des_alpha , ) iters += 1","title":"stop"},{"location":"reference/pyastrobee/control/keyboard_controller/","text":"Module pyastrobee.control.keyboard_controller Class/script for controlling the Astrobee via keyboard presses Usage: - Positional control via WASDQE - w: +x - s: -x - a: +y - d: -y - e: +z - q: -z - Angular control via IJKLUO - l: + roll - j: - roll - i: + pitch - k: - pitch - u: + yaw - o: - yaw - Arm control via arrow keys - Up: + proximal angle - Down: - proximal angle - Right: + distal angle - Left: - distal angle - Toggle opening/closing the gripper with G - Record a waypoint with P - Coarse control of position/orientation with capital letters (via Shift) - Coarse control of the arm positioning via C - Press Space to switch reference frames (global <=> robot) - Press Esc to exit Motions are only recorded on a button release to prevent over-queueing actions View Source \"\"\"Class/script for controlling the Astrobee via keyboard presses Usage: - Positional control via WASDQE - w: +x - s: -x - a: +y - d: -y - e: +z - q: -z - Angular control via IJKLUO - l: + roll - j: - roll - i: + pitch - k: - pitch - u: + yaw - o: - yaw - Arm control via arrow keys - Up: + proximal angle - Down: - proximal angle - Right: + distal angle - Left: - distal angle - Toggle opening/closing the gripper with G - Record a waypoint with P - Coarse control of position/orientation with capital letters (via Shift) - Coarse control of the arm positioning via C - Press Space to switch reference frames (global <=> robot) - Press Esc to exit Motions are only recorded on a button release to prevent over-queueing actions \"\"\" import time import numpy as np import pybullet from pynput import keyboard from pyastrobee.core.astrobee import Astrobee from pyastrobee.utils.poses import ( pos_euler_xyz_to_pos_quat , add_local_pose_delta , add_global_pose_delta , ) from pyastrobee.core.iss import ISS from pyastrobee.utils.debug_visualizer import get_viz_camera_params from pyastrobee.utils.python_utils import print_green , print_red class KeyboardController : \"\"\"Class to encompass the keyboard listening and corresponding robot actions Args: robot (Astrobee): The Astrobee to control pov (bool, optional): Whether to use a \"third person point of view\" perspective that follows the robot around. Defaults to True. \"\"\" def __init__ ( self , robot : Astrobee , pov : bool = True ): if not pybullet . isConnected (): raise ConnectionError ( \"Connect to pybullet before starting the keyboard controller\" ) # Disable keyboard shortcuts in pybullet so it doesn't do anything weird while we're controlling it pybullet . configureDebugVisualizer ( pybullet . COV_ENABLE_KEYBOARD_SHORTCUTS , 0 ) self . robot = robot self . pov = pov self . gripper_is_open = robot . gripper_position >= 90 # Copying over the original constraint from the Astrobee class (and the position controller) # TODO remove this when we switch over to velocity control for this controller self . constraint_id = pybullet . createConstraint ( self . robot . id , - 1 , - 1 , - 1 , pybullet . JOINT_FIXED , None , ( 0 , 0 , 0 ), ( 0 , 0 , 0 ) ) self . dx = 0.05 # m self . dy = 0.05 # m self . dz = 0.05 # m self . droll = 0.05 # rad self . dpitch = 0.05 # rad self . dyaw = 0.05 # rad self . djoint = 0.05 # rad # Configuration for non-position/angular control keys self . frame_switch_key = keyboard . Key . space self . exit_key = keyboard . Key . esc self . gripper_key = keyboard . KeyCode . from_char ( \"g\" ) self . waypoint_key = keyboard . KeyCode . from_char ( \"p\" ) self . coarse_control_key = keyboard . KeyCode . from_char ( \"c\" ) self . arm_keys = { keyboard . Key . up , keyboard . Key . down , keyboard . Key . right , keyboard . Key . left , } # Coarse control multiplier self . mult = 5 # States self . in_robot_frame = False self . in_coarse_mode = False # Initialize listener, update when listener started self . listener : keyboard . Listener = None # Timestep self . dt = pybullet . getPhysicsEngineParameters ()[ \"fixedTimeStep\" ] # Having this in position/Euler can be more interpretable than position/quaternion # Also, it is easier to scale Euler angles than quaternions for coarse control # (multiplying a quaternion by a constant won't change the rotation it represents) self . pos_euler_deltas_lowercase = { \"w\" : np . array ([ self . dx , 0 , 0 , 0 , 0 , 0 ]), \"s\" : np . array ([ - self . dx , 0 , 0 , 0 , 0 , 0 ]), \"a\" : np . array ([ 0 , self . dy , 0 , 0 , 0 , 0 ]), \"d\" : np . array ([ 0 , - self . dy , 0 , 0 , 0 , 0 ]), \"e\" : np . array ([ 0 , 0 , self . dz , 0 , 0 , 0 ]), \"q\" : np . array ([ 0 , 0 , - self . dz , 0 , 0 , 0 ]), \"l\" : np . array ([ 0 , 0 , 0 , self . droll , 0 , 0 ]), \"j\" : np . array ([ 0 , 0 , 0 , - self . droll , 0 , 0 ]), \"i\" : np . array ([ 0 , 0 , 0 , 0 , self . dpitch , 0 ]), \"k\" : np . array ([ 0 , 0 , 0 , 0 , - self . dpitch , 0 ]), \"u\" : np . array ([ 0 , 0 , 0 , 0 , 0 , self . dyaw ]), \"o\" : np . array ([ 0 , 0 , 0 , 0 , 0 , - self . dyaw ]), } # Change the keys to be in pynput Key format, and add coarse control for uppercase letters self . pose_deltas = {} for key , delta in self . pos_euler_deltas_lowercase . items (): self . pose_deltas [ keyboard . KeyCode . from_char ( key )] = ( pos_euler_xyz_to_pos_quat ( delta ) ) self . pose_deltas [ keyboard . KeyCode . from_char ( key . upper ())] = ( pos_euler_xyz_to_pos_quat ( self . mult * delta ) ) def _print_commands ( self ): \"\"\"Prints the keyboard/control action mapping information\"\"\" print ( \"Commands: \\n \" + \"w/s: +/- x \\n \" + \"a/d: +/- y \\n \" + \"e/q: +/- z \\n \" + \"l/j: +/- roll \\n \" + \"i/k: +/- pitch \\n \" + \"u/o: +/- yaw \\n \" + \"Capital letters: Coarse control of position/orientation \\n \" + \"up/down: +/- arm proximal joint angle \\n \" + \"right/left: +/- arm distal joint angle \\n \" + \"c: Toggle coarse control for the arm \\n \" + \"g: Open/close the gripper \\n \" + \"p: Record a pose \\n \" + \"Space: Switch reference frames \\n \" + \"Esc: Stop listening\" ) def start_listening ( self ): \"\"\"Starts the keyboard listener in a new thread\"\"\" print_green ( \"Now listening\" ) self . _print_commands () self . listener = keyboard . Listener ( on_press = self . on_press , on_release = self . on_release ) self . listener . start () @property def is_listening ( self ) -> bool : \"\"\"Whether or not the pynput Listener has been initialized\"\"\" return self . listener is not None def on_press ( self , key : keyboard . Key ): \"\"\"Callback for a keypress Args: key (Key): Key that was pressed Returns: bool: False when the \"stop listening\" key (Esc) is pressed \"\"\" if key == keyboard . Key . esc : print_red ( \" \\n LISTENER STOPPED\" ) print ( \"Simulation will remain active until killed\" ) return False # Returning false from a callback stops pynput def on_release ( self , key : keyboard . Key ): \"\"\"Callback for when a key is released Args: key (Key): Key that was pressed \"\"\" # If the key is associated with a motion, if key in self . pose_deltas : init_pose = self . robot . pose # Get the pose delta that key is associated with pose_delta = self . pose_deltas [ key ] if self . in_robot_frame : new_pose = add_local_pose_delta ( init_pose , pose_delta ) pybullet . changeConstraint ( self . constraint_id , new_pose [: 3 ], new_pose [ 3 :] ) else : new_pose = add_global_pose_delta ( init_pose , pose_delta ) pybullet . changeConstraint ( self . constraint_id , new_pose [: 3 ], new_pose [ 3 :] ) elif key == self . frame_switch_key : # Toggle the reference frame and update our knowledge of the state self . in_robot_frame = not self . in_robot_frame print ( f \" \\n FRAME SWITCHED. Now in { 'robot' if self . in_robot_frame else 'world' } frame\" ) elif key == self . gripper_key : # Toggle the gripper and update our knowledge of the state if self . gripper_is_open : self . robot . close_gripper () self . gripper_is_open = False else : self . robot . open_gripper () self . gripper_is_open = True print ( f \" \\n GRIPPER { 'OPENED' if self . gripper_is_open else 'CLOSED' } \" ) elif key == self . waypoint_key : # Record a waypoint and print the info to the terminal print ( f \" \\n Pose recorded: { self . robot . pose } \" ) print ( f \"Gripper position: { self . robot . gripper_position } \" ) print ( f \"Arm joints: { self . robot . arm_joint_angles } \" ) elif key == self . coarse_control_key : # Toggle coarse control mode self . in_coarse_mode = not self . in_coarse_mode print ( f \" \\n Coarse control { 'ACTIVATED' if self . in_coarse_mode else 'DEACTIVATED' } \" ) elif key in self . arm_keys : cur_prox , cur_dist = self . robot . arm_joint_angles prox_idx , dist_idx = self . robot . ARM_JOINT_IDXS delta = self . djoint * ( self . mult if self . in_coarse_mode else 1 ) if key == keyboard . Key . up : # Raise the proximal joint self . robot . set_joint_angles ( min ( cur_prox + delta , Astrobee . JOINT_POS_LIMITS [ prox_idx , 1 ]), prox_idx , ) elif key == keyboard . Key . down : # Lower the proximal joint self . robot . set_joint_angles ( max ( cur_prox - delta , Astrobee . JOINT_POS_LIMITS [ prox_idx , 0 ]), prox_idx , ) elif key == keyboard . Key . right : # Raise the distal joint self . robot . set_joint_angles ( min ( cur_dist + delta , Astrobee . JOINT_POS_LIMITS [ dist_idx , 1 ]), dist_idx , ) elif key == keyboard . Key . left : # Lower the distal joint self . robot . set_joint_angles ( max ( cur_dist - delta , Astrobee . JOINT_POS_LIMITS [ dist_idx , 0 ]), dist_idx , ) def step ( self ): \"\"\"Updates one step of the simulation\"\"\" pybullet . stepSimulation () if self . pov : # Update the camera view so we maintain our same perspective on the robot as it moves pybullet . resetDebugVisualizerCamera ( * get_viz_camera_params ( self . robot . tmat )) time . sleep ( self . dt ) def run ( self ): \"\"\"Runs the simulation loop with the keyboard listener active\"\"\" if not self . is_listening : self . start_listening () try : while True : self . step () finally : self . listener . stop () def _main (): pybullet . connect ( pybullet . GUI ) # Turn off additional GUI windows pybullet . configureDebugVisualizer ( pybullet . COV_ENABLE_GUI , False ) iss = ISS ( debug = False ) robot = Astrobee () robot . store_arm ( force = True ) controller = KeyboardController ( robot , pov = True ) controller . run () if __name__ == \"__main__\" : _main () Classes KeyboardController class KeyboardController ( robot : pyastrobee . core . astrobee . Astrobee , pov : bool = True ) Class to encompass the keyboard listening and corresponding robot actions Attributes Name Type Description Default robot Astrobee The Astrobee to control None pov bool Whether to use a \"third person point of view\" perspective that follows the robot around. Defaults to True. None View Source class KeyboardController : \"\"\"Class to encompass the keyboard listening and corresponding robot actions Args: robot (Astrobee): The Astrobee to control pov (bool, optional): Whether to use a \" third person point of view \" perspective that follows the robot around. Defaults to True. \"\"\" def __init__ ( self , robot : Astrobee , pov : bool = True ) : if not pybullet . isConnected () : raise ConnectionError ( \"Connect to pybullet before starting the keyboard controller\" ) # Disable keyboard shortcuts in pybullet so it doesn 't do anything weird while we' re controlling it pybullet . configureDebugVisualizer ( pybullet . COV_ENABLE_KEYBOARD_SHORTCUTS , 0 ) self . robot = robot self . pov = pov self . gripper_is_open = robot . gripper_position >= 90 # Copying over the original constraint from the Astrobee class ( and the position controller ) # TODO remove this when we switch over to velocity control for this controller self . constraint_id = pybullet . createConstraint ( self . robot . id , - 1 , - 1 , - 1 , pybullet . JOINT_FIXED , None , ( 0 , 0 , 0 ), ( 0 , 0 , 0 ) ) self . dx = 0.05 # m self . dy = 0.05 # m self . dz = 0.05 # m self . droll = 0.05 # rad self . dpitch = 0.05 # rad self . dyaw = 0.05 # rad self . djoint = 0.05 # rad # Configuration for non - position / angular control keys self . frame_switch_key = keyboard . Key . space self . exit_key = keyboard . Key . esc self . gripper_key = keyboard . KeyCode . from_char ( \"g\" ) self . waypoint_key = keyboard . KeyCode . from_char ( \"p\" ) self . coarse_control_key = keyboard . KeyCode . from_char ( \"c\" ) self . arm_keys = { keyboard . Key . up , keyboard . Key . down , keyboard . Key . right , keyboard . Key . left , } # Coarse control multiplier self . mult = 5 # States self . in_robot_frame = False self . in_coarse_mode = False # Initialize listener , update when listener started self . listener : keyboard . Listener = None # Timestep self . dt = pybullet . getPhysicsEngineParameters () [ \"fixedTimeStep\" ] # Having this in position / Euler can be more interpretable than position / quaternion # Also , it is easier to scale Euler angles than quaternions for coarse control # ( multiplying a quaternion by a constant won 't change the rotation it represents) self.pos_euler_deltas_lowercase = { \"w\": np.array([self.dx, 0, 0, 0, 0, 0]), \"s\": np.array([-self.dx, 0, 0, 0, 0, 0]), \"a\": np.array([0, self.dy, 0, 0, 0, 0]), \"d\": np.array([0, -self.dy, 0, 0, 0, 0]), \"e\": np.array([0, 0, self.dz, 0, 0, 0]), \"q\": np.array([0, 0, -self.dz, 0, 0, 0]), \"l\": np.array([0, 0, 0, self.droll, 0, 0]), \"j\": np.array([0, 0, 0, -self.droll, 0, 0]), \"i\": np.array([0, 0, 0, 0, self.dpitch, 0]), \"k\": np.array([0, 0, 0, 0, -self.dpitch, 0]), \"u\": np.array([0, 0, 0, 0, 0, self.dyaw]), \"o\": np.array([0, 0, 0, 0, 0, -self.dyaw]), } # Change the keys to be in pynput Key format, and add coarse control for uppercase letters self.pose_deltas = {} for key, delta in self.pos_euler_deltas_lowercase.items(): self.pose_deltas[keyboard.KeyCode.from_char(key)] = ( pos_euler_xyz_to_pos_quat(delta) ) self.pose_deltas[keyboard.KeyCode.from_char(key.upper())] = ( pos_euler_xyz_to_pos_quat(self.mult * delta) ) def _print_commands(self): \"\"\"Prints the keyboard/control action mapping information\"\"\" print( \"Commands:\\n\" + \"w/s: +/- x\\n\" + \"a/d: +/- y\\n\" + \"e/q: +/- z\\n\" + \"l/j: +/- roll\\n\" + \"i/k: +/- pitch\\n\" + \"u/o: +/- yaw\\n\" + \"Capital letters: Coarse control of position/orientation\\n\" + \"up/down: +/- arm proximal joint angle\\n\" + \"right/left: +/- arm distal joint angle\\n\" + \"c: Toggle coarse control for the arm\\n\" + \"g: Open/close the gripper\\n\" + \"p: Record a pose\\n\" + \"Space: Switch reference frames\\n\" + \"Esc: Stop listening\" ) def start_listening(self): \"\"\"Starts the keyboard listener in a new thread\"\"\" print_green(\"Now listening\") self._print_commands() self.listener = keyboard.Listener( on_press=self.on_press, on_release=self.on_release ) self.listener.start() @property def is_listening(self) -> bool: \"\"\"Whether or not the pynput Listener has been initialized\"\"\" return self.listener is not None def on_press(self, key: keyboard.Key): \"\"\"Callback for a keypress Args: key (Key): Key that was pressed Returns: bool: False when the \"stop listening\" key (Esc) is pressed \"\"\" if key == keyboard.Key.esc: print_red(\"\\nLISTENER STOPPED\") print(\"Simulation will remain active until killed\") return False # Returning false from a callback stops pynput def on_release(self, key: keyboard.Key): \"\"\"Callback for when a key is released Args: key (Key): Key that was pressed \"\"\" # If the key is associated with a motion, if key in self.pose_deltas: init_pose = self.robot.pose # Get the pose delta that key is associated with pose_delta = self.pose_deltas[key] if self.in_robot_frame: new_pose = add_local_pose_delta(init_pose, pose_delta) pybullet.changeConstraint( self.constraint_id, new_pose[:3], new_pose[3:] ) else: new_pose = add_global_pose_delta(init_pose, pose_delta) pybullet.changeConstraint( self.constraint_id, new_pose[:3], new_pose[3:] ) elif key == self.frame_switch_key: # Toggle the reference frame and update our knowledge of the state self.in_robot_frame = not self.in_robot_frame print( f\"\\nFRAME SWITCHED. Now in {' robot ' if self.in_robot_frame else ' world '} frame\" ) elif key == self.gripper_key: # Toggle the gripper and update our knowledge of the state if self.gripper_is_open: self.robot.close_gripper() self.gripper_is_open = False else: self.robot.open_gripper() self.gripper_is_open = True print(f\"\\nGRIPPER {' OPENED ' if self.gripper_is_open else ' CLOSED '}\") elif key == self.waypoint_key: # Record a waypoint and print the info to the terminal print(f\"\\nPose recorded: {self.robot.pose}\") print(f\"Gripper position: {self.robot.gripper_position}\") print(f\"Arm joints: {self.robot.arm_joint_angles}\") elif key == self.coarse_control_key: # Toggle coarse control mode self.in_coarse_mode = not self.in_coarse_mode print( f\"\\nCoarse control {' ACTIVATED ' if self.in_coarse_mode else ' DEACTIVATED '} \" ) elif key in self.arm_keys: cur_prox, cur_dist = self.robot.arm_joint_angles prox_idx, dist_idx = self.robot.ARM_JOINT_IDXS delta = self.djoint * (self.mult if self.in_coarse_mode else 1) if key == keyboard.Key.up: # Raise the proximal joint self.robot.set_joint_angles( min(cur_prox + delta, Astrobee.JOINT_POS_LIMITS[prox_idx, 1]), prox_idx, ) elif key == keyboard.Key.down: # Lower the proximal joint self.robot.set_joint_angles( max(cur_prox - delta, Astrobee.JOINT_POS_LIMITS[prox_idx, 0]), prox_idx, ) elif key == keyboard.Key.right: # Raise the distal joint self.robot.set_joint_angles( min(cur_dist + delta, Astrobee.JOINT_POS_LIMITS[dist_idx, 1]), dist_idx, ) elif key == keyboard.Key.left: # Lower the distal joint self.robot.set_joint_angles( max(cur_dist - delta, Astrobee.JOINT_POS_LIMITS[dist_idx, 0]), dist_idx, ) def step(self): \"\"\" Updates one step of the simulation \"\"\" pybullet.stepSimulation() if self.pov: # Update the camera view so we maintain our same perspective on the robot as it moves pybullet.resetDebugVisualizerCamera(*get_viz_camera_params(self.robot.tmat)) time.sleep(self.dt) def run(self): \"\"\" Runs the simulation loop with the keyboard listener active \"\" \" if not self . is_listening : self . start_listening () try : while True : self . step () finally : self . listener . stop () Instance variables is_listening Whether or not the pynput Listener has been initialized Methods on_press def on_press ( self , key : pynput . keyboard . _xorg . Key ) Callback for a keypress Parameters: Name Type Description Default key Key Key that was pressed None Returns: Type Description bool False when the \"stop listening\" key (Esc) is pressed View Source def on_press(self, key: keyboard.Key): \"\"\"Callback for a keypress Args: key (Key): Key that was pressed Returns: bool: False when the \"stop listening\" key (Esc) is pressed \"\"\" if key == keyboard.Key.esc: print_red(\"\\nLISTENER STOPPED\") print(\"Simulation will remain active until killed\") return False # Returning false from a callback stops pynput on_release def on_release ( self , key : pynput . keyboard . _xorg . Key ) Callback for when a key is released Parameters: Name Type Description Default key Key Key that was pressed None View Source def on_release ( self , key : keyboard . Key ) : \"\"\"Callback for when a key is released Args: key (Key): Key that was pressed \"\"\" # If the key is associated with a motion , if key in self . pose_deltas : init_pose = self . robot . pose # Get the pose delta that key is associated with pose_delta = self . pose_deltas [ key ] if self . in_robot_frame : new_pose = add_local_pose_delta ( init_pose , pose_delta ) pybullet . changeConstraint ( self . constraint_id , new_pose [ :3 ] , new_pose [ 3: ] ) else : new_pose = add_global_pose_delta ( init_pose , pose_delta ) pybullet . changeConstraint ( self . constraint_id , new_pose [ :3 ] , new_pose [ 3: ] ) elif key == self . frame_switch_key : # Toggle the reference frame and update our knowledge of the state self . in_robot_frame = not self . in_robot_frame print ( f \"\\nFRAME SWITCHED. Now in {'robot' if self.in_robot_frame else 'world'} frame\" ) elif key == self . gripper_key : # Toggle the gripper and update our knowledge of the state if self . gripper_is_open : self . robot . close_gripper () self . gripper_is_open = False else : self . robot . open_gripper () self . gripper_is_open = True print ( f \"\\nGRIPPER {'OPENED' if self.gripper_is_open else 'CLOSED'}\" ) elif key == self . waypoint_key : # Record a waypoint and print the info to the terminal print ( f \"\\nPose recorded: {self.robot.pose}\" ) print ( f \"Gripper position: {self.robot.gripper_position}\" ) print ( f \"Arm joints: {self.robot.arm_joint_angles}\" ) elif key == self . coarse_control_key : # Toggle coarse control mode self . in_coarse_mode = not self . in_coarse_mode print ( f \"\\nCoarse control {'ACTIVATED' if self.in_coarse_mode else 'DEACTIVATED'}\" ) elif key in self . arm_keys : cur_prox , cur_dist = self . robot . arm_joint_angles prox_idx , dist_idx = self . robot . ARM_JOINT_IDXS delta = self . djoint * ( self . mult if self . in_coarse_mode else 1 ) if key == keyboard . Key . up : # Raise the proximal joint self . robot . set_joint_angles ( min ( cur_prox + delta , Astrobee . JOINT_POS_LIMITS [ prox_idx, 1 ] ), prox_idx , ) elif key == keyboard . Key . down : # Lower the proximal joint self . robot . set_joint_angles ( max ( cur_prox - delta , Astrobee . JOINT_POS_LIMITS [ prox_idx, 0 ] ), prox_idx , ) elif key == keyboard . Key . right : # Raise the distal joint self . robot . set_joint_angles ( min ( cur_dist + delta , Astrobee . JOINT_POS_LIMITS [ dist_idx, 1 ] ), dist_idx , ) elif key == keyboard . Key . left : # Lower the distal joint self . robot . set_joint_angles ( max ( cur_dist - delta , Astrobee . JOINT_POS_LIMITS [ dist_idx, 0 ] ), dist_idx , ) run def run ( self ) Runs the simulation loop with the keyboard listener active View Source def run(self): \"\"\"Runs the simulation loop with the keyboard listener active\"\"\" if not self.is_listening: self.start_listening() try: while True: self.step() finally: self.listener.stop() start_listening def start_listening ( self ) Starts the keyboard listener in a new thread View Source def start_listening(self): \"\"\"Starts the keyboard listener in a new thread\"\"\" print_green(\"Now listening\") self._print_commands() self.listener = keyboard.Listener( on_press=self.on_press, on_release=self.on_release ) self.listener.start() step def step ( self ) Updates one step of the simulation View Source def step ( self ) : \"\" \"Updates one step of the simulation\" \"\" pybullet . stepSimulation () if self . pov : # Update the camera view so we maintain our same perspective on the robot as it moves pybullet . resetDebugVisualizerCamera ( * get_viz_camera_params ( self . robot . tmat )) time . sleep ( self . dt )","title":"Keyboard Controller"},{"location":"reference/pyastrobee/control/keyboard_controller/#module-pyastrobeecontrolkeyboard_controller","text":"Class/script for controlling the Astrobee via keyboard presses Usage: - Positional control via WASDQE - w: +x - s: -x - a: +y - d: -y - e: +z - q: -z - Angular control via IJKLUO - l: + roll - j: - roll - i: + pitch - k: - pitch - u: + yaw - o: - yaw - Arm control via arrow keys - Up: + proximal angle - Down: - proximal angle - Right: + distal angle - Left: - distal angle - Toggle opening/closing the gripper with G - Record a waypoint with P - Coarse control of position/orientation with capital letters (via Shift) - Coarse control of the arm positioning via C - Press Space to switch reference frames (global <=> robot) - Press Esc to exit Motions are only recorded on a button release to prevent over-queueing actions View Source \"\"\"Class/script for controlling the Astrobee via keyboard presses Usage: - Positional control via WASDQE - w: +x - s: -x - a: +y - d: -y - e: +z - q: -z - Angular control via IJKLUO - l: + roll - j: - roll - i: + pitch - k: - pitch - u: + yaw - o: - yaw - Arm control via arrow keys - Up: + proximal angle - Down: - proximal angle - Right: + distal angle - Left: - distal angle - Toggle opening/closing the gripper with G - Record a waypoint with P - Coarse control of position/orientation with capital letters (via Shift) - Coarse control of the arm positioning via C - Press Space to switch reference frames (global <=> robot) - Press Esc to exit Motions are only recorded on a button release to prevent over-queueing actions \"\"\" import time import numpy as np import pybullet from pynput import keyboard from pyastrobee.core.astrobee import Astrobee from pyastrobee.utils.poses import ( pos_euler_xyz_to_pos_quat , add_local_pose_delta , add_global_pose_delta , ) from pyastrobee.core.iss import ISS from pyastrobee.utils.debug_visualizer import get_viz_camera_params from pyastrobee.utils.python_utils import print_green , print_red class KeyboardController : \"\"\"Class to encompass the keyboard listening and corresponding robot actions Args: robot (Astrobee): The Astrobee to control pov (bool, optional): Whether to use a \"third person point of view\" perspective that follows the robot around. Defaults to True. \"\"\" def __init__ ( self , robot : Astrobee , pov : bool = True ): if not pybullet . isConnected (): raise ConnectionError ( \"Connect to pybullet before starting the keyboard controller\" ) # Disable keyboard shortcuts in pybullet so it doesn't do anything weird while we're controlling it pybullet . configureDebugVisualizer ( pybullet . COV_ENABLE_KEYBOARD_SHORTCUTS , 0 ) self . robot = robot self . pov = pov self . gripper_is_open = robot . gripper_position >= 90 # Copying over the original constraint from the Astrobee class (and the position controller) # TODO remove this when we switch over to velocity control for this controller self . constraint_id = pybullet . createConstraint ( self . robot . id , - 1 , - 1 , - 1 , pybullet . JOINT_FIXED , None , ( 0 , 0 , 0 ), ( 0 , 0 , 0 ) ) self . dx = 0.05 # m self . dy = 0.05 # m self . dz = 0.05 # m self . droll = 0.05 # rad self . dpitch = 0.05 # rad self . dyaw = 0.05 # rad self . djoint = 0.05 # rad # Configuration for non-position/angular control keys self . frame_switch_key = keyboard . Key . space self . exit_key = keyboard . Key . esc self . gripper_key = keyboard . KeyCode . from_char ( \"g\" ) self . waypoint_key = keyboard . KeyCode . from_char ( \"p\" ) self . coarse_control_key = keyboard . KeyCode . from_char ( \"c\" ) self . arm_keys = { keyboard . Key . up , keyboard . Key . down , keyboard . Key . right , keyboard . Key . left , } # Coarse control multiplier self . mult = 5 # States self . in_robot_frame = False self . in_coarse_mode = False # Initialize listener, update when listener started self . listener : keyboard . Listener = None # Timestep self . dt = pybullet . getPhysicsEngineParameters ()[ \"fixedTimeStep\" ] # Having this in position/Euler can be more interpretable than position/quaternion # Also, it is easier to scale Euler angles than quaternions for coarse control # (multiplying a quaternion by a constant won't change the rotation it represents) self . pos_euler_deltas_lowercase = { \"w\" : np . array ([ self . dx , 0 , 0 , 0 , 0 , 0 ]), \"s\" : np . array ([ - self . dx , 0 , 0 , 0 , 0 , 0 ]), \"a\" : np . array ([ 0 , self . dy , 0 , 0 , 0 , 0 ]), \"d\" : np . array ([ 0 , - self . dy , 0 , 0 , 0 , 0 ]), \"e\" : np . array ([ 0 , 0 , self . dz , 0 , 0 , 0 ]), \"q\" : np . array ([ 0 , 0 , - self . dz , 0 , 0 , 0 ]), \"l\" : np . array ([ 0 , 0 , 0 , self . droll , 0 , 0 ]), \"j\" : np . array ([ 0 , 0 , 0 , - self . droll , 0 , 0 ]), \"i\" : np . array ([ 0 , 0 , 0 , 0 , self . dpitch , 0 ]), \"k\" : np . array ([ 0 , 0 , 0 , 0 , - self . dpitch , 0 ]), \"u\" : np . array ([ 0 , 0 , 0 , 0 , 0 , self . dyaw ]), \"o\" : np . array ([ 0 , 0 , 0 , 0 , 0 , - self . dyaw ]), } # Change the keys to be in pynput Key format, and add coarse control for uppercase letters self . pose_deltas = {} for key , delta in self . pos_euler_deltas_lowercase . items (): self . pose_deltas [ keyboard . KeyCode . from_char ( key )] = ( pos_euler_xyz_to_pos_quat ( delta ) ) self . pose_deltas [ keyboard . KeyCode . from_char ( key . upper ())] = ( pos_euler_xyz_to_pos_quat ( self . mult * delta ) ) def _print_commands ( self ): \"\"\"Prints the keyboard/control action mapping information\"\"\" print ( \"Commands: \\n \" + \"w/s: +/- x \\n \" + \"a/d: +/- y \\n \" + \"e/q: +/- z \\n \" + \"l/j: +/- roll \\n \" + \"i/k: +/- pitch \\n \" + \"u/o: +/- yaw \\n \" + \"Capital letters: Coarse control of position/orientation \\n \" + \"up/down: +/- arm proximal joint angle \\n \" + \"right/left: +/- arm distal joint angle \\n \" + \"c: Toggle coarse control for the arm \\n \" + \"g: Open/close the gripper \\n \" + \"p: Record a pose \\n \" + \"Space: Switch reference frames \\n \" + \"Esc: Stop listening\" ) def start_listening ( self ): \"\"\"Starts the keyboard listener in a new thread\"\"\" print_green ( \"Now listening\" ) self . _print_commands () self . listener = keyboard . Listener ( on_press = self . on_press , on_release = self . on_release ) self . listener . start () @property def is_listening ( self ) -> bool : \"\"\"Whether or not the pynput Listener has been initialized\"\"\" return self . listener is not None def on_press ( self , key : keyboard . Key ): \"\"\"Callback for a keypress Args: key (Key): Key that was pressed Returns: bool: False when the \"stop listening\" key (Esc) is pressed \"\"\" if key == keyboard . Key . esc : print_red ( \" \\n LISTENER STOPPED\" ) print ( \"Simulation will remain active until killed\" ) return False # Returning false from a callback stops pynput def on_release ( self , key : keyboard . Key ): \"\"\"Callback for when a key is released Args: key (Key): Key that was pressed \"\"\" # If the key is associated with a motion, if key in self . pose_deltas : init_pose = self . robot . pose # Get the pose delta that key is associated with pose_delta = self . pose_deltas [ key ] if self . in_robot_frame : new_pose = add_local_pose_delta ( init_pose , pose_delta ) pybullet . changeConstraint ( self . constraint_id , new_pose [: 3 ], new_pose [ 3 :] ) else : new_pose = add_global_pose_delta ( init_pose , pose_delta ) pybullet . changeConstraint ( self . constraint_id , new_pose [: 3 ], new_pose [ 3 :] ) elif key == self . frame_switch_key : # Toggle the reference frame and update our knowledge of the state self . in_robot_frame = not self . in_robot_frame print ( f \" \\n FRAME SWITCHED. Now in { 'robot' if self . in_robot_frame else 'world' } frame\" ) elif key == self . gripper_key : # Toggle the gripper and update our knowledge of the state if self . gripper_is_open : self . robot . close_gripper () self . gripper_is_open = False else : self . robot . open_gripper () self . gripper_is_open = True print ( f \" \\n GRIPPER { 'OPENED' if self . gripper_is_open else 'CLOSED' } \" ) elif key == self . waypoint_key : # Record a waypoint and print the info to the terminal print ( f \" \\n Pose recorded: { self . robot . pose } \" ) print ( f \"Gripper position: { self . robot . gripper_position } \" ) print ( f \"Arm joints: { self . robot . arm_joint_angles } \" ) elif key == self . coarse_control_key : # Toggle coarse control mode self . in_coarse_mode = not self . in_coarse_mode print ( f \" \\n Coarse control { 'ACTIVATED' if self . in_coarse_mode else 'DEACTIVATED' } \" ) elif key in self . arm_keys : cur_prox , cur_dist = self . robot . arm_joint_angles prox_idx , dist_idx = self . robot . ARM_JOINT_IDXS delta = self . djoint * ( self . mult if self . in_coarse_mode else 1 ) if key == keyboard . Key . up : # Raise the proximal joint self . robot . set_joint_angles ( min ( cur_prox + delta , Astrobee . JOINT_POS_LIMITS [ prox_idx , 1 ]), prox_idx , ) elif key == keyboard . Key . down : # Lower the proximal joint self . robot . set_joint_angles ( max ( cur_prox - delta , Astrobee . JOINT_POS_LIMITS [ prox_idx , 0 ]), prox_idx , ) elif key == keyboard . Key . right : # Raise the distal joint self . robot . set_joint_angles ( min ( cur_dist + delta , Astrobee . JOINT_POS_LIMITS [ dist_idx , 1 ]), dist_idx , ) elif key == keyboard . Key . left : # Lower the distal joint self . robot . set_joint_angles ( max ( cur_dist - delta , Astrobee . JOINT_POS_LIMITS [ dist_idx , 0 ]), dist_idx , ) def step ( self ): \"\"\"Updates one step of the simulation\"\"\" pybullet . stepSimulation () if self . pov : # Update the camera view so we maintain our same perspective on the robot as it moves pybullet . resetDebugVisualizerCamera ( * get_viz_camera_params ( self . robot . tmat )) time . sleep ( self . dt ) def run ( self ): \"\"\"Runs the simulation loop with the keyboard listener active\"\"\" if not self . is_listening : self . start_listening () try : while True : self . step () finally : self . listener . stop () def _main (): pybullet . connect ( pybullet . GUI ) # Turn off additional GUI windows pybullet . configureDebugVisualizer ( pybullet . COV_ENABLE_GUI , False ) iss = ISS ( debug = False ) robot = Astrobee () robot . store_arm ( force = True ) controller = KeyboardController ( robot , pov = True ) controller . run () if __name__ == \"__main__\" : _main ()","title":"Module pyastrobee.control.keyboard_controller"},{"location":"reference/pyastrobee/control/keyboard_controller/#classes","text":"","title":"Classes"},{"location":"reference/pyastrobee/control/keyboard_controller/#keyboardcontroller","text":"class KeyboardController ( robot : pyastrobee . core . astrobee . Astrobee , pov : bool = True ) Class to encompass the keyboard listening and corresponding robot actions","title":"KeyboardController"},{"location":"reference/pyastrobee/control/keyboard_controller/#attributes","text":"Name Type Description Default robot Astrobee The Astrobee to control None pov bool Whether to use a \"third person point of view\" perspective that follows the robot around. Defaults to True. None View Source class KeyboardController : \"\"\"Class to encompass the keyboard listening and corresponding robot actions Args: robot (Astrobee): The Astrobee to control pov (bool, optional): Whether to use a \" third person point of view \" perspective that follows the robot around. Defaults to True. \"\"\" def __init__ ( self , robot : Astrobee , pov : bool = True ) : if not pybullet . isConnected () : raise ConnectionError ( \"Connect to pybullet before starting the keyboard controller\" ) # Disable keyboard shortcuts in pybullet so it doesn 't do anything weird while we' re controlling it pybullet . configureDebugVisualizer ( pybullet . COV_ENABLE_KEYBOARD_SHORTCUTS , 0 ) self . robot = robot self . pov = pov self . gripper_is_open = robot . gripper_position >= 90 # Copying over the original constraint from the Astrobee class ( and the position controller ) # TODO remove this when we switch over to velocity control for this controller self . constraint_id = pybullet . createConstraint ( self . robot . id , - 1 , - 1 , - 1 , pybullet . JOINT_FIXED , None , ( 0 , 0 , 0 ), ( 0 , 0 , 0 ) ) self . dx = 0.05 # m self . dy = 0.05 # m self . dz = 0.05 # m self . droll = 0.05 # rad self . dpitch = 0.05 # rad self . dyaw = 0.05 # rad self . djoint = 0.05 # rad # Configuration for non - position / angular control keys self . frame_switch_key = keyboard . Key . space self . exit_key = keyboard . Key . esc self . gripper_key = keyboard . KeyCode . from_char ( \"g\" ) self . waypoint_key = keyboard . KeyCode . from_char ( \"p\" ) self . coarse_control_key = keyboard . KeyCode . from_char ( \"c\" ) self . arm_keys = { keyboard . Key . up , keyboard . Key . down , keyboard . Key . right , keyboard . Key . left , } # Coarse control multiplier self . mult = 5 # States self . in_robot_frame = False self . in_coarse_mode = False # Initialize listener , update when listener started self . listener : keyboard . Listener = None # Timestep self . dt = pybullet . getPhysicsEngineParameters () [ \"fixedTimeStep\" ] # Having this in position / Euler can be more interpretable than position / quaternion # Also , it is easier to scale Euler angles than quaternions for coarse control # ( multiplying a quaternion by a constant won 't change the rotation it represents) self.pos_euler_deltas_lowercase = { \"w\": np.array([self.dx, 0, 0, 0, 0, 0]), \"s\": np.array([-self.dx, 0, 0, 0, 0, 0]), \"a\": np.array([0, self.dy, 0, 0, 0, 0]), \"d\": np.array([0, -self.dy, 0, 0, 0, 0]), \"e\": np.array([0, 0, self.dz, 0, 0, 0]), \"q\": np.array([0, 0, -self.dz, 0, 0, 0]), \"l\": np.array([0, 0, 0, self.droll, 0, 0]), \"j\": np.array([0, 0, 0, -self.droll, 0, 0]), \"i\": np.array([0, 0, 0, 0, self.dpitch, 0]), \"k\": np.array([0, 0, 0, 0, -self.dpitch, 0]), \"u\": np.array([0, 0, 0, 0, 0, self.dyaw]), \"o\": np.array([0, 0, 0, 0, 0, -self.dyaw]), } # Change the keys to be in pynput Key format, and add coarse control for uppercase letters self.pose_deltas = {} for key, delta in self.pos_euler_deltas_lowercase.items(): self.pose_deltas[keyboard.KeyCode.from_char(key)] = ( pos_euler_xyz_to_pos_quat(delta) ) self.pose_deltas[keyboard.KeyCode.from_char(key.upper())] = ( pos_euler_xyz_to_pos_quat(self.mult * delta) ) def _print_commands(self): \"\"\"Prints the keyboard/control action mapping information\"\"\" print( \"Commands:\\n\" + \"w/s: +/- x\\n\" + \"a/d: +/- y\\n\" + \"e/q: +/- z\\n\" + \"l/j: +/- roll\\n\" + \"i/k: +/- pitch\\n\" + \"u/o: +/- yaw\\n\" + \"Capital letters: Coarse control of position/orientation\\n\" + \"up/down: +/- arm proximal joint angle\\n\" + \"right/left: +/- arm distal joint angle\\n\" + \"c: Toggle coarse control for the arm\\n\" + \"g: Open/close the gripper\\n\" + \"p: Record a pose\\n\" + \"Space: Switch reference frames\\n\" + \"Esc: Stop listening\" ) def start_listening(self): \"\"\"Starts the keyboard listener in a new thread\"\"\" print_green(\"Now listening\") self._print_commands() self.listener = keyboard.Listener( on_press=self.on_press, on_release=self.on_release ) self.listener.start() @property def is_listening(self) -> bool: \"\"\"Whether or not the pynput Listener has been initialized\"\"\" return self.listener is not None def on_press(self, key: keyboard.Key): \"\"\"Callback for a keypress Args: key (Key): Key that was pressed Returns: bool: False when the \"stop listening\" key (Esc) is pressed \"\"\" if key == keyboard.Key.esc: print_red(\"\\nLISTENER STOPPED\") print(\"Simulation will remain active until killed\") return False # Returning false from a callback stops pynput def on_release(self, key: keyboard.Key): \"\"\"Callback for when a key is released Args: key (Key): Key that was pressed \"\"\" # If the key is associated with a motion, if key in self.pose_deltas: init_pose = self.robot.pose # Get the pose delta that key is associated with pose_delta = self.pose_deltas[key] if self.in_robot_frame: new_pose = add_local_pose_delta(init_pose, pose_delta) pybullet.changeConstraint( self.constraint_id, new_pose[:3], new_pose[3:] ) else: new_pose = add_global_pose_delta(init_pose, pose_delta) pybullet.changeConstraint( self.constraint_id, new_pose[:3], new_pose[3:] ) elif key == self.frame_switch_key: # Toggle the reference frame and update our knowledge of the state self.in_robot_frame = not self.in_robot_frame print( f\"\\nFRAME SWITCHED. Now in {' robot ' if self.in_robot_frame else ' world '} frame\" ) elif key == self.gripper_key: # Toggle the gripper and update our knowledge of the state if self.gripper_is_open: self.robot.close_gripper() self.gripper_is_open = False else: self.robot.open_gripper() self.gripper_is_open = True print(f\"\\nGRIPPER {' OPENED ' if self.gripper_is_open else ' CLOSED '}\") elif key == self.waypoint_key: # Record a waypoint and print the info to the terminal print(f\"\\nPose recorded: {self.robot.pose}\") print(f\"Gripper position: {self.robot.gripper_position}\") print(f\"Arm joints: {self.robot.arm_joint_angles}\") elif key == self.coarse_control_key: # Toggle coarse control mode self.in_coarse_mode = not self.in_coarse_mode print( f\"\\nCoarse control {' ACTIVATED ' if self.in_coarse_mode else ' DEACTIVATED '} \" ) elif key in self.arm_keys: cur_prox, cur_dist = self.robot.arm_joint_angles prox_idx, dist_idx = self.robot.ARM_JOINT_IDXS delta = self.djoint * (self.mult if self.in_coarse_mode else 1) if key == keyboard.Key.up: # Raise the proximal joint self.robot.set_joint_angles( min(cur_prox + delta, Astrobee.JOINT_POS_LIMITS[prox_idx, 1]), prox_idx, ) elif key == keyboard.Key.down: # Lower the proximal joint self.robot.set_joint_angles( max(cur_prox - delta, Astrobee.JOINT_POS_LIMITS[prox_idx, 0]), prox_idx, ) elif key == keyboard.Key.right: # Raise the distal joint self.robot.set_joint_angles( min(cur_dist + delta, Astrobee.JOINT_POS_LIMITS[dist_idx, 1]), dist_idx, ) elif key == keyboard.Key.left: # Lower the distal joint self.robot.set_joint_angles( max(cur_dist - delta, Astrobee.JOINT_POS_LIMITS[dist_idx, 0]), dist_idx, ) def step(self): \"\"\" Updates one step of the simulation \"\"\" pybullet.stepSimulation() if self.pov: # Update the camera view so we maintain our same perspective on the robot as it moves pybullet.resetDebugVisualizerCamera(*get_viz_camera_params(self.robot.tmat)) time.sleep(self.dt) def run(self): \"\"\" Runs the simulation loop with the keyboard listener active \"\" \" if not self . is_listening : self . start_listening () try : while True : self . step () finally : self . listener . stop ()","title":"Attributes"},{"location":"reference/pyastrobee/control/keyboard_controller/#instance-variables","text":"is_listening Whether or not the pynput Listener has been initialized","title":"Instance variables"},{"location":"reference/pyastrobee/control/keyboard_controller/#methods","text":"","title":"Methods"},{"location":"reference/pyastrobee/control/keyboard_controller/#on_press","text":"def on_press ( self , key : pynput . keyboard . _xorg . Key ) Callback for a keypress Parameters: Name Type Description Default key Key Key that was pressed None Returns: Type Description bool False when the \"stop listening\" key (Esc) is pressed View Source def on_press(self, key: keyboard.Key): \"\"\"Callback for a keypress Args: key (Key): Key that was pressed Returns: bool: False when the \"stop listening\" key (Esc) is pressed \"\"\" if key == keyboard.Key.esc: print_red(\"\\nLISTENER STOPPED\") print(\"Simulation will remain active until killed\") return False # Returning false from a callback stops pynput","title":"on_press"},{"location":"reference/pyastrobee/control/keyboard_controller/#on_release","text":"def on_release ( self , key : pynput . keyboard . _xorg . Key ) Callback for when a key is released Parameters: Name Type Description Default key Key Key that was pressed None View Source def on_release ( self , key : keyboard . Key ) : \"\"\"Callback for when a key is released Args: key (Key): Key that was pressed \"\"\" # If the key is associated with a motion , if key in self . pose_deltas : init_pose = self . robot . pose # Get the pose delta that key is associated with pose_delta = self . pose_deltas [ key ] if self . in_robot_frame : new_pose = add_local_pose_delta ( init_pose , pose_delta ) pybullet . changeConstraint ( self . constraint_id , new_pose [ :3 ] , new_pose [ 3: ] ) else : new_pose = add_global_pose_delta ( init_pose , pose_delta ) pybullet . changeConstraint ( self . constraint_id , new_pose [ :3 ] , new_pose [ 3: ] ) elif key == self . frame_switch_key : # Toggle the reference frame and update our knowledge of the state self . in_robot_frame = not self . in_robot_frame print ( f \"\\nFRAME SWITCHED. Now in {'robot' if self.in_robot_frame else 'world'} frame\" ) elif key == self . gripper_key : # Toggle the gripper and update our knowledge of the state if self . gripper_is_open : self . robot . close_gripper () self . gripper_is_open = False else : self . robot . open_gripper () self . gripper_is_open = True print ( f \"\\nGRIPPER {'OPENED' if self.gripper_is_open else 'CLOSED'}\" ) elif key == self . waypoint_key : # Record a waypoint and print the info to the terminal print ( f \"\\nPose recorded: {self.robot.pose}\" ) print ( f \"Gripper position: {self.robot.gripper_position}\" ) print ( f \"Arm joints: {self.robot.arm_joint_angles}\" ) elif key == self . coarse_control_key : # Toggle coarse control mode self . in_coarse_mode = not self . in_coarse_mode print ( f \"\\nCoarse control {'ACTIVATED' if self.in_coarse_mode else 'DEACTIVATED'}\" ) elif key in self . arm_keys : cur_prox , cur_dist = self . robot . arm_joint_angles prox_idx , dist_idx = self . robot . ARM_JOINT_IDXS delta = self . djoint * ( self . mult if self . in_coarse_mode else 1 ) if key == keyboard . Key . up : # Raise the proximal joint self . robot . set_joint_angles ( min ( cur_prox + delta , Astrobee . JOINT_POS_LIMITS [ prox_idx, 1 ] ), prox_idx , ) elif key == keyboard . Key . down : # Lower the proximal joint self . robot . set_joint_angles ( max ( cur_prox - delta , Astrobee . JOINT_POS_LIMITS [ prox_idx, 0 ] ), prox_idx , ) elif key == keyboard . Key . right : # Raise the distal joint self . robot . set_joint_angles ( min ( cur_dist + delta , Astrobee . JOINT_POS_LIMITS [ dist_idx, 1 ] ), dist_idx , ) elif key == keyboard . Key . left : # Lower the distal joint self . robot . set_joint_angles ( max ( cur_dist - delta , Astrobee . JOINT_POS_LIMITS [ dist_idx, 0 ] ), dist_idx , )","title":"on_release"},{"location":"reference/pyastrobee/control/keyboard_controller/#run","text":"def run ( self ) Runs the simulation loop with the keyboard listener active View Source def run(self): \"\"\"Runs the simulation loop with the keyboard listener active\"\"\" if not self.is_listening: self.start_listening() try: while True: self.step() finally: self.listener.stop()","title":"run"},{"location":"reference/pyastrobee/control/keyboard_controller/#start_listening","text":"def start_listening ( self ) Starts the keyboard listener in a new thread View Source def start_listening(self): \"\"\"Starts the keyboard listener in a new thread\"\"\" print_green(\"Now listening\") self._print_commands() self.listener = keyboard.Listener( on_press=self.on_press, on_release=self.on_release ) self.listener.start()","title":"start_listening"},{"location":"reference/pyastrobee/control/keyboard_controller/#step","text":"def step ( self ) Updates one step of the simulation View Source def step ( self ) : \"\" \"Updates one step of the simulation\" \"\" pybullet . stepSimulation () if self . pov : # Update the camera view so we maintain our same perspective on the robot as it moves pybullet . resetDebugVisualizerCamera ( * get_viz_camera_params ( self . robot . tmat )) time . sleep ( self . dt )","title":"step"},{"location":"reference/pyastrobee/control/metrics/","text":"Module pyastrobee.control.metrics Simple metrics / cost functions: For defining how well we track trajectories, remain in collision-free regions, ... View Source \"\"\"Simple metrics / cost functions: For defining how well we track trajectories, remain in collision-free regions, ...\"\"\" from typing import Union , Optional import numpy as np import numpy.typing as npt import matplotlib.pyplot as plt from matplotlib import colors from pyastrobee.utils.boxes import Box , plot_2D_box , is_in_box from pyastrobee.trajectories.trajectory import Trajectory from pyastrobee.utils.quaternions import quaternion_angular_error , quaternion_dist def state_tracking_cost ( cur_pos : npt . ArrayLike , cur_orn : npt . ArrayLike , cur_vel : npt . ArrayLike , cur_ang_vel : npt . ArrayLike , des_pos : npt . ArrayLike , des_orn : npt . ArrayLike , des_vel : npt . ArrayLike , des_ang_vel : npt . ArrayLike , pos_penalty : float , orn_penalty : float , vel_penalty : float , ang_vel_penalty : float , ) -> float : \"\"\"Evaluate a cost function for deviations between the current and desired dynamics state Args: cur_pos (npt.ArrayLike): Current position, shape (3,) cur_orn (npt.ArrayLike): Current XYZW quaternion orientation, shape (4,) cur_vel (npt.ArrayLike): Current linear velocity, shape (3,) cur_ang_vel (npt.ArrayLike): Current angular velocity, shape (3,) des_pos (npt.ArrayLike): Desired position, shape (3,) des_orn (npt.ArrayLike): Desired XYZW quaternion orientation, shape (4,) des_vel (npt.ArrayLike): Desired linear velocity, shape (3,) des_ang_vel (npt.ArrayLike): Desired angular velocity, shape (3,) pos_penalty (float): Penalty scaling factor for position error orn_penalty (float): Penalty scaling factor for orientation/angular error vel_penalty (float): Penalty scaling factor for linear velocity error ang_vel_penalty (float): Penalty scaling factor for angular velocity error Returns: float: Cost function evaluation \"\"\" pos_err = np . subtract ( cur_pos , des_pos ) orn_err = quaternion_angular_error ( cur_orn , des_orn ) vel_err = np . subtract ( cur_vel , des_vel ) ang_vel_err = np . subtract ( cur_ang_vel , des_ang_vel ) # NOTE Would an L1 norm be better here? return ( pos_penalty * np . linalg . norm ( pos_err ) + orn_penalty * np . linalg . norm ( orn_err ) + vel_penalty * np . linalg . norm ( vel_err ) + ang_vel_penalty * np . linalg . norm ( ang_vel_err ) ) def traj_tracking_cost ( des_traj : Trajectory , recorded_traj : Trajectory , pos_penalty : float , orn_penalty : float , vel_penalty : float , ang_vel_penalty : float , ) -> float : \"\"\"Evaluates a state mismatch cost function over the duration of a trajectory Args: des_traj (Trajectory): Desired trajectory recorded_traj (Trajectory): Recorded trajectory pos_penalty (float): Penalty scaling factor for position error orn_penalty (float): Penalty scaling factor for orientation/angular error vel_penalty (float): Penalty scaling factor for linear velocity error ang_vel_penalty (float): Penalty scaling factor for angular velocity error Returns: float: Cost function evaluation \"\"\" assert recorded_traj . num_timesteps == des_traj . num_timesteps total_cost = 0 for i in range ( recorded_traj . num_timesteps ): total_cost += state_tracking_cost ( recorded_traj . positions [ i ], recorded_traj . quaternions [ i ], recorded_traj . linear_velocities [ i ], recorded_traj . angular_velocities [ i ], des_traj . positions [ i ], des_traj . quaternions [ i ], des_traj . linear_velocities [ i ], des_traj . angular_velocities [ i ], pos_penalty , orn_penalty , vel_penalty , ang_vel_penalty , ) return total_cost def safe_set_cost ( position : npt . ArrayLike , boxes : Union [ Box , list [ Box ]], padding : Optional [ npt . ArrayLike ] = None , collision_penalty : float = 0 , ) -> float : \"\"\"Evaluate the cost function for a given position within an environment composed of safe boxes In general, the cost function rewards being centrally located within the safe set, with the cost increasing as the position approaches the wall. Costs are negative for being inside the safe set, and positive outside (in collision). We can add an additional large penalty for being in collision, to help ensure collision avoidance This is essentially an axis-aligned L1 signed distance field Args: position (npt.ArrayLike): Position to evaluate the cost function boxes (Union[Box, list[Box]]): Local description of the safe set. This does NOT need to be every box in the environment, just the ones in the proximity of the position being evaluated padding (Optional[npt.ArrayLike]): Distance(s) to pad the safe set by (for instance, if we evaluate the central point of a spherical robot). Defaults to None. collision_penalty (float, optional): Additional penalty to increase the cost function if collision occurs. Defaults to 0. Returns: float: Cost function evaluation \"\"\" dim = len ( position ) if isinstance ( boxes , Box ): boxes = [ boxes ] # If we're padding the boxes, go through each one and reduce their size by the padding amount if padding is not None : if isinstance ( padding , ( float , int )): padding = padding * np . ones ( dim ) else : padding = np . ravel ( padding ) . astype ( np . float64 ) assert len ( padding ) == dim for i , box in enumerate ( boxes ): boxes [ i ] = Box ( box . lower + padding , box . upper - padding ) # Keep track of which boxes we're inside, since the penalty depends on if we're in the safe set or not boxes_inside : list [ Box ] = [] for box in boxes : if is_in_box ( position , box ): boxes_inside . append ( box ) # If we are not in collision, we only consider the boxes that we're inside if len ( boxes_inside ) != 0 : return sum ( max ([ * ( position - box . upper ), * ( box . lower - position )]) for box in boxes_inside ) # If we are in collision, the collision depth is based on the nearest wall, which considers all boxes else : return collision_penalty + min ( max ([ * ( position - box . upper ), * ( box . lower - position )]) for box in boxes ) def integrated_safe_set_cost ( positions : npt . ArrayLike , boxes : Union [ Box , list [ Box ]], padding : Optional [ npt . ArrayLike ] = None , collision_penalty : float = 0 , ) -> tuple [ float , bool ]: \"\"\"Evaluates the safe-set collision avoidance cost function over a sequence of positions Args: positions (npt.ArrayLike): Positions to evaluate the cost function boxes (Union[Box, list[Box]]): Local description of the safe set. This does NOT need to be every box in the environment, just the ones in the proximity of the position being evaluated padding (Optional[npt.ArrayLike]): Distance(s) to pad the safe set by (for instance, if we evaluate the central point of a spherical robot). Defaults to None. collision_penalty (float, optional): Additional penalty to increase the cost function if collision occurs. Defaults to 0. Returns: tuple[float, bool]: float: The total integrated cost function evaluation bool: Whether a collision occurred at any point in the motion \"\"\" total_cost = 0 collision_occurred = False for pos in positions : cost = safe_set_cost ( pos , boxes , padding , collision_penalty ) total_cost += cost if cost >= 0 : collision_occurred = True return total_cost , collision_occurred def robot_and_bag_termination_criteria ( robot_state : tuple [ npt . ArrayLike , ... ], bag_state : tuple [ npt . ArrayLike , ... ], desired_robot_pose : npt . ArrayLike , pos_tol : float = 0.05 , orn_tol : float = np . deg2rad ( 10 ), vel_tol : float = 0.05 , omega_tol = np . deg2rad ( 10 ), ) -> bool : \"\"\"Deterine if the robot/bag system is successfully stabilized about the desired robot pose Note: The ending pose of the bag is not super important right now, so we're neglecting it in this criteria. If this is important later on, we can add it to this Args: robot_state (tuple[npt.ArrayLike, ...]): Current dynamics state of the robot: position, orientation (XYZW quaternion), velocity, and angular velocity bag_state (tuple[npt.ArrayLike, ...]): Current dynamics state of the bag: position, orientation (XYZW quaternion), velocity, and angular velocity desired_robot_pose (npt.ArrayLike): Desired position + XYZW quaternion pose of the robot, shape (7,) pos_tol (float, optional): Absolute tolerance on position. Defaults to 0.05 (within 5 cm) orn_tol (float, optional): Absolute tolerance on orientation (via quaternion distance metric). Defaults to deg2rad(10) (approximately within a 10 degree rotation) vel_tol (float, optional): Absolute tolerance on velocity. Defaults to 0.05 (within 5 cm/s) omega_tol (float, optional): Absolute tolerance on angular velocity. Defaults to deg2rad(10) (approximately within 10 deg/s) Returns: bool: True if stabilized at the desired pose \"\"\" des_pos = desired_robot_pose [: 3 ] des_orn = desired_robot_pose [ 3 :] pos , orn , vel , ang_vel = robot_state [: 4 ] bag_vel , bag_ang_vel = bag_state [ 2 :] return ( np . linalg . norm ( pos - des_pos ) <= pos_tol and quaternion_dist ( orn , des_orn ) <= orn_tol and np . linalg . norm ( vel ) <= vel_tol and np . linalg . norm ( ang_vel ) <= omega_tol and np . linalg . norm ( bag_vel ) <= vel_tol and np . linalg . norm ( bag_ang_vel ) <= omega_tol ) def _visualize_safe_set_cost (): \"\"\"Create a 2D example of two safe-set boxes and visualize a heatmap of the penalty function\"\"\" n = 50 X , Y = np . meshgrid ( np . linspace ( - 1 , 1 , n ), np . linspace ( - 1 , 1 , n )) Z = np . empty_like ( X ) box_1 = Box ([ - 1 , - 0.5 ], [ 0.5 , 0.5 ]) box_2 = Box ([ 0 , - 1 ], [ 1 , 1 ]) plt . figure () padding = np . array ([ 0.1 , 0.1 ]) penalty = 0.5 new_boxes = [ Box ( box_1 . lower + padding , box_1 . upper - padding ), Box ( box_2 . lower + padding , box_2 . upper - padding ), ] for i in range ( n ): for j in range ( n ): Z [ i , j ] = safe_set_cost ( ( X [ i , j ], Y [ i , j ]), [ box_1 , box_2 ], padding , penalty ) # Z[i, j] = (1 if Z[i, j] >= 0 else -1) * Z[i, j] ** 2 two_slope_norm = colors . TwoSlopeNorm ( vmin = np . min ( Z ), vcenter = 0 , vmax = np . max ( Z )) heatmap = plt . pcolormesh ( X , Y , Z , cmap = \"Spectral_r\" , norm = two_slope_norm ) plot_2D_box ( box_1 , None , False , \"k--\" ) plot_2D_box ( box_2 , None , False , \"k--\" ) plot_2D_box ( new_boxes [ 0 ], None , False , \"b--\" ) plot_2D_box ( new_boxes [ 1 ], None , False , \"b--\" ) plt . colorbar ( heatmap ) plt . title ( \"Safe Set Deviation\" ) plt . xlabel ( \"X\" ) plt . ylabel ( \"Y\" ) plt . show () if __name__ == \"__main__\" : _visualize_safe_set_cost () Functions integrated_safe_set_cost def integrated_safe_set_cost ( positions : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], boxes : Union [ pyastrobee . utils . boxes . Box , list [ pyastrobee . utils . boxes . Box ]], padding : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , collision_penalty : float = 0 ) -> tuple [ float , bool ] Evaluates the safe-set collision avoidance cost function over a sequence of positions Parameters: Name Type Description Default positions npt.ArrayLike Positions to evaluate the cost function None boxes Union[Box, list[Box]] Local description of the safe set. This does NOT need to be every box in the environment, just the ones in the proximity of the position being evaluated None padding Optional[npt.ArrayLike] Distance(s) to pad the safe set by (for instance, if we evaluate the central point of a spherical robot). Defaults to None. None collision_penalty float Additional penalty to increase the cost function if collision occurs. Defaults to 0. None Returns: Type Description tuple[float, bool] float: The total integrated cost function evaluation bool: Whether a collision occurred at any point in the motion View Source def integrated_safe_set_cost ( positions : npt . ArrayLike , boxes : Union [ Box, list[Box ] ] , padding : Optional [ npt.ArrayLike ] = None , collision_penalty : float = 0 , ) -> tuple [ float, bool ] : \"\"\"Evaluates the safe-set collision avoidance cost function over a sequence of positions Args: positions (npt.ArrayLike): Positions to evaluate the cost function boxes (Union[Box, list[Box]]): Local description of the safe set. This does NOT need to be every box in the environment, just the ones in the proximity of the position being evaluated padding (Optional[npt.ArrayLike]): Distance(s) to pad the safe set by (for instance, if we evaluate the central point of a spherical robot). Defaults to None. collision_penalty (float, optional): Additional penalty to increase the cost function if collision occurs. Defaults to 0. Returns: tuple[float, bool]: float: The total integrated cost function evaluation bool: Whether a collision occurred at any point in the motion \"\"\" total_cost = 0 collision_occurred = False for pos in positions : cost = safe_set_cost ( pos , boxes , padding , collision_penalty ) total_cost += cost if cost >= 0 : collision_occurred = True return total_cost , collision_occurred robot_and_bag_termination_criteria def robot_and_bag_termination_criteria ( robot_state : tuple [ typing . Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ typing . Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ typing . Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ typing . Union [ bool , int , float , complex , str , bytes ]]], ... ], bag_state : tuple [ typing . Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ typing . Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ typing . Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ typing . Union [ bool , int , float , complex , str , bytes ]]], ... ], desired_robot_pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pos_tol : float = 0.05 , orn_tol : float = 0.17453292519943295 , vel_tol : float = 0.05 , omega_tol = 0.17453292519943295 ) -> bool Deterine if the robot/bag system is successfully stabilized about the desired robot pose Note: The ending pose of the bag is not super important right now, so we're neglecting it in this criteria. If this is important later on, we can add it to this Parameters: Name Type Description Default robot_state tuple[npt.ArrayLike, ...] Current dynamics state of the robot: position, orientation (XYZW quaternion), velocity, and angular velocity None bag_state tuple[npt.ArrayLike, ...] Current dynamics state of the bag: position, orientation (XYZW quaternion), velocity, and angular velocity None desired_robot_pose npt.ArrayLike Desired position + XYZW quaternion pose of the robot, shape (7,) None pos_tol float Absolute tolerance on position. Defaults to 0.05 (within 5 cm) 0 orn_tol float Absolute tolerance on orientation (via quaternion distance metric). Defaults to deg2rad(10) (approximately within a 10 degree rotation) None vel_tol float Absolute tolerance on velocity. Defaults to 0.05 (within 5 cm/s) 0 omega_tol float Absolute tolerance on angular velocity. Defaults to deg2rad(10) (approximately within 10 deg/s) None Returns: Type Description bool True if stabilized at the desired pose View Source def robot_and_bag_termination_criteria ( robot_state : tuple [ npt . ArrayLike , ...], bag_state : tuple [ npt . ArrayLike , ...], desired_robot_pose : npt . ArrayLike , pos_tol : float = 0.05 , orn_tol : float = np . deg2rad ( 10 ), vel_tol : float = 0.05 , omega_tol = np . deg2rad ( 10 ), ) -> bool : \"\"\"Deterine if the robot/bag system is successfully stabilized about the desired robot pose Note: The ending pose of the bag is not super important right now, so we' re neglecting it in this criteria . If this is important later on , we can add it to this Args : robot_state ( tuple [ npt . ArrayLike , ...]) : Current dynamics state of the robot : position , orientation ( XYZW quaternion ), velocity , and angular velocity bag_state ( tuple [ npt . ArrayLike , ...]) : Current dynamics state of the bag : position , orientation ( XYZW quaternion ), velocity , and angular velocity desired_robot_pose ( npt . ArrayLike ) : Desired position + XYZW quaternion pose of the robot , shape ( 7 ,) pos_tol ( float , optional ) : Absolute tolerance on position . Defaults to 0.05 ( within 5 cm ) orn_tol ( float , optional ) : Absolute tolerance on orientation ( via quaternion distance metric ). Defaults to deg2rad ( 10 ) ( approximately within a 10 degree rotation ) vel_tol ( float , optional ) : Absolute tolerance on velocity . Defaults to 0.05 ( within 5 cm / s ) omega_tol ( float , optional ) : Absolute tolerance on angular velocity . Defaults to deg2rad ( 10 ) ( approximately within 10 deg / s ) Returns : bool : True if stabilized at the desired pose \"\"\" des_pos = desired_robot_pose[:3] des_orn = desired_robot_pose[3:] pos, orn, vel, ang_vel = robot_state[:4] bag_vel, bag_ang_vel = bag_state[2:] return ( np.linalg.norm(pos - des_pos) <= pos_tol and quaternion_dist(orn, des_orn) <= orn_tol and np.linalg.norm(vel) <= vel_tol and np.linalg.norm(ang_vel) <= omega_tol and np.linalg.norm(bag_vel) <= vel_tol and np.linalg.norm(bag_ang_vel) <= omega_tol ) safe_set_cost def safe_set_cost ( position : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], boxes : Union [ pyastrobee . utils . boxes . Box , list [ pyastrobee . utils . boxes . Box ]], padding : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , collision_penalty : float = 0 ) -> float Evaluate the cost function for a given position within an environment composed of safe boxes In general, the cost function rewards being centrally located within the safe set, with the cost increasing as the position approaches the wall. Costs are negative for being inside the safe set, and positive outside (in collision). We can add an additional large penalty for being in collision, to help ensure collision avoidance This is essentially an axis-aligned L1 signed distance field Parameters: Name Type Description Default position npt.ArrayLike Position to evaluate the cost function None boxes Union[Box, list[Box]] Local description of the safe set. This does NOT need to be every box in the environment, just the ones in the proximity of the position being evaluated None padding Optional[npt.ArrayLike] Distance(s) to pad the safe set by (for instance, if we evaluate the central point of a spherical robot). Defaults to None. None collision_penalty float Additional penalty to increase the cost function if collision occurs. Defaults to 0. None Returns: Type Description float Cost function evaluation View Source def safe_set_cost ( position : npt . ArrayLike , boxes : Union [ Box, list[Box ] ] , padding : Optional [ npt.ArrayLike ] = None , collision_penalty : float = 0 , ) -> float : \"\"\"Evaluate the cost function for a given position within an environment composed of safe boxes In general, the cost function rewards being centrally located within the safe set, with the cost increasing as the position approaches the wall. Costs are negative for being inside the safe set, and positive outside (in collision). We can add an additional large penalty for being in collision, to help ensure collision avoidance This is essentially an axis-aligned L1 signed distance field Args: position (npt.ArrayLike): Position to evaluate the cost function boxes (Union[Box, list[Box]]): Local description of the safe set. This does NOT need to be every box in the environment, just the ones in the proximity of the position being evaluated padding (Optional[npt.ArrayLike]): Distance(s) to pad the safe set by (for instance, if we evaluate the central point of a spherical robot). Defaults to None. collision_penalty (float, optional): Additional penalty to increase the cost function if collision occurs. Defaults to 0. Returns: float: Cost function evaluation \"\"\" dim = len ( position ) if isinstance ( boxes , Box ) : boxes = [ boxes ] # If we 're padding the boxes, go through each one and reduce their size by the padding amount if padding is not None: if isinstance(padding, (float, int)): padding = padding * np.ones(dim) else: padding = np.ravel(padding).astype(np.float64) assert len(padding) == dim for i, box in enumerate(boxes): boxes[i] = Box(box.lower + padding, box.upper - padding) # Keep track of which boxes we' re inside , since the penalty depends on if we 're in the safe set or not boxes_inside: list[Box] = [] for box in boxes: if is_in_box(position, box): boxes_inside.append(box) # If we are not in collision, we only consider the boxes that we' re inside if len ( boxes_inside ) != 0 : return sum ( max ( [ *(position - box.upper), *(box.lower - position) ] ) for box in boxes_inside ) # If we are in collision , the collision depth is based on the nearest wall , which considers all boxes else : return collision_penalty + min ( max ( [ *(position - box.upper), *(box.lower - position) ] ) for box in boxes ) state_tracking_cost def state_tracking_cost ( cur_pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], cur_orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], cur_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], cur_ang_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], des_pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], des_orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], des_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], des_ang_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pos_penalty : float , orn_penalty : float , vel_penalty : float , ang_vel_penalty : float ) -> float Evaluate a cost function for deviations between the current and desired dynamics state Parameters: Name Type Description Default cur_pos npt.ArrayLike Current position, shape (3,) None cur_orn npt.ArrayLike Current XYZW quaternion orientation, shape (4,) None cur_vel npt.ArrayLike Current linear velocity, shape (3,) None cur_ang_vel npt.ArrayLike Current angular velocity, shape (3,) None des_pos npt.ArrayLike Desired position, shape (3,) None des_orn npt.ArrayLike Desired XYZW quaternion orientation, shape (4,) None des_vel npt.ArrayLike Desired linear velocity, shape (3,) None des_ang_vel npt.ArrayLike Desired angular velocity, shape (3,) None pos_penalty float Penalty scaling factor for position error None orn_penalty float Penalty scaling factor for orientation/angular error None vel_penalty float Penalty scaling factor for linear velocity error None ang_vel_penalty float Penalty scaling factor for angular velocity error None Returns: Type Description float Cost function evaluation View Source def state_tracking_cost( cur_pos: npt.ArrayLike, cur_orn: npt.ArrayLike, cur_vel: npt.ArrayLike, cur_ang_vel: npt.ArrayLike, des_pos: npt.ArrayLike, des_orn: npt.ArrayLike, des_vel: npt.ArrayLike, des_ang_vel: npt.ArrayLike, pos_penalty: float, orn_penalty: float, vel_penalty: float, ang_vel_penalty: float, ) -> float: \"\"\"Evaluate a cost function for deviations between the current and desired dynamics state Args: cur_pos (npt.ArrayLike): Current position, shape (3,) cur_orn (npt.ArrayLike): Current XYZW quaternion orientation, shape (4,) cur_vel (npt.ArrayLike): Current linear velocity, shape (3,) cur_ang_vel (npt.ArrayLike): Current angular velocity, shape (3,) des_pos (npt.ArrayLike): Desired position, shape (3,) des_orn (npt.ArrayLike): Desired XYZW quaternion orientation, shape (4,) des_vel (npt.ArrayLike): Desired linear velocity, shape (3,) des_ang_vel (npt.ArrayLike): Desired angular velocity, shape (3,) pos_penalty (float): Penalty scaling factor for position error orn_penalty (float): Penalty scaling factor for orientation/angular error vel_penalty (float): Penalty scaling factor for linear velocity error ang_vel_penalty (float): Penalty scaling factor for angular velocity error Returns: float: Cost function evaluation \"\"\" pos_err = np.subtract(cur_pos, des_pos) orn_err = quaternion_angular_error(cur_orn, des_orn) vel_err = np.subtract(cur_vel, des_vel) ang_vel_err = np.subtract(cur_ang_vel, des_ang_vel) # NOTE Would an L1 norm be better here? return ( pos_penalty * np.linalg.norm(pos_err) + orn_penalty * np.linalg.norm(orn_err) + vel_penalty * np.linalg.norm(vel_err) + ang_vel_penalty * np.linalg.norm(ang_vel_err) ) traj_tracking_cost def traj_tracking_cost ( des_traj : pyastrobee . trajectories . trajectory . Trajectory , recorded_traj : pyastrobee . trajectories . trajectory . Trajectory , pos_penalty : float , orn_penalty : float , vel_penalty : float , ang_vel_penalty : float ) -> float Evaluates a state mismatch cost function over the duration of a trajectory Parameters: Name Type Description Default des_traj Trajectory Desired trajectory None recorded_traj Trajectory Recorded trajectory None pos_penalty float Penalty scaling factor for position error None orn_penalty float Penalty scaling factor for orientation/angular error None vel_penalty float Penalty scaling factor for linear velocity error None ang_vel_penalty float Penalty scaling factor for angular velocity error None Returns: Type Description float Cost function evaluation View Source def traj_tracking_cost ( des_traj : Trajectory , recorded_traj : Trajectory , pos_penalty : float , orn_penalty : float , vel_penalty : float , ang_vel_penalty : float , ) -> float : \"\"\"Evaluates a state mismatch cost function over the duration of a trajectory Args: des_traj (Trajectory): Desired trajectory recorded_traj (Trajectory): Recorded trajectory pos_penalty (float): Penalty scaling factor for position error orn_penalty (float): Penalty scaling factor for orientation/angular error vel_penalty (float): Penalty scaling factor for linear velocity error ang_vel_penalty (float): Penalty scaling factor for angular velocity error Returns: float: Cost function evaluation \"\"\" assert recorded_traj . num_timesteps == des_traj . num_timesteps total_cost = 0 for i in range ( recorded_traj . num_timesteps ) : total_cost += state_tracking_cost ( recorded_traj . positions [ i ] , recorded_traj . quaternions [ i ] , recorded_traj . linear_velocities [ i ] , recorded_traj . angular_velocities [ i ] , des_traj . positions [ i ] , des_traj . quaternions [ i ] , des_traj . linear_velocities [ i ] , des_traj . angular_velocities [ i ] , pos_penalty , orn_penalty , vel_penalty , ang_vel_penalty , ) return total_cost","title":"Metrics"},{"location":"reference/pyastrobee/control/metrics/#module-pyastrobeecontrolmetrics","text":"Simple metrics / cost functions: For defining how well we track trajectories, remain in collision-free regions, ... View Source \"\"\"Simple metrics / cost functions: For defining how well we track trajectories, remain in collision-free regions, ...\"\"\" from typing import Union , Optional import numpy as np import numpy.typing as npt import matplotlib.pyplot as plt from matplotlib import colors from pyastrobee.utils.boxes import Box , plot_2D_box , is_in_box from pyastrobee.trajectories.trajectory import Trajectory from pyastrobee.utils.quaternions import quaternion_angular_error , quaternion_dist def state_tracking_cost ( cur_pos : npt . ArrayLike , cur_orn : npt . ArrayLike , cur_vel : npt . ArrayLike , cur_ang_vel : npt . ArrayLike , des_pos : npt . ArrayLike , des_orn : npt . ArrayLike , des_vel : npt . ArrayLike , des_ang_vel : npt . ArrayLike , pos_penalty : float , orn_penalty : float , vel_penalty : float , ang_vel_penalty : float , ) -> float : \"\"\"Evaluate a cost function for deviations between the current and desired dynamics state Args: cur_pos (npt.ArrayLike): Current position, shape (3,) cur_orn (npt.ArrayLike): Current XYZW quaternion orientation, shape (4,) cur_vel (npt.ArrayLike): Current linear velocity, shape (3,) cur_ang_vel (npt.ArrayLike): Current angular velocity, shape (3,) des_pos (npt.ArrayLike): Desired position, shape (3,) des_orn (npt.ArrayLike): Desired XYZW quaternion orientation, shape (4,) des_vel (npt.ArrayLike): Desired linear velocity, shape (3,) des_ang_vel (npt.ArrayLike): Desired angular velocity, shape (3,) pos_penalty (float): Penalty scaling factor for position error orn_penalty (float): Penalty scaling factor for orientation/angular error vel_penalty (float): Penalty scaling factor for linear velocity error ang_vel_penalty (float): Penalty scaling factor for angular velocity error Returns: float: Cost function evaluation \"\"\" pos_err = np . subtract ( cur_pos , des_pos ) orn_err = quaternion_angular_error ( cur_orn , des_orn ) vel_err = np . subtract ( cur_vel , des_vel ) ang_vel_err = np . subtract ( cur_ang_vel , des_ang_vel ) # NOTE Would an L1 norm be better here? return ( pos_penalty * np . linalg . norm ( pos_err ) + orn_penalty * np . linalg . norm ( orn_err ) + vel_penalty * np . linalg . norm ( vel_err ) + ang_vel_penalty * np . linalg . norm ( ang_vel_err ) ) def traj_tracking_cost ( des_traj : Trajectory , recorded_traj : Trajectory , pos_penalty : float , orn_penalty : float , vel_penalty : float , ang_vel_penalty : float , ) -> float : \"\"\"Evaluates a state mismatch cost function over the duration of a trajectory Args: des_traj (Trajectory): Desired trajectory recorded_traj (Trajectory): Recorded trajectory pos_penalty (float): Penalty scaling factor for position error orn_penalty (float): Penalty scaling factor for orientation/angular error vel_penalty (float): Penalty scaling factor for linear velocity error ang_vel_penalty (float): Penalty scaling factor for angular velocity error Returns: float: Cost function evaluation \"\"\" assert recorded_traj . num_timesteps == des_traj . num_timesteps total_cost = 0 for i in range ( recorded_traj . num_timesteps ): total_cost += state_tracking_cost ( recorded_traj . positions [ i ], recorded_traj . quaternions [ i ], recorded_traj . linear_velocities [ i ], recorded_traj . angular_velocities [ i ], des_traj . positions [ i ], des_traj . quaternions [ i ], des_traj . linear_velocities [ i ], des_traj . angular_velocities [ i ], pos_penalty , orn_penalty , vel_penalty , ang_vel_penalty , ) return total_cost def safe_set_cost ( position : npt . ArrayLike , boxes : Union [ Box , list [ Box ]], padding : Optional [ npt . ArrayLike ] = None , collision_penalty : float = 0 , ) -> float : \"\"\"Evaluate the cost function for a given position within an environment composed of safe boxes In general, the cost function rewards being centrally located within the safe set, with the cost increasing as the position approaches the wall. Costs are negative for being inside the safe set, and positive outside (in collision). We can add an additional large penalty for being in collision, to help ensure collision avoidance This is essentially an axis-aligned L1 signed distance field Args: position (npt.ArrayLike): Position to evaluate the cost function boxes (Union[Box, list[Box]]): Local description of the safe set. This does NOT need to be every box in the environment, just the ones in the proximity of the position being evaluated padding (Optional[npt.ArrayLike]): Distance(s) to pad the safe set by (for instance, if we evaluate the central point of a spherical robot). Defaults to None. collision_penalty (float, optional): Additional penalty to increase the cost function if collision occurs. Defaults to 0. Returns: float: Cost function evaluation \"\"\" dim = len ( position ) if isinstance ( boxes , Box ): boxes = [ boxes ] # If we're padding the boxes, go through each one and reduce their size by the padding amount if padding is not None : if isinstance ( padding , ( float , int )): padding = padding * np . ones ( dim ) else : padding = np . ravel ( padding ) . astype ( np . float64 ) assert len ( padding ) == dim for i , box in enumerate ( boxes ): boxes [ i ] = Box ( box . lower + padding , box . upper - padding ) # Keep track of which boxes we're inside, since the penalty depends on if we're in the safe set or not boxes_inside : list [ Box ] = [] for box in boxes : if is_in_box ( position , box ): boxes_inside . append ( box ) # If we are not in collision, we only consider the boxes that we're inside if len ( boxes_inside ) != 0 : return sum ( max ([ * ( position - box . upper ), * ( box . lower - position )]) for box in boxes_inside ) # If we are in collision, the collision depth is based on the nearest wall, which considers all boxes else : return collision_penalty + min ( max ([ * ( position - box . upper ), * ( box . lower - position )]) for box in boxes ) def integrated_safe_set_cost ( positions : npt . ArrayLike , boxes : Union [ Box , list [ Box ]], padding : Optional [ npt . ArrayLike ] = None , collision_penalty : float = 0 , ) -> tuple [ float , bool ]: \"\"\"Evaluates the safe-set collision avoidance cost function over a sequence of positions Args: positions (npt.ArrayLike): Positions to evaluate the cost function boxes (Union[Box, list[Box]]): Local description of the safe set. This does NOT need to be every box in the environment, just the ones in the proximity of the position being evaluated padding (Optional[npt.ArrayLike]): Distance(s) to pad the safe set by (for instance, if we evaluate the central point of a spherical robot). Defaults to None. collision_penalty (float, optional): Additional penalty to increase the cost function if collision occurs. Defaults to 0. Returns: tuple[float, bool]: float: The total integrated cost function evaluation bool: Whether a collision occurred at any point in the motion \"\"\" total_cost = 0 collision_occurred = False for pos in positions : cost = safe_set_cost ( pos , boxes , padding , collision_penalty ) total_cost += cost if cost >= 0 : collision_occurred = True return total_cost , collision_occurred def robot_and_bag_termination_criteria ( robot_state : tuple [ npt . ArrayLike , ... ], bag_state : tuple [ npt . ArrayLike , ... ], desired_robot_pose : npt . ArrayLike , pos_tol : float = 0.05 , orn_tol : float = np . deg2rad ( 10 ), vel_tol : float = 0.05 , omega_tol = np . deg2rad ( 10 ), ) -> bool : \"\"\"Deterine if the robot/bag system is successfully stabilized about the desired robot pose Note: The ending pose of the bag is not super important right now, so we're neglecting it in this criteria. If this is important later on, we can add it to this Args: robot_state (tuple[npt.ArrayLike, ...]): Current dynamics state of the robot: position, orientation (XYZW quaternion), velocity, and angular velocity bag_state (tuple[npt.ArrayLike, ...]): Current dynamics state of the bag: position, orientation (XYZW quaternion), velocity, and angular velocity desired_robot_pose (npt.ArrayLike): Desired position + XYZW quaternion pose of the robot, shape (7,) pos_tol (float, optional): Absolute tolerance on position. Defaults to 0.05 (within 5 cm) orn_tol (float, optional): Absolute tolerance on orientation (via quaternion distance metric). Defaults to deg2rad(10) (approximately within a 10 degree rotation) vel_tol (float, optional): Absolute tolerance on velocity. Defaults to 0.05 (within 5 cm/s) omega_tol (float, optional): Absolute tolerance on angular velocity. Defaults to deg2rad(10) (approximately within 10 deg/s) Returns: bool: True if stabilized at the desired pose \"\"\" des_pos = desired_robot_pose [: 3 ] des_orn = desired_robot_pose [ 3 :] pos , orn , vel , ang_vel = robot_state [: 4 ] bag_vel , bag_ang_vel = bag_state [ 2 :] return ( np . linalg . norm ( pos - des_pos ) <= pos_tol and quaternion_dist ( orn , des_orn ) <= orn_tol and np . linalg . norm ( vel ) <= vel_tol and np . linalg . norm ( ang_vel ) <= omega_tol and np . linalg . norm ( bag_vel ) <= vel_tol and np . linalg . norm ( bag_ang_vel ) <= omega_tol ) def _visualize_safe_set_cost (): \"\"\"Create a 2D example of two safe-set boxes and visualize a heatmap of the penalty function\"\"\" n = 50 X , Y = np . meshgrid ( np . linspace ( - 1 , 1 , n ), np . linspace ( - 1 , 1 , n )) Z = np . empty_like ( X ) box_1 = Box ([ - 1 , - 0.5 ], [ 0.5 , 0.5 ]) box_2 = Box ([ 0 , - 1 ], [ 1 , 1 ]) plt . figure () padding = np . array ([ 0.1 , 0.1 ]) penalty = 0.5 new_boxes = [ Box ( box_1 . lower + padding , box_1 . upper - padding ), Box ( box_2 . lower + padding , box_2 . upper - padding ), ] for i in range ( n ): for j in range ( n ): Z [ i , j ] = safe_set_cost ( ( X [ i , j ], Y [ i , j ]), [ box_1 , box_2 ], padding , penalty ) # Z[i, j] = (1 if Z[i, j] >= 0 else -1) * Z[i, j] ** 2 two_slope_norm = colors . TwoSlopeNorm ( vmin = np . min ( Z ), vcenter = 0 , vmax = np . max ( Z )) heatmap = plt . pcolormesh ( X , Y , Z , cmap = \"Spectral_r\" , norm = two_slope_norm ) plot_2D_box ( box_1 , None , False , \"k--\" ) plot_2D_box ( box_2 , None , False , \"k--\" ) plot_2D_box ( new_boxes [ 0 ], None , False , \"b--\" ) plot_2D_box ( new_boxes [ 1 ], None , False , \"b--\" ) plt . colorbar ( heatmap ) plt . title ( \"Safe Set Deviation\" ) plt . xlabel ( \"X\" ) plt . ylabel ( \"Y\" ) plt . show () if __name__ == \"__main__\" : _visualize_safe_set_cost ()","title":"Module pyastrobee.control.metrics"},{"location":"reference/pyastrobee/control/metrics/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/control/metrics/#integrated_safe_set_cost","text":"def integrated_safe_set_cost ( positions : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], boxes : Union [ pyastrobee . utils . boxes . Box , list [ pyastrobee . utils . boxes . Box ]], padding : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , collision_penalty : float = 0 ) -> tuple [ float , bool ] Evaluates the safe-set collision avoidance cost function over a sequence of positions Parameters: Name Type Description Default positions npt.ArrayLike Positions to evaluate the cost function None boxes Union[Box, list[Box]] Local description of the safe set. This does NOT need to be every box in the environment, just the ones in the proximity of the position being evaluated None padding Optional[npt.ArrayLike] Distance(s) to pad the safe set by (for instance, if we evaluate the central point of a spherical robot). Defaults to None. None collision_penalty float Additional penalty to increase the cost function if collision occurs. Defaults to 0. None Returns: Type Description tuple[float, bool] float: The total integrated cost function evaluation bool: Whether a collision occurred at any point in the motion View Source def integrated_safe_set_cost ( positions : npt . ArrayLike , boxes : Union [ Box, list[Box ] ] , padding : Optional [ npt.ArrayLike ] = None , collision_penalty : float = 0 , ) -> tuple [ float, bool ] : \"\"\"Evaluates the safe-set collision avoidance cost function over a sequence of positions Args: positions (npt.ArrayLike): Positions to evaluate the cost function boxes (Union[Box, list[Box]]): Local description of the safe set. This does NOT need to be every box in the environment, just the ones in the proximity of the position being evaluated padding (Optional[npt.ArrayLike]): Distance(s) to pad the safe set by (for instance, if we evaluate the central point of a spherical robot). Defaults to None. collision_penalty (float, optional): Additional penalty to increase the cost function if collision occurs. Defaults to 0. Returns: tuple[float, bool]: float: The total integrated cost function evaluation bool: Whether a collision occurred at any point in the motion \"\"\" total_cost = 0 collision_occurred = False for pos in positions : cost = safe_set_cost ( pos , boxes , padding , collision_penalty ) total_cost += cost if cost >= 0 : collision_occurred = True return total_cost , collision_occurred","title":"integrated_safe_set_cost"},{"location":"reference/pyastrobee/control/metrics/#robot_and_bag_termination_criteria","text":"def robot_and_bag_termination_criteria ( robot_state : tuple [ typing . Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ typing . Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ typing . Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ typing . Union [ bool , int , float , complex , str , bytes ]]], ... ], bag_state : tuple [ typing . Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ typing . Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ typing . Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ typing . Union [ bool , int , float , complex , str , bytes ]]], ... ], desired_robot_pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pos_tol : float = 0.05 , orn_tol : float = 0.17453292519943295 , vel_tol : float = 0.05 , omega_tol = 0.17453292519943295 ) -> bool Deterine if the robot/bag system is successfully stabilized about the desired robot pose Note: The ending pose of the bag is not super important right now, so we're neglecting it in this criteria. If this is important later on, we can add it to this Parameters: Name Type Description Default robot_state tuple[npt.ArrayLike, ...] Current dynamics state of the robot: position, orientation (XYZW quaternion), velocity, and angular velocity None bag_state tuple[npt.ArrayLike, ...] Current dynamics state of the bag: position, orientation (XYZW quaternion), velocity, and angular velocity None desired_robot_pose npt.ArrayLike Desired position + XYZW quaternion pose of the robot, shape (7,) None pos_tol float Absolute tolerance on position. Defaults to 0.05 (within 5 cm) 0 orn_tol float Absolute tolerance on orientation (via quaternion distance metric). Defaults to deg2rad(10) (approximately within a 10 degree rotation) None vel_tol float Absolute tolerance on velocity. Defaults to 0.05 (within 5 cm/s) 0 omega_tol float Absolute tolerance on angular velocity. Defaults to deg2rad(10) (approximately within 10 deg/s) None Returns: Type Description bool True if stabilized at the desired pose View Source def robot_and_bag_termination_criteria ( robot_state : tuple [ npt . ArrayLike , ...], bag_state : tuple [ npt . ArrayLike , ...], desired_robot_pose : npt . ArrayLike , pos_tol : float = 0.05 , orn_tol : float = np . deg2rad ( 10 ), vel_tol : float = 0.05 , omega_tol = np . deg2rad ( 10 ), ) -> bool : \"\"\"Deterine if the robot/bag system is successfully stabilized about the desired robot pose Note: The ending pose of the bag is not super important right now, so we' re neglecting it in this criteria . If this is important later on , we can add it to this Args : robot_state ( tuple [ npt . ArrayLike , ...]) : Current dynamics state of the robot : position , orientation ( XYZW quaternion ), velocity , and angular velocity bag_state ( tuple [ npt . ArrayLike , ...]) : Current dynamics state of the bag : position , orientation ( XYZW quaternion ), velocity , and angular velocity desired_robot_pose ( npt . ArrayLike ) : Desired position + XYZW quaternion pose of the robot , shape ( 7 ,) pos_tol ( float , optional ) : Absolute tolerance on position . Defaults to 0.05 ( within 5 cm ) orn_tol ( float , optional ) : Absolute tolerance on orientation ( via quaternion distance metric ). Defaults to deg2rad ( 10 ) ( approximately within a 10 degree rotation ) vel_tol ( float , optional ) : Absolute tolerance on velocity . Defaults to 0.05 ( within 5 cm / s ) omega_tol ( float , optional ) : Absolute tolerance on angular velocity . Defaults to deg2rad ( 10 ) ( approximately within 10 deg / s ) Returns : bool : True if stabilized at the desired pose \"\"\" des_pos = desired_robot_pose[:3] des_orn = desired_robot_pose[3:] pos, orn, vel, ang_vel = robot_state[:4] bag_vel, bag_ang_vel = bag_state[2:] return ( np.linalg.norm(pos - des_pos) <= pos_tol and quaternion_dist(orn, des_orn) <= orn_tol and np.linalg.norm(vel) <= vel_tol and np.linalg.norm(ang_vel) <= omega_tol and np.linalg.norm(bag_vel) <= vel_tol and np.linalg.norm(bag_ang_vel) <= omega_tol )","title":"robot_and_bag_termination_criteria"},{"location":"reference/pyastrobee/control/metrics/#safe_set_cost","text":"def safe_set_cost ( position : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], boxes : Union [ pyastrobee . utils . boxes . Box , list [ pyastrobee . utils . boxes . Box ]], padding : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , collision_penalty : float = 0 ) -> float Evaluate the cost function for a given position within an environment composed of safe boxes In general, the cost function rewards being centrally located within the safe set, with the cost increasing as the position approaches the wall. Costs are negative for being inside the safe set, and positive outside (in collision). We can add an additional large penalty for being in collision, to help ensure collision avoidance This is essentially an axis-aligned L1 signed distance field Parameters: Name Type Description Default position npt.ArrayLike Position to evaluate the cost function None boxes Union[Box, list[Box]] Local description of the safe set. This does NOT need to be every box in the environment, just the ones in the proximity of the position being evaluated None padding Optional[npt.ArrayLike] Distance(s) to pad the safe set by (for instance, if we evaluate the central point of a spherical robot). Defaults to None. None collision_penalty float Additional penalty to increase the cost function if collision occurs. Defaults to 0. None Returns: Type Description float Cost function evaluation View Source def safe_set_cost ( position : npt . ArrayLike , boxes : Union [ Box, list[Box ] ] , padding : Optional [ npt.ArrayLike ] = None , collision_penalty : float = 0 , ) -> float : \"\"\"Evaluate the cost function for a given position within an environment composed of safe boxes In general, the cost function rewards being centrally located within the safe set, with the cost increasing as the position approaches the wall. Costs are negative for being inside the safe set, and positive outside (in collision). We can add an additional large penalty for being in collision, to help ensure collision avoidance This is essentially an axis-aligned L1 signed distance field Args: position (npt.ArrayLike): Position to evaluate the cost function boxes (Union[Box, list[Box]]): Local description of the safe set. This does NOT need to be every box in the environment, just the ones in the proximity of the position being evaluated padding (Optional[npt.ArrayLike]): Distance(s) to pad the safe set by (for instance, if we evaluate the central point of a spherical robot). Defaults to None. collision_penalty (float, optional): Additional penalty to increase the cost function if collision occurs. Defaults to 0. Returns: float: Cost function evaluation \"\"\" dim = len ( position ) if isinstance ( boxes , Box ) : boxes = [ boxes ] # If we 're padding the boxes, go through each one and reduce their size by the padding amount if padding is not None: if isinstance(padding, (float, int)): padding = padding * np.ones(dim) else: padding = np.ravel(padding).astype(np.float64) assert len(padding) == dim for i, box in enumerate(boxes): boxes[i] = Box(box.lower + padding, box.upper - padding) # Keep track of which boxes we' re inside , since the penalty depends on if we 're in the safe set or not boxes_inside: list[Box] = [] for box in boxes: if is_in_box(position, box): boxes_inside.append(box) # If we are not in collision, we only consider the boxes that we' re inside if len ( boxes_inside ) != 0 : return sum ( max ( [ *(position - box.upper), *(box.lower - position) ] ) for box in boxes_inside ) # If we are in collision , the collision depth is based on the nearest wall , which considers all boxes else : return collision_penalty + min ( max ( [ *(position - box.upper), *(box.lower - position) ] ) for box in boxes )","title":"safe_set_cost"},{"location":"reference/pyastrobee/control/metrics/#state_tracking_cost","text":"def state_tracking_cost ( cur_pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], cur_orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], cur_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], cur_ang_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], des_pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], des_orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], des_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], des_ang_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pos_penalty : float , orn_penalty : float , vel_penalty : float , ang_vel_penalty : float ) -> float Evaluate a cost function for deviations between the current and desired dynamics state Parameters: Name Type Description Default cur_pos npt.ArrayLike Current position, shape (3,) None cur_orn npt.ArrayLike Current XYZW quaternion orientation, shape (4,) None cur_vel npt.ArrayLike Current linear velocity, shape (3,) None cur_ang_vel npt.ArrayLike Current angular velocity, shape (3,) None des_pos npt.ArrayLike Desired position, shape (3,) None des_orn npt.ArrayLike Desired XYZW quaternion orientation, shape (4,) None des_vel npt.ArrayLike Desired linear velocity, shape (3,) None des_ang_vel npt.ArrayLike Desired angular velocity, shape (3,) None pos_penalty float Penalty scaling factor for position error None orn_penalty float Penalty scaling factor for orientation/angular error None vel_penalty float Penalty scaling factor for linear velocity error None ang_vel_penalty float Penalty scaling factor for angular velocity error None Returns: Type Description float Cost function evaluation View Source def state_tracking_cost( cur_pos: npt.ArrayLike, cur_orn: npt.ArrayLike, cur_vel: npt.ArrayLike, cur_ang_vel: npt.ArrayLike, des_pos: npt.ArrayLike, des_orn: npt.ArrayLike, des_vel: npt.ArrayLike, des_ang_vel: npt.ArrayLike, pos_penalty: float, orn_penalty: float, vel_penalty: float, ang_vel_penalty: float, ) -> float: \"\"\"Evaluate a cost function for deviations between the current and desired dynamics state Args: cur_pos (npt.ArrayLike): Current position, shape (3,) cur_orn (npt.ArrayLike): Current XYZW quaternion orientation, shape (4,) cur_vel (npt.ArrayLike): Current linear velocity, shape (3,) cur_ang_vel (npt.ArrayLike): Current angular velocity, shape (3,) des_pos (npt.ArrayLike): Desired position, shape (3,) des_orn (npt.ArrayLike): Desired XYZW quaternion orientation, shape (4,) des_vel (npt.ArrayLike): Desired linear velocity, shape (3,) des_ang_vel (npt.ArrayLike): Desired angular velocity, shape (3,) pos_penalty (float): Penalty scaling factor for position error orn_penalty (float): Penalty scaling factor for orientation/angular error vel_penalty (float): Penalty scaling factor for linear velocity error ang_vel_penalty (float): Penalty scaling factor for angular velocity error Returns: float: Cost function evaluation \"\"\" pos_err = np.subtract(cur_pos, des_pos) orn_err = quaternion_angular_error(cur_orn, des_orn) vel_err = np.subtract(cur_vel, des_vel) ang_vel_err = np.subtract(cur_ang_vel, des_ang_vel) # NOTE Would an L1 norm be better here? return ( pos_penalty * np.linalg.norm(pos_err) + orn_penalty * np.linalg.norm(orn_err) + vel_penalty * np.linalg.norm(vel_err) + ang_vel_penalty * np.linalg.norm(ang_vel_err) )","title":"state_tracking_cost"},{"location":"reference/pyastrobee/control/metrics/#traj_tracking_cost","text":"def traj_tracking_cost ( des_traj : pyastrobee . trajectories . trajectory . Trajectory , recorded_traj : pyastrobee . trajectories . trajectory . Trajectory , pos_penalty : float , orn_penalty : float , vel_penalty : float , ang_vel_penalty : float ) -> float Evaluates a state mismatch cost function over the duration of a trajectory Parameters: Name Type Description Default des_traj Trajectory Desired trajectory None recorded_traj Trajectory Recorded trajectory None pos_penalty float Penalty scaling factor for position error None orn_penalty float Penalty scaling factor for orientation/angular error None vel_penalty float Penalty scaling factor for linear velocity error None ang_vel_penalty float Penalty scaling factor for angular velocity error None Returns: Type Description float Cost function evaluation View Source def traj_tracking_cost ( des_traj : Trajectory , recorded_traj : Trajectory , pos_penalty : float , orn_penalty : float , vel_penalty : float , ang_vel_penalty : float , ) -> float : \"\"\"Evaluates a state mismatch cost function over the duration of a trajectory Args: des_traj (Trajectory): Desired trajectory recorded_traj (Trajectory): Recorded trajectory pos_penalty (float): Penalty scaling factor for position error orn_penalty (float): Penalty scaling factor for orientation/angular error vel_penalty (float): Penalty scaling factor for linear velocity error ang_vel_penalty (float): Penalty scaling factor for angular velocity error Returns: float: Cost function evaluation \"\"\" assert recorded_traj . num_timesteps == des_traj . num_timesteps total_cost = 0 for i in range ( recorded_traj . num_timesteps ) : total_cost += state_tracking_cost ( recorded_traj . positions [ i ] , recorded_traj . quaternions [ i ] , recorded_traj . linear_velocities [ i ] , recorded_traj . angular_velocities [ i ] , des_traj . positions [ i ] , des_traj . quaternions [ i ] , des_traj . linear_velocities [ i ] , des_traj . angular_velocities [ i ] , pos_penalty , orn_penalty , vel_penalty , ang_vel_penalty , ) return total_cost","title":"traj_tracking_cost"},{"location":"reference/pyastrobee/control/multi_robot/","text":"Module pyastrobee.control.multi_robot Multi-robot control View Source \"\"\"Multi-robot control\"\"\" import time from typing import Optional import numpy as np import pybullet from pybullet_utils.bullet_client import BulletClient from pyastrobee.trajectories.trajectory import Trajectory from pyastrobee.control.force_torque_control import ForceTorqueController def multi_robot_control ( controllers : list [ ForceTorqueController ], trajs : list [ Trajectory ], stop_at_end : bool , client : Optional [ BulletClient ] = None , ): \"\"\"Control multiple Astrobees to follow their own respective trajectories simultaneously Args: controllers (list[ForceTorqueController]): Robot controllers (1 per Astrobee) trajs (list[Trajectory]): Trajectories to follow (1 per Astrobee) stop_at_end (bool): Whether to command the robots to stop at the end of the trajectory client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Raises: ValueError: If there is a mismatch in the number of trajectories/controllers \"\"\" if not len ( trajs ) == len ( controllers ): raise ValueError ( \"Mismatched inputs: Each controller must correspond to a trajectory\" ) client : pybullet = pybullet if client is None else client num_timesteps = trajs [ 0 ] . num_timesteps num_controllers = len ( controllers ) for t in range ( num_timesteps ): des_states = [ [ trajs [ i ] . positions [ t , :], trajs [ i ] . linear_velocities [ t , :], trajs [ i ] . linear_accels [ t , :], trajs [ i ] . quaternions [ t , :], trajs [ i ] . angular_velocities [ t , :], trajs [ i ] . angular_accels [ t , :], ] for i in range ( num_controllers ) ] step_controllers ( controllers , des_states , client ) # time.sleep(1 / 120) if stop_at_end : des_states = [ [ trajs [ i ] . positions [ - 1 , :], np . zeros ( 3 ), np . zeros ( 3 ), trajs [ i ] . quaternions [ - 1 , :], np . zeros ( 3 ), np . zeros ( 3 ), ] for i in range ( num_controllers ) ] while True : step_controllers ( controllers , des_states , client ) # time.sleep(1 / 120) else : while True : client . stepSimulation () # time.sleep(1 / 120) def step_controllers ( controllers : list [ ForceTorqueController ], des_states : list [ np . ndarray ], client : BulletClient , ): \"\"\"Step a series of controllers within the same simulation simultaneously Args: controllers (list[ForceTorqueController]): Active controllers in the simulation des_states (list[np.ndarray]): Desired states for each robot. Length = len(controllers). Each state should include (in order) the desired position, velocity, acceleration, quaternion, angular velocity, and angular acceleration client (BulletClient): Pybullet simulation client containing the controllers \"\"\" if len ( des_states ) != len ( controllers ): raise ValueError ( \"Mismatched input lengths. Each controller should have a corresponding goal state\" ) # Check that the quaternion input is in the correct location if len ( des_states [ 0 ][ 3 ]) != 4 : raise ValueError ( \"Desired states appear to be mis-ordered. \\n \" + \"Each state should include position, velocity, acceleration, quaternion, omega, alpha\" ) for controller , des_state in zip ( controllers , des_states ): pos , orn , vel , omega = controller . get_current_state () controller . step ( pos , vel , orn , omega , * des_state , step_sim = False ) client . stepSimulation () Functions multi_robot_control def multi_robot_control ( controllers : list [ pyastrobee . control . force_torque_control . ForceTorqueController ], trajs : list [ pyastrobee . trajectories . trajectory . Trajectory ], stop_at_end : bool , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) Control multiple Astrobees to follow their own respective trajectories simultaneously Parameters: Name Type Description Default controllers list[ForceTorqueController] Robot controllers (1 per Astrobee) None trajs list[Trajectory] Trajectories to follow (1 per Astrobee) None stop_at_end bool Whether to command the robots to stop at the end of the trajectory None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Raises: Type Description ValueError If there is a mismatch in the number of trajectories/controllers View Source def multi_robot_control ( controllers : list [ ForceTorqueController ] , trajs : list [ Trajectory ] , stop_at_end : bool , client : Optional [ BulletClient ] = None , ) : \"\"\"Control multiple Astrobees to follow their own respective trajectories simultaneously Args: controllers (list[ForceTorqueController]): Robot controllers (1 per Astrobee) trajs (list[Trajectory]): Trajectories to follow (1 per Astrobee) stop_at_end (bool): Whether to command the robots to stop at the end of the trajectory client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Raises: ValueError: If there is a mismatch in the number of trajectories/controllers \"\"\" if not len ( trajs ) == len ( controllers ) : raise ValueError ( \"Mismatched inputs: Each controller must correspond to a trajectory\" ) client : pybullet = pybullet if client is None else client num_timesteps = trajs [ 0 ] . num_timesteps num_controllers = len ( controllers ) for t in range ( num_timesteps ) : des_states = [ [ trajs[i ] . positions [ t, : ] , trajs [ i ] . linear_velocities [ t, : ] , trajs [ i ] . linear_accels [ t, : ] , trajs [ i ] . quaternions [ t, : ] , trajs [ i ] . angular_velocities [ t, : ] , trajs [ i ] . angular_accels [ t, : ] , ] for i in range ( num_controllers ) ] step_controllers ( controllers , des_states , client ) # time . sleep ( 1 / 120 ) if stop_at_end : des_states = [ [ trajs[i ] . positions [ -1, : ] , np . zeros ( 3 ), np . zeros ( 3 ), trajs [ i ] . quaternions [ -1, : ] , np . zeros ( 3 ), np . zeros ( 3 ), ] for i in range ( num_controllers ) ] while True : step_controllers ( controllers , des_states , client ) # time . sleep ( 1 / 120 ) else : while True : client . stepSimulation () # time . sleep ( 1 / 120 ) step_controllers def step_controllers ( controllers : list [ pyastrobee . control . force_torque_control . ForceTorqueController ], des_states : list [ numpy . ndarray ], client : pybullet_utils . bullet_client . BulletClient ) Step a series of controllers within the same simulation simultaneously Parameters: Name Type Description Default controllers list[ForceTorqueController] Active controllers in the simulation None des_states list[np.ndarray] Desired states for each robot. Length = len(controllers). Each state should include (in order) the desired position, velocity, acceleration, quaternion, angular velocity, and angular acceleration None client BulletClient Pybullet simulation client containing the controllers None View Source def step_controllers ( controllers : list [ ForceTorqueController ] , des_states : list [ np.ndarray ] , client : BulletClient , ) : \"\"\"Step a series of controllers within the same simulation simultaneously Args: controllers (list[ForceTorqueController]): Active controllers in the simulation des_states (list[np.ndarray]): Desired states for each robot. Length = len(controllers). Each state should include (in order) the desired position, velocity, acceleration, quaternion, angular velocity, and angular acceleration client (BulletClient): Pybullet simulation client containing the controllers \"\"\" if len ( des_states ) != len ( controllers ) : raise ValueError ( \"Mismatched input lengths. Each controller should have a corresponding goal state\" ) # Check that the quaternion input is in the correct location if len ( des_states [ 0 ][ 3 ] ) != 4 : raise ValueError ( \"Desired states appear to be mis-ordered.\\n\" + \"Each state should include position, velocity, acceleration, quaternion, omega, alpha\" ) for controller , des_state in zip ( controllers , des_states ) : pos , orn , vel , omega = controller . get_current_state () controller . step ( pos , vel , orn , omega , * des_state , step_sim = False ) client . stepSimulation ()","title":"Multi Robot"},{"location":"reference/pyastrobee/control/multi_robot/#module-pyastrobeecontrolmulti_robot","text":"Multi-robot control View Source \"\"\"Multi-robot control\"\"\" import time from typing import Optional import numpy as np import pybullet from pybullet_utils.bullet_client import BulletClient from pyastrobee.trajectories.trajectory import Trajectory from pyastrobee.control.force_torque_control import ForceTorqueController def multi_robot_control ( controllers : list [ ForceTorqueController ], trajs : list [ Trajectory ], stop_at_end : bool , client : Optional [ BulletClient ] = None , ): \"\"\"Control multiple Astrobees to follow their own respective trajectories simultaneously Args: controllers (list[ForceTorqueController]): Robot controllers (1 per Astrobee) trajs (list[Trajectory]): Trajectories to follow (1 per Astrobee) stop_at_end (bool): Whether to command the robots to stop at the end of the trajectory client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Raises: ValueError: If there is a mismatch in the number of trajectories/controllers \"\"\" if not len ( trajs ) == len ( controllers ): raise ValueError ( \"Mismatched inputs: Each controller must correspond to a trajectory\" ) client : pybullet = pybullet if client is None else client num_timesteps = trajs [ 0 ] . num_timesteps num_controllers = len ( controllers ) for t in range ( num_timesteps ): des_states = [ [ trajs [ i ] . positions [ t , :], trajs [ i ] . linear_velocities [ t , :], trajs [ i ] . linear_accels [ t , :], trajs [ i ] . quaternions [ t , :], trajs [ i ] . angular_velocities [ t , :], trajs [ i ] . angular_accels [ t , :], ] for i in range ( num_controllers ) ] step_controllers ( controllers , des_states , client ) # time.sleep(1 / 120) if stop_at_end : des_states = [ [ trajs [ i ] . positions [ - 1 , :], np . zeros ( 3 ), np . zeros ( 3 ), trajs [ i ] . quaternions [ - 1 , :], np . zeros ( 3 ), np . zeros ( 3 ), ] for i in range ( num_controllers ) ] while True : step_controllers ( controllers , des_states , client ) # time.sleep(1 / 120) else : while True : client . stepSimulation () # time.sleep(1 / 120) def step_controllers ( controllers : list [ ForceTorqueController ], des_states : list [ np . ndarray ], client : BulletClient , ): \"\"\"Step a series of controllers within the same simulation simultaneously Args: controllers (list[ForceTorqueController]): Active controllers in the simulation des_states (list[np.ndarray]): Desired states for each robot. Length = len(controllers). Each state should include (in order) the desired position, velocity, acceleration, quaternion, angular velocity, and angular acceleration client (BulletClient): Pybullet simulation client containing the controllers \"\"\" if len ( des_states ) != len ( controllers ): raise ValueError ( \"Mismatched input lengths. Each controller should have a corresponding goal state\" ) # Check that the quaternion input is in the correct location if len ( des_states [ 0 ][ 3 ]) != 4 : raise ValueError ( \"Desired states appear to be mis-ordered. \\n \" + \"Each state should include position, velocity, acceleration, quaternion, omega, alpha\" ) for controller , des_state in zip ( controllers , des_states ): pos , orn , vel , omega = controller . get_current_state () controller . step ( pos , vel , orn , omega , * des_state , step_sim = False ) client . stepSimulation ()","title":"Module pyastrobee.control.multi_robot"},{"location":"reference/pyastrobee/control/multi_robot/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/control/multi_robot/#multi_robot_control","text":"def multi_robot_control ( controllers : list [ pyastrobee . control . force_torque_control . ForceTorqueController ], trajs : list [ pyastrobee . trajectories . trajectory . Trajectory ], stop_at_end : bool , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) Control multiple Astrobees to follow their own respective trajectories simultaneously Parameters: Name Type Description Default controllers list[ForceTorqueController] Robot controllers (1 per Astrobee) None trajs list[Trajectory] Trajectories to follow (1 per Astrobee) None stop_at_end bool Whether to command the robots to stop at the end of the trajectory None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Raises: Type Description ValueError If there is a mismatch in the number of trajectories/controllers View Source def multi_robot_control ( controllers : list [ ForceTorqueController ] , trajs : list [ Trajectory ] , stop_at_end : bool , client : Optional [ BulletClient ] = None , ) : \"\"\"Control multiple Astrobees to follow their own respective trajectories simultaneously Args: controllers (list[ForceTorqueController]): Robot controllers (1 per Astrobee) trajs (list[Trajectory]): Trajectories to follow (1 per Astrobee) stop_at_end (bool): Whether to command the robots to stop at the end of the trajectory client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Raises: ValueError: If there is a mismatch in the number of trajectories/controllers \"\"\" if not len ( trajs ) == len ( controllers ) : raise ValueError ( \"Mismatched inputs: Each controller must correspond to a trajectory\" ) client : pybullet = pybullet if client is None else client num_timesteps = trajs [ 0 ] . num_timesteps num_controllers = len ( controllers ) for t in range ( num_timesteps ) : des_states = [ [ trajs[i ] . positions [ t, : ] , trajs [ i ] . linear_velocities [ t, : ] , trajs [ i ] . linear_accels [ t, : ] , trajs [ i ] . quaternions [ t, : ] , trajs [ i ] . angular_velocities [ t, : ] , trajs [ i ] . angular_accels [ t, : ] , ] for i in range ( num_controllers ) ] step_controllers ( controllers , des_states , client ) # time . sleep ( 1 / 120 ) if stop_at_end : des_states = [ [ trajs[i ] . positions [ -1, : ] , np . zeros ( 3 ), np . zeros ( 3 ), trajs [ i ] . quaternions [ -1, : ] , np . zeros ( 3 ), np . zeros ( 3 ), ] for i in range ( num_controllers ) ] while True : step_controllers ( controllers , des_states , client ) # time . sleep ( 1 / 120 ) else : while True : client . stepSimulation () # time . sleep ( 1 / 120 )","title":"multi_robot_control"},{"location":"reference/pyastrobee/control/multi_robot/#step_controllers","text":"def step_controllers ( controllers : list [ pyastrobee . control . force_torque_control . ForceTorqueController ], des_states : list [ numpy . ndarray ], client : pybullet_utils . bullet_client . BulletClient ) Step a series of controllers within the same simulation simultaneously Parameters: Name Type Description Default controllers list[ForceTorqueController] Active controllers in the simulation None des_states list[np.ndarray] Desired states for each robot. Length = len(controllers). Each state should include (in order) the desired position, velocity, acceleration, quaternion, angular velocity, and angular acceleration None client BulletClient Pybullet simulation client containing the controllers None View Source def step_controllers ( controllers : list [ ForceTorqueController ] , des_states : list [ np.ndarray ] , client : BulletClient , ) : \"\"\"Step a series of controllers within the same simulation simultaneously Args: controllers (list[ForceTorqueController]): Active controllers in the simulation des_states (list[np.ndarray]): Desired states for each robot. Length = len(controllers). Each state should include (in order) the desired position, velocity, acceleration, quaternion, angular velocity, and angular acceleration client (BulletClient): Pybullet simulation client containing the controllers \"\"\" if len ( des_states ) != len ( controllers ) : raise ValueError ( \"Mismatched input lengths. Each controller should have a corresponding goal state\" ) # Check that the quaternion input is in the correct location if len ( des_states [ 0 ][ 3 ] ) != 4 : raise ValueError ( \"Desired states appear to be mis-ordered.\\n\" + \"Each state should include position, velocity, acceleration, quaternion, omega, alpha\" ) for controller , des_state in zip ( controllers , des_states ) : pos , orn , vel , omega = controller . get_current_state () controller . step ( pos , vel , orn , omega , * des_state , step_sim = False ) client . stepSimulation ()","title":"step_controllers"},{"location":"reference/pyastrobee/control/sampling_mpc/","text":"Module pyastrobee.control.sampling_mpc Sampling-based MPC with the simulator as the model (single-threaded version) See the multithreaded version for a better implementation so that the state save/resets don't occur in the same simulation View Source \"\"\"Sampling-based MPC with the simulator as the model (single-threaded version) See the multithreaded version for a better implementation so that the state save/resets don't occur in the same simulation \"\"\" from pybullet_utils.bullet_client import BulletClient import numpy as np import numpy.typing as npt from pyastrobee.core.astrobee import Astrobee from pyastrobee.core.deformable_bag import DeformableCargoBag from pyastrobee.core.iss import ISS from pyastrobee.utils.bullet_utils import initialize_pybullet from pyastrobee.trajectories.trajectory import stopping_criteria from pyastrobee.control.metrics import state_tracking_cost from pyastrobee.trajectories.planner import global_planner from pyastrobee.trajectories.sampling import generate_trajs from pyastrobee.control.force_torque_control import ForceTorqueController from pyastrobee.utils.debug_visualizer import remove_debug_objects def init ( robot_pose : npt . ArrayLike , use_gui : bool = True ) -> tuple [ BulletClient , Astrobee , DeformableCargoBag ]: \"\"\"Initialize the simulation environment with our assets Args: robot_pose (npt.ArrayLike): Initial pose of the Astrobee use_gui (bool, optional): Whether or not to launch the simulation in a GUI window. Defaults to True. Returns: tuple[BulletClient, Astrobee, CargoBag]: BulletClient: The Pybullet client Astrobee: The Astrobee object CargoBag: The Cargo Bag object \"\"\" client = initialize_pybullet ( use_gui ) iss = ISS ( client = client ) robot = Astrobee ( robot_pose , client = client ) bag_mass = 10 bag = DeformableCargoBag ( \"top_handle\" , bag_mass , client = client ) bag . attach_to ( robot , object_to_move = \"bag\" ) return client , robot , bag def mpc_main ( start_pose : npt . ArrayLike , goal_pose : npt . ArrayLike , debug : bool = False , ): \"\"\"Launches the environment and runs a model-predictive-controller to move Astrobee between two poses while carrying a cargo bag Args: start_pose (npt.ArrayLike): Starting pose of the Astrobee (position and XYZW quaternion), shape (7,) goal_pose (npt.ArrayLike): Ending pose of the Astrobee (position and XYZW quaternion), shape (7,) debug (bool, optional): Whether to visualize the trajectories and rollouts during execution. Defaults to False. \"\"\" # Assign constants (TODO decide which of these should be inputs, if any) # Tracking controller gains kp = 20 kv = 5 kq = 1 kw = 0.1 # Penalty scales for deviations from the nominal trajectory # TODO refine these values!! totally different scales, and different impact on performance pos_penalty = 1 orn_penalty = 1 vel_penalty = 1 ang_vel_penalty = 1 # Sampling standard deviations for candidate replanning trajectories # TODO refine these values pos_stdev = 0.05 orn_stdev = 0.05 vel_stdev = 0.05 ang_vel_stdev = 0.05 accel_stdev = 0.05 alpha_stdev = 0.05 # Timestep (based on pybullet physics) dt = 1 / 350 # Number of steps to execute in a rollout n_rollout_steps = 350 # Number of trajectories to consider within an MPC iteration n_candidate_trajs = 5 # Tolerance on dynamics errors for determining if we've stopped the Astrobee # TODO figure out if these should be larger pos_tol = 1e-2 vel_tol = 1e-2 orn_tol = 1e-2 ang_vel_tol = 5e-3 client , robot , bag = init ( start_pose , use_gui = True ) tracking_controller = ForceTorqueController ( robot . id , robot . mass , robot . inertia , kp , kv , kq , kw , dt , client = client ) nominal_traj = global_planner ( start_pose [: 3 ], start_pose [ 3 :], goal_pose [: 3 ], goal_pose [ 3 :], dt , ) if debug : line_ids = nominal_traj . visualize ( 20 , client = client ) input ( \"Press Enter to continue\" ) remove_debug_objects ( line_ids , client ) # Add some buffer time to the end of the trajectory for stopping max_stopping_time = 3 # seconds max_steps = nominal_traj . num_timesteps + round ( max_stopping_time / dt ) end_idx = nominal_traj . num_timesteps - 1 cur_idx = 0 prev_accel = 0 # TODO improve this handling prev_alpha = 0 step_count = 0 # Each iteration of the loop will step the simulation by the number of rollout steps # This is because we don't need to replan every single simulation step while True : if step_count >= max_steps : print ( \"MAX STEPS EXCEEDED\" ) break state_id = client . saveState () pos , orn , vel , ang_vel = robot . dynamics_state if cur_idx == end_idx and stopping_criteria ( pos , orn , vel , ang_vel , nominal_traj . positions [ - 1 ], nominal_traj . quaternions [ - 1 ], pos_tol , orn_tol , vel_tol , ang_vel_tol , ): break costs = [] lookahead_idx = min ( cur_idx + n_rollout_steps , end_idx ) stop_at_end = lookahead_idx == end_idx # TODO need to figure out the number of steps in the generated trajectories # depending on if the robot should be stopping or not # TODO wondering if I should just have an entirely different mode for \"stopping\" # TODO MAKE SURE THAT THE STEP/CONTROL ALLOCATION WORKS WHEN STOPPING trajs = generate_trajs ( pos , orn , vel , ang_vel , prev_accel , prev_alpha , nominal_traj . positions [ lookahead_idx ], nominal_traj . quaternions [ lookahead_idx ], nominal_traj . linear_velocities [ lookahead_idx ], nominal_traj . angular_velocities [ lookahead_idx ], nominal_traj . linear_accels [ lookahead_idx ], nominal_traj . angular_accels [ lookahead_idx ], pos_stdev , orn_stdev , vel_stdev , ang_vel_stdev , accel_stdev , alpha_stdev , n_candidate_trajs , dt * ( lookahead_idx - cur_idx ), dt , include_nominal_traj = True , ) for traj in trajs : if debug : line_ids = traj . visualize ( 10 , client = client ) input ( \"Press Enter to continue\" ) remove_debug_objects ( line_ids , client ) # This is effectively a perfect rollout (TODO make this fact clearer) tracking_controller . follow_traj ( traj , stop_at_end , n_rollout_steps ) # TODO should we visualize the deviation in the trajectory? pos , orn , vel , ang_vel = robot . dynamics_state costs . append ( state_tracking_cost ( pos , orn , vel , ang_vel , nominal_traj . positions [ lookahead_idx ], nominal_traj . quaternions [ lookahead_idx ], nominal_traj . linear_velocities [ lookahead_idx ], nominal_traj . angular_velocities [ lookahead_idx ], pos_penalty , orn_penalty , vel_penalty , ang_vel_penalty , ) ) client . restoreState ( stateId = state_id ) best_traj = trajs [ np . argmin ( costs )] # Execute the best trajectory tracking_controller . follow_traj ( best_traj , stop_at_end ) # Update loop variables cur_idx = lookahead_idx step_count += n_rollout_steps prev_accel = best_traj . linear_accels [ - 1 ] prev_alpha = best_traj . angular_accels [ - 1 ] # TODO decide what to do once the main loop finishes? def _test_mpc ( debug = False ): start_pose = [ 0 , 0 , 0 , 0 , 0 , 0 , 1 ] end_pose = [ 6 , 0 , 0.2 , 0 , 0 , 0 , 1 ] # Easy-to-reach location in JPM mpc_main ( start_pose , end_pose , debug ) if __name__ == \"__main__\" : _test_mpc ( debug = False ) # _test_init() Functions init def init ( robot_pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], use_gui : bool = True ) -> tuple [ pybullet_utils . bullet_client . BulletClient , pyastrobee . core . astrobee . Astrobee , pyastrobee . core . deformable_bag . DeformableCargoBag ] Initialize the simulation environment with our assets Parameters: Name Type Description Default robot_pose npt.ArrayLike Initial pose of the Astrobee None use_gui bool Whether or not to launch the simulation in a GUI window. Defaults to True. True Returns: Type Description tuple[BulletClient, Astrobee, CargoBag] BulletClient: The Pybullet client Astrobee: The Astrobee object CargoBag: The Cargo Bag object View Source def init ( robot_pose : npt . ArrayLike , use_gui : bool = True ) -> tuple [ BulletClient , Astrobee , DeformableCargoBag ] : \"\"\"Initialize the simulation environment with our assets Args: robot_pose (npt.ArrayLike): Initial pose of the Astrobee use_gui (bool, optional): Whether or not to launch the simulation in a GUI window. Defaults to True. Returns: tuple[BulletClient, Astrobee, CargoBag]: BulletClient: The Pybullet client Astrobee: The Astrobee object CargoBag: The Cargo Bag object \"\"\" client = initialize_pybullet ( use_gui ) iss = ISS ( client = client ) robot = Astrobee ( robot_pose , client = client ) bag_mass = 10 bag = DeformableCargoBag ( \"top_handle\" , bag_mass , client = client ) bag . attach_to ( robot , object_to_move = \"bag\" ) return client , robot , bag mpc_main def mpc_main ( start_pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], goal_pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], debug : bool = False ) Launches the environment and runs a model-predictive-controller to move Astrobee between two poses while carrying a cargo bag Parameters: Name Type Description Default start_pose npt.ArrayLike Starting pose of the Astrobee (position and XYZW quaternion), shape (7,) None goal_pose npt.ArrayLike Ending pose of the Astrobee (position and XYZW quaternion), shape (7,) None debug bool Whether to visualize the trajectories and rollouts during execution. Defaults to False. False View Source def mpc_main ( start_pose : npt . ArrayLike , goal_pose : npt . ArrayLike , debug : bool = False , ) : \"\"\"Launches the environment and runs a model-predictive-controller to move Astrobee between two poses while carrying a cargo bag Args: start_pose (npt.ArrayLike): Starting pose of the Astrobee (position and XYZW quaternion), shape (7,) goal_pose (npt.ArrayLike): Ending pose of the Astrobee (position and XYZW quaternion), shape (7,) debug (bool, optional): Whether to visualize the trajectories and rollouts during execution. Defaults to False. \"\"\" # Assign constants ( TODO decide which of these should be inputs , if any ) # Tracking controller gains kp = 20 kv = 5 kq = 1 kw = 0.1 # Penalty scales for deviations from the nominal trajectory # TODO refine these values !! totally different scales , and different impact on performance pos_penalty = 1 orn_penalty = 1 vel_penalty = 1 ang_vel_penalty = 1 # Sampling standard deviations for candidate replanning trajectories # TODO refine these values pos_stdev = 0.05 orn_stdev = 0.05 vel_stdev = 0.05 ang_vel_stdev = 0.05 accel_stdev = 0.05 alpha_stdev = 0.05 # Timestep ( based on pybullet physics ) dt = 1 / 350 # Number of steps to execute in a rollout n_rollout_steps = 350 # Number of trajectories to consider within an MPC iteration n_candidate_trajs = 5 # Tolerance on dynamics errors for determining if we 've stopped the Astrobee # TODO figure out if these should be larger pos_tol = 1e-2 vel_tol = 1e-2 orn_tol = 1e-2 ang_vel_tol = 5e-3 client, robot, bag = init(start_pose, use_gui=True) tracking_controller = ForceTorqueController( robot.id, robot.mass, robot.inertia, kp, kv, kq, kw, dt, client=client ) nominal_traj = global_planner( start_pose[:3], start_pose[3:], goal_pose[:3], goal_pose[3:], dt, ) if debug: line_ids = nominal_traj.visualize(20, client=client) input(\"Press Enter to continue\") remove_debug_objects(line_ids, client) # Add some buffer time to the end of the trajectory for stopping max_stopping_time = 3 # seconds max_steps = nominal_traj.num_timesteps + round(max_stopping_time / dt) end_idx = nominal_traj.num_timesteps - 1 cur_idx = 0 prev_accel = 0 # TODO improve this handling prev_alpha = 0 step_count = 0 # Each iteration of the loop will step the simulation by the number of rollout steps # This is because we don' t need to replan every single simulation step while True : if step_count >= max_steps : print ( \"MAX STEPS EXCEEDED\" ) break state_id = client . saveState () pos , orn , vel , ang_vel = robot . dynamics_state if cur_idx == end_idx and stopping_criteria ( pos , orn , vel , ang_vel , nominal_traj . positions [ -1 ] , nominal_traj . quaternions [ -1 ] , pos_tol , orn_tol , vel_tol , ang_vel_tol , ) : break costs = [] lookahead_idx = min ( cur_idx + n_rollout_steps , end_idx ) stop_at_end = lookahead_idx == end_idx # TODO need to figure out the number of steps in the generated trajectories # depending on if the robot should be stopping or not # TODO wondering if I should just have an entirely different mode for \"stopping\" # TODO MAKE SURE THAT THE STEP / CONTROL ALLOCATION WORKS WHEN STOPPING trajs = generate_trajs ( pos , orn , vel , ang_vel , prev_accel , prev_alpha , nominal_traj . positions [ lookahead_idx ] , nominal_traj . quaternions [ lookahead_idx ] , nominal_traj . linear_velocities [ lookahead_idx ] , nominal_traj . angular_velocities [ lookahead_idx ] , nominal_traj . linear_accels [ lookahead_idx ] , nominal_traj . angular_accels [ lookahead_idx ] , pos_stdev , orn_stdev , vel_stdev , ang_vel_stdev , accel_stdev , alpha_stdev , n_candidate_trajs , dt * ( lookahead_idx - cur_idx ), dt , include_nominal_traj = True , ) for traj in trajs : if debug : line_ids = traj . visualize ( 10 , client = client ) input ( \"Press Enter to continue\" ) remove_debug_objects ( line_ids , client ) # This is effectively a perfect rollout ( TODO make this fact clearer ) tracking_controller . follow_traj ( traj , stop_at_end , n_rollout_steps ) # TODO should we visualize the deviation in the trajectory ? pos , orn , vel , ang_vel = robot . dynamics_state costs . append ( state_tracking_cost ( pos , orn , vel , ang_vel , nominal_traj . positions [ lookahead_idx ] , nominal_traj . quaternions [ lookahead_idx ] , nominal_traj . linear_velocities [ lookahead_idx ] , nominal_traj . angular_velocities [ lookahead_idx ] , pos_penalty , orn_penalty , vel_penalty , ang_vel_penalty , ) ) client . restoreState ( stateId = state_id ) best_traj = trajs [ np.argmin(costs) ] # Execute the best trajectory tracking_controller . follow_traj ( best_traj , stop_at_end ) # Update loop variables cur_idx = lookahead_idx step_count += n_rollout_steps prev_accel = best_traj . linear_accels [ -1 ] prev_alpha = best_traj . angular_accels [ -1 ] # TODO decide what to do once the main loop finishes ?","title":"Sampling Mpc"},{"location":"reference/pyastrobee/control/sampling_mpc/#module-pyastrobeecontrolsampling_mpc","text":"Sampling-based MPC with the simulator as the model (single-threaded version) See the multithreaded version for a better implementation so that the state save/resets don't occur in the same simulation View Source \"\"\"Sampling-based MPC with the simulator as the model (single-threaded version) See the multithreaded version for a better implementation so that the state save/resets don't occur in the same simulation \"\"\" from pybullet_utils.bullet_client import BulletClient import numpy as np import numpy.typing as npt from pyastrobee.core.astrobee import Astrobee from pyastrobee.core.deformable_bag import DeformableCargoBag from pyastrobee.core.iss import ISS from pyastrobee.utils.bullet_utils import initialize_pybullet from pyastrobee.trajectories.trajectory import stopping_criteria from pyastrobee.control.metrics import state_tracking_cost from pyastrobee.trajectories.planner import global_planner from pyastrobee.trajectories.sampling import generate_trajs from pyastrobee.control.force_torque_control import ForceTorqueController from pyastrobee.utils.debug_visualizer import remove_debug_objects def init ( robot_pose : npt . ArrayLike , use_gui : bool = True ) -> tuple [ BulletClient , Astrobee , DeformableCargoBag ]: \"\"\"Initialize the simulation environment with our assets Args: robot_pose (npt.ArrayLike): Initial pose of the Astrobee use_gui (bool, optional): Whether or not to launch the simulation in a GUI window. Defaults to True. Returns: tuple[BulletClient, Astrobee, CargoBag]: BulletClient: The Pybullet client Astrobee: The Astrobee object CargoBag: The Cargo Bag object \"\"\" client = initialize_pybullet ( use_gui ) iss = ISS ( client = client ) robot = Astrobee ( robot_pose , client = client ) bag_mass = 10 bag = DeformableCargoBag ( \"top_handle\" , bag_mass , client = client ) bag . attach_to ( robot , object_to_move = \"bag\" ) return client , robot , bag def mpc_main ( start_pose : npt . ArrayLike , goal_pose : npt . ArrayLike , debug : bool = False , ): \"\"\"Launches the environment and runs a model-predictive-controller to move Astrobee between two poses while carrying a cargo bag Args: start_pose (npt.ArrayLike): Starting pose of the Astrobee (position and XYZW quaternion), shape (7,) goal_pose (npt.ArrayLike): Ending pose of the Astrobee (position and XYZW quaternion), shape (7,) debug (bool, optional): Whether to visualize the trajectories and rollouts during execution. Defaults to False. \"\"\" # Assign constants (TODO decide which of these should be inputs, if any) # Tracking controller gains kp = 20 kv = 5 kq = 1 kw = 0.1 # Penalty scales for deviations from the nominal trajectory # TODO refine these values!! totally different scales, and different impact on performance pos_penalty = 1 orn_penalty = 1 vel_penalty = 1 ang_vel_penalty = 1 # Sampling standard deviations for candidate replanning trajectories # TODO refine these values pos_stdev = 0.05 orn_stdev = 0.05 vel_stdev = 0.05 ang_vel_stdev = 0.05 accel_stdev = 0.05 alpha_stdev = 0.05 # Timestep (based on pybullet physics) dt = 1 / 350 # Number of steps to execute in a rollout n_rollout_steps = 350 # Number of trajectories to consider within an MPC iteration n_candidate_trajs = 5 # Tolerance on dynamics errors for determining if we've stopped the Astrobee # TODO figure out if these should be larger pos_tol = 1e-2 vel_tol = 1e-2 orn_tol = 1e-2 ang_vel_tol = 5e-3 client , robot , bag = init ( start_pose , use_gui = True ) tracking_controller = ForceTorqueController ( robot . id , robot . mass , robot . inertia , kp , kv , kq , kw , dt , client = client ) nominal_traj = global_planner ( start_pose [: 3 ], start_pose [ 3 :], goal_pose [: 3 ], goal_pose [ 3 :], dt , ) if debug : line_ids = nominal_traj . visualize ( 20 , client = client ) input ( \"Press Enter to continue\" ) remove_debug_objects ( line_ids , client ) # Add some buffer time to the end of the trajectory for stopping max_stopping_time = 3 # seconds max_steps = nominal_traj . num_timesteps + round ( max_stopping_time / dt ) end_idx = nominal_traj . num_timesteps - 1 cur_idx = 0 prev_accel = 0 # TODO improve this handling prev_alpha = 0 step_count = 0 # Each iteration of the loop will step the simulation by the number of rollout steps # This is because we don't need to replan every single simulation step while True : if step_count >= max_steps : print ( \"MAX STEPS EXCEEDED\" ) break state_id = client . saveState () pos , orn , vel , ang_vel = robot . dynamics_state if cur_idx == end_idx and stopping_criteria ( pos , orn , vel , ang_vel , nominal_traj . positions [ - 1 ], nominal_traj . quaternions [ - 1 ], pos_tol , orn_tol , vel_tol , ang_vel_tol , ): break costs = [] lookahead_idx = min ( cur_idx + n_rollout_steps , end_idx ) stop_at_end = lookahead_idx == end_idx # TODO need to figure out the number of steps in the generated trajectories # depending on if the robot should be stopping or not # TODO wondering if I should just have an entirely different mode for \"stopping\" # TODO MAKE SURE THAT THE STEP/CONTROL ALLOCATION WORKS WHEN STOPPING trajs = generate_trajs ( pos , orn , vel , ang_vel , prev_accel , prev_alpha , nominal_traj . positions [ lookahead_idx ], nominal_traj . quaternions [ lookahead_idx ], nominal_traj . linear_velocities [ lookahead_idx ], nominal_traj . angular_velocities [ lookahead_idx ], nominal_traj . linear_accels [ lookahead_idx ], nominal_traj . angular_accels [ lookahead_idx ], pos_stdev , orn_stdev , vel_stdev , ang_vel_stdev , accel_stdev , alpha_stdev , n_candidate_trajs , dt * ( lookahead_idx - cur_idx ), dt , include_nominal_traj = True , ) for traj in trajs : if debug : line_ids = traj . visualize ( 10 , client = client ) input ( \"Press Enter to continue\" ) remove_debug_objects ( line_ids , client ) # This is effectively a perfect rollout (TODO make this fact clearer) tracking_controller . follow_traj ( traj , stop_at_end , n_rollout_steps ) # TODO should we visualize the deviation in the trajectory? pos , orn , vel , ang_vel = robot . dynamics_state costs . append ( state_tracking_cost ( pos , orn , vel , ang_vel , nominal_traj . positions [ lookahead_idx ], nominal_traj . quaternions [ lookahead_idx ], nominal_traj . linear_velocities [ lookahead_idx ], nominal_traj . angular_velocities [ lookahead_idx ], pos_penalty , orn_penalty , vel_penalty , ang_vel_penalty , ) ) client . restoreState ( stateId = state_id ) best_traj = trajs [ np . argmin ( costs )] # Execute the best trajectory tracking_controller . follow_traj ( best_traj , stop_at_end ) # Update loop variables cur_idx = lookahead_idx step_count += n_rollout_steps prev_accel = best_traj . linear_accels [ - 1 ] prev_alpha = best_traj . angular_accels [ - 1 ] # TODO decide what to do once the main loop finishes? def _test_mpc ( debug = False ): start_pose = [ 0 , 0 , 0 , 0 , 0 , 0 , 1 ] end_pose = [ 6 , 0 , 0.2 , 0 , 0 , 0 , 1 ] # Easy-to-reach location in JPM mpc_main ( start_pose , end_pose , debug ) if __name__ == \"__main__\" : _test_mpc ( debug = False ) # _test_init()","title":"Module pyastrobee.control.sampling_mpc"},{"location":"reference/pyastrobee/control/sampling_mpc/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/control/sampling_mpc/#init","text":"def init ( robot_pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], use_gui : bool = True ) -> tuple [ pybullet_utils . bullet_client . BulletClient , pyastrobee . core . astrobee . Astrobee , pyastrobee . core . deformable_bag . DeformableCargoBag ] Initialize the simulation environment with our assets Parameters: Name Type Description Default robot_pose npt.ArrayLike Initial pose of the Astrobee None use_gui bool Whether or not to launch the simulation in a GUI window. Defaults to True. True Returns: Type Description tuple[BulletClient, Astrobee, CargoBag] BulletClient: The Pybullet client Astrobee: The Astrobee object CargoBag: The Cargo Bag object View Source def init ( robot_pose : npt . ArrayLike , use_gui : bool = True ) -> tuple [ BulletClient , Astrobee , DeformableCargoBag ] : \"\"\"Initialize the simulation environment with our assets Args: robot_pose (npt.ArrayLike): Initial pose of the Astrobee use_gui (bool, optional): Whether or not to launch the simulation in a GUI window. Defaults to True. Returns: tuple[BulletClient, Astrobee, CargoBag]: BulletClient: The Pybullet client Astrobee: The Astrobee object CargoBag: The Cargo Bag object \"\"\" client = initialize_pybullet ( use_gui ) iss = ISS ( client = client ) robot = Astrobee ( robot_pose , client = client ) bag_mass = 10 bag = DeformableCargoBag ( \"top_handle\" , bag_mass , client = client ) bag . attach_to ( robot , object_to_move = \"bag\" ) return client , robot , bag","title":"init"},{"location":"reference/pyastrobee/control/sampling_mpc/#mpc_main","text":"def mpc_main ( start_pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], goal_pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], debug : bool = False ) Launches the environment and runs a model-predictive-controller to move Astrobee between two poses while carrying a cargo bag Parameters: Name Type Description Default start_pose npt.ArrayLike Starting pose of the Astrobee (position and XYZW quaternion), shape (7,) None goal_pose npt.ArrayLike Ending pose of the Astrobee (position and XYZW quaternion), shape (7,) None debug bool Whether to visualize the trajectories and rollouts during execution. Defaults to False. False View Source def mpc_main ( start_pose : npt . ArrayLike , goal_pose : npt . ArrayLike , debug : bool = False , ) : \"\"\"Launches the environment and runs a model-predictive-controller to move Astrobee between two poses while carrying a cargo bag Args: start_pose (npt.ArrayLike): Starting pose of the Astrobee (position and XYZW quaternion), shape (7,) goal_pose (npt.ArrayLike): Ending pose of the Astrobee (position and XYZW quaternion), shape (7,) debug (bool, optional): Whether to visualize the trajectories and rollouts during execution. Defaults to False. \"\"\" # Assign constants ( TODO decide which of these should be inputs , if any ) # Tracking controller gains kp = 20 kv = 5 kq = 1 kw = 0.1 # Penalty scales for deviations from the nominal trajectory # TODO refine these values !! totally different scales , and different impact on performance pos_penalty = 1 orn_penalty = 1 vel_penalty = 1 ang_vel_penalty = 1 # Sampling standard deviations for candidate replanning trajectories # TODO refine these values pos_stdev = 0.05 orn_stdev = 0.05 vel_stdev = 0.05 ang_vel_stdev = 0.05 accel_stdev = 0.05 alpha_stdev = 0.05 # Timestep ( based on pybullet physics ) dt = 1 / 350 # Number of steps to execute in a rollout n_rollout_steps = 350 # Number of trajectories to consider within an MPC iteration n_candidate_trajs = 5 # Tolerance on dynamics errors for determining if we 've stopped the Astrobee # TODO figure out if these should be larger pos_tol = 1e-2 vel_tol = 1e-2 orn_tol = 1e-2 ang_vel_tol = 5e-3 client, robot, bag = init(start_pose, use_gui=True) tracking_controller = ForceTorqueController( robot.id, robot.mass, robot.inertia, kp, kv, kq, kw, dt, client=client ) nominal_traj = global_planner( start_pose[:3], start_pose[3:], goal_pose[:3], goal_pose[3:], dt, ) if debug: line_ids = nominal_traj.visualize(20, client=client) input(\"Press Enter to continue\") remove_debug_objects(line_ids, client) # Add some buffer time to the end of the trajectory for stopping max_stopping_time = 3 # seconds max_steps = nominal_traj.num_timesteps + round(max_stopping_time / dt) end_idx = nominal_traj.num_timesteps - 1 cur_idx = 0 prev_accel = 0 # TODO improve this handling prev_alpha = 0 step_count = 0 # Each iteration of the loop will step the simulation by the number of rollout steps # This is because we don' t need to replan every single simulation step while True : if step_count >= max_steps : print ( \"MAX STEPS EXCEEDED\" ) break state_id = client . saveState () pos , orn , vel , ang_vel = robot . dynamics_state if cur_idx == end_idx and stopping_criteria ( pos , orn , vel , ang_vel , nominal_traj . positions [ -1 ] , nominal_traj . quaternions [ -1 ] , pos_tol , orn_tol , vel_tol , ang_vel_tol , ) : break costs = [] lookahead_idx = min ( cur_idx + n_rollout_steps , end_idx ) stop_at_end = lookahead_idx == end_idx # TODO need to figure out the number of steps in the generated trajectories # depending on if the robot should be stopping or not # TODO wondering if I should just have an entirely different mode for \"stopping\" # TODO MAKE SURE THAT THE STEP / CONTROL ALLOCATION WORKS WHEN STOPPING trajs = generate_trajs ( pos , orn , vel , ang_vel , prev_accel , prev_alpha , nominal_traj . positions [ lookahead_idx ] , nominal_traj . quaternions [ lookahead_idx ] , nominal_traj . linear_velocities [ lookahead_idx ] , nominal_traj . angular_velocities [ lookahead_idx ] , nominal_traj . linear_accels [ lookahead_idx ] , nominal_traj . angular_accels [ lookahead_idx ] , pos_stdev , orn_stdev , vel_stdev , ang_vel_stdev , accel_stdev , alpha_stdev , n_candidate_trajs , dt * ( lookahead_idx - cur_idx ), dt , include_nominal_traj = True , ) for traj in trajs : if debug : line_ids = traj . visualize ( 10 , client = client ) input ( \"Press Enter to continue\" ) remove_debug_objects ( line_ids , client ) # This is effectively a perfect rollout ( TODO make this fact clearer ) tracking_controller . follow_traj ( traj , stop_at_end , n_rollout_steps ) # TODO should we visualize the deviation in the trajectory ? pos , orn , vel , ang_vel = robot . dynamics_state costs . append ( state_tracking_cost ( pos , orn , vel , ang_vel , nominal_traj . positions [ lookahead_idx ] , nominal_traj . quaternions [ lookahead_idx ] , nominal_traj . linear_velocities [ lookahead_idx ] , nominal_traj . angular_velocities [ lookahead_idx ] , pos_penalty , orn_penalty , vel_penalty , ang_vel_penalty , ) ) client . restoreState ( stateId = state_id ) best_traj = trajs [ np.argmin(costs) ] # Execute the best trajectory tracking_controller . follow_traj ( best_traj , stop_at_end ) # Update loop variables cur_idx = lookahead_idx step_count += n_rollout_steps prev_accel = best_traj . linear_accels [ -1 ] prev_alpha = best_traj . angular_accels [ -1 ] # TODO decide what to do once the main loop finishes ?","title":"mpc_main"},{"location":"reference/pyastrobee/control/sampling_mpc_multithreaded/","text":"Module pyastrobee.control.sampling_mpc_multithreaded Sampling-based MPC with the simulator as the model (multi-threaded version) We create three different types of environments: 1: The main simulation 2: One parallel environment which evaluates the \"nominal\" trajectory 3: Other parallel environments which evaluate deviations on the nominal value When debugging, we visualize the nominal parallel environment as well, and show the trajectory rollout plan View Source \"\"\"Sampling-based MPC with the simulator as the model (multi-threaded version) We create three different types of environments: 1: The main simulation 2: One parallel environment which evaluates the \"nominal\" trajectory 3: Other parallel environments which evaluate deviations on the nominal value When debugging, we visualize the nominal parallel environment as well, and show the trajectory rollout plan \"\"\" # Note: This is pretty slow # There are definitely smarter ways of doing sampling-based nonlinear MPC (or SCP nonlinear MPC), # and better simulators to use if parallelization is the goal (Issac gym, Mujoco MJX, Genesis, ...) # This was just the original design approach I took as a first-stab at the problem from pathlib import Path from datetime import datetime from typing import Optional import numpy as np import numpy.typing as npt from stable_baselines3.common.env_util import DummyVecEnv , SubprocVecEnv from pyastrobee.core.deformable_bag import DeformableCargoBag from pyastrobee.core.constraint_bag import ConstraintCargoBag from pyastrobee.core.environments import AstrobeeMPCEnv , make_vec_env from pyastrobee.trajectories.trajectory import Trajectory from pyastrobee.trajectories.planner import global_planner from pyastrobee.trajectories.arm_planner import plan_arm_traj from pyastrobee.utils.python_utils import print_red , print_green from pyastrobee.utils.video_concatenation import concatenate_videos # Recording parameters RECORD_MAIN_ENV = False RECORD_DEBUG_ENV = True MAIN_VIDEO_DIRECTORY = ( f \"artifacts/ { Path ( __file__ ) . stem } _ { datetime . now () . strftime ( '%Y%m %d _%H%M%S_ %f ' ) } /\" ) DEBUG_VIDEO_DIRECTORY = MAIN_VIDEO_DIRECTORY . rstrip ( \"/\" ) + \"_debug/\" # Debug visualizer camera parameters: Dist, yaw, pitch, target NODE_2_VIEW = ( 1.40 , - 69.60 , - 19.00 , ( 0.55 , 0.00 , - 0.39 )) JPM_VIEW = ( 1.00 , 64.40 , - 12.20 , ( 6.44 , - 0.39 , 0.07 )) EXTERNAL_VIEW = ( 9.20 , 49.60 , - 9.80 , ( - 1.07 , - 1.53 , - 0.41 )) def parallel_mpc_main ( start_pose : npt . ArrayLike , goal_pose : npt . ArrayLike , n_vec_envs : int , bag_name : str = \"top_handle\" , bag_mass : float = 10 , use_deformable_primary_sim : bool = True , use_deformable_rollouts : bool = False , debug : bool = False , random_seed : Optional [ int ] = None , ): \"\"\"Launches a series of environments in parallel and runs a model-predictive-controller to move Astrobee between two poses while carrying a cargo bag Args: start_pose (npt.ArrayLike): Starting pose of the Astrobee (position and XYZW quaternion), shape (7,) goal_pose (npt.ArrayLike): Ending pose of the Astrobee (position and XYZW quaternion), shape (7,) n_vec_envs (int): Number of vectorized environments to launch in parallel (>= 1) bag_name (str, optional): Type of cargo bag to load. Defaults to \"top_handle\". bag_mass (float): Mass of the cargo bag, in kg. Defaults to 10 use_deformable_primary_sim (bool, optional): Whether to load the deformable bag in the main simulation env. Defaults to True (load the deformable version) use_deformable_rollouts (bool, optional): Whether to use the deformable bag for rollouts. Defaults to False (perform rollouts with the simplified rigid bag) debug (bool, optional): Whether to launch one of the vectorized environments with the GUI active, to visualize some of the rollouts being evaluated. Defaults to False. random_seed (Optional[int]): Seed for the random number generator, if desired. Defaults to None (unseeded) \"\"\" if n_vec_envs < 1 : raise ValueError ( \"Must have at least one environment for evaluating rollouts\" ) # Set up main environment main_env = AstrobeeMPCEnv ( use_gui = True , is_primary = True , robot_pose = start_pose , bag_name = bag_name , bag_mass = bag_mass , bag_type = ( DeformableCargoBag if use_deformable_primary_sim else ConstraintCargoBag ), load_full_iss = True , ) # Set up vectorized environments env_kwargs = { \"use_gui\" : False , \"is_primary\" : False , \"robot_pose\" : start_pose , \"bag_name\" : bag_name , \"bag_mass\" : bag_mass , \"bag_type\" : ( DeformableCargoBag if use_deformable_rollouts else ConstraintCargoBag ), # We need the full ISS loaded if using deformable rollouts so save/restore state sees the same envs \"load_full_iss\" : use_deformable_rollouts , } debug_env_idx = 0 # Enable GUI for one of the vec envs if debugging, and use this to test the nominal (non-sampled) trajs per_env_kwargs = { debug_env_idx : { \"use_gui\" : debug , \"nominal_rollouts\" : True }} vec_env = make_vec_env ( AstrobeeMPCEnv , n_vec_envs , random_seed , env_kwargs = env_kwargs , vec_env_cls = SubprocVecEnv if n_vec_envs > 1 else DummyVecEnv , per_env_kwargs = per_env_kwargs , ) main_env . reset ( random_seed ) vec_env . seed ( random_seed ) vec_env . reset () # Random seed included in make_vec_env # Generate nominal trajectory dt = main_env . client . getPhysicsEngineParameters ()[ \"fixedTimeStep\" ] nominal_traj = global_planner ( start_pose [: 3 ], start_pose [ 3 :], goal_pose [: 3 ], goal_pose [ 3 :], dt , ) nominal_arm_traj = plan_arm_traj ( nominal_traj ) # Store the goal pose to determine stopping criteria # TODO should this instead be an input to the environment? # TODO it seems like this doesn't actually work properly main_env . goal_pose = goal_pose vec_env . set_attr ( \"goal_pose\" , goal_pose ) video_index = 0 camera_moved = False if RECORD_MAIN_ENV or RECORD_DEBUG_ENV : main_env . client . resetDebugVisualizerCamera ( * NODE_2_VIEW ) vec_env . env_method ( \"send_client_command\" , \"resetDebugVisualizerCamera\" , * NODE_2_VIEW , indices = [ debug_env_idx ], ) # main_env.client.resetDebugVisualizerCamera(*EXTERNAL_VIEW) print ( \"Ready to record video. Remember to maximize the GUI\" ) main_path = Path ( MAIN_VIDEO_DIRECTORY ) debug_path = Path ( DEBUG_VIDEO_DIRECTORY ) if ( main_path . exists () and RECORD_MAIN_ENV ) or ( debug_path . exists and RECORD_DEBUG_ENV ): print_red ( \"WARNING: Recording video will overwrite existing files\" ) # TODO decide if we should empty the directory/directories input ( \"Press Enter to begin\" ) if RECORD_MAIN_ENV : main_path . mkdir ( parents = True , exist_ok = True ) if RECORD_DEBUG_ENV : debug_path . mkdir ( parents = True , exist_ok = True ) # Time parameters (TODO make some of these inputs?) cur_time = 0.0 traj_end_time = nominal_traj . times [ - 1 ] max_stopping_time = 30 # seconds max_time = traj_end_time + max_stopping_time rollout_duration = 5 # seconds execution_duration = 1 # seconds (How much of the rollout to actually execute) # TEMP, TESTING. IMPROVE THIS main_env . set_planning_duration ( rollout_duration ) vec_env . env_method ( \"set_planning_duration\" , rollout_duration ) # State machine mode = AstrobeeMPCEnv . FlightStates . NOMINAL point_ids = None cur_idx = 0 # Execute the main MPC code in a try/finally block to make sure things close out / clean up when done try : while True : # TODO handle the stopping mode better... Should we be \"stopping\" if the rollout or planned execution # reaches the end of the trajectory? Or just when we've fully reached the end? # Determine the duration of the rollout and where on the trajectory we are interested remaining_traj_time = traj_end_time - cur_time remaining_total_time = max_time - cur_time out_of_time = remaining_total_time <= dt # Update our flight state machine (TODO improve logic, make separate method) if ( remaining_traj_time <= rollout_duration and mode == AstrobeeMPCEnv . FlightStates . NOMINAL ): # Update this flag in our environments only once, when this changes print ( \"Setting flight state to SLOWING\" ) main_env . set_flight_state ( AstrobeeMPCEnv . FlightStates . SLOWING ) vec_env . env_method ( \"set_flight_state\" , AstrobeeMPCEnv . FlightStates . SLOWING ) mode = AstrobeeMPCEnv . FlightStates . SLOWING if ( remaining_traj_time <= dt and mode != AstrobeeMPCEnv . FlightStates . STOPPING ): # Update this flag in our environments only once, when this changes print ( \"Setting flight state to STOPPING\" ) main_env . set_flight_state ( AstrobeeMPCEnv . FlightStates . STOPPING ) vec_env . env_method ( \"set_flight_state\" , AstrobeeMPCEnv . FlightStates . STOPPING ) mode = AstrobeeMPCEnv . FlightStates . STOPPING if out_of_time : print_red ( \"Terminating due to time limit\" ) break if mode in { AstrobeeMPCEnv . FlightStates . SLOWING , AstrobeeMPCEnv . FlightStates . STOPPING , }: lookahead_idx = - 1 else : lookahead_idx = np . searchsorted ( nominal_traj . times , cur_time + rollout_duration ) # Clear any previously visualized trajectories before viewing the new plan if debug : vec_env . env_method ( \"unshow_traj_plan\" , indices = [ debug_env_idx ]) if point_ids is not None : for pid in point_ids : vec_env . env_method ( \"send_client_command\" , \"removeUserDebugItem\" , pid ) # THIS IS WEIRD # The thinking here is that when we are slowing down we might have a plan that we will get to our goal in # like 2 seconds even if the rollout duration is 5 seconds target_duration = min ( max ( 0 , remaining_traj_time ), rollout_duration ) # Set the desired state of the robot at the lookahead point target_state = [ nominal_traj . positions [ lookahead_idx ], nominal_traj . quaternions [ lookahead_idx ], nominal_traj . linear_velocities [ lookahead_idx ], nominal_traj . angular_velocities [ lookahead_idx ], nominal_traj . linear_accels [ lookahead_idx ], nominal_traj . angular_accels [ lookahead_idx ], target_duration , ] main_env . set_target_state ( * target_state ) vec_env . env_method ( \"set_target_state\" , * target_state ) # Generate sampled trajectories within each vec env vec_env . env_method ( \"sample_trajectory\" ) # HACK n = vec_env . get_attr ( \"traj_plan\" , [ 0 ])[ 0 ] . num_timesteps # Handle arm traj arm_traj_plan = nominal_arm_traj . get_segment ( cur_idx , cur_idx + n ) # main_env.set_arm_traj(arm_traj_plan) vec_env . env_method ( \"set_arm_traj\" , arm_traj_plan ) if debug : env_state_samples = vec_env . get_attr ( \"sampled_end_state\" ) env_poss = [ s [ 0 ] for s in env_state_samples ] point_ids = vec_env . env_method ( \"send_client_command\" , \"addUserDebugPoints\" , env_poss , [[ 1 , 1 , 1 ]] * len ( env_poss ), 10 , 0 , indices = [ debug_env_idx ], ) vec_env . env_method ( \"show_traj_plan\" , 10 , indices = [ debug_env_idx ]) # Stepping in the vec env will follow the sampled trajectory # Action input in step(actions) is a dummy parameter for now, just for Gym compatibility if RECORD_DEBUG_ENV : debug_log_id = vec_env . env_method ( \"send_client_command\" , \"startStateLogging\" , main_env . client . STATE_LOGGING_VIDEO_MP4 , f \" { DEBUG_VIDEO_DIRECTORY }{ video_index } .mp4\" , indices = [ debug_env_idx ], )[ 0 ] env_obs , env_rewards , env_dones , env_infos = vec_env . step ( np . zeros ( n_vec_envs ) ) if RECORD_DEBUG_ENV : vec_env . env_method ( \"send_client_command\" , \"stopStateLogging\" , debug_log_id , indices = [ debug_env_idx ], ) video_index += 1 best_traj : Trajectory = vec_env . get_attr ( \"traj_plan\" , [ int ( np . argmax ( env_rewards ))] )[ 0 ] # Follow the best rollout in the main environment. (Use dummy action value in step call) n_execution_timesteps = int ( best_traj . num_timesteps * ( execution_duration / rollout_duration ) ) # print(\"N EXECUTION TIMESTEPS: \", n_execution_timesteps) # print(\"N ROLLOUT TIMESTEPS: \", lookahead_idx - cur_idx) # print(\"CUR IDX: \", cur_idx) main_env . traj_plan = best_traj . get_segment ( 0 , n_execution_timesteps ) main_env . set_arm_traj ( nominal_arm_traj . get_segment ( cur_idx , cur_idx + n_execution_timesteps ) ) if RECORD_MAIN_ENV : main_log_id = main_env . client . startStateLogging ( main_env . client . STATE_LOGGING_VIDEO_MP4 , f \" { MAIN_VIDEO_DIRECTORY }{ video_index } .mp4\" , ) ( main_obs , main_reward , main_terminated , main_truncated , main_info , ) = main_env . step ( 0 ) if RECORD_MAIN_ENV : main_env . client . stopStateLogging ( main_log_id ) video_index += 1 robot_state , bag_state = main_obs # Update our knowledge of the last acceleration commands main_env . last_accel_cmd = best_traj . linear_accels [ - 1 ] main_env . last_alpha_cmd = best_traj . angular_accels [ - 1 ] vec_env . set_attr ( \"last_accel_cmd\" , best_traj . linear_accels [ - 1 ]) vec_env . set_attr ( \"last_alpha_cmd\" , best_traj . angular_accels [ - 1 ]) # Update our time information cur_time += execution_duration # TODO should the cur_time value actually be times[cur_idx]???? cur_idx += n_execution_timesteps # Update the camera if we're taking video. These are hardcoded for the JPM motion # Switch cameras when the robot base passes x = 2.5 if ( ( RECORD_MAIN_ENV or RECORD_DEBUG_ENV ) and not camera_moved and robot_state [ 0 ][ 0 ] >= 2.5 ): main_env . client . resetDebugVisualizerCamera ( * JPM_VIEW ) vec_env . env_method ( \"send_client_command\" , \"resetDebugVisualizerCamera\" , * JPM_VIEW ) camera_moved = True # Check if we've successfully completed the trajectory if main_terminated : print_green ( \"Success! Stabilized at end of trajectory within tolerance\" ) break # We are not done, so reset the environments back to the same point as the main env # Ensure that the vec envs start from the same point as the main simulation if use_deformable_rollouts : # If we are using the deformable bag for rollouts, we have to fully save the state to disk (slow) # because there is no other way to restore the deformable saved_file = main_env . save_state () vec_env . env_method ( \"restore_state\" , saved_file ) else : # If we're using the simple rigid bag for rollouts, we can just do a very simple reset mechanic vec_env . env_method ( \"reset_robot_state\" , robot_state ) vec_env . env_method ( \"reset_bag_state\" , bag_state ) input ( \"Complete. Press Enter to exit\" ) finally : if RECORD_MAIN_ENV : concatenate_videos ( MAIN_VIDEO_DIRECTORY , cleanup = True ) if RECORD_DEBUG_ENV : concatenate_videos ( DEBUG_VIDEO_DIRECTORY , cleanup = True ) print ( \"Closing environments\" ) main_env . close () vec_env . close () def _test_node_2_to_jpm (): \"\"\"Quick function to test that the parallel MPC is working as expected\"\"\" random_seed = 0 np . random . seed ( random_seed ) start_pose = [ 0 , 0 , 0 , 0 , 0 , 0 , 1 ] end_pose = [ 6 , 0 , 0.2 , 0 , 0 , 0 , 1 ] # Easy-to-reach location in JPM bag_name = \"top_handle_symmetric\" bag_mass = 10 n_vec_envs = 10 debug = True use_deformable_main_sim = True use_deformable_rollouts = False parallel_mpc_main ( start_pose , end_pose , n_vec_envs , bag_name , bag_mass , use_deformable_main_sim , use_deformable_rollouts , debug , random_seed , ) def _test_jpm_to_us_lab (): \"\"\"Quick function to test that the parallel MPC is working as expected\"\"\" random_seed = 0 np . random . seed ( random_seed ) start_pose = [ 6 , 0 , 0.2 , 0 , 0 , 1 , 0 ] # JPM end_pose = [ - 0.063 , - 8.5355 , 0 , 0 , 0 , - np . sqrt ( 2 ) / 2 , np . sqrt ( 2 ) / 2 ] # US bag_name = \"top_handle_symmetric\" bag_mass = 10 n_vec_envs = 10 debug = True use_deformable_main_sim = True use_deformable_rollouts = False parallel_mpc_main ( start_pose , end_pose , n_vec_envs , bag_name , bag_mass , use_deformable_main_sim , use_deformable_rollouts , debug , random_seed , ) if __name__ == \"__main__\" : # _test_node_2_to_jpm() _test_jpm_to_us_lab () Variables DEBUG_VIDEO_DIRECTORY EXTERNAL_VIEW JPM_VIEW MAIN_VIDEO_DIRECTORY NODE_2_VIEW RECORD_DEBUG_ENV RECORD_MAIN_ENV Functions parallel_mpc_main def parallel_mpc_main ( start_pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], goal_pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], n_vec_envs : int , bag_name : str = 'top_handle' , bag_mass : float = 10 , use_deformable_primary_sim : bool = True , use_deformable_rollouts : bool = False , debug : bool = False , random_seed : Optional [ int ] = None ) Launches a series of environments in parallel and runs a model-predictive-controller to move Astrobee between two poses while carrying a cargo bag Parameters: Name Type Description Default start_pose npt.ArrayLike Starting pose of the Astrobee (position and XYZW quaternion), shape (7,) None goal_pose npt.ArrayLike Ending pose of the Astrobee (position and XYZW quaternion), shape (7,) None n_vec_envs int Number of vectorized environments to launch in parallel (>= 1) None bag_name str Type of cargo bag to load. Defaults to \"top_handle\". \"top_handle\" bag_mass float Mass of the cargo bag, in kg. Defaults to 10 None use_deformable_primary_sim bool Whether to load the deformable bag in the main simulation env. Defaults to True (load the deformable version) None use_deformable_rollouts bool Whether to use the deformable bag for rollouts. Defaults to False (perform rollouts with the simplified rigid bag) None debug bool Whether to launch one of the vectorized environments with the GUI active, to visualize some of the rollouts being evaluated. Defaults to False. None random_seed Optional[int] Seed for the random number generator, if desired. Defaults to None (unseeded) None View Source def parallel_mpc_main ( start_pose : npt . ArrayLike , goal_pose : npt . ArrayLike , n_vec_envs : int , bag_name : str = \"top_handle\" , bag_mass : float = 10 , use_deformable_primary_sim : bool = True , use_deformable_rollouts : bool = False , debug : bool = False , random_seed : Optional [ int ] = None , ) : \"\"\"Launches a series of environments in parallel and runs a model-predictive-controller to move Astrobee between two poses while carrying a cargo bag Args: start_pose (npt.ArrayLike): Starting pose of the Astrobee (position and XYZW quaternion), shape (7,) goal_pose (npt.ArrayLike): Ending pose of the Astrobee (position and XYZW quaternion), shape (7,) n_vec_envs (int): Number of vectorized environments to launch in parallel (>= 1) bag_name (str, optional): Type of cargo bag to load. Defaults to \" top_handle \". bag_mass (float): Mass of the cargo bag, in kg. Defaults to 10 use_deformable_primary_sim (bool, optional): Whether to load the deformable bag in the main simulation env. Defaults to True (load the deformable version) use_deformable_rollouts (bool, optional): Whether to use the deformable bag for rollouts. Defaults to False (perform rollouts with the simplified rigid bag) debug (bool, optional): Whether to launch one of the vectorized environments with the GUI active, to visualize some of the rollouts being evaluated. Defaults to False. random_seed (Optional[int]): Seed for the random number generator, if desired. Defaults to None (unseeded) \"\"\" if n_vec_envs < 1 : raise ValueError ( \"Must have at least one environment for evaluating rollouts\" ) # Set up main environment main_env = AstrobeeMPCEnv ( use_gui = True , is_primary = True , robot_pose = start_pose , bag_name = bag_name , bag_mass = bag_mass , bag_type = ( DeformableCargoBag if use_deformable_primary_sim else ConstraintCargoBag ), load_full_iss = True , ) # Set up vectorized environments env_kwargs = { \"use_gui\" : False , \"is_primary\" : False , \"robot_pose\" : start_pose , \"bag_name\" : bag_name , \"bag_mass\" : bag_mass , \"bag_type\" : ( DeformableCargoBag if use_deformable_rollouts else ConstraintCargoBag ), # We need the full ISS loaded if using deformable rollouts so save / restore state sees the same envs \"load_full_iss\" : use_deformable_rollouts , } debug_env_idx = 0 # Enable GUI for one of the vec envs if debugging , and use this to test the nominal ( non - sampled ) trajs per_env_kwargs = { debug_env_idx : { \"use_gui\" : debug , \"nominal_rollouts\" : True }} vec_env = make_vec_env ( AstrobeeMPCEnv , n_vec_envs , random_seed , env_kwargs = env_kwargs , vec_env_cls = SubprocVecEnv if n_vec_envs > 1 else DummyVecEnv , per_env_kwargs = per_env_kwargs , ) main_env . reset ( random_seed ) vec_env . seed ( random_seed ) vec_env . reset () # Random seed included in make_vec_env # Generate nominal trajectory dt = main_env . client . getPhysicsEngineParameters () [ \"fixedTimeStep\" ] nominal_traj = global_planner ( start_pose [ :3 ] , start_pose [ 3: ] , goal_pose [ :3 ] , goal_pose [ 3: ] , dt , ) nominal_arm_traj = plan_arm_traj ( nominal_traj ) # Store the goal pose to determine stopping criteria # TODO should this instead be an input to the environment ? # TODO it seems like this doesn 't actually work properly main_env.goal_pose = goal_pose vec_env.set_attr(\"goal_pose\", goal_pose) video_index = 0 camera_moved = False if RECORD_MAIN_ENV or RECORD_DEBUG_ENV: main_env.client.resetDebugVisualizerCamera(*NODE_2_VIEW) vec_env.env_method( \"send_client_command\", \"resetDebugVisualizerCamera\", *NODE_2_VIEW, indices=[debug_env_idx], ) # main_env.client.resetDebugVisualizerCamera(*EXTERNAL_VIEW) print(\"Ready to record video. Remember to maximize the GUI\") main_path = Path(MAIN_VIDEO_DIRECTORY) debug_path = Path(DEBUG_VIDEO_DIRECTORY) if (main_path.exists() and RECORD_MAIN_ENV) or ( debug_path.exists and RECORD_DEBUG_ENV ): print_red(\"WARNING: Recording video will overwrite existing files\") # TODO decide if we should empty the directory/directories input(\"Press Enter to begin\") if RECORD_MAIN_ENV: main_path.mkdir(parents=True, exist_ok=True) if RECORD_DEBUG_ENV: debug_path.mkdir(parents=True, exist_ok=True) # Time parameters (TODO make some of these inputs?) cur_time = 0.0 traj_end_time = nominal_traj.times[-1] max_stopping_time = 30 # seconds max_time = traj_end_time + max_stopping_time rollout_duration = 5 # seconds execution_duration = 1 # seconds (How much of the rollout to actually execute) # TEMP, TESTING. IMPROVE THIS main_env.set_planning_duration(rollout_duration) vec_env.env_method(\"set_planning_duration\", rollout_duration) # State machine mode = AstrobeeMPCEnv.FlightStates.NOMINAL point_ids = None cur_idx = 0 # Execute the main MPC code in a try/finally block to make sure things close out / clean up when done try: while True: # TODO handle the stopping mode better... Should we be \"stopping\" if the rollout or planned execution # reaches the end of the trajectory? Or just when we' ve fully reached the end ? # Determine the duration of the rollout and where on the trajectory we are interested remaining_traj_time = traj_end_time - cur_time remaining_total_time = max_time - cur_time out_of_time = remaining_total_time <= dt # Update our flight state machine ( TODO improve logic , make separate method ) if ( remaining_traj_time <= rollout_duration and mode == AstrobeeMPCEnv . FlightStates . NOMINAL ) : # Update this flag in our environments only once , when this changes print ( \"Setting flight state to SLOWING\" ) main_env . set_flight_state ( AstrobeeMPCEnv . FlightStates . SLOWING ) vec_env . env_method ( \"set_flight_state\" , AstrobeeMPCEnv . FlightStates . SLOWING ) mode = AstrobeeMPCEnv . FlightStates . SLOWING if ( remaining_traj_time <= dt and mode != AstrobeeMPCEnv . FlightStates . STOPPING ) : # Update this flag in our environments only once , when this changes print ( \"Setting flight state to STOPPING\" ) main_env . set_flight_state ( AstrobeeMPCEnv . FlightStates . STOPPING ) vec_env . env_method ( \"set_flight_state\" , AstrobeeMPCEnv . FlightStates . STOPPING ) mode = AstrobeeMPCEnv . FlightStates . STOPPING if out_of_time : print_red ( \"Terminating due to time limit\" ) break if mode in { AstrobeeMPCEnv . FlightStates . SLOWING , AstrobeeMPCEnv . FlightStates . STOPPING , }: lookahead_idx = - 1 else : lookahead_idx = np . searchsorted ( nominal_traj . times , cur_time + rollout_duration ) # Clear any previously visualized trajectories before viewing the new plan if debug : vec_env . env_method ( \"unshow_traj_plan\" , indices =[ debug_env_idx ] ) if point_ids is not None : for pid in point_ids : vec_env . env_method ( \"send_client_command\" , \"removeUserDebugItem\" , pid ) # THIS IS WEIRD # The thinking here is that when we are slowing down we might have a plan that we will get to our goal in # like 2 seconds even if the rollout duration is 5 seconds target_duration = min ( max ( 0 , remaining_traj_time ), rollout_duration ) # Set the desired state of the robot at the lookahead point target_state = [ nominal_traj.positions[lookahead_idx ] , nominal_traj . quaternions [ lookahead_idx ] , nominal_traj . linear_velocities [ lookahead_idx ] , nominal_traj . angular_velocities [ lookahead_idx ] , nominal_traj . linear_accels [ lookahead_idx ] , nominal_traj . angular_accels [ lookahead_idx ] , target_duration , ] main_env . set_target_state ( * target_state ) vec_env . env_method ( \"set_target_state\" , * target_state ) # Generate sampled trajectories within each vec env vec_env . env_method ( \"sample_trajectory\" ) # HACK n = vec_env . get_attr ( \"traj_plan\" , [ 0 ] ) [ 0 ] . num_timesteps # Handle arm traj arm_traj_plan = nominal_arm_traj . get_segment ( cur_idx , cur_idx + n ) # main_env . set_arm_traj ( arm_traj_plan ) vec_env . env_method ( \"set_arm_traj\" , arm_traj_plan ) if debug : env_state_samples = vec_env . get_attr ( \"sampled_end_state\" ) env_poss = [ s[0 ] for s in env_state_samples ] point_ids = vec_env . env_method ( \"send_client_command\" , \"addUserDebugPoints\" , env_poss , [ [1, 1, 1 ] ] * len ( env_poss ), 10 , 0 , indices =[ debug_env_idx ] , ) vec_env . env_method ( \"show_traj_plan\" , 10 , indices =[ debug_env_idx ] ) # Stepping in the vec env will follow the sampled trajectory # Action input in step ( actions ) is a dummy parameter for now , just for Gym compatibility if RECORD_DEBUG_ENV : debug_log_id = vec_env . env_method ( \"send_client_command\" , \"startStateLogging\" , main_env . client . STATE_LOGGING_VIDEO_MP4 , f \"{DEBUG_VIDEO_DIRECTORY}{video_index}.mp4\" , indices =[ debug_env_idx ] , ) [ 0 ] env_obs , env_rewards , env_dones , env_infos = vec_env . step ( np . zeros ( n_vec_envs ) ) if RECORD_DEBUG_ENV : vec_env . env_method ( \"send_client_command\" , \"stopStateLogging\" , debug_log_id , indices =[ debug_env_idx ] , ) video_index += 1 best_traj : Trajectory = vec_env . get_attr ( \"traj_plan\" , [ int(np.argmax(env_rewards)) ] ) [ 0 ] # Follow the best rollout in the main environment . ( Use dummy action value in step call ) n_execution_timesteps = int ( best_traj . num_timesteps * ( execution_duration / rollout_duration ) ) # print ( \"N EXECUTION TIMESTEPS: \" , n_execution_timesteps ) # print ( \"N ROLLOUT TIMESTEPS: \" , lookahead_idx - cur_idx ) # print ( \"CUR IDX: \" , cur_idx ) main_env . traj_plan = best_traj . get_segment ( 0 , n_execution_timesteps ) main_env . set_arm_traj ( nominal_arm_traj . get_segment ( cur_idx , cur_idx + n_execution_timesteps ) ) if RECORD_MAIN_ENV : main_log_id = main_env . client . startStateLogging ( main_env . client . STATE_LOGGING_VIDEO_MP4 , f \"{MAIN_VIDEO_DIRECTORY}{video_index}.mp4\" , ) ( main_obs , main_reward , main_terminated , main_truncated , main_info , ) = main_env . step ( 0 ) if RECORD_MAIN_ENV : main_env . client . stopStateLogging ( main_log_id ) video_index += 1 robot_state , bag_state = main_obs # Update our knowledge of the last acceleration commands main_env . last_accel_cmd = best_traj . linear_accels [ -1 ] main_env . last_alpha_cmd = best_traj . angular_accels [ -1 ] vec_env . set_attr ( \"last_accel_cmd\" , best_traj . linear_accels [ -1 ] ) vec_env . set_attr ( \"last_alpha_cmd\" , best_traj . angular_accels [ -1 ] ) # Update our time information cur_time += execution_duration # TODO should the cur_time value actually be times [ cur_idx ] ???? cur_idx += n_execution_timesteps # Update the camera if we 're taking video. These are hardcoded for the JPM motion # Switch cameras when the robot base passes x = 2.5 if ( (RECORD_MAIN_ENV or RECORD_DEBUG_ENV) and not camera_moved and robot_state[0][0] >= 2.5 ): main_env.client.resetDebugVisualizerCamera(*JPM_VIEW) vec_env.env_method( \"send_client_command\", \"resetDebugVisualizerCamera\", *JPM_VIEW ) camera_moved = True # Check if we' ve successfully completed the trajectory if main_terminated : print_green ( \"Success! Stabilized at end of trajectory within tolerance\" ) break # We are not done , so reset the environments back to the same point as the main env # Ensure that the vec envs start from the same point as the main simulation if use_deformable_rollouts : # If we are using the deformable bag for rollouts , we have to fully save the state to disk ( slow ) # because there is no other way to restore the deformable saved_file = main_env . save_state () vec_env . env_method ( \"restore_state\" , saved_file ) else : # If we ' re using the simple rigid bag for rollouts , we can just do a very simple reset mechanic vec_env . env_method ( \"reset_robot_state\" , robot_state ) vec_env . env_method ( \"reset_bag_state\" , bag_state ) input ( \"Complete. Press Enter to exit\" ) finally : if RECORD_MAIN_ENV : concatenate_videos ( MAIN_VIDEO_DIRECTORY , cleanup = True ) if RECORD_DEBUG_ENV : concatenate_videos ( DEBUG_VIDEO_DIRECTORY , cleanup = True ) print ( \"Closing environments\" ) main_env . close () vec_env . close ()","title":"Sampling Mpc Multithreaded"},{"location":"reference/pyastrobee/control/sampling_mpc_multithreaded/#module-pyastrobeecontrolsampling_mpc_multithreaded","text":"Sampling-based MPC with the simulator as the model (multi-threaded version) We create three different types of environments: 1: The main simulation 2: One parallel environment which evaluates the \"nominal\" trajectory 3: Other parallel environments which evaluate deviations on the nominal value When debugging, we visualize the nominal parallel environment as well, and show the trajectory rollout plan View Source \"\"\"Sampling-based MPC with the simulator as the model (multi-threaded version) We create three different types of environments: 1: The main simulation 2: One parallel environment which evaluates the \"nominal\" trajectory 3: Other parallel environments which evaluate deviations on the nominal value When debugging, we visualize the nominal parallel environment as well, and show the trajectory rollout plan \"\"\" # Note: This is pretty slow # There are definitely smarter ways of doing sampling-based nonlinear MPC (or SCP nonlinear MPC), # and better simulators to use if parallelization is the goal (Issac gym, Mujoco MJX, Genesis, ...) # This was just the original design approach I took as a first-stab at the problem from pathlib import Path from datetime import datetime from typing import Optional import numpy as np import numpy.typing as npt from stable_baselines3.common.env_util import DummyVecEnv , SubprocVecEnv from pyastrobee.core.deformable_bag import DeformableCargoBag from pyastrobee.core.constraint_bag import ConstraintCargoBag from pyastrobee.core.environments import AstrobeeMPCEnv , make_vec_env from pyastrobee.trajectories.trajectory import Trajectory from pyastrobee.trajectories.planner import global_planner from pyastrobee.trajectories.arm_planner import plan_arm_traj from pyastrobee.utils.python_utils import print_red , print_green from pyastrobee.utils.video_concatenation import concatenate_videos # Recording parameters RECORD_MAIN_ENV = False RECORD_DEBUG_ENV = True MAIN_VIDEO_DIRECTORY = ( f \"artifacts/ { Path ( __file__ ) . stem } _ { datetime . now () . strftime ( '%Y%m %d _%H%M%S_ %f ' ) } /\" ) DEBUG_VIDEO_DIRECTORY = MAIN_VIDEO_DIRECTORY . rstrip ( \"/\" ) + \"_debug/\" # Debug visualizer camera parameters: Dist, yaw, pitch, target NODE_2_VIEW = ( 1.40 , - 69.60 , - 19.00 , ( 0.55 , 0.00 , - 0.39 )) JPM_VIEW = ( 1.00 , 64.40 , - 12.20 , ( 6.44 , - 0.39 , 0.07 )) EXTERNAL_VIEW = ( 9.20 , 49.60 , - 9.80 , ( - 1.07 , - 1.53 , - 0.41 )) def parallel_mpc_main ( start_pose : npt . ArrayLike , goal_pose : npt . ArrayLike , n_vec_envs : int , bag_name : str = \"top_handle\" , bag_mass : float = 10 , use_deformable_primary_sim : bool = True , use_deformable_rollouts : bool = False , debug : bool = False , random_seed : Optional [ int ] = None , ): \"\"\"Launches a series of environments in parallel and runs a model-predictive-controller to move Astrobee between two poses while carrying a cargo bag Args: start_pose (npt.ArrayLike): Starting pose of the Astrobee (position and XYZW quaternion), shape (7,) goal_pose (npt.ArrayLike): Ending pose of the Astrobee (position and XYZW quaternion), shape (7,) n_vec_envs (int): Number of vectorized environments to launch in parallel (>= 1) bag_name (str, optional): Type of cargo bag to load. Defaults to \"top_handle\". bag_mass (float): Mass of the cargo bag, in kg. Defaults to 10 use_deformable_primary_sim (bool, optional): Whether to load the deformable bag in the main simulation env. Defaults to True (load the deformable version) use_deformable_rollouts (bool, optional): Whether to use the deformable bag for rollouts. Defaults to False (perform rollouts with the simplified rigid bag) debug (bool, optional): Whether to launch one of the vectorized environments with the GUI active, to visualize some of the rollouts being evaluated. Defaults to False. random_seed (Optional[int]): Seed for the random number generator, if desired. Defaults to None (unseeded) \"\"\" if n_vec_envs < 1 : raise ValueError ( \"Must have at least one environment for evaluating rollouts\" ) # Set up main environment main_env = AstrobeeMPCEnv ( use_gui = True , is_primary = True , robot_pose = start_pose , bag_name = bag_name , bag_mass = bag_mass , bag_type = ( DeformableCargoBag if use_deformable_primary_sim else ConstraintCargoBag ), load_full_iss = True , ) # Set up vectorized environments env_kwargs = { \"use_gui\" : False , \"is_primary\" : False , \"robot_pose\" : start_pose , \"bag_name\" : bag_name , \"bag_mass\" : bag_mass , \"bag_type\" : ( DeformableCargoBag if use_deformable_rollouts else ConstraintCargoBag ), # We need the full ISS loaded if using deformable rollouts so save/restore state sees the same envs \"load_full_iss\" : use_deformable_rollouts , } debug_env_idx = 0 # Enable GUI for one of the vec envs if debugging, and use this to test the nominal (non-sampled) trajs per_env_kwargs = { debug_env_idx : { \"use_gui\" : debug , \"nominal_rollouts\" : True }} vec_env = make_vec_env ( AstrobeeMPCEnv , n_vec_envs , random_seed , env_kwargs = env_kwargs , vec_env_cls = SubprocVecEnv if n_vec_envs > 1 else DummyVecEnv , per_env_kwargs = per_env_kwargs , ) main_env . reset ( random_seed ) vec_env . seed ( random_seed ) vec_env . reset () # Random seed included in make_vec_env # Generate nominal trajectory dt = main_env . client . getPhysicsEngineParameters ()[ \"fixedTimeStep\" ] nominal_traj = global_planner ( start_pose [: 3 ], start_pose [ 3 :], goal_pose [: 3 ], goal_pose [ 3 :], dt , ) nominal_arm_traj = plan_arm_traj ( nominal_traj ) # Store the goal pose to determine stopping criteria # TODO should this instead be an input to the environment? # TODO it seems like this doesn't actually work properly main_env . goal_pose = goal_pose vec_env . set_attr ( \"goal_pose\" , goal_pose ) video_index = 0 camera_moved = False if RECORD_MAIN_ENV or RECORD_DEBUG_ENV : main_env . client . resetDebugVisualizerCamera ( * NODE_2_VIEW ) vec_env . env_method ( \"send_client_command\" , \"resetDebugVisualizerCamera\" , * NODE_2_VIEW , indices = [ debug_env_idx ], ) # main_env.client.resetDebugVisualizerCamera(*EXTERNAL_VIEW) print ( \"Ready to record video. Remember to maximize the GUI\" ) main_path = Path ( MAIN_VIDEO_DIRECTORY ) debug_path = Path ( DEBUG_VIDEO_DIRECTORY ) if ( main_path . exists () and RECORD_MAIN_ENV ) or ( debug_path . exists and RECORD_DEBUG_ENV ): print_red ( \"WARNING: Recording video will overwrite existing files\" ) # TODO decide if we should empty the directory/directories input ( \"Press Enter to begin\" ) if RECORD_MAIN_ENV : main_path . mkdir ( parents = True , exist_ok = True ) if RECORD_DEBUG_ENV : debug_path . mkdir ( parents = True , exist_ok = True ) # Time parameters (TODO make some of these inputs?) cur_time = 0.0 traj_end_time = nominal_traj . times [ - 1 ] max_stopping_time = 30 # seconds max_time = traj_end_time + max_stopping_time rollout_duration = 5 # seconds execution_duration = 1 # seconds (How much of the rollout to actually execute) # TEMP, TESTING. IMPROVE THIS main_env . set_planning_duration ( rollout_duration ) vec_env . env_method ( \"set_planning_duration\" , rollout_duration ) # State machine mode = AstrobeeMPCEnv . FlightStates . NOMINAL point_ids = None cur_idx = 0 # Execute the main MPC code in a try/finally block to make sure things close out / clean up when done try : while True : # TODO handle the stopping mode better... Should we be \"stopping\" if the rollout or planned execution # reaches the end of the trajectory? Or just when we've fully reached the end? # Determine the duration of the rollout and where on the trajectory we are interested remaining_traj_time = traj_end_time - cur_time remaining_total_time = max_time - cur_time out_of_time = remaining_total_time <= dt # Update our flight state machine (TODO improve logic, make separate method) if ( remaining_traj_time <= rollout_duration and mode == AstrobeeMPCEnv . FlightStates . NOMINAL ): # Update this flag in our environments only once, when this changes print ( \"Setting flight state to SLOWING\" ) main_env . set_flight_state ( AstrobeeMPCEnv . FlightStates . SLOWING ) vec_env . env_method ( \"set_flight_state\" , AstrobeeMPCEnv . FlightStates . SLOWING ) mode = AstrobeeMPCEnv . FlightStates . SLOWING if ( remaining_traj_time <= dt and mode != AstrobeeMPCEnv . FlightStates . STOPPING ): # Update this flag in our environments only once, when this changes print ( \"Setting flight state to STOPPING\" ) main_env . set_flight_state ( AstrobeeMPCEnv . FlightStates . STOPPING ) vec_env . env_method ( \"set_flight_state\" , AstrobeeMPCEnv . FlightStates . STOPPING ) mode = AstrobeeMPCEnv . FlightStates . STOPPING if out_of_time : print_red ( \"Terminating due to time limit\" ) break if mode in { AstrobeeMPCEnv . FlightStates . SLOWING , AstrobeeMPCEnv . FlightStates . STOPPING , }: lookahead_idx = - 1 else : lookahead_idx = np . searchsorted ( nominal_traj . times , cur_time + rollout_duration ) # Clear any previously visualized trajectories before viewing the new plan if debug : vec_env . env_method ( \"unshow_traj_plan\" , indices = [ debug_env_idx ]) if point_ids is not None : for pid in point_ids : vec_env . env_method ( \"send_client_command\" , \"removeUserDebugItem\" , pid ) # THIS IS WEIRD # The thinking here is that when we are slowing down we might have a plan that we will get to our goal in # like 2 seconds even if the rollout duration is 5 seconds target_duration = min ( max ( 0 , remaining_traj_time ), rollout_duration ) # Set the desired state of the robot at the lookahead point target_state = [ nominal_traj . positions [ lookahead_idx ], nominal_traj . quaternions [ lookahead_idx ], nominal_traj . linear_velocities [ lookahead_idx ], nominal_traj . angular_velocities [ lookahead_idx ], nominal_traj . linear_accels [ lookahead_idx ], nominal_traj . angular_accels [ lookahead_idx ], target_duration , ] main_env . set_target_state ( * target_state ) vec_env . env_method ( \"set_target_state\" , * target_state ) # Generate sampled trajectories within each vec env vec_env . env_method ( \"sample_trajectory\" ) # HACK n = vec_env . get_attr ( \"traj_plan\" , [ 0 ])[ 0 ] . num_timesteps # Handle arm traj arm_traj_plan = nominal_arm_traj . get_segment ( cur_idx , cur_idx + n ) # main_env.set_arm_traj(arm_traj_plan) vec_env . env_method ( \"set_arm_traj\" , arm_traj_plan ) if debug : env_state_samples = vec_env . get_attr ( \"sampled_end_state\" ) env_poss = [ s [ 0 ] for s in env_state_samples ] point_ids = vec_env . env_method ( \"send_client_command\" , \"addUserDebugPoints\" , env_poss , [[ 1 , 1 , 1 ]] * len ( env_poss ), 10 , 0 , indices = [ debug_env_idx ], ) vec_env . env_method ( \"show_traj_plan\" , 10 , indices = [ debug_env_idx ]) # Stepping in the vec env will follow the sampled trajectory # Action input in step(actions) is a dummy parameter for now, just for Gym compatibility if RECORD_DEBUG_ENV : debug_log_id = vec_env . env_method ( \"send_client_command\" , \"startStateLogging\" , main_env . client . STATE_LOGGING_VIDEO_MP4 , f \" { DEBUG_VIDEO_DIRECTORY }{ video_index } .mp4\" , indices = [ debug_env_idx ], )[ 0 ] env_obs , env_rewards , env_dones , env_infos = vec_env . step ( np . zeros ( n_vec_envs ) ) if RECORD_DEBUG_ENV : vec_env . env_method ( \"send_client_command\" , \"stopStateLogging\" , debug_log_id , indices = [ debug_env_idx ], ) video_index += 1 best_traj : Trajectory = vec_env . get_attr ( \"traj_plan\" , [ int ( np . argmax ( env_rewards ))] )[ 0 ] # Follow the best rollout in the main environment. (Use dummy action value in step call) n_execution_timesteps = int ( best_traj . num_timesteps * ( execution_duration / rollout_duration ) ) # print(\"N EXECUTION TIMESTEPS: \", n_execution_timesteps) # print(\"N ROLLOUT TIMESTEPS: \", lookahead_idx - cur_idx) # print(\"CUR IDX: \", cur_idx) main_env . traj_plan = best_traj . get_segment ( 0 , n_execution_timesteps ) main_env . set_arm_traj ( nominal_arm_traj . get_segment ( cur_idx , cur_idx + n_execution_timesteps ) ) if RECORD_MAIN_ENV : main_log_id = main_env . client . startStateLogging ( main_env . client . STATE_LOGGING_VIDEO_MP4 , f \" { MAIN_VIDEO_DIRECTORY }{ video_index } .mp4\" , ) ( main_obs , main_reward , main_terminated , main_truncated , main_info , ) = main_env . step ( 0 ) if RECORD_MAIN_ENV : main_env . client . stopStateLogging ( main_log_id ) video_index += 1 robot_state , bag_state = main_obs # Update our knowledge of the last acceleration commands main_env . last_accel_cmd = best_traj . linear_accels [ - 1 ] main_env . last_alpha_cmd = best_traj . angular_accels [ - 1 ] vec_env . set_attr ( \"last_accel_cmd\" , best_traj . linear_accels [ - 1 ]) vec_env . set_attr ( \"last_alpha_cmd\" , best_traj . angular_accels [ - 1 ]) # Update our time information cur_time += execution_duration # TODO should the cur_time value actually be times[cur_idx]???? cur_idx += n_execution_timesteps # Update the camera if we're taking video. These are hardcoded for the JPM motion # Switch cameras when the robot base passes x = 2.5 if ( ( RECORD_MAIN_ENV or RECORD_DEBUG_ENV ) and not camera_moved and robot_state [ 0 ][ 0 ] >= 2.5 ): main_env . client . resetDebugVisualizerCamera ( * JPM_VIEW ) vec_env . env_method ( \"send_client_command\" , \"resetDebugVisualizerCamera\" , * JPM_VIEW ) camera_moved = True # Check if we've successfully completed the trajectory if main_terminated : print_green ( \"Success! Stabilized at end of trajectory within tolerance\" ) break # We are not done, so reset the environments back to the same point as the main env # Ensure that the vec envs start from the same point as the main simulation if use_deformable_rollouts : # If we are using the deformable bag for rollouts, we have to fully save the state to disk (slow) # because there is no other way to restore the deformable saved_file = main_env . save_state () vec_env . env_method ( \"restore_state\" , saved_file ) else : # If we're using the simple rigid bag for rollouts, we can just do a very simple reset mechanic vec_env . env_method ( \"reset_robot_state\" , robot_state ) vec_env . env_method ( \"reset_bag_state\" , bag_state ) input ( \"Complete. Press Enter to exit\" ) finally : if RECORD_MAIN_ENV : concatenate_videos ( MAIN_VIDEO_DIRECTORY , cleanup = True ) if RECORD_DEBUG_ENV : concatenate_videos ( DEBUG_VIDEO_DIRECTORY , cleanup = True ) print ( \"Closing environments\" ) main_env . close () vec_env . close () def _test_node_2_to_jpm (): \"\"\"Quick function to test that the parallel MPC is working as expected\"\"\" random_seed = 0 np . random . seed ( random_seed ) start_pose = [ 0 , 0 , 0 , 0 , 0 , 0 , 1 ] end_pose = [ 6 , 0 , 0.2 , 0 , 0 , 0 , 1 ] # Easy-to-reach location in JPM bag_name = \"top_handle_symmetric\" bag_mass = 10 n_vec_envs = 10 debug = True use_deformable_main_sim = True use_deformable_rollouts = False parallel_mpc_main ( start_pose , end_pose , n_vec_envs , bag_name , bag_mass , use_deformable_main_sim , use_deformable_rollouts , debug , random_seed , ) def _test_jpm_to_us_lab (): \"\"\"Quick function to test that the parallel MPC is working as expected\"\"\" random_seed = 0 np . random . seed ( random_seed ) start_pose = [ 6 , 0 , 0.2 , 0 , 0 , 1 , 0 ] # JPM end_pose = [ - 0.063 , - 8.5355 , 0 , 0 , 0 , - np . sqrt ( 2 ) / 2 , np . sqrt ( 2 ) / 2 ] # US bag_name = \"top_handle_symmetric\" bag_mass = 10 n_vec_envs = 10 debug = True use_deformable_main_sim = True use_deformable_rollouts = False parallel_mpc_main ( start_pose , end_pose , n_vec_envs , bag_name , bag_mass , use_deformable_main_sim , use_deformable_rollouts , debug , random_seed , ) if __name__ == \"__main__\" : # _test_node_2_to_jpm() _test_jpm_to_us_lab ()","title":"Module pyastrobee.control.sampling_mpc_multithreaded"},{"location":"reference/pyastrobee/control/sampling_mpc_multithreaded/#variables","text":"DEBUG_VIDEO_DIRECTORY EXTERNAL_VIEW JPM_VIEW MAIN_VIDEO_DIRECTORY NODE_2_VIEW RECORD_DEBUG_ENV RECORD_MAIN_ENV","title":"Variables"},{"location":"reference/pyastrobee/control/sampling_mpc_multithreaded/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/control/sampling_mpc_multithreaded/#parallel_mpc_main","text":"def parallel_mpc_main ( start_pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], goal_pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], n_vec_envs : int , bag_name : str = 'top_handle' , bag_mass : float = 10 , use_deformable_primary_sim : bool = True , use_deformable_rollouts : bool = False , debug : bool = False , random_seed : Optional [ int ] = None ) Launches a series of environments in parallel and runs a model-predictive-controller to move Astrobee between two poses while carrying a cargo bag Parameters: Name Type Description Default start_pose npt.ArrayLike Starting pose of the Astrobee (position and XYZW quaternion), shape (7,) None goal_pose npt.ArrayLike Ending pose of the Astrobee (position and XYZW quaternion), shape (7,) None n_vec_envs int Number of vectorized environments to launch in parallel (>= 1) None bag_name str Type of cargo bag to load. Defaults to \"top_handle\". \"top_handle\" bag_mass float Mass of the cargo bag, in kg. Defaults to 10 None use_deformable_primary_sim bool Whether to load the deformable bag in the main simulation env. Defaults to True (load the deformable version) None use_deformable_rollouts bool Whether to use the deformable bag for rollouts. Defaults to False (perform rollouts with the simplified rigid bag) None debug bool Whether to launch one of the vectorized environments with the GUI active, to visualize some of the rollouts being evaluated. Defaults to False. None random_seed Optional[int] Seed for the random number generator, if desired. Defaults to None (unseeded) None View Source def parallel_mpc_main ( start_pose : npt . ArrayLike , goal_pose : npt . ArrayLike , n_vec_envs : int , bag_name : str = \"top_handle\" , bag_mass : float = 10 , use_deformable_primary_sim : bool = True , use_deformable_rollouts : bool = False , debug : bool = False , random_seed : Optional [ int ] = None , ) : \"\"\"Launches a series of environments in parallel and runs a model-predictive-controller to move Astrobee between two poses while carrying a cargo bag Args: start_pose (npt.ArrayLike): Starting pose of the Astrobee (position and XYZW quaternion), shape (7,) goal_pose (npt.ArrayLike): Ending pose of the Astrobee (position and XYZW quaternion), shape (7,) n_vec_envs (int): Number of vectorized environments to launch in parallel (>= 1) bag_name (str, optional): Type of cargo bag to load. Defaults to \" top_handle \". bag_mass (float): Mass of the cargo bag, in kg. Defaults to 10 use_deformable_primary_sim (bool, optional): Whether to load the deformable bag in the main simulation env. Defaults to True (load the deformable version) use_deformable_rollouts (bool, optional): Whether to use the deformable bag for rollouts. Defaults to False (perform rollouts with the simplified rigid bag) debug (bool, optional): Whether to launch one of the vectorized environments with the GUI active, to visualize some of the rollouts being evaluated. Defaults to False. random_seed (Optional[int]): Seed for the random number generator, if desired. Defaults to None (unseeded) \"\"\" if n_vec_envs < 1 : raise ValueError ( \"Must have at least one environment for evaluating rollouts\" ) # Set up main environment main_env = AstrobeeMPCEnv ( use_gui = True , is_primary = True , robot_pose = start_pose , bag_name = bag_name , bag_mass = bag_mass , bag_type = ( DeformableCargoBag if use_deformable_primary_sim else ConstraintCargoBag ), load_full_iss = True , ) # Set up vectorized environments env_kwargs = { \"use_gui\" : False , \"is_primary\" : False , \"robot_pose\" : start_pose , \"bag_name\" : bag_name , \"bag_mass\" : bag_mass , \"bag_type\" : ( DeformableCargoBag if use_deformable_rollouts else ConstraintCargoBag ), # We need the full ISS loaded if using deformable rollouts so save / restore state sees the same envs \"load_full_iss\" : use_deformable_rollouts , } debug_env_idx = 0 # Enable GUI for one of the vec envs if debugging , and use this to test the nominal ( non - sampled ) trajs per_env_kwargs = { debug_env_idx : { \"use_gui\" : debug , \"nominal_rollouts\" : True }} vec_env = make_vec_env ( AstrobeeMPCEnv , n_vec_envs , random_seed , env_kwargs = env_kwargs , vec_env_cls = SubprocVecEnv if n_vec_envs > 1 else DummyVecEnv , per_env_kwargs = per_env_kwargs , ) main_env . reset ( random_seed ) vec_env . seed ( random_seed ) vec_env . reset () # Random seed included in make_vec_env # Generate nominal trajectory dt = main_env . client . getPhysicsEngineParameters () [ \"fixedTimeStep\" ] nominal_traj = global_planner ( start_pose [ :3 ] , start_pose [ 3: ] , goal_pose [ :3 ] , goal_pose [ 3: ] , dt , ) nominal_arm_traj = plan_arm_traj ( nominal_traj ) # Store the goal pose to determine stopping criteria # TODO should this instead be an input to the environment ? # TODO it seems like this doesn 't actually work properly main_env.goal_pose = goal_pose vec_env.set_attr(\"goal_pose\", goal_pose) video_index = 0 camera_moved = False if RECORD_MAIN_ENV or RECORD_DEBUG_ENV: main_env.client.resetDebugVisualizerCamera(*NODE_2_VIEW) vec_env.env_method( \"send_client_command\", \"resetDebugVisualizerCamera\", *NODE_2_VIEW, indices=[debug_env_idx], ) # main_env.client.resetDebugVisualizerCamera(*EXTERNAL_VIEW) print(\"Ready to record video. Remember to maximize the GUI\") main_path = Path(MAIN_VIDEO_DIRECTORY) debug_path = Path(DEBUG_VIDEO_DIRECTORY) if (main_path.exists() and RECORD_MAIN_ENV) or ( debug_path.exists and RECORD_DEBUG_ENV ): print_red(\"WARNING: Recording video will overwrite existing files\") # TODO decide if we should empty the directory/directories input(\"Press Enter to begin\") if RECORD_MAIN_ENV: main_path.mkdir(parents=True, exist_ok=True) if RECORD_DEBUG_ENV: debug_path.mkdir(parents=True, exist_ok=True) # Time parameters (TODO make some of these inputs?) cur_time = 0.0 traj_end_time = nominal_traj.times[-1] max_stopping_time = 30 # seconds max_time = traj_end_time + max_stopping_time rollout_duration = 5 # seconds execution_duration = 1 # seconds (How much of the rollout to actually execute) # TEMP, TESTING. IMPROVE THIS main_env.set_planning_duration(rollout_duration) vec_env.env_method(\"set_planning_duration\", rollout_duration) # State machine mode = AstrobeeMPCEnv.FlightStates.NOMINAL point_ids = None cur_idx = 0 # Execute the main MPC code in a try/finally block to make sure things close out / clean up when done try: while True: # TODO handle the stopping mode better... Should we be \"stopping\" if the rollout or planned execution # reaches the end of the trajectory? Or just when we' ve fully reached the end ? # Determine the duration of the rollout and where on the trajectory we are interested remaining_traj_time = traj_end_time - cur_time remaining_total_time = max_time - cur_time out_of_time = remaining_total_time <= dt # Update our flight state machine ( TODO improve logic , make separate method ) if ( remaining_traj_time <= rollout_duration and mode == AstrobeeMPCEnv . FlightStates . NOMINAL ) : # Update this flag in our environments only once , when this changes print ( \"Setting flight state to SLOWING\" ) main_env . set_flight_state ( AstrobeeMPCEnv . FlightStates . SLOWING ) vec_env . env_method ( \"set_flight_state\" , AstrobeeMPCEnv . FlightStates . SLOWING ) mode = AstrobeeMPCEnv . FlightStates . SLOWING if ( remaining_traj_time <= dt and mode != AstrobeeMPCEnv . FlightStates . STOPPING ) : # Update this flag in our environments only once , when this changes print ( \"Setting flight state to STOPPING\" ) main_env . set_flight_state ( AstrobeeMPCEnv . FlightStates . STOPPING ) vec_env . env_method ( \"set_flight_state\" , AstrobeeMPCEnv . FlightStates . STOPPING ) mode = AstrobeeMPCEnv . FlightStates . STOPPING if out_of_time : print_red ( \"Terminating due to time limit\" ) break if mode in { AstrobeeMPCEnv . FlightStates . SLOWING , AstrobeeMPCEnv . FlightStates . STOPPING , }: lookahead_idx = - 1 else : lookahead_idx = np . searchsorted ( nominal_traj . times , cur_time + rollout_duration ) # Clear any previously visualized trajectories before viewing the new plan if debug : vec_env . env_method ( \"unshow_traj_plan\" , indices =[ debug_env_idx ] ) if point_ids is not None : for pid in point_ids : vec_env . env_method ( \"send_client_command\" , \"removeUserDebugItem\" , pid ) # THIS IS WEIRD # The thinking here is that when we are slowing down we might have a plan that we will get to our goal in # like 2 seconds even if the rollout duration is 5 seconds target_duration = min ( max ( 0 , remaining_traj_time ), rollout_duration ) # Set the desired state of the robot at the lookahead point target_state = [ nominal_traj.positions[lookahead_idx ] , nominal_traj . quaternions [ lookahead_idx ] , nominal_traj . linear_velocities [ lookahead_idx ] , nominal_traj . angular_velocities [ lookahead_idx ] , nominal_traj . linear_accels [ lookahead_idx ] , nominal_traj . angular_accels [ lookahead_idx ] , target_duration , ] main_env . set_target_state ( * target_state ) vec_env . env_method ( \"set_target_state\" , * target_state ) # Generate sampled trajectories within each vec env vec_env . env_method ( \"sample_trajectory\" ) # HACK n = vec_env . get_attr ( \"traj_plan\" , [ 0 ] ) [ 0 ] . num_timesteps # Handle arm traj arm_traj_plan = nominal_arm_traj . get_segment ( cur_idx , cur_idx + n ) # main_env . set_arm_traj ( arm_traj_plan ) vec_env . env_method ( \"set_arm_traj\" , arm_traj_plan ) if debug : env_state_samples = vec_env . get_attr ( \"sampled_end_state\" ) env_poss = [ s[0 ] for s in env_state_samples ] point_ids = vec_env . env_method ( \"send_client_command\" , \"addUserDebugPoints\" , env_poss , [ [1, 1, 1 ] ] * len ( env_poss ), 10 , 0 , indices =[ debug_env_idx ] , ) vec_env . env_method ( \"show_traj_plan\" , 10 , indices =[ debug_env_idx ] ) # Stepping in the vec env will follow the sampled trajectory # Action input in step ( actions ) is a dummy parameter for now , just for Gym compatibility if RECORD_DEBUG_ENV : debug_log_id = vec_env . env_method ( \"send_client_command\" , \"startStateLogging\" , main_env . client . STATE_LOGGING_VIDEO_MP4 , f \"{DEBUG_VIDEO_DIRECTORY}{video_index}.mp4\" , indices =[ debug_env_idx ] , ) [ 0 ] env_obs , env_rewards , env_dones , env_infos = vec_env . step ( np . zeros ( n_vec_envs ) ) if RECORD_DEBUG_ENV : vec_env . env_method ( \"send_client_command\" , \"stopStateLogging\" , debug_log_id , indices =[ debug_env_idx ] , ) video_index += 1 best_traj : Trajectory = vec_env . get_attr ( \"traj_plan\" , [ int(np.argmax(env_rewards)) ] ) [ 0 ] # Follow the best rollout in the main environment . ( Use dummy action value in step call ) n_execution_timesteps = int ( best_traj . num_timesteps * ( execution_duration / rollout_duration ) ) # print ( \"N EXECUTION TIMESTEPS: \" , n_execution_timesteps ) # print ( \"N ROLLOUT TIMESTEPS: \" , lookahead_idx - cur_idx ) # print ( \"CUR IDX: \" , cur_idx ) main_env . traj_plan = best_traj . get_segment ( 0 , n_execution_timesteps ) main_env . set_arm_traj ( nominal_arm_traj . get_segment ( cur_idx , cur_idx + n_execution_timesteps ) ) if RECORD_MAIN_ENV : main_log_id = main_env . client . startStateLogging ( main_env . client . STATE_LOGGING_VIDEO_MP4 , f \"{MAIN_VIDEO_DIRECTORY}{video_index}.mp4\" , ) ( main_obs , main_reward , main_terminated , main_truncated , main_info , ) = main_env . step ( 0 ) if RECORD_MAIN_ENV : main_env . client . stopStateLogging ( main_log_id ) video_index += 1 robot_state , bag_state = main_obs # Update our knowledge of the last acceleration commands main_env . last_accel_cmd = best_traj . linear_accels [ -1 ] main_env . last_alpha_cmd = best_traj . angular_accels [ -1 ] vec_env . set_attr ( \"last_accel_cmd\" , best_traj . linear_accels [ -1 ] ) vec_env . set_attr ( \"last_alpha_cmd\" , best_traj . angular_accels [ -1 ] ) # Update our time information cur_time += execution_duration # TODO should the cur_time value actually be times [ cur_idx ] ???? cur_idx += n_execution_timesteps # Update the camera if we 're taking video. These are hardcoded for the JPM motion # Switch cameras when the robot base passes x = 2.5 if ( (RECORD_MAIN_ENV or RECORD_DEBUG_ENV) and not camera_moved and robot_state[0][0] >= 2.5 ): main_env.client.resetDebugVisualizerCamera(*JPM_VIEW) vec_env.env_method( \"send_client_command\", \"resetDebugVisualizerCamera\", *JPM_VIEW ) camera_moved = True # Check if we' ve successfully completed the trajectory if main_terminated : print_green ( \"Success! Stabilized at end of trajectory within tolerance\" ) break # We are not done , so reset the environments back to the same point as the main env # Ensure that the vec envs start from the same point as the main simulation if use_deformable_rollouts : # If we are using the deformable bag for rollouts , we have to fully save the state to disk ( slow ) # because there is no other way to restore the deformable saved_file = main_env . save_state () vec_env . env_method ( \"restore_state\" , saved_file ) else : # If we ' re using the simple rigid bag for rollouts , we can just do a very simple reset mechanic vec_env . env_method ( \"reset_robot_state\" , robot_state ) vec_env . env_method ( \"reset_bag_state\" , bag_state ) input ( \"Complete. Press Enter to exit\" ) finally : if RECORD_MAIN_ENV : concatenate_videos ( MAIN_VIDEO_DIRECTORY , cleanup = True ) if RECORD_DEBUG_ENV : concatenate_videos ( DEBUG_VIDEO_DIRECTORY , cleanup = True ) print ( \"Closing environments\" ) main_env . close () vec_env . close ()","title":"parallel_mpc_main"},{"location":"reference/pyastrobee/core/","text":"Module pyastrobee.core Sub-modules pyastrobee.core.abstract_bag pyastrobee.core.astrobee pyastrobee.core.composite_bag pyastrobee.core.constraint_bag pyastrobee.core.deformable_bag pyastrobee.core.environments pyastrobee.core.hybrid_bag pyastrobee.core.iss pyastrobee.core.rigid_bag","title":"Index"},{"location":"reference/pyastrobee/core/#module-pyastrobeecore","text":"","title":"Module pyastrobee.core"},{"location":"reference/pyastrobee/core/#sub-modules","text":"pyastrobee.core.abstract_bag pyastrobee.core.astrobee pyastrobee.core.composite_bag pyastrobee.core.constraint_bag pyastrobee.core.deformable_bag pyastrobee.core.environments pyastrobee.core.hybrid_bag pyastrobee.core.iss pyastrobee.core.rigid_bag","title":"Sub-modules"},{"location":"reference/pyastrobee/core/abstract_bag/","text":"Module pyastrobee.core.abstract_bag Abstract base class for representing cargo bags with different models View Source \"\"\"Abstract base class for representing cargo bags with different models\"\"\" from abc import ABC from typing import Union , Optional import pybullet from pybullet_utils.bullet_client import BulletClient import numpy as np import numpy.typing as npt from pyastrobee.core.astrobee import Astrobee from pyastrobee.utils.poses import pos_quat_to_tmat , tmat_to_pos_quat from pyastrobee.utils.transformations import invert_transform_mat from pyastrobee.utils.rotations import quat_to_rmat import pyastrobee.config.bag_properties as bag_props class CargoBag ( ABC ): \"\"\"Base (abstract) cargo bag class See inherited cargo bags for full implementations (deformable bag, rigid bag, constraint bag, ...) Args: bag_name (str): Type of cargo bag to load. Single handle: \"front_handle\", \"right_handle\", \"top_handle\". Dual handle: \"front_back_handle\", \"right_left_handle\", \"top_bottom_handle\" mass (float): Mass of the cargo bag, in kg pos (npt.ArrayLike): Initial XYZ position to load the bag orn (npt.ArrayLike): Initial XYZW quaternion to load the bag client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" LENGTH = 0.50 # meters WIDTH = 0.25 # meters HEIGHT = 0.42 # meters URDF_DIR = \"pyastrobee/assets/urdf/bags/\" MESH_DIR = \"pyastrobee/assets/meshes/bags/\" SINGLE_HANDLE_BAGS = [ \"front_handle\" , \"right_handle\" , \"top_handle\" , \"top_handle_symmetric\" , # TODO: Add more symmetric versions (single and dual handle) ] DUAL_HANDLE_BAGS = [ \"front_back_handle\" , \"right_left_handle\" , \"top_bottom_handle\" ] BAG_NAMES = SINGLE_HANDLE_BAGS + DUAL_HANDLE_BAGS HANDLE_TRANSFORMS = { \"front\" : bag_props . FRONT_HANDLE_TRANSFORM , \"back\" : bag_props . BACK_HANDLE_TRANSFORM , \"left\" : bag_props . LEFT_HANDLE_TRANSFORM , \"right\" : bag_props . RIGHT_HANDLE_TRANSFORM , \"top\" : bag_props . TOP_HANDLE_TRANSFORM , \"bottom\" : bag_props . BOTTOM_HANDLE_TRANSFORM , } def __init__ ( self , bag_name : str , mass : float , pos : npt . ArrayLike , orn : npt . ArrayLike , client : Optional [ BulletClient ] = None , ): self . client : pybullet = pybullet if client is None else client if not self . client . isConnected (): raise ConnectionError ( \"Need to connect to pybullet before loading a bag\" ) if bag_name not in self . BAG_NAMES : raise ValueError ( f \"Invalid bag name: { bag_name } . Must be one of { self . BAG_NAMES } \" ) self . _mass = mass self . _name = bag_name self . _attached = [] self . _dt = self . client . getPhysicsEngineParameters ()[ \"fixedTimeStep\" ] self . id = self . _load ( pos , orn ) if self . id < 0 : raise ValueError ( \"Bag was not properly loaded!\" ) @property def mass ( self ) -> float : \"\"\"Mass of the cargo bag\"\"\" return self . _mass @property def attached ( self ) -> list [ int ]: \"\"\"ID(s) of the robot (or robots) grasping the bag. Empty if no robots are attached\"\"\" return self . _attached @property def name ( self ) -> str : \"\"\"Type of cargo bag\"\"\" return self . _name @property def grasp_transforms ( self ) -> list [ np . ndarray ]: \"\"\"Transformation matrices \"handle to bag\" representing the grasp locations on the handles to the bag COM In the case of a single-handled bag, this list will only have one entry \"\"\" if self . _name . startswith ( \"front_handle\" ): return [ self . HANDLE_TRANSFORMS [ \"front\" ]] elif self . _name . startswith ( \"right_handle\" ): return [ self . HANDLE_TRANSFORMS [ \"right\" ]] elif self . _name . startswith ( \"top_handle\" ): return [ self . HANDLE_TRANSFORMS [ \"top\" ]] elif self . _name . startswith ( \"front_back_handle\" ): return [ self . HANDLE_TRANSFORMS [ \"front\" ], self . HANDLE_TRANSFORMS [ \"back\" ]] elif self . _name . startswith ( \"right_left_handle\" ): return [ self . HANDLE_TRANSFORMS [ \"right\" ], self . HANDLE_TRANSFORMS [ \"left\" ]] elif self . _name . startswith ( \"top_bottom_handle\" ): return [ self . HANDLE_TRANSFORMS [ \"top\" ], self . HANDLE_TRANSFORMS [ \"bottom\" ]] else : raise NotImplementedError ( f \"Grasp transform(s) not available for bag: { self . _name } \" ) @property def pose ( self ) -> np . ndarray : \"\"\"Current position + XYZW quaternion pose of the bag\"\"\" return np . concatenate ( self . client . getBasePositionAndOrientation ( self . id )) @property def tmat ( self ): \"\"\"Current transformation matrix for the cargo bag: (Bag to world)\"\"\" return pos_quat_to_tmat ( self . pose ) @property def position ( self ) -> np . ndarray : \"\"\"Current XYZ position of the origin (COM frame) of the cargo bag\"\"\" return np . array ( self . client . getBasePositionAndOrientation ( self . id )[ 0 ]) @property def orientation ( self ) -> np . ndarray : \"\"\"Current XYZW quaternion orientation of the cargo bag's COM frame\"\"\" return np . array ( self . client . getBasePositionAndOrientation ( self . id )[ 1 ]) # TODO decide if using dynamics state is actually the best here @property def velocity ( self ) -> np . ndarray : \"\"\"Current [vx, vy, vz] velocity of the cargo bag's COM frame - If both velocity and angular velocity are desired, use the dynamics_state property instead \"\"\" return np . array ( self . client . getBaseVelocity ( self . id )[ 0 ]) @property def angular_velocity ( self ) -> np . ndarray : \"\"\"Current [wx, wy, wz] angular velocity of the cargo bag's COM frame - If both velocity and angular velocity are desired, use the dynamics_state property instead \"\"\" return np . array ( self . client . getBaseVelocity ( self . id )[ 1 ]) @property def dynamics_state ( self ) -> tuple [ np . ndarray , np . ndarray , np . ndarray , np . ndarray ]: \"\"\"Current state of the bag dynamics: Position, orientation, linear vel, and angular vel Returns: tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: np.ndarray: Position, shape (3,) np.ndarray: XYZW quaternion orientation, shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) \"\"\" pos , orn = self . client . getBasePositionAndOrientation ( self . id ) lin_vel , ang_vel = self . client . getBaseVelocity ( self . id ) return ( np . array ( pos ), np . array ( orn ), np . array ( lin_vel ), np . array ( ang_vel ), ) @property def num_handles ( self ) -> int : \"\"\"Number of handles on the cargo bag\"\"\" if self . _name in self . SINGLE_HANDLE_BAGS : return 1 elif self . _name in self . DUAL_HANDLE_BAGS : return 2 else : raise ValueError ( \"Name not recognized - number of handles unknown\" ) @property def corner_positions ( self ) -> list [ np . ndarray ]: \"\"\"Positions of the 8 corners of the main compartment of the bag, shape (8, 3)\"\"\" # The main compartment is the base link in all URDFs pos , quat = self . client . getBasePositionAndOrientation ( self . id ) rmat = quat_to_rmat ( quat ) l , w , h = self . LENGTH , self . WIDTH , self . HEIGHT return ( pos + np . array ( [ [ l / 2 , w / 2 , h / 2 ], [ l / 2 , w / 2 , - h / 2 ], [ l / 2 , - w / 2 , h / 2 ], [ l / 2 , - w / 2 , - h / 2 ], [ - l / 2 , w / 2 , h / 2 ], [ - l / 2 , w / 2 , - h / 2 ], [ - l / 2 , - w / 2 , h / 2 ], [ - l / 2 , - w / 2 , - h / 2 ], ] ) @ rmat . T ) def _load ( self , pos : npt . ArrayLike , orn : npt . ArrayLike ) -> int : \"\"\"Loads a cargo bag at the specified position/orientation Args: pos (npt.ArrayLike): XYZ position, shape (3,) orn (npt.ArrayLike): XYZW quaternion, shape (4,) Returns: int: Pybullet ID for the cargo bag \"\"\" return - 1 # Dummy value def unload ( self ) -> None : \"\"\"Removes the cargo bag from the simulation\"\"\" self . detach () self . client . removeBody ( self . id ) self . id = None def attach_to ( self , robot_or_robots : Union [ Astrobee , list [ Astrobee ], tuple [ Astrobee ]], object_to_move : str = \"robot\" , ) -> None : \"\"\"Attaches a robot (or multiple robots) to the handle(s) of the bag Args: robot_or_robots (Union[Astrobee, list[Astrobee], tuple[Astrobee]]): Robot(s) to attach to the bag object_to_move (str, optional): Either \"robot\" or \"bag\". This dictates what object will get its position reset in order to make the grasp connection. In general, it makes more sense to move the robot to the bag (default behavior) Raises: ValueError: For invalid inputs, or if the bag does not have enough handles for each robot NotImplementedError: Multi-robot case with >2 robots \"\"\" # Handle inputs if isinstance ( robot_or_robots , Astrobee ): # Single robot num_robots = 1 elif isinstance ( robot_or_robots , ( list , tuple )): # Multi-robot if not all ( isinstance ( r , Astrobee ) for r in robot_or_robots ): raise ValueError ( \"Non-Astrobee input detected\" ) num_robots = len ( robot_or_robots ) if self . num_handles < num_robots : raise ValueError ( f \"Bag does not have enough handles to support { num_robots } robots\" ) if num_robots == 1 : # Edge case: Unpack the list if only one robot robot_or_robots = robot_or_robots [ 0 ] else : raise ValueError ( \"Invalid input: Must provide either an Astrobee or a list of multiple Astrobees\" ) if object_to_move not in { \"robot\" , \"bag\" }: raise ValueError ( \"Invalid object to move: Must be either 'robot' or 'bag'.\" ) bag_to_world = pos_quat_to_tmat ( self . pose ) if num_robots == 1 : robot = robot_or_robots # Unpack list if object_to_move == \"robot\" : # Reset the position of the robot to interface with the handle handle_to_bag = self . grasp_transforms [ 0 ] handle_to_world = bag_to_world @ handle_to_bag handle_pose = tmat_to_pos_quat ( handle_to_world ) robot . reset_to_ee_pose ( handle_pose ) else : # Move the bag to the robot self . reset_to_handle_pose ( robot . ee_pose ) self . _attach ( robot , 0 ) elif num_robots == 2 : robot_1 , robot_2 = robot_or_robots # Unpack list if object_to_move == \"robot\" : # Reset the position of each robot to interface with the two handles handle_1_to_bag = self . grasp_transforms [ 0 ] handle_2_to_bag = self . grasp_transforms [ 1 ] handle_1_to_world = bag_to_world @ handle_1_to_bag handle_2_to_world = bag_to_world @ handle_2_to_bag robot_1 . reset_to_ee_pose ( tmat_to_pos_quat ( handle_1_to_world )) robot_2 . reset_to_ee_pose ( tmat_to_pos_quat ( handle_2_to_world )) self . _attach ( robot_1 , 0 ) self . _attach ( robot_2 , 1 ) else : # Move the bag while leaving the robots static raise NotImplementedError ( \"Attaching the bag to multiple robots requires moving at least 1 robot\" ) else : raise NotImplementedError ( \"The multi-robot case is only implemented for 2 Astrobees\" ) def _attach ( self , robot : Astrobee , handle_index : int ) -> None : \"\"\"Helper function: Connects a single robot to a handle at a specified pose This function assumes that the robot and the bag are already correctly positioned for a grasp, which is why it should not be called directly Args: robot (Astrobee): Robot to attach handle_index (int): Index of the handle on the bag \"\"\" pass def detach ( self ) -> None : \"\"\"Detach all connections to the bag\"\"\" pass def detach_robot ( self , robot_id : int ) -> None : \"\"\"Detaches a specific robot from the bag Args: robot_id (int): Pybullet ID of the robot to detach \"\"\" pass def reset_to_handle_pose ( self , handle_pose : npt . ArrayLike , handle_index : int = 0 ) -> None : \"\"\"Resets the position of the bag so that the handle is positioned at a desired pose Args: handle_pose (npt.ArrayLike): Desired pose of the handle (\"handle-to-world\"), shape (7,) handle_index (int, optional): Index of the handle to align to the desired pose. Defaults to 0. \"\"\" handle_to_world = pos_quat_to_tmat ( handle_pose ) bag_to_handle = invert_transform_mat ( self . grasp_transforms [ handle_index ]) bag_to_world = handle_to_world @ bag_to_handle bag_pose = tmat_to_pos_quat ( bag_to_world ) # This assumes that we want the bag to be stationary self . reset_dynamics ( bag_pose [: 3 ], bag_pose [ 3 :], np . zeros ( 3 ), np . zeros ( 3 )) def reset_dynamics ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , lin_vel : npt . ArrayLike , ang_vel : npt . ArrayLike , ) -> None : \"\"\"Resets the pose and velocities of the bag Args: pos (npt.ArrayLike): Position, shape (3,) orn (npt.ArrayLike): XYZW quaternion orientation, shape (4,) lin_vel (npt.ArrayLike): Linear velocity, shape (3,) ang_vel (npt.ArrayLike): Angular velocity, shape (3,) \"\"\" self . client . resetBasePositionAndOrientation ( self . id , pos , orn ) self . client . resetBaseVelocity ( self . id , lin_vel , ang_vel ) @property def bounding_box ( self ) -> np . ndarray : \"\"\"Current axis-aligned bounding box of the bag (or just the main compartment), shape (2, 3)\"\"\" # TODO convert to Box instance? return np . array ( self . client . getAABB ( self . id , - 1 )) Classes CargoBag class CargoBag ( bag_name : str , mass : float , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) Base (abstract) cargo bag class See inherited cargo bags for full implementations (deformable bag, rigid bag, constraint bag, ...) Attributes Name Type Description Default bag_name str Type of cargo bag to load. Single handle: \"front_handle\", \"right_handle\", \"top_handle\". Dual handle: \"front_back_handle\", \"right_left_handle\", \"top_bottom_handle\" None mass float Mass of the cargo bag, in kg None pos npt.ArrayLike Initial XYZ position to load the bag None orn npt.ArrayLike Initial XYZW quaternion to load the bag None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None View Source class CargoBag ( ABC ): \"\"\"Base (abstract) cargo bag class See inherited cargo bags for full implementations (deformable bag, rigid bag, constraint bag, ...) Args: bag_name (str): Type of cargo bag to load. Single handle: \"front_handle\", \"right_handle\", \"top_handle\". Dual handle: \"front_back_handle\", \"right_left_handle\", \"top_bottom_handle\" mass (float): Mass of the cargo bag, in kg pos (npt.ArrayLike): Initial XYZ position to load the bag orn (npt.ArrayLike): Initial XYZW quaternion to load the bag client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" LENGTH = 0.50 # meters WIDTH = 0.25 # meters HEIGHT = 0.42 # meters URDF_DIR = \"pyastrobee/assets/urdf/bags/\" MESH_DIR = \"pyastrobee/assets/meshes/bags/\" SINGLE_HANDLE_BAGS = [ \"front_handle\" , \"right_handle\" , \"top_handle\" , \"top_handle_symmetric\" , # TODO: Add more symmetric versions (single and dual handle) ] DUAL_HANDLE_BAGS = [ \"front_back_handle\" , \"right_left_handle\" , \"top_bottom_handle\" ] BAG_NAMES = SINGLE_HANDLE_BAGS + DUAL_HANDLE_BAGS HANDLE_TRANSFORMS = { \"front\" : bag_props . FRONT_HANDLE_TRANSFORM , \"back\" : bag_props . BACK_HANDLE_TRANSFORM , \"left\" : bag_props . LEFT_HANDLE_TRANSFORM , \"right\" : bag_props . RIGHT_HANDLE_TRANSFORM , \"top\" : bag_props . TOP_HANDLE_TRANSFORM , \"bottom\" : bag_props . BOTTOM_HANDLE_TRANSFORM , } def __init__ ( self , bag_name : str , mass : float , pos : npt . ArrayLike , orn : npt . ArrayLike , client : Optional [ BulletClient ] = None , ): self . client : pybullet = pybullet if client is None else client if not self . client . isConnected (): raise ConnectionError ( \"Need to connect to pybullet before loading a bag\" ) if bag_name not in self . BAG_NAMES : raise ValueError ( f \"Invalid bag name: {bag_name}. Must be one of {self.BAG_NAMES}\" ) self . _mass = mass self . _name = bag_name self . _attached = [] self . _dt = self . client . getPhysicsEngineParameters ()[ \"fixedTimeStep\" ] self . id = self . _load ( pos , orn ) if self . id < 0 : raise ValueError ( \"Bag was not properly loaded!\" ) @ property def mass ( self ) -> float : \"\"\"Mass of the cargo bag\"\"\" return self . _mass @ property def attached ( self ) -> list [ int ]: \"\"\"ID(s) of the robot (or robots) grasping the bag. Empty if no robots are attached\"\"\" return self . _attached @ property def name ( self ) -> str : \"\"\"Type of cargo bag\"\"\" return self . _name @ property def grasp_transforms ( self ) -> list [ np . ndarray ]: \"\"\"Transformation matrices \"handle to bag\" representing the grasp locations on the handles to the bag COM In the case of a single-handled bag, this list will only have one entry \"\"\" if self . _name . startswith ( \"front_handle\" ): return [ self . HANDLE_TRANSFORMS [ \"front\" ]] elif self . _name . startswith ( \"right_handle\" ): return [ self . HANDLE_TRANSFORMS [ \"right\" ]] elif self . _name . startswith ( \"top_handle\" ): return [ self . HANDLE_TRANSFORMS [ \"top\" ]] elif self . _name . startswith ( \"front_back_handle\" ): return [ self . HANDLE_TRANSFORMS [ \"front\" ], self . HANDLE_TRANSFORMS [ \"back\" ]] elif self . _name . startswith ( \"right_left_handle\" ): return [ self . HANDLE_TRANSFORMS [ \"right\" ], self . HANDLE_TRANSFORMS [ \"left\" ]] elif self . _name . startswith ( \"top_bottom_handle\" ): return [ self . HANDLE_TRANSFORMS [ \"top\" ], self . HANDLE_TRANSFORMS [ \"bottom\" ]] else : raise NotImplementedError ( f \"Grasp transform(s) not available for bag: {self._name}\" ) @ property def pose ( self ) -> np . ndarray : \"\"\"Current position + XYZW quaternion pose of the bag\"\"\" return np . concatenate ( self . client . getBasePositionAndOrientation ( self . id )) @ property def tmat ( self ): \"\"\"Current transformation matrix for the cargo bag: (Bag to world)\"\"\" return pos_quat_to_tmat ( self . pose ) @ property def position ( self ) -> np . ndarray : \"\"\"Current XYZ position of the origin (COM frame) of the cargo bag\"\"\" return np . array ( self . client . getBasePositionAndOrientation ( self . id )[ 0 ]) @ property def orientation ( self ) -> np . ndarray : \"\"\"Current XYZW quaternion orientation of the cargo bag's COM frame\"\"\" return np . array ( self . client . getBasePositionAndOrientation ( self . id )[ 1 ]) # TODO decide if using dynamics state is actually the best here @ property def velocity ( self ) -> np . ndarray : \"\"\"Current [vx, vy, vz] velocity of the cargo bag's COM frame - If both velocity and angular velocity are desired, use the dynamics_state property instead \"\"\" return np . array ( self . client . getBaseVelocity ( self . id )[ 0 ]) @ property def angular_velocity ( self ) -> np . ndarray : \"\"\"Current [wx, wy, wz] angular velocity of the cargo bag's COM frame - If both velocity and angular velocity are desired, use the dynamics_state property instead \"\"\" return np . array ( self . client . getBaseVelocity ( self . id )[ 1 ]) @ property def dynamics_state ( self ) -> tuple [ np . ndarray , np . ndarray , np . ndarray , np . ndarray ]: \"\"\"Current state of the bag dynamics: Position, orientation, linear vel, and angular vel Returns: tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: np.ndarray: Position, shape (3,) np.ndarray: XYZW quaternion orientation, shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) \"\"\" pos , orn = self . client . getBasePositionAndOrientation ( self . id ) lin_vel , ang_vel = self . client . getBaseVelocity ( self . id ) return ( np . array ( pos ), np . array ( orn ), np . array ( lin_vel ), np . array ( ang_vel ), ) @ property def num_handles ( self ) -> int : \"\"\"Number of handles on the cargo bag\"\"\" if self . _name in self . SINGLE_HANDLE_BAGS : return 1 elif self . _name in self . DUAL_HANDLE_BAGS : return 2 else : raise ValueError ( \"Name not recognized - number of handles unknown\" ) @ property def corner_positions ( self ) -> list [ np . ndarray ]: \"\"\"Positions of the 8 corners of the main compartment of the bag, shape (8, 3)\"\"\" # The main compartment is the base link in all URDFs pos , quat = self . client . getBasePositionAndOrientation ( self . id ) rmat = quat_to_rmat ( quat ) l , w , h = self . LENGTH , self . WIDTH , self . HEIGHT return ( pos + np . array ( [ [ l / 2 , w / 2 , h / 2 ], [ l / 2 , w / 2 , - h / 2 ], [ l / 2 , - w / 2 , h / 2 ], [ l / 2 , - w / 2 , - h / 2 ], [ - l / 2 , w / 2 , h / 2 ], [ - l / 2 , w / 2 , - h / 2 ], [ - l / 2 , - w / 2 , h / 2 ], [ - l / 2 , - w / 2 , - h / 2 ], ] ) @ rmat . T ) def _load ( self , pos : npt . ArrayLike , orn : npt . ArrayLike ) -> int : \"\"\"Loads a cargo bag at the specified position/orientation Args: pos (npt.ArrayLike): XYZ position, shape (3,) orn (npt.ArrayLike): XYZW quaternion, shape (4,) Returns: int: Pybullet ID for the cargo bag \"\"\" return - 1 # Dummy value def unload ( self ) -> None : \"\"\"Removes the cargo bag from the simulation\"\"\" self . detach () self . client . removeBody ( self . id ) self . id = None def attach_to ( self , robot_or_robots : Union [ Astrobee , list [ Astrobee ], tuple [ Astrobee ]], object_to_move : str = \"robot\" , ) -> None : \"\"\"Attaches a robot (or multiple robots) to the handle(s) of the bag Args: robot_or_robots (Union[Astrobee, list[Astrobee], tuple[Astrobee]]): Robot(s) to attach to the bag object_to_move (str, optional): Either \"robot\" or \"bag\". This dictates what object will get its position reset in order to make the grasp connection. In general, it makes more sense to move the robot to the bag (default behavior) Raises: ValueError: For invalid inputs, or if the bag does not have enough handles for each robot NotImplementedError: Multi-robot case with >2 robots \"\"\" # Handle inputs if isinstance ( robot_or_robots , Astrobee ): # Single robot num_robots = 1 elif isinstance ( robot_or_robots , ( list , tuple )): # Multi-robot if not all ( isinstance ( r , Astrobee ) for r in robot_or_robots ): raise ValueError ( \"Non-Astrobee input detected\" ) num_robots = len ( robot_or_robots ) if self . num_handles < num_robots : raise ValueError ( f \"Bag does not have enough handles to support {num_robots} robots\" ) if num_robots == 1 : # Edge case: Unpack the list if only one robot robot_or_robots = robot_or_robots [ 0 ] else : raise ValueError ( \"Invalid input: Must provide either an Astrobee or a list of multiple Astrobees\" ) if object_to_move not in { \"robot\" , \"bag\" }: raise ValueError ( \"Invalid object to move: Must be either 'robot' or 'bag'.\" ) bag_to_world = pos_quat_to_tmat ( self . pose ) if num_robots == 1 : robot = robot_or_robots # Unpack list if object_to_move == \"robot\" : # Reset the position of the robot to interface with the handle handle_to_bag = self . grasp_transforms [ 0 ] handle_to_world = bag_to_world @ handle_to_bag handle_pose = tmat_to_pos_quat ( handle_to_world ) robot . reset_to_ee_pose ( handle_pose ) else : # Move the bag to the robot self . reset_to_handle_pose ( robot . ee_pose ) self . _attach ( robot , 0 ) elif num_robots == 2 : robot_1 , robot_2 = robot_or_robots # Unpack list if object_to_move == \"robot\" : # Reset the position of each robot to interface with the two handles handle_1_to_bag = self . grasp_transforms [ 0 ] handle_2_to_bag = self . grasp_transforms [ 1 ] handle_1_to_world = bag_to_world @ handle_1_to_bag handle_2_to_world = bag_to_world @ handle_2_to_bag robot_1 . reset_to_ee_pose ( tmat_to_pos_quat ( handle_1_to_world )) robot_2 . reset_to_ee_pose ( tmat_to_pos_quat ( handle_2_to_world )) self . _attach ( robot_1 , 0 ) self . _attach ( robot_2 , 1 ) else : # Move the bag while leaving the robots static raise NotImplementedError ( \"Attaching the bag to multiple robots requires moving at least 1 robot\" ) else : raise NotImplementedError ( \"The multi-robot case is only implemented for 2 Astrobees\" ) def _attach ( self , robot : Astrobee , handle_index : int ) -> None : \"\"\"Helper function: Connects a single robot to a handle at a specified pose This function assumes that the robot and the bag are already correctly positioned for a grasp, which is why it should not be called directly Args: robot (Astrobee): Robot to attach handle_index (int): Index of the handle on the bag \"\"\" pass def detach ( self ) -> None : \"\"\"Detach all connections to the bag\"\"\" pass def detach_robot ( self , robot_id : int ) -> None : \"\"\"Detaches a specific robot from the bag Args: robot_id (int): Pybullet ID of the robot to detach \"\"\" pass def reset_to_handle_pose ( self , handle_pose : npt . ArrayLike , handle_index : int = 0 ) -> None : \"\"\"Resets the position of the bag so that the handle is positioned at a desired pose Args: handle_pose (npt.ArrayLike): Desired pose of the handle (\"handle-to-world\"), shape (7,) handle_index (int, optional): Index of the handle to align to the desired pose. Defaults to 0. \"\"\" handle_to_world = pos_quat_to_tmat ( handle_pose ) bag_to_handle = invert_transform_mat ( self . grasp_transforms [ handle_index ]) bag_to_world = handle_to_world @ bag_to_handle bag_pose = tmat_to_pos_quat ( bag_to_world ) # This assumes that we want the bag to be stationary self . reset_dynamics ( bag_pose [: 3 ], bag_pose [ 3 :], np . zeros ( 3 ), np . zeros ( 3 )) def reset_dynamics ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , lin_vel : npt . ArrayLike , ang_vel : npt . ArrayLike , ) -> None : \"\"\"Resets the pose and velocities of the bag Args: pos (npt.ArrayLike): Position, shape (3,) orn (npt.ArrayLike): XYZW quaternion orientation, shape (4,) lin_vel (npt.ArrayLike): Linear velocity, shape (3,) ang_vel (npt.ArrayLike): Angular velocity, shape (3,) \"\"\" self . client . resetBasePositionAndOrientation ( self . id , pos , orn ) self . client . resetBaseVelocity ( self . id , lin_vel , ang_vel ) @ property def bounding_box ( self ) -> np . ndarray : \"\"\"Current axis-aligned bounding box of the bag (or just the main compartment), shape (2, 3)\"\"\" # TODO convert to Box instance? return np . array ( self . client . getAABB ( self . id , - 1 )) Ancestors (in MRO) abc.ABC Descendants pyastrobee.core.deformable_bag.DeformableCargoBag pyastrobee.core.constraint_bag.ConstraintCargoBag pyastrobee.core.composite_bag.CompositeCargoBag pyastrobee.core.hybrid_bag.HybridCargoBag pyastrobee.core.rigid_bag.RigidCargoBag Class variables BAG_NAMES DUAL_HANDLE_BAGS HANDLE_TRANSFORMS HEIGHT LENGTH MESH_DIR SINGLE_HANDLE_BAGS URDF_DIR WIDTH Instance variables angular_velocity Current [wx, wy, wz] angular velocity of the cargo bag's COM frame If both velocity and angular velocity are desired, use the dynamics_state property instead attached ID(s) of the robot (or robots) grasping the bag. Empty if no robots are attached bounding_box Current axis-aligned bounding box of the bag (or just the main compartment), shape (2, 3) corner_positions Positions of the 8 corners of the main compartment of the bag, shape (8, 3) dynamics_state Current state of the bag dynamics: Position, orientation, linear vel, and angular vel grasp_transforms Transformation matrices \"handle to bag\" representing the grasp locations on the handles to the bag COM In the case of a single-handled bag, this list will only have one entry mass Mass of the cargo bag name Type of cargo bag num_handles Number of handles on the cargo bag orientation Current XYZW quaternion orientation of the cargo bag's COM frame pose Current position + XYZW quaternion pose of the bag position Current XYZ position of the origin (COM frame) of the cargo bag tmat Current transformation matrix for the cargo bag: (Bag to world) velocity Current [vx, vy, vz] velocity of the cargo bag's COM frame If both velocity and angular velocity are desired, use the dynamics_state property instead Methods attach_to def attach_to ( self , robot_or_robots : Union [ pyastrobee . core . astrobee . Astrobee , list [ pyastrobee . core . astrobee . Astrobee ], tuple [ pyastrobee . core . astrobee . Astrobee ]], object_to_move : str = 'robot' ) -> None Attaches a robot (or multiple robots) to the handle(s) of the bag Parameters: Name Type Description Default robot_or_robots Union[Astrobee, list[Astrobee], tuple[Astrobee]] Robot(s) to attach to the bag None object_to_move str Either \"robot\" or \"bag\". This dictates what object will get its position reset in order to make the grasp connection. In general, it makes more sense to move the robot to the bag (default behavior) None Raises: Type Description ValueError For invalid inputs, or if the bag does not have enough handles for each robot NotImplementedError Multi-robot case with >2 robots View Source def attach_to ( self , robot_or_robots : Union [ Astrobee, list[Astrobee ] , tuple [ Astrobee ] ] , object_to_move : str = \"robot\" , ) -> None : \"\"\"Attaches a robot (or multiple robots) to the handle(s) of the bag Args: robot_or_robots (Union[Astrobee, list[Astrobee], tuple[Astrobee]]): Robot(s) to attach to the bag object_to_move (str, optional): Either \" robot \" or \" bag \". This dictates what object will get its position reset in order to make the grasp connection. In general, it makes more sense to move the robot to the bag (default behavior) Raises: ValueError: For invalid inputs, or if the bag does not have enough handles for each robot NotImplementedError: Multi-robot case with >2 robots \"\"\" # Handle inputs if isinstance ( robot_or_robots , Astrobee ) : # Single robot num_robots = 1 elif isinstance ( robot_or_robots , ( list , tuple )) : # Multi - robot if not all ( isinstance ( r , Astrobee ) for r in robot_or_robots ) : raise ValueError ( \"Non-Astrobee input detected\" ) num_robots = len ( robot_or_robots ) if self . num_handles < num_robots : raise ValueError ( f \"Bag does not have enough handles to support {num_robots} robots\" ) if num_robots == 1 : # Edge case : Unpack the list if only one robot robot_or_robots = robot_or_robots [ 0 ] else : raise ValueError ( \"Invalid input: Must provide either an Astrobee or a list of multiple Astrobees\" ) if object_to_move not in { \"robot\" , \"bag\" }: raise ValueError ( \"Invalid object to move: Must be either 'robot' or 'bag'.\" ) bag_to_world = pos_quat_to_tmat ( self . pose ) if num_robots == 1 : robot = robot_or_robots # Unpack list if object_to_move == \"robot\" : # Reset the position of the robot to interface with the handle handle_to_bag = self . grasp_transforms [ 0 ] handle_to_world = bag_to_world @ handle_to_bag handle_pose = tmat_to_pos_quat ( handle_to_world ) robot . reset_to_ee_pose ( handle_pose ) else : # Move the bag to the robot self . reset_to_handle_pose ( robot . ee_pose ) self . _attach ( robot , 0 ) elif num_robots == 2 : robot_1 , robot_2 = robot_or_robots # Unpack list if object_to_move == \"robot\" : # Reset the position of each robot to interface with the two handles handle_1_to_bag = self . grasp_transforms [ 0 ] handle_2_to_bag = self . grasp_transforms [ 1 ] handle_1_to_world = bag_to_world @ handle_1_to_bag handle_2_to_world = bag_to_world @ handle_2_to_bag robot_1 . reset_to_ee_pose ( tmat_to_pos_quat ( handle_1_to_world )) robot_2 . reset_to_ee_pose ( tmat_to_pos_quat ( handle_2_to_world )) self . _attach ( robot_1 , 0 ) self . _attach ( robot_2 , 1 ) else : # Move the bag while leaving the robots static raise NotImplementedError ( \"Attaching the bag to multiple robots requires moving at least 1 robot\" ) else : raise NotImplementedError ( \"The multi-robot case is only implemented for 2 Astrobees\" ) detach def detach ( self ) -> None Detach all connections to the bag View Source def detach ( self ) -> None : \"\"\"Detach all connections to the bag\"\"\" pass detach_robot def detach_robot ( self , robot_id : int ) -> None Detaches a specific robot from the bag Parameters: Name Type Description Default robot_id int Pybullet ID of the robot to detach None View Source def detach_robot ( self , robot_id : int ) -> None : \"\"\"Detaches a specific robot from the bag Args: robot_id (int): Pybullet ID of the robot to detach \"\"\" pass reset_dynamics def reset_dynamics ( self , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], lin_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], ang_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> None Resets the pose and velocities of the bag Parameters: Name Type Description Default pos npt.ArrayLike Position, shape (3,) None orn npt.ArrayLike XYZW quaternion orientation, shape (4,) None lin_vel npt.ArrayLike Linear velocity, shape (3,) None ang_vel npt.ArrayLike Angular velocity, shape (3,) None View Source def reset_dynamics ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , lin_vel : npt . ArrayLike , ang_vel : npt . ArrayLike , ) -> None : \"\"\"Resets the pose and velocities of the bag Args: pos (npt.ArrayLike): Position, shape (3,) orn (npt.ArrayLike): XYZW quaternion orientation, shape (4,) lin_vel (npt.ArrayLike): Linear velocity, shape (3,) ang_vel (npt.ArrayLike): Angular velocity, shape (3,) \"\"\" self . client . resetBasePositionAndOrientation ( self . id , pos , orn ) self . client . resetBaseVelocity ( self . id , lin_vel , ang_vel ) reset_to_handle_pose def reset_to_handle_pose ( self , handle_pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], handle_index : int = 0 ) -> None Resets the position of the bag so that the handle is positioned at a desired pose Parameters: Name Type Description Default handle_pose npt.ArrayLike Desired pose of the handle (\"handle-to-world\"), shape (7,) None handle_index int Index of the handle to align to the desired pose. Defaults to 0. 0 View Source def reset_to_handle_pose ( self , handle_pose : npt . ArrayLike , handle_index : int = 0 ) -> None : \"\"\"Resets the position of the bag so that the handle is positioned at a desired pose Args: handle_pose (npt.ArrayLike): Desired pose of the handle (\" handle - to - world \"), shape (7,) handle_index (int, optional): Index of the handle to align to the desired pose. Defaults to 0. \"\"\" handle_to_world = pos_quat_to_tmat ( handle_pose ) bag_to_handle = invert_transform_mat ( self . grasp_transforms [ handle_index ] ) bag_to_world = handle_to_world @ bag_to_handle bag_pose = tmat_to_pos_quat ( bag_to_world ) # This assumes that we want the bag to be stationary self . reset_dynamics ( bag_pose [ :3 ] , bag_pose [ 3: ] , np . zeros ( 3 ), np . zeros ( 3 )) unload def unload ( self ) -> None Removes the cargo bag from the simulation View Source def unload ( self ) -> None : \"\"\"Removes the cargo bag from the simulation\"\"\" self . detach () self . client . removeBody ( self . id ) self . id = None","title":"Abstract Bag"},{"location":"reference/pyastrobee/core/abstract_bag/#module-pyastrobeecoreabstract_bag","text":"Abstract base class for representing cargo bags with different models View Source \"\"\"Abstract base class for representing cargo bags with different models\"\"\" from abc import ABC from typing import Union , Optional import pybullet from pybullet_utils.bullet_client import BulletClient import numpy as np import numpy.typing as npt from pyastrobee.core.astrobee import Astrobee from pyastrobee.utils.poses import pos_quat_to_tmat , tmat_to_pos_quat from pyastrobee.utils.transformations import invert_transform_mat from pyastrobee.utils.rotations import quat_to_rmat import pyastrobee.config.bag_properties as bag_props class CargoBag ( ABC ): \"\"\"Base (abstract) cargo bag class See inherited cargo bags for full implementations (deformable bag, rigid bag, constraint bag, ...) Args: bag_name (str): Type of cargo bag to load. Single handle: \"front_handle\", \"right_handle\", \"top_handle\". Dual handle: \"front_back_handle\", \"right_left_handle\", \"top_bottom_handle\" mass (float): Mass of the cargo bag, in kg pos (npt.ArrayLike): Initial XYZ position to load the bag orn (npt.ArrayLike): Initial XYZW quaternion to load the bag client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" LENGTH = 0.50 # meters WIDTH = 0.25 # meters HEIGHT = 0.42 # meters URDF_DIR = \"pyastrobee/assets/urdf/bags/\" MESH_DIR = \"pyastrobee/assets/meshes/bags/\" SINGLE_HANDLE_BAGS = [ \"front_handle\" , \"right_handle\" , \"top_handle\" , \"top_handle_symmetric\" , # TODO: Add more symmetric versions (single and dual handle) ] DUAL_HANDLE_BAGS = [ \"front_back_handle\" , \"right_left_handle\" , \"top_bottom_handle\" ] BAG_NAMES = SINGLE_HANDLE_BAGS + DUAL_HANDLE_BAGS HANDLE_TRANSFORMS = { \"front\" : bag_props . FRONT_HANDLE_TRANSFORM , \"back\" : bag_props . BACK_HANDLE_TRANSFORM , \"left\" : bag_props . LEFT_HANDLE_TRANSFORM , \"right\" : bag_props . RIGHT_HANDLE_TRANSFORM , \"top\" : bag_props . TOP_HANDLE_TRANSFORM , \"bottom\" : bag_props . BOTTOM_HANDLE_TRANSFORM , } def __init__ ( self , bag_name : str , mass : float , pos : npt . ArrayLike , orn : npt . ArrayLike , client : Optional [ BulletClient ] = None , ): self . client : pybullet = pybullet if client is None else client if not self . client . isConnected (): raise ConnectionError ( \"Need to connect to pybullet before loading a bag\" ) if bag_name not in self . BAG_NAMES : raise ValueError ( f \"Invalid bag name: { bag_name } . Must be one of { self . BAG_NAMES } \" ) self . _mass = mass self . _name = bag_name self . _attached = [] self . _dt = self . client . getPhysicsEngineParameters ()[ \"fixedTimeStep\" ] self . id = self . _load ( pos , orn ) if self . id < 0 : raise ValueError ( \"Bag was not properly loaded!\" ) @property def mass ( self ) -> float : \"\"\"Mass of the cargo bag\"\"\" return self . _mass @property def attached ( self ) -> list [ int ]: \"\"\"ID(s) of the robot (or robots) grasping the bag. Empty if no robots are attached\"\"\" return self . _attached @property def name ( self ) -> str : \"\"\"Type of cargo bag\"\"\" return self . _name @property def grasp_transforms ( self ) -> list [ np . ndarray ]: \"\"\"Transformation matrices \"handle to bag\" representing the grasp locations on the handles to the bag COM In the case of a single-handled bag, this list will only have one entry \"\"\" if self . _name . startswith ( \"front_handle\" ): return [ self . HANDLE_TRANSFORMS [ \"front\" ]] elif self . _name . startswith ( \"right_handle\" ): return [ self . HANDLE_TRANSFORMS [ \"right\" ]] elif self . _name . startswith ( \"top_handle\" ): return [ self . HANDLE_TRANSFORMS [ \"top\" ]] elif self . _name . startswith ( \"front_back_handle\" ): return [ self . HANDLE_TRANSFORMS [ \"front\" ], self . HANDLE_TRANSFORMS [ \"back\" ]] elif self . _name . startswith ( \"right_left_handle\" ): return [ self . HANDLE_TRANSFORMS [ \"right\" ], self . HANDLE_TRANSFORMS [ \"left\" ]] elif self . _name . startswith ( \"top_bottom_handle\" ): return [ self . HANDLE_TRANSFORMS [ \"top\" ], self . HANDLE_TRANSFORMS [ \"bottom\" ]] else : raise NotImplementedError ( f \"Grasp transform(s) not available for bag: { self . _name } \" ) @property def pose ( self ) -> np . ndarray : \"\"\"Current position + XYZW quaternion pose of the bag\"\"\" return np . concatenate ( self . client . getBasePositionAndOrientation ( self . id )) @property def tmat ( self ): \"\"\"Current transformation matrix for the cargo bag: (Bag to world)\"\"\" return pos_quat_to_tmat ( self . pose ) @property def position ( self ) -> np . ndarray : \"\"\"Current XYZ position of the origin (COM frame) of the cargo bag\"\"\" return np . array ( self . client . getBasePositionAndOrientation ( self . id )[ 0 ]) @property def orientation ( self ) -> np . ndarray : \"\"\"Current XYZW quaternion orientation of the cargo bag's COM frame\"\"\" return np . array ( self . client . getBasePositionAndOrientation ( self . id )[ 1 ]) # TODO decide if using dynamics state is actually the best here @property def velocity ( self ) -> np . ndarray : \"\"\"Current [vx, vy, vz] velocity of the cargo bag's COM frame - If both velocity and angular velocity are desired, use the dynamics_state property instead \"\"\" return np . array ( self . client . getBaseVelocity ( self . id )[ 0 ]) @property def angular_velocity ( self ) -> np . ndarray : \"\"\"Current [wx, wy, wz] angular velocity of the cargo bag's COM frame - If both velocity and angular velocity are desired, use the dynamics_state property instead \"\"\" return np . array ( self . client . getBaseVelocity ( self . id )[ 1 ]) @property def dynamics_state ( self ) -> tuple [ np . ndarray , np . ndarray , np . ndarray , np . ndarray ]: \"\"\"Current state of the bag dynamics: Position, orientation, linear vel, and angular vel Returns: tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: np.ndarray: Position, shape (3,) np.ndarray: XYZW quaternion orientation, shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) \"\"\" pos , orn = self . client . getBasePositionAndOrientation ( self . id ) lin_vel , ang_vel = self . client . getBaseVelocity ( self . id ) return ( np . array ( pos ), np . array ( orn ), np . array ( lin_vel ), np . array ( ang_vel ), ) @property def num_handles ( self ) -> int : \"\"\"Number of handles on the cargo bag\"\"\" if self . _name in self . SINGLE_HANDLE_BAGS : return 1 elif self . _name in self . DUAL_HANDLE_BAGS : return 2 else : raise ValueError ( \"Name not recognized - number of handles unknown\" ) @property def corner_positions ( self ) -> list [ np . ndarray ]: \"\"\"Positions of the 8 corners of the main compartment of the bag, shape (8, 3)\"\"\" # The main compartment is the base link in all URDFs pos , quat = self . client . getBasePositionAndOrientation ( self . id ) rmat = quat_to_rmat ( quat ) l , w , h = self . LENGTH , self . WIDTH , self . HEIGHT return ( pos + np . array ( [ [ l / 2 , w / 2 , h / 2 ], [ l / 2 , w / 2 , - h / 2 ], [ l / 2 , - w / 2 , h / 2 ], [ l / 2 , - w / 2 , - h / 2 ], [ - l / 2 , w / 2 , h / 2 ], [ - l / 2 , w / 2 , - h / 2 ], [ - l / 2 , - w / 2 , h / 2 ], [ - l / 2 , - w / 2 , - h / 2 ], ] ) @ rmat . T ) def _load ( self , pos : npt . ArrayLike , orn : npt . ArrayLike ) -> int : \"\"\"Loads a cargo bag at the specified position/orientation Args: pos (npt.ArrayLike): XYZ position, shape (3,) orn (npt.ArrayLike): XYZW quaternion, shape (4,) Returns: int: Pybullet ID for the cargo bag \"\"\" return - 1 # Dummy value def unload ( self ) -> None : \"\"\"Removes the cargo bag from the simulation\"\"\" self . detach () self . client . removeBody ( self . id ) self . id = None def attach_to ( self , robot_or_robots : Union [ Astrobee , list [ Astrobee ], tuple [ Astrobee ]], object_to_move : str = \"robot\" , ) -> None : \"\"\"Attaches a robot (or multiple robots) to the handle(s) of the bag Args: robot_or_robots (Union[Astrobee, list[Astrobee], tuple[Astrobee]]): Robot(s) to attach to the bag object_to_move (str, optional): Either \"robot\" or \"bag\". This dictates what object will get its position reset in order to make the grasp connection. In general, it makes more sense to move the robot to the bag (default behavior) Raises: ValueError: For invalid inputs, or if the bag does not have enough handles for each robot NotImplementedError: Multi-robot case with >2 robots \"\"\" # Handle inputs if isinstance ( robot_or_robots , Astrobee ): # Single robot num_robots = 1 elif isinstance ( robot_or_robots , ( list , tuple )): # Multi-robot if not all ( isinstance ( r , Astrobee ) for r in robot_or_robots ): raise ValueError ( \"Non-Astrobee input detected\" ) num_robots = len ( robot_or_robots ) if self . num_handles < num_robots : raise ValueError ( f \"Bag does not have enough handles to support { num_robots } robots\" ) if num_robots == 1 : # Edge case: Unpack the list if only one robot robot_or_robots = robot_or_robots [ 0 ] else : raise ValueError ( \"Invalid input: Must provide either an Astrobee or a list of multiple Astrobees\" ) if object_to_move not in { \"robot\" , \"bag\" }: raise ValueError ( \"Invalid object to move: Must be either 'robot' or 'bag'.\" ) bag_to_world = pos_quat_to_tmat ( self . pose ) if num_robots == 1 : robot = robot_or_robots # Unpack list if object_to_move == \"robot\" : # Reset the position of the robot to interface with the handle handle_to_bag = self . grasp_transforms [ 0 ] handle_to_world = bag_to_world @ handle_to_bag handle_pose = tmat_to_pos_quat ( handle_to_world ) robot . reset_to_ee_pose ( handle_pose ) else : # Move the bag to the robot self . reset_to_handle_pose ( robot . ee_pose ) self . _attach ( robot , 0 ) elif num_robots == 2 : robot_1 , robot_2 = robot_or_robots # Unpack list if object_to_move == \"robot\" : # Reset the position of each robot to interface with the two handles handle_1_to_bag = self . grasp_transforms [ 0 ] handle_2_to_bag = self . grasp_transforms [ 1 ] handle_1_to_world = bag_to_world @ handle_1_to_bag handle_2_to_world = bag_to_world @ handle_2_to_bag robot_1 . reset_to_ee_pose ( tmat_to_pos_quat ( handle_1_to_world )) robot_2 . reset_to_ee_pose ( tmat_to_pos_quat ( handle_2_to_world )) self . _attach ( robot_1 , 0 ) self . _attach ( robot_2 , 1 ) else : # Move the bag while leaving the robots static raise NotImplementedError ( \"Attaching the bag to multiple robots requires moving at least 1 robot\" ) else : raise NotImplementedError ( \"The multi-robot case is only implemented for 2 Astrobees\" ) def _attach ( self , robot : Astrobee , handle_index : int ) -> None : \"\"\"Helper function: Connects a single robot to a handle at a specified pose This function assumes that the robot and the bag are already correctly positioned for a grasp, which is why it should not be called directly Args: robot (Astrobee): Robot to attach handle_index (int): Index of the handle on the bag \"\"\" pass def detach ( self ) -> None : \"\"\"Detach all connections to the bag\"\"\" pass def detach_robot ( self , robot_id : int ) -> None : \"\"\"Detaches a specific robot from the bag Args: robot_id (int): Pybullet ID of the robot to detach \"\"\" pass def reset_to_handle_pose ( self , handle_pose : npt . ArrayLike , handle_index : int = 0 ) -> None : \"\"\"Resets the position of the bag so that the handle is positioned at a desired pose Args: handle_pose (npt.ArrayLike): Desired pose of the handle (\"handle-to-world\"), shape (7,) handle_index (int, optional): Index of the handle to align to the desired pose. Defaults to 0. \"\"\" handle_to_world = pos_quat_to_tmat ( handle_pose ) bag_to_handle = invert_transform_mat ( self . grasp_transforms [ handle_index ]) bag_to_world = handle_to_world @ bag_to_handle bag_pose = tmat_to_pos_quat ( bag_to_world ) # This assumes that we want the bag to be stationary self . reset_dynamics ( bag_pose [: 3 ], bag_pose [ 3 :], np . zeros ( 3 ), np . zeros ( 3 )) def reset_dynamics ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , lin_vel : npt . ArrayLike , ang_vel : npt . ArrayLike , ) -> None : \"\"\"Resets the pose and velocities of the bag Args: pos (npt.ArrayLike): Position, shape (3,) orn (npt.ArrayLike): XYZW quaternion orientation, shape (4,) lin_vel (npt.ArrayLike): Linear velocity, shape (3,) ang_vel (npt.ArrayLike): Angular velocity, shape (3,) \"\"\" self . client . resetBasePositionAndOrientation ( self . id , pos , orn ) self . client . resetBaseVelocity ( self . id , lin_vel , ang_vel ) @property def bounding_box ( self ) -> np . ndarray : \"\"\"Current axis-aligned bounding box of the bag (or just the main compartment), shape (2, 3)\"\"\" # TODO convert to Box instance? return np . array ( self . client . getAABB ( self . id , - 1 ))","title":"Module pyastrobee.core.abstract_bag"},{"location":"reference/pyastrobee/core/abstract_bag/#classes","text":"","title":"Classes"},{"location":"reference/pyastrobee/core/abstract_bag/#cargobag","text":"class CargoBag ( bag_name : str , mass : float , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) Base (abstract) cargo bag class See inherited cargo bags for full implementations (deformable bag, rigid bag, constraint bag, ...)","title":"CargoBag"},{"location":"reference/pyastrobee/core/abstract_bag/#attributes","text":"Name Type Description Default bag_name str Type of cargo bag to load. Single handle: \"front_handle\", \"right_handle\", \"top_handle\". Dual handle: \"front_back_handle\", \"right_left_handle\", \"top_bottom_handle\" None mass float Mass of the cargo bag, in kg None pos npt.ArrayLike Initial XYZ position to load the bag None orn npt.ArrayLike Initial XYZW quaternion to load the bag None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None View Source class CargoBag ( ABC ): \"\"\"Base (abstract) cargo bag class See inherited cargo bags for full implementations (deformable bag, rigid bag, constraint bag, ...) Args: bag_name (str): Type of cargo bag to load. Single handle: \"front_handle\", \"right_handle\", \"top_handle\". Dual handle: \"front_back_handle\", \"right_left_handle\", \"top_bottom_handle\" mass (float): Mass of the cargo bag, in kg pos (npt.ArrayLike): Initial XYZ position to load the bag orn (npt.ArrayLike): Initial XYZW quaternion to load the bag client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" LENGTH = 0.50 # meters WIDTH = 0.25 # meters HEIGHT = 0.42 # meters URDF_DIR = \"pyastrobee/assets/urdf/bags/\" MESH_DIR = \"pyastrobee/assets/meshes/bags/\" SINGLE_HANDLE_BAGS = [ \"front_handle\" , \"right_handle\" , \"top_handle\" , \"top_handle_symmetric\" , # TODO: Add more symmetric versions (single and dual handle) ] DUAL_HANDLE_BAGS = [ \"front_back_handle\" , \"right_left_handle\" , \"top_bottom_handle\" ] BAG_NAMES = SINGLE_HANDLE_BAGS + DUAL_HANDLE_BAGS HANDLE_TRANSFORMS = { \"front\" : bag_props . FRONT_HANDLE_TRANSFORM , \"back\" : bag_props . BACK_HANDLE_TRANSFORM , \"left\" : bag_props . LEFT_HANDLE_TRANSFORM , \"right\" : bag_props . RIGHT_HANDLE_TRANSFORM , \"top\" : bag_props . TOP_HANDLE_TRANSFORM , \"bottom\" : bag_props . BOTTOM_HANDLE_TRANSFORM , } def __init__ ( self , bag_name : str , mass : float , pos : npt . ArrayLike , orn : npt . ArrayLike , client : Optional [ BulletClient ] = None , ): self . client : pybullet = pybullet if client is None else client if not self . client . isConnected (): raise ConnectionError ( \"Need to connect to pybullet before loading a bag\" ) if bag_name not in self . BAG_NAMES : raise ValueError ( f \"Invalid bag name: {bag_name}. Must be one of {self.BAG_NAMES}\" ) self . _mass = mass self . _name = bag_name self . _attached = [] self . _dt = self . client . getPhysicsEngineParameters ()[ \"fixedTimeStep\" ] self . id = self . _load ( pos , orn ) if self . id < 0 : raise ValueError ( \"Bag was not properly loaded!\" ) @ property def mass ( self ) -> float : \"\"\"Mass of the cargo bag\"\"\" return self . _mass @ property def attached ( self ) -> list [ int ]: \"\"\"ID(s) of the robot (or robots) grasping the bag. Empty if no robots are attached\"\"\" return self . _attached @ property def name ( self ) -> str : \"\"\"Type of cargo bag\"\"\" return self . _name @ property def grasp_transforms ( self ) -> list [ np . ndarray ]: \"\"\"Transformation matrices \"handle to bag\" representing the grasp locations on the handles to the bag COM In the case of a single-handled bag, this list will only have one entry \"\"\" if self . _name . startswith ( \"front_handle\" ): return [ self . HANDLE_TRANSFORMS [ \"front\" ]] elif self . _name . startswith ( \"right_handle\" ): return [ self . HANDLE_TRANSFORMS [ \"right\" ]] elif self . _name . startswith ( \"top_handle\" ): return [ self . HANDLE_TRANSFORMS [ \"top\" ]] elif self . _name . startswith ( \"front_back_handle\" ): return [ self . HANDLE_TRANSFORMS [ \"front\" ], self . HANDLE_TRANSFORMS [ \"back\" ]] elif self . _name . startswith ( \"right_left_handle\" ): return [ self . HANDLE_TRANSFORMS [ \"right\" ], self . HANDLE_TRANSFORMS [ \"left\" ]] elif self . _name . startswith ( \"top_bottom_handle\" ): return [ self . HANDLE_TRANSFORMS [ \"top\" ], self . HANDLE_TRANSFORMS [ \"bottom\" ]] else : raise NotImplementedError ( f \"Grasp transform(s) not available for bag: {self._name}\" ) @ property def pose ( self ) -> np . ndarray : \"\"\"Current position + XYZW quaternion pose of the bag\"\"\" return np . concatenate ( self . client . getBasePositionAndOrientation ( self . id )) @ property def tmat ( self ): \"\"\"Current transformation matrix for the cargo bag: (Bag to world)\"\"\" return pos_quat_to_tmat ( self . pose ) @ property def position ( self ) -> np . ndarray : \"\"\"Current XYZ position of the origin (COM frame) of the cargo bag\"\"\" return np . array ( self . client . getBasePositionAndOrientation ( self . id )[ 0 ]) @ property def orientation ( self ) -> np . ndarray : \"\"\"Current XYZW quaternion orientation of the cargo bag's COM frame\"\"\" return np . array ( self . client . getBasePositionAndOrientation ( self . id )[ 1 ]) # TODO decide if using dynamics state is actually the best here @ property def velocity ( self ) -> np . ndarray : \"\"\"Current [vx, vy, vz] velocity of the cargo bag's COM frame - If both velocity and angular velocity are desired, use the dynamics_state property instead \"\"\" return np . array ( self . client . getBaseVelocity ( self . id )[ 0 ]) @ property def angular_velocity ( self ) -> np . ndarray : \"\"\"Current [wx, wy, wz] angular velocity of the cargo bag's COM frame - If both velocity and angular velocity are desired, use the dynamics_state property instead \"\"\" return np . array ( self . client . getBaseVelocity ( self . id )[ 1 ]) @ property def dynamics_state ( self ) -> tuple [ np . ndarray , np . ndarray , np . ndarray , np . ndarray ]: \"\"\"Current state of the bag dynamics: Position, orientation, linear vel, and angular vel Returns: tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: np.ndarray: Position, shape (3,) np.ndarray: XYZW quaternion orientation, shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) \"\"\" pos , orn = self . client . getBasePositionAndOrientation ( self . id ) lin_vel , ang_vel = self . client . getBaseVelocity ( self . id ) return ( np . array ( pos ), np . array ( orn ), np . array ( lin_vel ), np . array ( ang_vel ), ) @ property def num_handles ( self ) -> int : \"\"\"Number of handles on the cargo bag\"\"\" if self . _name in self . SINGLE_HANDLE_BAGS : return 1 elif self . _name in self . DUAL_HANDLE_BAGS : return 2 else : raise ValueError ( \"Name not recognized - number of handles unknown\" ) @ property def corner_positions ( self ) -> list [ np . ndarray ]: \"\"\"Positions of the 8 corners of the main compartment of the bag, shape (8, 3)\"\"\" # The main compartment is the base link in all URDFs pos , quat = self . client . getBasePositionAndOrientation ( self . id ) rmat = quat_to_rmat ( quat ) l , w , h = self . LENGTH , self . WIDTH , self . HEIGHT return ( pos + np . array ( [ [ l / 2 , w / 2 , h / 2 ], [ l / 2 , w / 2 , - h / 2 ], [ l / 2 , - w / 2 , h / 2 ], [ l / 2 , - w / 2 , - h / 2 ], [ - l / 2 , w / 2 , h / 2 ], [ - l / 2 , w / 2 , - h / 2 ], [ - l / 2 , - w / 2 , h / 2 ], [ - l / 2 , - w / 2 , - h / 2 ], ] ) @ rmat . T ) def _load ( self , pos : npt . ArrayLike , orn : npt . ArrayLike ) -> int : \"\"\"Loads a cargo bag at the specified position/orientation Args: pos (npt.ArrayLike): XYZ position, shape (3,) orn (npt.ArrayLike): XYZW quaternion, shape (4,) Returns: int: Pybullet ID for the cargo bag \"\"\" return - 1 # Dummy value def unload ( self ) -> None : \"\"\"Removes the cargo bag from the simulation\"\"\" self . detach () self . client . removeBody ( self . id ) self . id = None def attach_to ( self , robot_or_robots : Union [ Astrobee , list [ Astrobee ], tuple [ Astrobee ]], object_to_move : str = \"robot\" , ) -> None : \"\"\"Attaches a robot (or multiple robots) to the handle(s) of the bag Args: robot_or_robots (Union[Astrobee, list[Astrobee], tuple[Astrobee]]): Robot(s) to attach to the bag object_to_move (str, optional): Either \"robot\" or \"bag\". This dictates what object will get its position reset in order to make the grasp connection. In general, it makes more sense to move the robot to the bag (default behavior) Raises: ValueError: For invalid inputs, or if the bag does not have enough handles for each robot NotImplementedError: Multi-robot case with >2 robots \"\"\" # Handle inputs if isinstance ( robot_or_robots , Astrobee ): # Single robot num_robots = 1 elif isinstance ( robot_or_robots , ( list , tuple )): # Multi-robot if not all ( isinstance ( r , Astrobee ) for r in robot_or_robots ): raise ValueError ( \"Non-Astrobee input detected\" ) num_robots = len ( robot_or_robots ) if self . num_handles < num_robots : raise ValueError ( f \"Bag does not have enough handles to support {num_robots} robots\" ) if num_robots == 1 : # Edge case: Unpack the list if only one robot robot_or_robots = robot_or_robots [ 0 ] else : raise ValueError ( \"Invalid input: Must provide either an Astrobee or a list of multiple Astrobees\" ) if object_to_move not in { \"robot\" , \"bag\" }: raise ValueError ( \"Invalid object to move: Must be either 'robot' or 'bag'.\" ) bag_to_world = pos_quat_to_tmat ( self . pose ) if num_robots == 1 : robot = robot_or_robots # Unpack list if object_to_move == \"robot\" : # Reset the position of the robot to interface with the handle handle_to_bag = self . grasp_transforms [ 0 ] handle_to_world = bag_to_world @ handle_to_bag handle_pose = tmat_to_pos_quat ( handle_to_world ) robot . reset_to_ee_pose ( handle_pose ) else : # Move the bag to the robot self . reset_to_handle_pose ( robot . ee_pose ) self . _attach ( robot , 0 ) elif num_robots == 2 : robot_1 , robot_2 = robot_or_robots # Unpack list if object_to_move == \"robot\" : # Reset the position of each robot to interface with the two handles handle_1_to_bag = self . grasp_transforms [ 0 ] handle_2_to_bag = self . grasp_transforms [ 1 ] handle_1_to_world = bag_to_world @ handle_1_to_bag handle_2_to_world = bag_to_world @ handle_2_to_bag robot_1 . reset_to_ee_pose ( tmat_to_pos_quat ( handle_1_to_world )) robot_2 . reset_to_ee_pose ( tmat_to_pos_quat ( handle_2_to_world )) self . _attach ( robot_1 , 0 ) self . _attach ( robot_2 , 1 ) else : # Move the bag while leaving the robots static raise NotImplementedError ( \"Attaching the bag to multiple robots requires moving at least 1 robot\" ) else : raise NotImplementedError ( \"The multi-robot case is only implemented for 2 Astrobees\" ) def _attach ( self , robot : Astrobee , handle_index : int ) -> None : \"\"\"Helper function: Connects a single robot to a handle at a specified pose This function assumes that the robot and the bag are already correctly positioned for a grasp, which is why it should not be called directly Args: robot (Astrobee): Robot to attach handle_index (int): Index of the handle on the bag \"\"\" pass def detach ( self ) -> None : \"\"\"Detach all connections to the bag\"\"\" pass def detach_robot ( self , robot_id : int ) -> None : \"\"\"Detaches a specific robot from the bag Args: robot_id (int): Pybullet ID of the robot to detach \"\"\" pass def reset_to_handle_pose ( self , handle_pose : npt . ArrayLike , handle_index : int = 0 ) -> None : \"\"\"Resets the position of the bag so that the handle is positioned at a desired pose Args: handle_pose (npt.ArrayLike): Desired pose of the handle (\"handle-to-world\"), shape (7,) handle_index (int, optional): Index of the handle to align to the desired pose. Defaults to 0. \"\"\" handle_to_world = pos_quat_to_tmat ( handle_pose ) bag_to_handle = invert_transform_mat ( self . grasp_transforms [ handle_index ]) bag_to_world = handle_to_world @ bag_to_handle bag_pose = tmat_to_pos_quat ( bag_to_world ) # This assumes that we want the bag to be stationary self . reset_dynamics ( bag_pose [: 3 ], bag_pose [ 3 :], np . zeros ( 3 ), np . zeros ( 3 )) def reset_dynamics ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , lin_vel : npt . ArrayLike , ang_vel : npt . ArrayLike , ) -> None : \"\"\"Resets the pose and velocities of the bag Args: pos (npt.ArrayLike): Position, shape (3,) orn (npt.ArrayLike): XYZW quaternion orientation, shape (4,) lin_vel (npt.ArrayLike): Linear velocity, shape (3,) ang_vel (npt.ArrayLike): Angular velocity, shape (3,) \"\"\" self . client . resetBasePositionAndOrientation ( self . id , pos , orn ) self . client . resetBaseVelocity ( self . id , lin_vel , ang_vel ) @ property def bounding_box ( self ) -> np . ndarray : \"\"\"Current axis-aligned bounding box of the bag (or just the main compartment), shape (2, 3)\"\"\" # TODO convert to Box instance? return np . array ( self . client . getAABB ( self . id , - 1 ))","title":"Attributes"},{"location":"reference/pyastrobee/core/abstract_bag/#ancestors-in-mro","text":"abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/pyastrobee/core/abstract_bag/#descendants","text":"pyastrobee.core.deformable_bag.DeformableCargoBag pyastrobee.core.constraint_bag.ConstraintCargoBag pyastrobee.core.composite_bag.CompositeCargoBag pyastrobee.core.hybrid_bag.HybridCargoBag pyastrobee.core.rigid_bag.RigidCargoBag","title":"Descendants"},{"location":"reference/pyastrobee/core/abstract_bag/#class-variables","text":"BAG_NAMES DUAL_HANDLE_BAGS HANDLE_TRANSFORMS HEIGHT LENGTH MESH_DIR SINGLE_HANDLE_BAGS URDF_DIR WIDTH","title":"Class variables"},{"location":"reference/pyastrobee/core/abstract_bag/#instance-variables","text":"angular_velocity Current [wx, wy, wz] angular velocity of the cargo bag's COM frame If both velocity and angular velocity are desired, use the dynamics_state property instead attached ID(s) of the robot (or robots) grasping the bag. Empty if no robots are attached bounding_box Current axis-aligned bounding box of the bag (or just the main compartment), shape (2, 3) corner_positions Positions of the 8 corners of the main compartment of the bag, shape (8, 3) dynamics_state Current state of the bag dynamics: Position, orientation, linear vel, and angular vel grasp_transforms Transformation matrices \"handle to bag\" representing the grasp locations on the handles to the bag COM In the case of a single-handled bag, this list will only have one entry mass Mass of the cargo bag name Type of cargo bag num_handles Number of handles on the cargo bag orientation Current XYZW quaternion orientation of the cargo bag's COM frame pose Current position + XYZW quaternion pose of the bag position Current XYZ position of the origin (COM frame) of the cargo bag tmat Current transformation matrix for the cargo bag: (Bag to world) velocity Current [vx, vy, vz] velocity of the cargo bag's COM frame If both velocity and angular velocity are desired, use the dynamics_state property instead","title":"Instance variables"},{"location":"reference/pyastrobee/core/abstract_bag/#methods","text":"","title":"Methods"},{"location":"reference/pyastrobee/core/abstract_bag/#attach_to","text":"def attach_to ( self , robot_or_robots : Union [ pyastrobee . core . astrobee . Astrobee , list [ pyastrobee . core . astrobee . Astrobee ], tuple [ pyastrobee . core . astrobee . Astrobee ]], object_to_move : str = 'robot' ) -> None Attaches a robot (or multiple robots) to the handle(s) of the bag Parameters: Name Type Description Default robot_or_robots Union[Astrobee, list[Astrobee], tuple[Astrobee]] Robot(s) to attach to the bag None object_to_move str Either \"robot\" or \"bag\". This dictates what object will get its position reset in order to make the grasp connection. In general, it makes more sense to move the robot to the bag (default behavior) None Raises: Type Description ValueError For invalid inputs, or if the bag does not have enough handles for each robot NotImplementedError Multi-robot case with >2 robots View Source def attach_to ( self , robot_or_robots : Union [ Astrobee, list[Astrobee ] , tuple [ Astrobee ] ] , object_to_move : str = \"robot\" , ) -> None : \"\"\"Attaches a robot (or multiple robots) to the handle(s) of the bag Args: robot_or_robots (Union[Astrobee, list[Astrobee], tuple[Astrobee]]): Robot(s) to attach to the bag object_to_move (str, optional): Either \" robot \" or \" bag \". This dictates what object will get its position reset in order to make the grasp connection. In general, it makes more sense to move the robot to the bag (default behavior) Raises: ValueError: For invalid inputs, or if the bag does not have enough handles for each robot NotImplementedError: Multi-robot case with >2 robots \"\"\" # Handle inputs if isinstance ( robot_or_robots , Astrobee ) : # Single robot num_robots = 1 elif isinstance ( robot_or_robots , ( list , tuple )) : # Multi - robot if not all ( isinstance ( r , Astrobee ) for r in robot_or_robots ) : raise ValueError ( \"Non-Astrobee input detected\" ) num_robots = len ( robot_or_robots ) if self . num_handles < num_robots : raise ValueError ( f \"Bag does not have enough handles to support {num_robots} robots\" ) if num_robots == 1 : # Edge case : Unpack the list if only one robot robot_or_robots = robot_or_robots [ 0 ] else : raise ValueError ( \"Invalid input: Must provide either an Astrobee or a list of multiple Astrobees\" ) if object_to_move not in { \"robot\" , \"bag\" }: raise ValueError ( \"Invalid object to move: Must be either 'robot' or 'bag'.\" ) bag_to_world = pos_quat_to_tmat ( self . pose ) if num_robots == 1 : robot = robot_or_robots # Unpack list if object_to_move == \"robot\" : # Reset the position of the robot to interface with the handle handle_to_bag = self . grasp_transforms [ 0 ] handle_to_world = bag_to_world @ handle_to_bag handle_pose = tmat_to_pos_quat ( handle_to_world ) robot . reset_to_ee_pose ( handle_pose ) else : # Move the bag to the robot self . reset_to_handle_pose ( robot . ee_pose ) self . _attach ( robot , 0 ) elif num_robots == 2 : robot_1 , robot_2 = robot_or_robots # Unpack list if object_to_move == \"robot\" : # Reset the position of each robot to interface with the two handles handle_1_to_bag = self . grasp_transforms [ 0 ] handle_2_to_bag = self . grasp_transforms [ 1 ] handle_1_to_world = bag_to_world @ handle_1_to_bag handle_2_to_world = bag_to_world @ handle_2_to_bag robot_1 . reset_to_ee_pose ( tmat_to_pos_quat ( handle_1_to_world )) robot_2 . reset_to_ee_pose ( tmat_to_pos_quat ( handle_2_to_world )) self . _attach ( robot_1 , 0 ) self . _attach ( robot_2 , 1 ) else : # Move the bag while leaving the robots static raise NotImplementedError ( \"Attaching the bag to multiple robots requires moving at least 1 robot\" ) else : raise NotImplementedError ( \"The multi-robot case is only implemented for 2 Astrobees\" )","title":"attach_to"},{"location":"reference/pyastrobee/core/abstract_bag/#detach","text":"def detach ( self ) -> None Detach all connections to the bag View Source def detach ( self ) -> None : \"\"\"Detach all connections to the bag\"\"\" pass","title":"detach"},{"location":"reference/pyastrobee/core/abstract_bag/#detach_robot","text":"def detach_robot ( self , robot_id : int ) -> None Detaches a specific robot from the bag Parameters: Name Type Description Default robot_id int Pybullet ID of the robot to detach None View Source def detach_robot ( self , robot_id : int ) -> None : \"\"\"Detaches a specific robot from the bag Args: robot_id (int): Pybullet ID of the robot to detach \"\"\" pass","title":"detach_robot"},{"location":"reference/pyastrobee/core/abstract_bag/#reset_dynamics","text":"def reset_dynamics ( self , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], lin_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], ang_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> None Resets the pose and velocities of the bag Parameters: Name Type Description Default pos npt.ArrayLike Position, shape (3,) None orn npt.ArrayLike XYZW quaternion orientation, shape (4,) None lin_vel npt.ArrayLike Linear velocity, shape (3,) None ang_vel npt.ArrayLike Angular velocity, shape (3,) None View Source def reset_dynamics ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , lin_vel : npt . ArrayLike , ang_vel : npt . ArrayLike , ) -> None : \"\"\"Resets the pose and velocities of the bag Args: pos (npt.ArrayLike): Position, shape (3,) orn (npt.ArrayLike): XYZW quaternion orientation, shape (4,) lin_vel (npt.ArrayLike): Linear velocity, shape (3,) ang_vel (npt.ArrayLike): Angular velocity, shape (3,) \"\"\" self . client . resetBasePositionAndOrientation ( self . id , pos , orn ) self . client . resetBaseVelocity ( self . id , lin_vel , ang_vel )","title":"reset_dynamics"},{"location":"reference/pyastrobee/core/abstract_bag/#reset_to_handle_pose","text":"def reset_to_handle_pose ( self , handle_pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], handle_index : int = 0 ) -> None Resets the position of the bag so that the handle is positioned at a desired pose Parameters: Name Type Description Default handle_pose npt.ArrayLike Desired pose of the handle (\"handle-to-world\"), shape (7,) None handle_index int Index of the handle to align to the desired pose. Defaults to 0. 0 View Source def reset_to_handle_pose ( self , handle_pose : npt . ArrayLike , handle_index : int = 0 ) -> None : \"\"\"Resets the position of the bag so that the handle is positioned at a desired pose Args: handle_pose (npt.ArrayLike): Desired pose of the handle (\" handle - to - world \"), shape (7,) handle_index (int, optional): Index of the handle to align to the desired pose. Defaults to 0. \"\"\" handle_to_world = pos_quat_to_tmat ( handle_pose ) bag_to_handle = invert_transform_mat ( self . grasp_transforms [ handle_index ] ) bag_to_world = handle_to_world @ bag_to_handle bag_pose = tmat_to_pos_quat ( bag_to_world ) # This assumes that we want the bag to be stationary self . reset_dynamics ( bag_pose [ :3 ] , bag_pose [ 3: ] , np . zeros ( 3 ), np . zeros ( 3 ))","title":"reset_to_handle_pose"},{"location":"reference/pyastrobee/core/abstract_bag/#unload","text":"def unload ( self ) -> None Removes the cargo bag from the simulation View Source def unload ( self ) -> None : \"\"\"Removes the cargo bag from the simulation\"\"\" self . detach () self . client . removeBody ( self . id ) self . id = None","title":"unload"},{"location":"reference/pyastrobee/core/astrobee/","text":"Module pyastrobee.core.astrobee Manages the properties of the astrobee and all control-associated functions In general, we assume that we're working with Honey. Multiple astrobees can be loaded, but we assume that they all have the exact same configuration View Source \"\"\"Manages the properties of the astrobee and all control-associated functions In general, we assume that we're working with Honey. Multiple astrobees can be loaded, but we assume that they all have the exact same configuration \"\"\" from typing import Optional , Union from enum import Enum import pybullet from pybullet_utils.bullet_client import BulletClient import numpy as np import numpy.typing as npt from pyastrobee.utils.bullet_utils import initialize_pybullet , run_sim from pyastrobee.utils.transformations import ( make_transform_mat , invert_transform_mat , transform_point , ) from pyastrobee.utils.rotations import quat_to_rmat from pyastrobee.utils.poses import tmat_to_pos_quat , pos_quat_to_tmat from pyastrobee.config import astrobee_transforms from pyastrobee.config.astrobee_geom import COLLISION_RADIUS from pyastrobee.utils.python_utils import print_green from pyastrobee.utils.dynamics import ( inertial_transformation , state_matrix , control_matrix , ) class Astrobee : \"\"\"Astrobee class for managing control, states, and properties Args: pose (npt.ArrayLike, optional): Initial pose of the astrobee when loaded. Defaults to (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0) (At origin, pointed forward along x axis). arm_joints (npt.ArrayLike, optional): Initial position of the arm's joints. Defaults to (0.0, 0.0) (Hanging straight down) gripper_pos (float, optional): Initial gripper position, in [0, 100]. Defaults to 100 (fully open) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Raises: ConnectionError: If a pybullet server is not connected before initialization \"\"\" URDF = \"pyastrobee/assets/urdf/astrobee/astrobee.urdf\" NUM_JOINTS = 7 NUM_LINKS = 8 TRANSFORMS = astrobee_transforms # TODO figure out if this is the best way to store this info GRIPPER_JOINT_IDXS = [ 3 , 4 , 5 , 6 ] ARM_JOINT_IDXS = [ 1 , 2 ] # Joint limit information is extracted from the URDF # Joint pos limits are [lower, upper] for each joint JOINT_POS_LIMITS = np . array ( [ [ 0.0 , 0.0 ], # top aft (fixed) [ - 2.0944 , 1.57079 ], # arm proximal joint [ - 1.57079 , 1.57079 ], # arm distal joint [ 0.349066 , 0.698132 ], # gripper left proximal joint [ - 1.22173 , - 0.69813 ], # gripper left distal joint [ - 0.698132 , - 0.349066 ], # gripper right proximal joint [ 0.69813 , 1.22173 ], # gripper right distal joint ] ) JOINT_EFFORT_LIMITS = np . array ( [ 0.0 , # top aft (fixed) 1.0 , # arm proximal joint 1.0 , # arm distal joint 0.1 , # gripper left proximal joint 0.1 , # gripper left distal joint 0.1 , # gripper right proximal joint 0.1 , # gripper right distal joint ] ) JOINT_VEL_LIMITS = np . array ( [ 0.00 , # top aft (fixed) 0.12 , # arm proximal joint 0.12 , # arm distal joint 0.12 , # gripper left proximal joint 0.12 , # gripper left distal joint 0.12 , # gripper right proximal joint 0.12 , # gripper right distal joint ] ) # Bounding sphere for collision modeling COLLISION_RADIUS = COLLISION_RADIUS class Joints ( Enum ): \"\"\"Enumerates the different joints on the astrobee via their Pybullet index\"\"\" # Comments indicate the name of the joint in the URDF ARM_BASE = 0 # top_aft (fixed joint) ARM_PROXIMAL = 1 # top_aft_arm_proximal_joint ARM_DISTAL = 2 # top_aft_arm_distal_joint GRIPPER_LEFT_PROXIMAL = 3 # top_aft_gripper_left_proximal_joint GRIPPER_LEFT_DISTAL = 4 # top_aft_gripper_left_distal_joint GRIPPER_RIGHT_PROXIMAL = 5 # top_aft_gripper_right_proximal_joint GRIPPER_RIGHT_DISTAL = 6 # top_aft_gripper_right_distal_joint class Links ( Enum ): \"\"\"Enumerates the different links on the astrobee via their Pybullet index Note: the URDF technically has 8 links, but it appears that pybullet considers the very first link to be the base link \"\"\" # Comments indicate the name of the link in the URDF BODY = - 1 # honey_body ARM_BASE = 0 # honey_top_aft ARM_PROXIMAL = 1 # honey_top_aft_arm_proximal_link ARM_DISTAL = 2 # honey_top_aft_arm_distal_link GRIPPER_LEFT_PROXIMAL = 3 # honey_top_aft_gripper_left_proximal_link GRIPPER_LEFT_DISTAL = 4 # honey_top_aft_gripper_left_distal_link GRIPPER_RIGHT_PROXIMAL = 5 # honey_top_aft_gripper_right_proximal_link GRIPPER_RIGHT_DISTAL = 6 # honey_top_aft_gripper_right_distal_link def __init__ ( self , pose : npt . ArrayLike = ( 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 1.0 ), arm_joints : npt . ArrayLike = ( 0.0 , 0.0 ), gripper_pos : float = 100 , client : Optional [ BulletClient ] = None , ): self . client : pybullet = pybullet if client is None else client if not self . client . isConnected (): raise ConnectionError ( \"Need to connect to pybullet before initializing an astrobee\" ) self . id = self . client . loadURDF ( Astrobee . URDF , pose [: 3 ], pose [ 3 :], flags = pybullet . URDF_USE_INERTIA_FROM_FILE ) self . _dt = self . client . getPhysicsEngineParameters ()[ \"fixedTimeStep\" ] self . set_gripper_position ( gripper_pos , force = True ) self . set_arm_joints ( arm_joints , force = True ) # Initialize dynamics info with estimated numbers from NASA, we can recompute based on the sim state later # if desired. Values are from A Brief Guide to Astrobee self . _mass = 9.58 # kg self . _inertia = np . diag ([ 0.153 , 0.143 , 0.162 ]) # kg-m^2 self . _inv_inertia = np . linalg . inv ( self . _inertia ) self . _local_com_position = np . zeros ( 3 ) # Init, not accurate # TODO decide if we should recompute automatically??? # self.recompute_inertial_properties() print_green ( \"Astrobee is ready\" ) def unload ( self ) -> None : \"\"\"Remove the Astrobee from the simulation\"\"\" self . client . removeBody ( self . id ) @property def pose ( self ) -> np . ndarray : \"\"\"The current robot pose (position + XYZW quaternion) expressed in world frame Returns: np.ndarray: Position and quaternion, size (7,) \"\"\" pos , orn = self . client . getBasePositionAndOrientation ( self . id ) return np . concatenate ([ pos , orn ]) @property def tmat ( self ) -> np . ndarray : \"\"\"The current robot pose in world frame, expressed as a transformation matrix Returns: np.ndarray: Transformation matrix (Robot to World), shape (4,4) \"\"\" return pos_quat_to_tmat ( self . pose ) @property def position ( self ) -> np . ndarray : \"\"\"Just the position component of the full pose Returns: np.ndarray: (3,) position vector \"\"\" return self . pose [: 3 ] @property def orientation ( self ) -> np . ndarray : \"\"\"Just the quaternion component of the full pose Returns: np.ndarray: (4,) XYZW quaternion \"\"\" return self . pose [ 3 :] @property def rmat ( self ) -> np . ndarray : \"\"\"The orientation of the robot expressed as a rotation matrix Returns: np.ndarray: Rotation matrix (Robot to World), shape (3,3) \"\"\" return quat_to_rmat ( self . orientation ) @property def heading ( self ) -> np . ndarray : \"\"\"A unit vector in the forward (x) component of the astrobee Some notes: - This is NOT a full description of orientation since rotation about this axis is undefined - The arm is on the REAR side of the astrobee, not the front - The y vector points to the port (left) side of the astrobee, and the z vector is up Returns: np.ndarray: (3,) unit vector \"\"\" R_R2W = quat_to_rmat ( self . orientation ) # Robot to world return R_R2W [:, 0 ] # Robot frame x vector expressed in world @property def velocity ( self ) -> np . ndarray : \"\"\"Linear velocity of the Astrobee, with respect to the world frame xyz axes Returns: np.ndarray: [vx, vy, vz] linear velocities, shape (3,) \"\"\" lin_vel , _ = self . client . getBaseVelocity ( self . id ) return np . array ( lin_vel ) @property def angular_velocity ( self ) -> np . ndarray : \"\"\"Angular velocity of the Astrobee, about the world frame xyz axes Returns: np.ndarray: [wx, wy, wz] angular velocities, shape (3,) \"\"\" _ , ang_vel = self . client . getBaseVelocity ( self . id ) return np . array ( ang_vel ) @property def ee_pose ( self ) -> np . ndarray : \"\"\"The current end-effector pose (position + XYZW quaternion) expressed in world frame Returns: np.ndarray: Position and quaternion, size (7,) \"\"\" return tmat_to_pos_quat ( self . ee_tmat ) @property def ee_tmat ( self ) -> np . ndarray : \"\"\"The current end-effector transformation matrix (gripper-to-world) Returns: np.ndarray: Transformation matrix, shape (4, 4) \"\"\" T_G2D = Astrobee . TRANSFORMS . GRIPPER_TO_ARM_DISTAL # Gripper to distal T_D2W = self . get_link_transform ( Astrobee . Links . ARM_DISTAL . value ) # Distal to world return T_D2W @ T_G2D @property def joint_angles ( self ) -> np . ndarray : \"\"\"Angular positions (radians) of each joint on the Astrobee Returns: np.ndarray: Joint angles, shape (NUM_JOINTS,) \"\"\" # States: tuple[tuple], size (7, 4) # 7 corresponds to NUM_JOINTS # 4 corresponds to position, velocity, reaction forces, and applied torque states = self . client . getJointStates ( self . id , list ( range ( Astrobee . NUM_JOINTS ))) # Index 0: position return np . array ([ states [ i ][ 0 ] for i in range ( Astrobee . NUM_JOINTS )]) @property def joint_vels ( self ) -> np . ndarray : \"\"\"Angular velocities (radians/sec) of each joint on the Astrobee Returns: np.ndarray: Joint velocities, shape (NUM_JOINTS,) \"\"\" states = self . client . getJointStates ( self . id , list ( range ( Astrobee . NUM_JOINTS ))) # Index 1: velocity return np . array ([ states [ i ][ 1 ] for i in range ( Astrobee . NUM_JOINTS )]) @property def joint_torques ( self ) -> np . ndarray : \"\"\"Torques (N-m) applied by each joint on the Astrobee Returns: np.ndarray: Joint torques, shape (NUM_JOINTS,) \"\"\" states = self . client . getJointStates ( self . id , list ( range ( Astrobee . NUM_JOINTS ))) # Index 3: torque return np . array ([ states [ i ][ 3 ] for i in range ( Astrobee . NUM_JOINTS )]) @property def arm_joint_angles ( self ) -> np . ndarray : \"\"\"Gives the two joint angles associated with the proximal + distal joints of the arm Returns: np.ndarray: Arm joint angles, shape (2,) \"\"\" return self . joint_angles [ Astrobee . ARM_JOINT_IDXS ] @property def gripper_joint_angles ( self ) -> np . ndarray : \"\"\"Gives the four joint angles associated with the proximal + distal joints of the two gripper fingers Returns: np.ndarray: Gripper joint angles, shape (4,) \"\"\" return self . joint_angles [ Astrobee . GRIPPER_JOINT_IDXS ] @property def inertia ( self ) -> np . ndarray : \"\"\"Body inertia tensor for the Astrobee, shape (3, 3)\"\"\" return self . _inertia @property def inv_inertia ( self ) -> np . ndarray : \"\"\"Inverse of the Astrobee's body inertia tensor, shape (3, 3)\"\"\" return self . _inv_inertia @property def world_inertia ( self ) -> np . ndarray : \"\"\"World-frame inertia tensor of the Astrobee, shape (3, 3) This takes into account the current rotation of Astrobee \"\"\" R = self . rmat return R @ self . inertia @ R . T @property def world_inv_inertia ( self ) -> np . ndarray : \"\"\"Inverse of the world-frame inertia tensor of the Astrobee, shape (3, 3) This takes into account the current rotation of Astrobee \"\"\" R = self . rmat return R @ self . inv_inertia @ R . T @property def mass ( self ) -> float : \"\"\"Mass of the Astrobee\"\"\" return self . _mass @property def local_com_position ( self ) -> np . ndarray : \"\"\"Position of the center of mass of the robot w.r.t. the base, in local frame. Shape (3,)\"\"\" return self . _local_com_position @property def world_com_position ( self ) -> np . ndarray : \"\"\"Position of the center of mass of the robot, in world frame. Shape (3,)\"\"\" return transform_point ( self . tmat , self . local_com_position ) @property def state_space_matrices ( self ) -> tuple [ np . ndarray , np . ndarray ]: \"\"\"The state and control matrices A and B, such that x_dot = Ax + Bu We assume that the state x = [position, velocity, quaternion, angular velocity] \u2208 R13 and that the control u = [force, torque] \u2208 R6 We linearize the system about the current state Returns: tuple[np.ndarray, np.ndarray]: np.ndarray: A: State matrix, shape (13, 13) np.ndarray: B: Control matrix, shape (13, 6) \"\"\" # TODO: decide if using the true joint-angle-based inertia tensor _ , q , _ , w = self . dynamics_state R = self . rmat # Use inertias defined in the world frame inertia = R @ self . inertia @ R . T inv_inertia = R @ self . inv_inertia @ R . T return ( state_matrix ( q , w , inertia , inv_inertia ), control_matrix ( self . mass , inv_inertia ), ) @property def state_vector ( self ) -> np . ndarray : \"\"\"The state vector x, such that x_dot = Ax + Bu We compose the state as [position, velocity, quaternion, angular velocity] \u2208 R13 \"\"\" pos , orn = self . client . getBasePositionAndOrientation ( self . id ) lin_vel , ang_vel = self . client . getBaseVelocity ( self . id ) return np . concatenate ([ pos , lin_vel , orn , ang_vel ]) @property def dynamics_state ( self ) -> tuple [ np . ndarray , np . ndarray , np . ndarray , np . ndarray ]: \"\"\"Current state of the Astrobee's dynamics: Position, orientation, linear vel, and angular vel Returns: tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: np.ndarray: Position, shape (3,) np.ndarray: XYZW quaternion orientation, shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) \"\"\" pos , orn = self . client . getBasePositionAndOrientation ( self . id ) lin_vel , ang_vel = self . client . getBaseVelocity ( self . id ) return np . array ( pos ), np . array ( orn ), np . array ( lin_vel ), np . array ( ang_vel ) @property def mass_matrix ( self ) -> np . ndarray : \"\"\"Mass/Inertia matrix for the Astrobee, given its current configuration - This is used to determine the kinetic energy (K = (1/2) * qdot.T @ M @ qdot) or the relationship between joint accelerations and torque (M * joint_accels + centrifugal_coriolis_vec + gravity_vec = torque) Returns: np.ndarray: The mass matrix, shape (12, 12). (12 is the number of degrees of freedom of the Astrobee - 6 DOF for a floating base, plus 6 for the six non-fixed joints) \"\"\" # Inputs must be a lists (no numpy) or else pybullet will seg fault M = self . client . calculateMassMatrix ( self . id , list ( self . joint_angles )) return np . array ( M ) def get_jacobians ( self , link : Union [ Links , int ], local_pos : npt . ArrayLike = ( 0.0 , 0.0 , 0.0 ) ) -> tuple [ np . ndarray , np . ndarray ]: \"\"\"Calculate the linear and angular jacobians (Jv and Jw) for a point on a link - These relate joint motion and task-space motion: [v; w] = [Jv; Jw] * dq - These jacobians will have a 12 columns corresponding to 6 DOF from the Astrobee's floating base, plus another 6 DOF from the non-fixed joints Args: link (Union[Links, int]): Link or link index of interest. Common links: For the base, set this to -1. For the arm distal link, set this to 2 local_pos (npt.ArrayLike, optional): Position in the link's reference frame. Defaults to [0.0, 0.0, 0.0]. For the grasp point, use the position from the calibrated distal/grasp transformation Returns: tuple[np.ndarray, np.ndarray]: np.ndarray: Jv: Linear jacobian, shape (3, 12) np.ndarray: Jw: Angular jacobian, shape (3, 12) \"\"\" if isinstance ( link , Astrobee . Links ): link = link . value ndof = 6 # 7 joints, but 1 fixed # The quickstart guide says that the joint velocities and desired accelerations are just there # for an internal call to calculateInverseDynamics (and maybe aren't really meaningful?) desired_accels = ndof * [ 0.0 ] # All inputs must be lists (no numpy) or else pybullet will seg fault Jv , Jw = self . client . calculateJacobian ( self . id , link , list ( local_pos ), list ( self . joint_angles )[ 1 :], # Don't include the first fixed joint list ( self . joint_vels )[ 1 :], # Don't include the first fixed joint desired_accels , ) return np . array ( Jv ), np . array ( Jw ) def get_link_transform ( self , link_index : Union [ Links , int ]) -> np . ndarray : \"\"\"Calculates the transformation matrix (w.r.t the world) for a specified link Args: link_index (int): Index of the link on the robot Returns: np.ndarray: Transformation matrix (link to world). Shape = (4,4) \"\"\" if isinstance ( link_index , Astrobee . Links ): link_index = link_index . value # We have 8 links, indexed from -1 to 6 # Pybullet does not allow access to the base link (-1) through getLinkState # So, use this only for non-base links if link_index > 6 or link_index < 0 : raise ValueError ( f \"Invalid link index: { link_index } \" ) link_state = self . client . getLinkState ( self . id , link_index , computeForwardKinematics = True ) # First two link state values are linkWorldPosition, linkWorldOrientation # There are other state positions and orientations, but they're confusing. (TODO check on these) pos , quat = link_state [: 2 ] return make_transform_mat ( quat_to_rmat ( quat ), pos ) @property # Is this better as a property or as a \"getter\"? def gripper_position ( self ) -> int : \"\"\"The current position of the gripper, in range [0, 100] Returns: int: Position of the gripper, an integer between 0 (closed) and 100 (open) \"\"\" joint_states = self . client . getJointStates ( self . id , Astrobee . GRIPPER_JOINT_IDXS ) joint_angles = [ state [ 0 ] for state in joint_states ] l_angles = joint_angles [: 2 ] r_angles = joint_angles [ 2 :] l_closed , l_open , r_closed , r_open = self . _get_gripper_joint_ranges () l_pct = 100 * ( l_angles - l_closed ) / ( l_open - l_closed ) r_pct = 100 * ( r_angles - r_closed ) / ( r_open - r_closed ) return np . round ( np . average ( np . concatenate ([ l_pct , r_pct ]))) . astype ( int ) # TODO decide if we need finer-grain control of the individual joints, or if this integer-position is fine def set_gripper_position ( self , position : float , force : bool = False , wait : bool = False ) -> None : \"\"\"Sets the gripper to a position between 0 (fully closed) to 100 (fully open) Args: position (float): Gripper position, in range [0, 100] force (bool, optional): Whether to (non-physically) instantly reset the gripper position, instead of stepping the sim. Should only be used at initialization. Defaults to False wait (bool, optional): Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False \"\"\" if position < 0 or position > 100 : raise ValueError ( \"Position should be in range [0, 100]\" ) l_closed , l_open , r_closed , r_open = self . _get_gripper_joint_ranges () left_pos = l_closed + ( position / 100 ) * ( l_open - l_closed ) right_pos = r_closed + ( position / 100 ) * ( r_open - r_closed ) angle_cmd = [ * left_pos , * right_pos ] self . set_gripper_joints ( angle_cmd , force , wait ) def open_gripper ( self ) -> None : \"\"\"Fully opens the gripper\"\"\" self . set_gripper_position ( 100 ) # TODO add force/torque control? def close_gripper ( self ) -> None : \"\"\"Fully closes the gripper\"\"\" self . set_gripper_position ( 0 ) # TODO rework this? def _get_gripper_joint_ranges ( self , ) -> tuple [ np . ndarray , np . ndarray , np . ndarray , np . ndarray ]: \"\"\"Helper function to determine the range of motion (closed -> open) of the gripper joints - This is a bit confusing because of how the URDF specifies joint min/max and how this translates to an open/closed position on the gripper - For a fully-closed gripper, the right side joints are at their max, and the left side joints are at their min - Likewise, for a fully-open gripper, the right side is at the joint min, and the left at joint max Returns: tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: np.ndarray: Left-side gripper finger angles when closed. Shape (2,) np.ndarray: Left-side gripper finger angles when open. Shape (2,) np.ndarray: Right-side gripper finger angles when closed. Shape (2,) np.ndarray: Right-side gripper finger angles when open. Shape (2,) \"\"\" left_joints = Astrobee . GRIPPER_JOINT_IDXS [: 2 ] right_joints = Astrobee . GRIPPER_JOINT_IDXS [ 2 :] # As a numpy array, each row will correspond to a joint, and the two columns are [min, max] left_closed , left_open = Astrobee . JOINT_POS_LIMITS [ left_joints ] . T right_open , right_closed = Astrobee . JOINT_POS_LIMITS [ right_joints ] . T return left_closed , left_open , right_closed , right_open def set_joint_angles ( self , angles : npt . ArrayLike , indices : Optional [ npt . ArrayLike ] = None , force : bool = False , wait : bool = False , ): \"\"\"Sets the joint angles for the Astrobee (either all joints, or a specified subset) Args: angles (npt.ArrayLike): Desired joint angles, in radians indices (npt.ArrayLike, optional): Indices of the joints to control. Defaults to None, in which case we assume all 7 joints will be set. force (bool, optional): Whether to (non-physically) instantly reset the joint state. Should only be used at initialization. Defaults to False wait (bool, optional): Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False Raises: ValueError: If the number of angles provided do not match the number of indices ValueError: If the angles are out of the joint limits for the specified indices \"\"\" if indices is None : indices = list ( range ( Astrobee . NUM_JOINTS )) angles = np . atleast_1d ( angles ) # If scalar, ensure we don't have a 0-D array indices = np . atleast_1d ( indices ) if indices . shape != angles . shape : raise ValueError ( \"Number of angles must match with the number of provided indices\" ) if np . any ( angles < Astrobee . JOINT_POS_LIMITS [ indices , 0 ]) or np . any ( angles > Astrobee . JOINT_POS_LIMITS [ indices , 1 ] ): raise ValueError ( f \"Joint angle command is outside of joint limits. \\n Got: { angles } for joints { indices } \" ) if force : for ind , angle in zip ( indices , angles ): self . client . resetJointState ( self . id , ind , angle ) # Set the position control for the arm so Pybullet will correct for disturbances self . client . setJointMotorControlArray ( self . id , indices , self . client . POSITION_CONTROL , angles , forces = self . JOINT_EFFORT_LIMITS [ indices ], ) # Step the sim until the arm is at the desired angle, if waiting for it to reach the position if wait : tol = 0.01 # TODO TOTALLY ARBITRARY FOR NOW while np . any ( np . abs ( self . get_joint_angles ( indices ) - angles ) > tol ): self . client . stepSimulation () def get_joint_angles ( self , indices : Optional [ npt . ArrayLike ] = None ) -> np . ndarray : \"\"\"Gives the current joint angles for the Astrobee Args: indices (npt.ArrayLike, optional): Indices of the joints of interest. Defaults to None, in which case all joint angles will be returned Returns: np.ndarray: Joint angles (in radians), length = len(indices) or Astrobee.NUM_JOINTS \"\"\" states = self . client . getJointStates ( self . id , indices ) return np . array ([ state [ 0 ] for state in states ]) def set_arm_joints ( self , angles : npt . ArrayLike , force : bool = False , wait : bool = False ) -> None : \"\"\"Sets the joint angles for the arm (proximal + distal) Args: angles (npt.ArrayLike): Arm joint angles, length = 2 force (bool, optional): Whether to (non-physically) instantly reset the joint states. Should only be used at initialization. Defaults to False wait (bool, optional): Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False \"\"\" self . set_joint_angles ( angles , Astrobee . ARM_JOINT_IDXS , force , wait ) def set_gripper_joints ( self , angles : npt . ArrayLike , force : bool = False , wait : bool = False ) -> None : \"\"\"Sets the joint angles for the gripper (left + right, proximal + distal) Args: angles (npt.ArrayLike): Gripper joint angles, length = 4 force (bool, optional): Whether to (non-physically) instantly reset the gripper joints. Should only be used at initialization. Defaults to False wait (bool, optional): Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False \"\"\" self . set_joint_angles ( angles , Astrobee . GRIPPER_JOINT_IDXS , force , wait ) def reset_to_ee_pose ( self , pose : npt . ArrayLike ) -> None : \"\"\"Resets the position of the robot to achieve a target end-effector pose This will currently NOT adjust any of the joints in a \"smart\" way, it will just reset the position of the base given the current joint configuration Args: pose (npt.ArrayLike): Desired position + XYZW quaternion end-effector pose, shape (7,) \"\"\" # Notation: EE: End effector, B: Base, W: World des_EE2W = pos_quat_to_tmat ( pose ) cur_B2W = pos_quat_to_tmat ( self . pose ) cur_EE2W = pos_quat_to_tmat ( self . ee_pose ) cur_W2EE = invert_transform_mat ( cur_EE2W ) cur_B2EE = cur_W2EE @ cur_B2W des_B2W = des_EE2W @ cur_B2EE self . reset_to_base_pose ( tmat_to_pos_quat ( des_B2W )) def reset_to_base_pose ( self , pose : npt . ArrayLike ) -> None : \"\"\"Resets the base of the robot to a target pose Args: pose (npt.ArrayLike): Desired position + XYZW quaternion pose of the Astrobee's base, shape (7,) \"\"\" self . client . resetBasePositionAndOrientation ( self . id , pose [: 3 ], pose [ 3 :]) def localize ( self ): raise NotImplementedError () # TODO.. see dynamics state. Should have a noise parameter def recompute_inertial_properties ( self ) -> None : \"\"\"Calculate the inertial properties based on the current state of the robot in sim This is more accurate than the fixed, base-only values from NASA's documentation, but it is fairly expensive to compute and should NOT be done on every simulation step. This will update the mass, inertia, inv_inertia, and center of mass \"\"\" # Note: Mass will be fixed, but it is not necessarily the same value as provided by NASA mass = 0.0 inertia = np . zeros (( 3 , 3 )) com = np . zeros ( 3 ) T_B2W = self . tmat # Base to world for link in Astrobee . Links : link_info = pybullet . getDynamicsInfo ( self . id , link . value ) link_mass = link_info [ 0 ] link_inertia_diagonal = link_info [ 2 ] if link . value == - 1 : # Separate handling for base link inertia += np . diag ( link_inertia_diagonal ) com += link_mass * T_B2W [: 3 , 3 ] else : T_L2W = self . get_link_transform ( link . value ) # Link to world T_L2B = invert_transform_mat ( T_B2W ) @ T_L2W # Link to base inertia += inertial_transformation ( link_mass , np . diag ( link_inertia_diagonal ), T_L2B ) com += link_mass * T_L2W [: 3 , 3 ] mass += link_mass com /= mass self . _local_com_position = T_B2W [: 3 , : 3 ] . T @ ( com - T_B2W [: 3 , 3 ]) self . _mass = mass self . _inertia = inertia self . _inv_inertia = np . linalg . inv ( inertia ) def store_arm ( self , force : bool = False , wait : bool = False ): \"\"\"Folds the Astrobee's arm into its body Note: Storing the arm reduces the products of inertia, so this is the preferable configuration if not manipulating any objects Args: force (bool, optional): Whether to (non-physically) instantly reset the joints. Should only be used at initialization. Defaults to False wait (bool, optional): Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False \"\"\" self . set_arm_joints ([ Astrobee . JOINT_POS_LIMITS [ 1 , 1 ], 0 ], force , wait ) self . set_gripper_position ( 0 , force , wait ) def deploy_arm ( self , force : bool = False , wait : bool = False ): \"\"\"Sets the arm to the default position, with the gripper fully open Args: force (bool, optional): Whether to (non-physically) instantly reset the joints. Should only be used at initialization. Defaults to False wait (bool, optional): Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False \"\"\" self . set_arm_joints ([ 0 , 0 ], force , wait ) self . set_gripper_position ( 100 , force , wait ) @property def full_state ( self ) -> tuple [ np . ndarray , ... ]: \"\"\"All information required to fully reset the state of the Astrobee Returns: tuple[np.ndarray, ...]: np.ndarray: Position, shape (3,) np.ndarray: Orientation (XYZW quaternion), shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) np.ndarray: Joint positions, shape (NUM_JOINTS,) np.ndarray: Joint velocities, shape (NUM_JOINTS,) \"\"\" pos , orn = self . client . getBasePositionAndOrientation ( self . id ) vel , ang_vel = self . client . getBaseVelocity ( self . id ) joint_states = self . client . getJointStates ( self . id , list ( range ( Astrobee . NUM_JOINTS )) ) joint_positions = np . empty ( Astrobee . NUM_JOINTS ) joint_vels = np . empty ( Astrobee . NUM_JOINTS ) for i in range ( Astrobee . NUM_JOINTS ): joint_positions [ i ] = joint_states [ i ][ 0 ] joint_vels [ i ] = joint_states [ i ][ 1 ] return ( np . array ( pos ), np . array ( orn ), np . array ( vel ), np . array ( ang_vel ), joint_positions , joint_vels , ) def reset_full_state ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , vel : npt . ArrayLike , omega : npt . ArrayLike , q : npt . ArrayLike , qdot : npt . ArrayLike , ): \"\"\"Fully resets the state of the Astrobee Args: pos (npt.ArrayLike): Position, shape (3,) orn (npt.ArrayLike): Orientation (XYZW quaternion), shape (4,) vel (npt.ArrayLike): Linear velocity, shape (3,) omega (npt.ArrayLike): Angular velocity, shape (3,) q (npt.ArrayLike): Joint positions, shape (NUM_JOINTS,) qdot (npt.ArrayLike): Joint velocities, shape (NUM_JOINTS,) \"\"\" self . client . resetBasePositionAndOrientation ( self . id , pos , orn ) self . client . resetBaseVelocity ( self . id , vel , omega ) for i in range ( Astrobee . NUM_JOINTS ): self . client . resetJointState ( self . id , i , q [ i ], qdot [ i ]) @property def bounding_box ( self ) -> np . ndarray : \"\"\"Current axis-aligned bounding box of the Astrobee body (Not including the arm), shape (2, 3)\"\"\" return np . array ( self . client . getAABB ( self . id , - 1 )) def _main (): client = initialize_pybullet ( bg_color = [ 1 , 1 , 1 ]) robot = Astrobee () run_sim () if __name__ == \"__main__\" : _main () Variables COLLISION_RADIUS Classes Astrobee class Astrobee ( pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 1.0 ), arm_joints : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 0.0 , 0.0 ), gripper_pos : float = 100 , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) Astrobee class for managing control, states, and properties Attributes Name Type Description Default pose npt.ArrayLike Initial pose of the astrobee when loaded. Defaults to (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0) (At origin, pointed forward along x axis). None arm_joints npt.ArrayLike Initial position of the arm's joints. Defaults to (0.0, 0.0) (Hanging straight down) None gripper_pos float Initial gripper position, in [0, 100]. Defaults to 100 (fully open) None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None View Source class Astrobee : \"\"\"Astrobee class for managing control, states, and properties Args: pose (npt.ArrayLike, optional): Initial pose of the astrobee when loaded. Defaults to (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0) (At origin, pointed forward along x axis). arm_joints (npt.ArrayLike, optional): Initial position of the arm's joints. Defaults to (0.0, 0.0) (Hanging straight down) gripper_pos (float, optional): Initial gripper position, in [0, 100]. Defaults to 100 (fully open) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Raises: ConnectionError: If a pybullet server is not connected before initialization \"\"\" URDF = \"pyastrobee/assets/urdf/astrobee/astrobee.urdf\" NUM_JOINTS = 7 NUM_LINKS = 8 TRANSFORMS = astrobee_transforms # TODO figure out if this is the best way to store this info GRIPPER_JOINT_IDXS = [ 3, 4, 5, 6 ] ARM_JOINT_IDXS = [ 1, 2 ] # Joint limit information is extracted from the URDF # Joint pos limits are [ lower, upper ] for each joint JOINT_POS_LIMITS = np . array ( [ [0.0, 0.0 ] , # top aft ( fixed ) [ -2.0944, 1.57079 ] , # arm proximal joint [ -1.57079, 1.57079 ] , # arm distal joint [ 0.349066, 0.698132 ] , # gripper left proximal joint [ -1.22173, -0.69813 ] , # gripper left distal joint [ -0.698132, -0.349066 ] , # gripper right proximal joint [ 0.69813, 1.22173 ] , # gripper right distal joint ] ) JOINT_EFFORT_LIMITS = np . array ( [ 0.0, # top aft (fixed) 1.0, # arm proximal joint 1.0, # arm distal joint 0.1, # gripper left proximal joint 0.1, # gripper left distal joint 0.1, # gripper right proximal joint 0.1, # gripper right distal joint ] ) JOINT_VEL_LIMITS = np . array ( [ 0.00, # top aft (fixed) 0.12, # arm proximal joint 0.12, # arm distal joint 0.12, # gripper left proximal joint 0.12, # gripper left distal joint 0.12, # gripper right proximal joint 0.12, # gripper right distal joint ] ) # Bounding sphere for collision modeling COLLISION_RADIUS = COLLISION_RADIUS class Joints ( Enum ) : \"\"\"Enumerates the different joints on the astrobee via their Pybullet index\"\"\" # Comments indicate the name of the joint in the URDF ARM_BASE = 0 # top_aft ( fixed joint ) ARM_PROXIMAL = 1 # top_aft_arm_proximal_joint ARM_DISTAL = 2 # top_aft_arm_distal_joint GRIPPER_LEFT_PROXIMAL = 3 # top_aft_gripper_left_proximal_joint GRIPPER_LEFT_DISTAL = 4 # top_aft_gripper_left_distal_joint GRIPPER_RIGHT_PROXIMAL = 5 # top_aft_gripper_right_proximal_joint GRIPPER_RIGHT_DISTAL = 6 # top_aft_gripper_right_distal_joint class Links ( Enum ) : \"\"\"Enumerates the different links on the astrobee via their Pybullet index Note: the URDF technically has 8 links, but it appears that pybullet considers the very first link to be the base link \"\"\" # Comments indicate the name of the link in the URDF BODY = - 1 # honey_body ARM_BASE = 0 # honey_top_aft ARM_PROXIMAL = 1 # honey_top_aft_arm_proximal_link ARM_DISTAL = 2 # honey_top_aft_arm_distal_link GRIPPER_LEFT_PROXIMAL = 3 # honey_top_aft_gripper_left_proximal_link GRIPPER_LEFT_DISTAL = 4 # honey_top_aft_gripper_left_distal_link GRIPPER_RIGHT_PROXIMAL = 5 # honey_top_aft_gripper_right_proximal_link GRIPPER_RIGHT_DISTAL = 6 # honey_top_aft_gripper_right_distal_link def __init__ ( self , pose : npt . ArrayLike = ( 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 1.0 ), arm_joints : npt . ArrayLike = ( 0.0 , 0.0 ), gripper_pos : float = 100 , client : Optional [ BulletClient ] = None , ) : self . client : pybullet = pybullet if client is None else client if not self . client . isConnected () : raise ConnectionError ( \"Need to connect to pybullet before initializing an astrobee\" ) self . id = self . client . loadURDF ( Astrobee . URDF , pose [ :3 ] , pose [ 3: ] , flags = pybullet . URDF_USE_INERTIA_FROM_FILE ) self . _dt = self . client . getPhysicsEngineParameters () [ \"fixedTimeStep\" ] self . set_gripper_position ( gripper_pos , force = True ) self . set_arm_joints ( arm_joints , force = True ) # Initialize dynamics info with estimated numbers from NASA , we can recompute based on the sim state later # if desired . Values are from A Brief Guide to Astrobee self . _mass = 9.58 # kg self . _inertia = np . diag ( [ 0.153, 0.143, 0.162 ] ) # kg - m ^ 2 self . _inv_inertia = np . linalg . inv ( self . _inertia ) self . _local_com_position = np . zeros ( 3 ) # Init , not accurate # TODO decide if we should recompute automatically ??? # self . recompute_inertial_properties () print_green ( \"Astrobee is ready\" ) def unload ( self ) -> None : \"\"\"Remove the Astrobee from the simulation\"\"\" self . client . removeBody ( self . id ) @property def pose ( self ) -> np . ndarray : \"\"\"The current robot pose (position + XYZW quaternion) expressed in world frame Returns: np.ndarray: Position and quaternion, size (7,) \"\"\" pos , orn = self . client . getBasePositionAndOrientation ( self . id ) return np . concatenate ( [ pos, orn ] ) @property def tmat ( self ) -> np . ndarray : \"\"\"The current robot pose in world frame, expressed as a transformation matrix Returns: np.ndarray: Transformation matrix (Robot to World), shape (4,4) \"\"\" return pos_quat_to_tmat ( self . pose ) @property def position ( self ) -> np . ndarray : \"\"\"Just the position component of the full pose Returns: np.ndarray: (3,) position vector \"\"\" return self . pose [ :3 ] @property def orientation ( self ) -> np . ndarray : \"\"\"Just the quaternion component of the full pose Returns: np.ndarray: (4,) XYZW quaternion \"\"\" return self . pose [ 3: ] @property def rmat ( self ) -> np . ndarray : \"\"\"The orientation of the robot expressed as a rotation matrix Returns: np.ndarray: Rotation matrix (Robot to World), shape (3,3) \"\"\" return quat_to_rmat ( self . orientation ) @property def heading ( self ) -> np . ndarray : \"\"\"A unit vector in the forward (x) component of the astrobee Some notes: - This is NOT a full description of orientation since rotation about this axis is undefined - The arm is on the REAR side of the astrobee, not the front - The y vector points to the port (left) side of the astrobee, and the z vector is up Returns: np.ndarray: (3,) unit vector \"\"\" R_R2W = quat_to_rmat ( self . orientation ) # Robot to world return R_R2W [ :, 0 ] # Robot frame x vector expressed in world @property def velocity ( self ) -> np . ndarray : \"\"\"Linear velocity of the Astrobee, with respect to the world frame xyz axes Returns: np.ndarray: [vx, vy, vz] linear velocities, shape (3,) \"\"\" lin_vel , _ = self . client . getBaseVelocity ( self . id ) return np . array ( lin_vel ) @property def angular_velocity ( self ) -> np . ndarray : \"\"\"Angular velocity of the Astrobee, about the world frame xyz axes Returns: np.ndarray: [wx, wy, wz] angular velocities, shape (3,) \"\"\" _ , ang_vel = self . client . getBaseVelocity ( self . id ) return np . array ( ang_vel ) @property def ee_pose ( self ) -> np . ndarray : \"\"\"The current end-effector pose (position + XYZW quaternion) expressed in world frame Returns: np.ndarray: Position and quaternion, size (7,) \"\"\" return tmat_to_pos_quat ( self . ee_tmat ) @property def ee_tmat ( self ) -> np . ndarray : \"\"\"The current end-effector transformation matrix (gripper-to-world) Returns: np.ndarray: Transformation matrix, shape (4, 4) \"\"\" T_G2D = Astrobee . TRANSFORMS . GRIPPER_TO_ARM_DISTAL # Gripper to distal T_D2W = self . get_link_transform ( Astrobee . Links . ARM_DISTAL . value ) # Distal to world return T_D2W @ T_G2D @property def joint_angles ( self ) -> np . ndarray : \"\"\"Angular positions (radians) of each joint on the Astrobee Returns: np.ndarray: Joint angles, shape (NUM_JOINTS,) \"\"\" # States : tuple [ tuple ] , size ( 7 , 4 ) # 7 corresponds to NUM_JOINTS # 4 corresponds to position , velocity , reaction forces , and applied torque states = self . client . getJointStates ( self . id , list ( range ( Astrobee . NUM_JOINTS ))) # Index 0 : position return np . array ( [ states[i ][ 0 ] for i in range ( Astrobee . NUM_JOINTS ) ] ) @property def joint_vels ( self ) -> np . ndarray : \"\"\"Angular velocities (radians/sec) of each joint on the Astrobee Returns: np.ndarray: Joint velocities, shape (NUM_JOINTS,) \"\"\" states = self . client . getJointStates ( self . id , list ( range ( Astrobee . NUM_JOINTS ))) # Index 1 : velocity return np . array ( [ states[i ][ 1 ] for i in range ( Astrobee . NUM_JOINTS ) ] ) @property def joint_torques ( self ) -> np . ndarray : \"\"\"Torques (N-m) applied by each joint on the Astrobee Returns: np.ndarray: Joint torques, shape (NUM_JOINTS,) \"\"\" states = self . client . getJointStates ( self . id , list ( range ( Astrobee . NUM_JOINTS ))) # Index 3 : torque return np . array ( [ states[i ][ 3 ] for i in range ( Astrobee . NUM_JOINTS ) ] ) @property def arm_joint_angles ( self ) -> np . ndarray : \"\"\"Gives the two joint angles associated with the proximal + distal joints of the arm Returns: np.ndarray: Arm joint angles, shape (2,) \"\"\" return self . joint_angles [ Astrobee.ARM_JOINT_IDXS ] @property def gripper_joint_angles ( self ) -> np . ndarray : \"\"\"Gives the four joint angles associated with the proximal + distal joints of the two gripper fingers Returns: np.ndarray: Gripper joint angles, shape (4,) \"\"\" return self . joint_angles [ Astrobee.GRIPPER_JOINT_IDXS ] @property def inertia ( self ) -> np . ndarray : \"\"\"Body inertia tensor for the Astrobee, shape (3, 3)\"\"\" return self . _inertia @property def inv_inertia ( self ) -> np . ndarray : \"\"\"Inverse of the Astrobee's body inertia tensor, shape (3, 3)\"\"\" return self . _inv_inertia @property def world_inertia ( self ) -> np . ndarray : \"\"\"World-frame inertia tensor of the Astrobee, shape (3, 3) This takes into account the current rotation of Astrobee \"\"\" R = self . rmat return R @ self . inertia @ R . T @property def world_inv_inertia ( self ) -> np . ndarray : \"\"\"Inverse of the world-frame inertia tensor of the Astrobee, shape (3, 3) This takes into account the current rotation of Astrobee \"\"\" R = self . rmat return R @ self . inv_inertia @ R . T @property def mass ( self ) -> float : \"\"\"Mass of the Astrobee\"\"\" return self . _mass @property def local_com_position ( self ) -> np . ndarray : \"\"\"Position of the center of mass of the robot w.r.t. the base, in local frame. Shape (3,)\"\"\" return self . _local_com_position @property def world_com_position ( self ) -> np . ndarray : \"\"\"Position of the center of mass of the robot, in world frame. Shape (3,)\"\"\" return transform_point ( self . tmat , self . local_com_position ) @property def state_space_matrices ( self ) -> tuple [ np.ndarray, np.ndarray ] : \"\"\"The state and control matrices A and B, such that x_dot = Ax + Bu We assume that the state x = [position, velocity, quaternion, angular velocity] \u2208 R13 and that the control u = [force, torque] \u2208 R6 We linearize the system about the current state Returns: tuple[np.ndarray, np.ndarray]: np.ndarray: A: State matrix, shape (13, 13) np.ndarray: B: Control matrix, shape (13, 6) \"\"\" # TODO : decide if using the true joint - angle - based inertia tensor _ , q , _ , w = self . dynamics_state R = self . rmat # Use inertias defined in the world frame inertia = R @ self . inertia @ R . T inv_inertia = R @ self . inv_inertia @ R . T return ( state_matrix ( q , w , inertia , inv_inertia ), control_matrix ( self . mass , inv_inertia ), ) @property def state_vector ( self ) -> np . ndarray : \"\"\"The state vector x, such that x_dot = Ax + Bu We compose the state as [position, velocity, quaternion, angular velocity] \u2208 R13 \"\"\" pos , orn = self . client . getBasePositionAndOrientation ( self . id ) lin_vel , ang_vel = self . client . getBaseVelocity ( self . id ) return np . concatenate ( [ pos, lin_vel, orn, ang_vel ] ) @property def dynamics_state ( self ) -> tuple [ np.ndarray, np.ndarray, np.ndarray, np.ndarray ] : \"\"\"Current state of the Astrobee's dynamics: Position, orientation, linear vel, and angular vel Returns: tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: np.ndarray: Position, shape (3,) np.ndarray: XYZW quaternion orientation, shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) \"\"\" pos , orn = self . client . getBasePositionAndOrientation ( self . id ) lin_vel , ang_vel = self . client . getBaseVelocity ( self . id ) return np . array ( pos ), np . array ( orn ), np . array ( lin_vel ), np . array ( ang_vel ) @property def mass_matrix ( self ) -> np . ndarray : \"\"\"Mass/Inertia matrix for the Astrobee, given its current configuration - This is used to determine the kinetic energy (K = (1/2) * qdot.T @ M @ qdot) or the relationship between joint accelerations and torque (M * joint_accels + centrifugal_coriolis_vec + gravity_vec = torque) Returns: np.ndarray: The mass matrix, shape (12, 12). (12 is the number of degrees of freedom of the Astrobee - 6 DOF for a floating base, plus 6 for the six non-fixed joints) \"\"\" # Inputs must be a lists ( no numpy ) or else pybullet will seg fault M = self . client . calculateMassMatrix ( self . id , list ( self . joint_angles )) return np . array ( M ) def get_jacobians ( self , link : Union [ Links, int ] , local_pos : npt . ArrayLike = ( 0.0 , 0.0 , 0.0 ) ) -> tuple [ np.ndarray, np.ndarray ] : \"\"\"Calculate the linear and angular jacobians (Jv and Jw) for a point on a link - These relate joint motion and task-space motion: [v; w] = [Jv; Jw] * dq - These jacobians will have a 12 columns corresponding to 6 DOF from the Astrobee's floating base, plus another 6 DOF from the non-fixed joints Args: link (Union[Links, int]): Link or link index of interest. Common links: For the base, set this to -1. For the arm distal link, set this to 2 local_pos (npt.ArrayLike, optional): Position in the link's reference frame. Defaults to [0.0, 0.0, 0.0]. For the grasp point, use the position from the calibrated distal/grasp transformation Returns: tuple[np.ndarray, np.ndarray]: np.ndarray: Jv: Linear jacobian, shape (3, 12) np.ndarray: Jw: Angular jacobian, shape (3, 12) \"\"\" if isinstance ( link , Astrobee . Links ) : link = link . value ndof = 6 # 7 joints , but 1 fixed # The quickstart guide says that the joint velocities and desired accelerations are just there # for an internal call to calculateInverseDynamics ( and maybe aren 't really meaningful?) desired_accels = ndof * [0.0] # All inputs must be lists (no numpy) or else pybullet will seg fault Jv, Jw = self.client.calculateJacobian( self.id, link, list(local_pos), list(self.joint_angles)[1:], # Don' t include the first fixed joint list ( self . joint_vels ) [ 1: ] , # Don 't include the first fixed joint desired_accels, ) return np.array(Jv), np.array(Jw) def get_link_transform(self, link_index: Union[Links, int]) -> np.ndarray: \"\"\"Calculates the transformation matrix (w.r.t the world) for a specified link Args: link_index (int): Index of the link on the robot Returns: np.ndarray: Transformation matrix (link to world). Shape = (4,4) \"\"\" if isinstance(link_index, Astrobee.Links): link_index = link_index.value # We have 8 links, indexed from -1 to 6 # Pybullet does not allow access to the base link (-1) through getLinkState # So, use this only for non-base links if link_index > 6 or link_index < 0: raise ValueError(f\"Invalid link index: {link_index}\") link_state = self.client.getLinkState( self.id, link_index, computeForwardKinematics=True ) # First two link state values are linkWorldPosition, linkWorldOrientation # There are other state positions and orientations, but they' re confusing . ( TODO check on these ) pos , quat = link_state [ :2 ] return make_transform_mat ( quat_to_rmat ( quat ), pos ) @property # Is this better as a property or as a \"getter\" ? def gripper_position ( self ) -> int : \"\"\"The current position of the gripper, in range [0, 100] Returns: int: Position of the gripper, an integer between 0 (closed) and 100 (open) \"\"\" joint_states = self . client . getJointStates ( self . id , Astrobee . GRIPPER_JOINT_IDXS ) joint_angles = [ state[0 ] for state in joint_states ] l_angles = joint_angles [ :2 ] r_angles = joint_angles [ 2: ] l_closed , l_open , r_closed , r_open = self . _get_gripper_joint_ranges () l_pct = 100 * ( l_angles - l_closed ) / ( l_open - l_closed ) r_pct = 100 * ( r_angles - r_closed ) / ( r_open - r_closed ) return np . round ( np . average ( np . concatenate ( [ l_pct, r_pct ] ))). astype ( int ) # TODO decide if we need finer - grain control of the individual joints , or if this integer - position is fine def set_gripper_position ( self , position : float , force : bool = False , wait : bool = False ) -> None : \"\"\"Sets the gripper to a position between 0 (fully closed) to 100 (fully open) Args: position (float): Gripper position, in range [0, 100] force (bool, optional): Whether to (non-physically) instantly reset the gripper position, instead of stepping the sim. Should only be used at initialization. Defaults to False wait (bool, optional): Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False \"\"\" if position < 0 or position > 100 : raise ValueError ( \"Position should be in range [0, 100]\" ) l_closed , l_open , r_closed , r_open = self . _get_gripper_joint_ranges () left_pos = l_closed + ( position / 100 ) * ( l_open - l_closed ) right_pos = r_closed + ( position / 100 ) * ( r_open - r_closed ) angle_cmd = [ *left_pos, *right_pos ] self . set_gripper_joints ( angle_cmd , force , wait ) def open_gripper ( self ) -> None : \"\"\"Fully opens the gripper\"\"\" self . set_gripper_position ( 100 ) # TODO add force / torque control ? def close_gripper ( self ) -> None : \"\"\"Fully closes the gripper\"\"\" self . set_gripper_position ( 0 ) # TODO rework this ? def _get_gripper_joint_ranges ( self , ) -> tuple [ np.ndarray, np.ndarray, np.ndarray, np.ndarray ] : \"\"\"Helper function to determine the range of motion (closed -> open) of the gripper joints - This is a bit confusing because of how the URDF specifies joint min/max and how this translates to an open/closed position on the gripper - For a fully-closed gripper, the right side joints are at their max, and the left side joints are at their min - Likewise, for a fully-open gripper, the right side is at the joint min, and the left at joint max Returns: tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: np.ndarray: Left-side gripper finger angles when closed. Shape (2,) np.ndarray: Left-side gripper finger angles when open. Shape (2,) np.ndarray: Right-side gripper finger angles when closed. Shape (2,) np.ndarray: Right-side gripper finger angles when open. Shape (2,) \"\"\" left_joints = Astrobee . GRIPPER_JOINT_IDXS [ :2 ] right_joints = Astrobee . GRIPPER_JOINT_IDXS [ 2: ] # As a numpy array , each row will correspond to a joint , and the two columns are [ min, max ] left_closed , left_open = Astrobee . JOINT_POS_LIMITS [ left_joints ] . T right_open , right_closed = Astrobee . JOINT_POS_LIMITS [ right_joints ] . T return left_closed , left_open , right_closed , right_open def set_joint_angles ( self , angles : npt . ArrayLike , indices : Optional [ npt.ArrayLike ] = None , force : bool = False , wait : bool = False , ) : \"\"\"Sets the joint angles for the Astrobee (either all joints, or a specified subset) Args: angles (npt.ArrayLike): Desired joint angles, in radians indices (npt.ArrayLike, optional): Indices of the joints to control. Defaults to None, in which case we assume all 7 joints will be set. force (bool, optional): Whether to (non-physically) instantly reset the joint state. Should only be used at initialization. Defaults to False wait (bool, optional): Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False Raises: ValueError: If the number of angles provided do not match the number of indices ValueError: If the angles are out of the joint limits for the specified indices \"\"\" if indices is None : indices = list ( range ( Astrobee . NUM_JOINTS )) angles = np . atleast_1d ( angles ) # If scalar , ensure we don 't have a 0-D array indices = np.atleast_1d(indices) if indices.shape != angles.shape: raise ValueError( \"Number of angles must match with the number of provided indices\" ) if np.any(angles < Astrobee.JOINT_POS_LIMITS[indices, 0]) or np.any( angles > Astrobee.JOINT_POS_LIMITS[indices, 1] ): raise ValueError( f\"Joint angle command is outside of joint limits.\\nGot: {angles} for joints {indices}\" ) if force: for ind, angle in zip(indices, angles): self.client.resetJointState(self.id, ind, angle) # Set the position control for the arm so Pybullet will correct for disturbances self.client.setJointMotorControlArray( self.id, indices, self.client.POSITION_CONTROL, angles, forces=self.JOINT_EFFORT_LIMITS[indices], ) # Step the sim until the arm is at the desired angle, if waiting for it to reach the position if wait: tol = 0.01 # TODO TOTALLY ARBITRARY FOR NOW while np.any(np.abs(self.get_joint_angles(indices) - angles) > tol): self.client.stepSimulation() def get_joint_angles(self, indices: Optional[npt.ArrayLike] = None) -> np.ndarray: \"\"\"Gives the current joint angles for the Astrobee Args: indices (npt.ArrayLike, optional): Indices of the joints of interest. Defaults to None, in which case all joint angles will be returned Returns: np.ndarray: Joint angles (in radians), length = len(indices) or Astrobee.NUM_JOINTS \"\"\" states = self.client.getJointStates(self.id, indices) return np.array([state[0] for state in states]) def set_arm_joints( self, angles: npt.ArrayLike, force: bool = False, wait: bool = False ) -> None: \"\"\"Sets the joint angles for the arm (proximal + distal) Args: angles (npt.ArrayLike): Arm joint angles, length = 2 force (bool, optional): Whether to (non-physically) instantly reset the joint states. Should only be used at initialization. Defaults to False wait (bool, optional): Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False \"\"\" self.set_joint_angles(angles, Astrobee.ARM_JOINT_IDXS, force, wait) def set_gripper_joints( self, angles: npt.ArrayLike, force: bool = False, wait: bool = False ) -> None: \"\"\"Sets the joint angles for the gripper (left + right, proximal + distal) Args: angles (npt.ArrayLike): Gripper joint angles, length = 4 force (bool, optional): Whether to (non-physically) instantly reset the gripper joints. Should only be used at initialization. Defaults to False wait (bool, optional): Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False \"\"\" self.set_joint_angles(angles, Astrobee.GRIPPER_JOINT_IDXS, force, wait) def reset_to_ee_pose(self, pose: npt.ArrayLike) -> None: \"\"\"Resets the position of the robot to achieve a target end-effector pose This will currently NOT adjust any of the joints in a \"smart\" way, it will just reset the position of the base given the current joint configuration Args: pose (npt.ArrayLike): Desired position + XYZW quaternion end-effector pose, shape (7,) \"\"\" # Notation: EE: End effector, B: Base, W: World des_EE2W = pos_quat_to_tmat(pose) cur_B2W = pos_quat_to_tmat(self.pose) cur_EE2W = pos_quat_to_tmat(self.ee_pose) cur_W2EE = invert_transform_mat(cur_EE2W) cur_B2EE = cur_W2EE @ cur_B2W des_B2W = des_EE2W @ cur_B2EE self.reset_to_base_pose(tmat_to_pos_quat(des_B2W)) def reset_to_base_pose(self, pose: npt.ArrayLike) -> None: \"\"\"Resets the base of the robot to a target pose Args: pose (npt.ArrayLike): Desired position + XYZW quaternion pose of the Astrobee' s base , shape ( 7 ,) \"\"\" self.client.resetBasePositionAndOrientation(self.id, pose[:3], pose[3:]) def localize(self): raise NotImplementedError() # TODO.. see dynamics state. Should have a noise parameter def recompute_inertial_properties(self) -> None: \"\"\" Calculate the inertial properties based on the current state of the robot in sim This is more accurate than the fixed , base - only values from NASA 's documentation, but it is fairly expensive to compute and should NOT be done on every simulation step. This will update the mass, inertia, inv_inertia, and center of mass \"\"\" # Note: Mass will be fixed, but it is not necessarily the same value as provided by NASA mass = 0.0 inertia = np.zeros((3, 3)) com = np.zeros(3) T_B2W = self.tmat # Base to world for link in Astrobee.Links: link_info = pybullet.getDynamicsInfo(self.id, link.value) link_mass = link_info[0] link_inertia_diagonal = link_info[2] if link.value == -1: # Separate handling for base link inertia += np.diag(link_inertia_diagonal) com += link_mass * T_B2W[:3, 3] else: T_L2W = self.get_link_transform(link.value) # Link to world T_L2B = invert_transform_mat(T_B2W) @ T_L2W # Link to base inertia += inertial_transformation( link_mass, np.diag(link_inertia_diagonal), T_L2B ) com += link_mass * T_L2W[:3, 3] mass += link_mass com /= mass self._local_com_position = T_B2W[:3, :3].T @ (com - T_B2W[:3, 3]) self._mass = mass self._inertia = inertia self._inv_inertia = np.linalg.inv(inertia) def store_arm(self, force: bool = False, wait: bool = False): \"\"\"Folds the Astrobee' s arm into its body Note : Storing the arm reduces the products of inertia , so this is the preferable configuration if not manipulating any objects Args : force ( bool , optional ) : Whether to ( non - physically ) instantly reset the joints . Should only be used at initialization . Defaults to False wait ( bool , optional ) : Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner . Defaults to False \"\"\" self.set_arm_joints([Astrobee.JOINT_POS_LIMITS[1, 1], 0], force, wait) self.set_gripper_position(0, force, wait) def deploy_arm(self, force: bool = False, wait: bool = False): \"\"\" Sets the arm to the default position , with the gripper fully open Args : force ( bool , optional ) : Whether to ( non - physically ) instantly reset the joints . Should only be used at initialization . Defaults to False wait ( bool , optional ) : Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner . Defaults to False \"\"\" self.set_arm_joints([0, 0], force, wait) self.set_gripper_position(100, force, wait) @property def full_state(self) -> tuple[np.ndarray, ...]: \"\"\" All information required to fully reset the state of the Astrobee Returns : tuple [ np.ndarray, ... ] : np . ndarray : Position , shape ( 3 ,) np . ndarray : Orientation ( XYZW quaternion ), shape ( 4 ,) np . ndarray : Linear velocity , shape ( 3 ,) np . ndarray : Angular velocity , shape ( 3 ,) np . ndarray : Joint positions , shape ( NUM_JOINTS ,) np . ndarray : Joint velocities , shape ( NUM_JOINTS ,) \"\"\" pos, orn = self.client.getBasePositionAndOrientation(self.id) vel, ang_vel = self.client.getBaseVelocity(self.id) joint_states = self.client.getJointStates( self.id, list(range(Astrobee.NUM_JOINTS)) ) joint_positions = np.empty(Astrobee.NUM_JOINTS) joint_vels = np.empty(Astrobee.NUM_JOINTS) for i in range(Astrobee.NUM_JOINTS): joint_positions[i] = joint_states[i][0] joint_vels[i] = joint_states[i][1] return ( np.array(pos), np.array(orn), np.array(vel), np.array(ang_vel), joint_positions, joint_vels, ) def reset_full_state( self, pos: npt.ArrayLike, orn: npt.ArrayLike, vel: npt.ArrayLike, omega: npt.ArrayLike, q: npt.ArrayLike, qdot: npt.ArrayLike, ): \"\"\" Fully resets the state of the Astrobee Args : pos ( npt . ArrayLike ) : Position , shape ( 3 ,) orn ( npt . ArrayLike ) : Orientation ( XYZW quaternion ), shape ( 4 ,) vel ( npt . ArrayLike ) : Linear velocity , shape ( 3 ,) omega ( npt . ArrayLike ) : Angular velocity , shape ( 3 ,) q ( npt . ArrayLike ) : Joint positions , shape ( NUM_JOINTS ,) qdot ( npt . ArrayLike ) : Joint velocities , shape ( NUM_JOINTS ,) \"\"\" self.client.resetBasePositionAndOrientation(self.id, pos, orn) self.client.resetBaseVelocity(self.id, vel, omega) for i in range(Astrobee.NUM_JOINTS): self.client.resetJointState(self.id, i, q[i], qdot[i]) @property def bounding_box(self) -> np.ndarray: \"\"\" Current axis - aligned bounding box of the Astrobee body ( Not including the arm ), shape ( 2 , 3 ) \"\" \" return np . array ( self . client . getAABB ( self . id , - 1 )) Class variables ARM_JOINT_IDXS COLLISION_RADIUS GRIPPER_JOINT_IDXS JOINT_EFFORT_LIMITS JOINT_POS_LIMITS JOINT_VEL_LIMITS Joints Links NUM_JOINTS NUM_LINKS TRANSFORMS URDF Instance variables angular_velocity Angular velocity of the Astrobee, about the world frame xyz axes arm_joint_angles Gives the two joint angles associated with the proximal + distal joints of the arm bounding_box Current axis-aligned bounding box of the Astrobee body (Not including the arm), shape (2, 3) dynamics_state Current state of the Astrobee's dynamics: Position, orientation, linear vel, and angular vel ee_pose The current end-effector pose (position + XYZW quaternion) expressed in world frame ee_tmat The current end-effector transformation matrix (gripper-to-world) full_state All information required to fully reset the state of the Astrobee gripper_joint_angles Gives the four joint angles associated with the proximal + distal joints of the two gripper fingers gripper_position The current position of the gripper, in range [0, 100] heading A unit vector in the forward (x) component of the astrobee Some notes: - This is NOT a full description of orientation since rotation about this axis is undefined - The arm is on the REAR side of the astrobee, not the front - The y vector points to the port (left) side of the astrobee, and the z vector is up inertia Body inertia tensor for the Astrobee, shape (3, 3) inv_inertia Inverse of the Astrobee's body inertia tensor, shape (3, 3) joint_angles Angular positions (radians) of each joint on the Astrobee joint_torques Torques (N-m) applied by each joint on the Astrobee joint_vels Angular velocities (radians/sec) of each joint on the Astrobee local_com_position Position of the center of mass of the robot w.r.t. the base, in local frame. Shape (3,) mass Mass of the Astrobee mass_matrix Mass/Inertia matrix for the Astrobee, given its current configuration This is used to determine the kinetic energy (K = (1/2) * qdot.T @ M @ qdot) or the relationship between joint accelerations and torque (M * joint_accels + centrifugal_coriolis_vec + gravity_vec = torque) orientation Just the quaternion component of the full pose pose The current robot pose (position + XYZW quaternion) expressed in world frame position Just the position component of the full pose rmat The orientation of the robot expressed as a rotation matrix state_space_matrices The state and control matrices A and B, such that x_dot = Ax + Bu We assume that the state x = [position, velocity, quaternion, angular velocity] \u2208 R13 and that the control u = [force, torque] \u2208 R6 We linearize the system about the current state state_vector The state vector x, such that x_dot = Ax + Bu We compose the state as [position, velocity, quaternion, angular velocity] \u2208 R13 tmat The current robot pose in world frame, expressed as a transformation matrix velocity Linear velocity of the Astrobee, with respect to the world frame xyz axes world_com_position Position of the center of mass of the robot, in world frame. Shape (3,) world_inertia World-frame inertia tensor of the Astrobee, shape (3, 3) This takes into account the current rotation of Astrobee world_inv_inertia Inverse of the world-frame inertia tensor of the Astrobee, shape (3, 3) This takes into account the current rotation of Astrobee Methods close_gripper def close_gripper ( self ) -> None Fully closes the gripper View Source def close_gripper ( self ) -> None : \"\"\"Fully closes the gripper\"\"\" self . set_gripper_position ( 0 ) deploy_arm def deploy_arm ( self , force : bool = False , wait : bool = False ) Sets the arm to the default position, with the gripper fully open Parameters: Name Type Description Default force bool Whether to (non-physically) instantly reset the joints. Should only be used at initialization. Defaults to False None wait bool Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False None View Source def deploy_arm(self, force: bool = False, wait: bool = False): \"\"\"Sets the arm to the default position, with the gripper fully open Args: force (bool, optional): Whether to (non-physically) instantly reset the joints. Should only be used at initialization. Defaults to False wait (bool, optional): Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False \"\"\" self.set_arm_joints([0, 0], force, wait) self.set_gripper_position(100, force, wait) get_jacobians def get_jacobians ( self , link : Union [ pyastrobee . core . astrobee . Astrobee . Links , int ], local_pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 0.0 , 0.0 , 0.0 ) ) -> tuple [ numpy . ndarray , numpy . ndarray ] Calculate the linear and angular jacobians (Jv and Jw) for a point on a link These relate joint motion and task-space motion: [v; w] = [Jv; Jw] * dq These jacobians will have a 12 columns corresponding to 6 DOF from the Astrobee's floating base, plus another 6 DOF from the non-fixed joints Parameters: Name Type Description Default link Union[Links, int] Link or link index of interest. Common links: For the base, set this to -1. For the arm distal link, set this to 2 None local_pos npt.ArrayLike Position in the link's reference frame. Defaults to [0.0, 0.0, 0.0]. For the grasp point, use the position from the calibrated distal/grasp transformation [0.0, 0.0, 0.0] Returns: Type Description tuple[np.ndarray, np.ndarray] np.ndarray: Jv: Linear jacobian, shape (3, 12) np.ndarray: Jw: Angular jacobian, shape (3, 12) View Source def get_jacobians ( self , link : Union [ Links , int ] , local_pos : npt . ArrayLike = ( 0 . 0 , 0 . 0 , 0 . 0 ) ) - > tuple [ np.ndarray , np.ndarray ] : \"\"\"Calculate the linear and angular jacobians (Jv and Jw) for a point on a link - These relate joint motion and task-space motion: [ v ; w ] = [ Jv ; Jw ] * dq - These jacobians will have a 12 columns corresponding to 6 DOF from the Astrobee's floating base, plus another 6 DOF from the non-fixed joints Args: link (Union [ Links , int ] ): Link or link index of interest. Common links: For the base, set this to -1. For the arm distal link, set this to 2 local_pos (npt.ArrayLike, optional): Position in the link's reference frame. Defaults to [ 0.0 , 0.0 , 0.0 ] . For the grasp point, use the position from the calibrated distal/grasp transformation Returns: tuple [ np.ndarray , np.ndarray ] : np.ndarray: Jv: Linear jacobian, shape (3, 12) np.ndarray: Jw: Angular jacobian, shape (3, 12) \"\"\" if isinstance ( link , Astrobee . Links ): link = link . value ndof = 6 # 7 joints , but 1 fixed # The quickstart guide says that the joint velocities and desired accelerations are just there # for an internal call to calculateInverseDynamics ( and maybe aren 't really meaningful?) desired_accels = ndof * [ 0.0 ] # All inputs must be lists (no numpy) or else pybullet will seg fault Jv, Jw = self.client.calculateJacobian( self.id, link, list(local_pos), list(self.joint_angles) [ 1 : ] , # Don' t include the first fixed joint list ( self . joint_vels ) [ 1 : ] , # Don ' t include the first fixed joint desired_accels , ) return np . array ( Jv ), np . array ( Jw ) get_joint_angles def get_joint_angles ( self , indices : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None ) -> numpy . ndarray Gives the current joint angles for the Astrobee Parameters: Name Type Description Default indices npt.ArrayLike Indices of the joints of interest. Defaults to None, in which case all joint angles will be returned None Returns: Type Description np.ndarray Joint angles (in radians), length = len(indices) or Astrobee.NUM_JOINTS View Source def get_joint_angles ( self , indices : Optional [ npt . ArrayLike ] = None ) -> np . ndarray : \"\"\"Gives the current joint angles for the Astrobee Args: indices (npt.ArrayLike, optional): Indices of the joints of interest. Defaults to None, in which case all joint angles will be returned Returns: np.ndarray: Joint angles (in radians), length = len(indices) or Astrobee.NUM_JOINTS \"\"\" states = self . client . getJointStates ( self . id , indices ) return np . array ([ state [ 0 ] for state in states ]) get_link_transform def get_link_transform ( self , link_index : Union [ pyastrobee . core . astrobee . Astrobee . Links , int ] ) -> numpy . ndarray Calculates the transformation matrix (w.r.t the world) for a specified link Parameters: Name Type Description Default link_index int Index of the link on the robot None Returns: Type Description np.ndarray Transformation matrix (link to world). Shape = (4,4) View Source def get_link_transform ( self , link_index : Union [ Links , int ]) -> np . ndarray : \"\"\"Calculates the transformation matrix (w.r.t the world) for a specified link Args: link_index (int): Index of the link on the robot Returns: np.ndarray: Transformation matrix (link to world). Shape = (4,4) \"\"\" if isinstance ( link_index , Astrobee . Links ) : link_index = link_index . value # We have 8 links , indexed from - 1 to 6 # Pybullet does not allow access to the base link ( - 1 ) through getLinkState # So , use this only for non - base links if link_index > 6 or link_index < 0 : raise ValueError ( f \"Invalid link index: {link_index}\" ) link_state = self . client . getLinkState ( self . id , link_index , computeForwardKinematics = True ) # First two link state values are linkWorldPosition , linkWorldOrientation # There are other state positions and orientations , but they 're confusing. (TODO check on these) pos, quat = link_state[:2] return make_transform_mat(quat_to_rmat(quat), pos) localize def localize ( self ) View Source def localize(self): raise NotImplementedError() # TODO.. see dynamics state. Should have a noise parameter open_gripper def open_gripper ( self ) -> None Fully opens the gripper View Source def open_gripper ( self ) -> None : \"\"\"Fully opens the gripper\"\"\" self . set_gripper_position ( 100 ) recompute_inertial_properties def recompute_inertial_properties ( self ) -> None Calculate the inertial properties based on the current state of the robot in sim This is more accurate than the fixed, base-only values from NASA's documentation, but it is fairly expensive to compute and should NOT be done on every simulation step. This will update the mass, inertia, inv_inertia, and center of mass View Source def recompute_inertial_properties(self) -> None: \"\"\"Calculate the inertial properties based on the current state of the robot in sim This is more accurate than the fixed, base-only values from NASA's documentation, but it is fairly expensive to compute and should NOT be done on every simulation step. This will update the mass, inertia, inv_inertia, and center of mass \"\"\" # Note: Mass will be fixed, but it is not necessarily the same value as provided by NASA mass = 0.0 inertia = np.zeros((3, 3)) com = np.zeros(3) T_B2W = self.tmat # Base to world for link in Astrobee.Links: link_info = pybullet.getDynamicsInfo(self.id, link.value) link_mass = link_info[0] link_inertia_diagonal = link_info[2] if link.value == -1: # Separate handling for base link inertia += np.diag(link_inertia_diagonal) com += link_mass * T_B2W[:3, 3] else: T_L2W = self.get_link_transform(link.value) # Link to world T_L2B = invert_transform_mat(T_B2W) @ T_L2W # Link to base inertia += inertial_transformation( link_mass, np.diag(link_inertia_diagonal), T_L2B ) com += link_mass * T_L2W[:3, 3] mass += link_mass com /= mass self._local_com_position = T_B2W[:3, :3].T @ (com - T_B2W[:3, 3]) self._mass = mass self._inertia = inertia self._inv_inertia = np.linalg.inv(inertia) reset_full_state def reset_full_state ( self , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], omega : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], q : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], qdot : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) Fully resets the state of the Astrobee Parameters: Name Type Description Default pos npt.ArrayLike Position, shape (3,) None orn npt.ArrayLike Orientation (XYZW quaternion), shape (4,) None vel npt.ArrayLike Linear velocity, shape (3,) None omega npt.ArrayLike Angular velocity, shape (3,) None q npt.ArrayLike Joint positions, shape (NUM_JOINTS,) None qdot npt.ArrayLike Joint velocities, shape (NUM_JOINTS,) None View Source def reset_full_state ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , vel : npt . ArrayLike , omega : npt . ArrayLike , q : npt . ArrayLike , qdot : npt . ArrayLike , ) : \"\"\"Fully resets the state of the Astrobee Args: pos (npt.ArrayLike): Position, shape (3,) orn (npt.ArrayLike): Orientation (XYZW quaternion), shape (4,) vel (npt.ArrayLike): Linear velocity, shape (3,) omega (npt.ArrayLike): Angular velocity, shape (3,) q (npt.ArrayLike): Joint positions, shape (NUM_JOINTS,) qdot (npt.ArrayLike): Joint velocities, shape (NUM_JOINTS,) \"\"\" self . client . resetBasePositionAndOrientation ( self . id , pos , orn ) self . client . resetBaseVelocity ( self . id , vel , omega ) for i in range ( Astrobee . NUM_JOINTS ) : self . client . resetJointState ( self . id , i , q [ i ] , qdot [ i ] ) reset_to_base_pose def reset_to_base_pose ( self , pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> None Resets the base of the robot to a target pose Parameters: Name Type Description Default pose npt.ArrayLike Desired position + XYZW quaternion pose of the Astrobee's base, shape (7,) None View Source def reset_to_base_pose ( self , pose : npt . ArrayLike ) -> None : \"\"\"Resets the base of the robot to a target pose Args: pose (npt.ArrayLike): Desired position + XYZW quaternion pose of the Astrobee' s base , shape ( 7 ,) \"\"\" self.client.resetBasePositionAndOrientation(self.id, pose[:3], pose[3:]) reset_to_ee_pose def reset_to_ee_pose ( self , pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> None Resets the position of the robot to achieve a target end-effector pose This will currently NOT adjust any of the joints in a \"smart\" way, it will just reset the position of the base given the current joint configuration Parameters: Name Type Description Default pose npt.ArrayLike Desired position + XYZW quaternion end-effector pose, shape (7,) None View Source def reset_to_ee_pose ( self , pose : npt . ArrayLike ) -> None : \"\"\"Resets the position of the robot to achieve a target end-effector pose This will currently NOT adjust any of the joints in a \" smart \" way, it will just reset the position of the base given the current joint configuration Args: pose (npt.ArrayLike): Desired position + XYZW quaternion end-effector pose, shape (7,) \"\"\" # Notation : EE : End effector , B : Base , W : World des_EE2W = pos_quat_to_tmat ( pose ) cur_B2W = pos_quat_to_tmat ( self . pose ) cur_EE2W = pos_quat_to_tmat ( self . ee_pose ) cur_W2EE = invert_transform_mat ( cur_EE2W ) cur_B2EE = cur_W2EE @ cur_B2W des_B2W = des_EE2W @ cur_B2EE self . reset_to_base_pose ( tmat_to_pos_quat ( des_B2W )) set_arm_joints def set_arm_joints ( self , angles : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], force : bool = False , wait : bool = False ) -> None Sets the joint angles for the arm (proximal + distal) Parameters: Name Type Description Default angles npt.ArrayLike Arm joint angles, length = 2 None force bool Whether to (non-physically) instantly reset the joint states. Should only be used at initialization. Defaults to False None wait bool Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False None View Source def set_arm_joints ( self , angles : npt . ArrayLike , force : bool = False , wait : bool = False ) -> None : \"\"\"Sets the joint angles for the arm (proximal + distal) Args: angles (npt.ArrayLike): Arm joint angles, length = 2 force (bool, optional): Whether to (non-physically) instantly reset the joint states. Should only be used at initialization. Defaults to False wait (bool, optional): Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False \"\"\" self . set_joint_angles ( angles , Astrobee . ARM_JOINT_IDXS , force , wait ) set_gripper_joints def set_gripper_joints ( self , angles : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], force : bool = False , wait : bool = False ) -> None Sets the joint angles for the gripper (left + right, proximal + distal) Parameters: Name Type Description Default angles npt.ArrayLike Gripper joint angles, length = 4 None force bool Whether to (non-physically) instantly reset the gripper joints. Should only be used at initialization. Defaults to False None wait bool Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False None View Source def set_gripper_joints ( self , angles : npt . ArrayLike , force : bool = False , wait : bool = False ) -> None : \"\"\"Sets the joint angles for the gripper (left + right, proximal + distal) Args: angles (npt.ArrayLike): Gripper joint angles, length = 4 force (bool, optional): Whether to (non-physically) instantly reset the gripper joints. Should only be used at initialization. Defaults to False wait (bool, optional): Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False \"\"\" self . set_joint_angles ( angles , Astrobee . GRIPPER_JOINT_IDXS , force , wait ) set_gripper_position def set_gripper_position ( self , position : float , force : bool = False , wait : bool = False ) -> None Sets the gripper to a position between 0 (fully closed) to 100 (fully open) Parameters: Name Type Description Default position float Gripper position, in range [0, 100] None force bool Whether to (non-physically) instantly reset the gripper position, instead of stepping the sim. Should only be used at initialization. Defaults to False None wait bool Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False None View Source def set_gripper_position( self, position: float, force: bool = False, wait: bool = False ) -> None: \"\"\"Sets the gripper to a position between 0 (fully closed) to 100 (fully open) Args: position (float): Gripper position, in range [0, 100] force (bool, optional): Whether to (non-physically) instantly reset the gripper position, instead of stepping the sim. Should only be used at initialization. Defaults to False wait (bool, optional): Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False \"\"\" if position < 0 or position > 100: raise ValueError(\"Position should be in range [0, 100]\") l_closed, l_open, r_closed, r_open = self._get_gripper_joint_ranges() left_pos = l_closed + (position / 100) * (l_open - l_closed) right_pos = r_closed + (position / 100) * (r_open - r_closed) angle_cmd = [*left_pos, *right_pos] self.set_gripper_joints(angle_cmd, force, wait) set_joint_angles def set_joint_angles ( self , angles : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], indices : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , force : bool = False , wait : bool = False ) Sets the joint angles for the Astrobee (either all joints, or a specified subset) Parameters: Name Type Description Default angles npt.ArrayLike Desired joint angles, in radians None indices npt.ArrayLike Indices of the joints to control. Defaults to None, in which case we assume all 7 joints will be set. None force bool Whether to (non-physically) instantly reset the joint state. Should only be used at initialization. Defaults to False None wait bool Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False None Raises: Type Description ValueError If the number of angles provided do not match the number of indices ValueError If the angles are out of the joint limits for the specified indices View Source def set_joint_angles ( self , angles : npt . ArrayLike , indices : Optional [ npt.ArrayLike ] = None , force : bool = False , wait : bool = False , ) : \"\"\"Sets the joint angles for the Astrobee (either all joints, or a specified subset) Args: angles (npt.ArrayLike): Desired joint angles, in radians indices (npt.ArrayLike, optional): Indices of the joints to control. Defaults to None, in which case we assume all 7 joints will be set. force (bool, optional): Whether to (non-physically) instantly reset the joint state. Should only be used at initialization. Defaults to False wait (bool, optional): Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False Raises: ValueError: If the number of angles provided do not match the number of indices ValueError: If the angles are out of the joint limits for the specified indices \"\"\" if indices is None : indices = list ( range ( Astrobee . NUM_JOINTS )) angles = np . atleast_1d ( angles ) # If scalar , ensure we don ' t have a 0 - D array indices = np . atleast_1d ( indices ) if indices . shape != angles . shape : raise ValueError ( \"Number of angles must match with the number of provided indices\" ) if np . any ( angles < Astrobee . JOINT_POS_LIMITS [ indices, 0 ] ) or np . any ( angles > Astrobee . JOINT_POS_LIMITS [ indices, 1 ] ) : raise ValueError ( f \"Joint angle command is outside of joint limits.\\nGot: {angles} for joints {indices}\" ) if force : for ind , angle in zip ( indices , angles ) : self . client . resetJointState ( self . id , ind , angle ) # Set the position control for the arm so Pybullet will correct for disturbances self . client . setJointMotorControlArray ( self . id , indices , self . client . POSITION_CONTROL , angles , forces = self . JOINT_EFFORT_LIMITS [ indices ] , ) # Step the sim until the arm is at the desired angle , if waiting for it to reach the position if wait : tol = 0.01 # TODO TOTALLY ARBITRARY FOR NOW while np . any ( np . abs ( self . get_joint_angles ( indices ) - angles ) > tol ) : self . client . stepSimulation () store_arm def store_arm ( self , force : bool = False , wait : bool = False ) Folds the Astrobee's arm into its body Note: Storing the arm reduces the products of inertia, so this is the preferable configuration if not manipulating any objects Parameters: Name Type Description Default force bool Whether to (non-physically) instantly reset the joints. Should only be used at initialization. Defaults to False None wait bool Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False None View Source def store_arm(self, force: bool = False, wait: bool = False): \"\"\"Folds the Astrobee's arm into its body Note: Storing the arm reduces the products of inertia, so this is the preferable configuration if not manipulating any objects Args: force (bool, optional): Whether to (non-physically) instantly reset the joints. Should only be used at initialization. Defaults to False wait (bool, optional): Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False \"\"\" self.set_arm_joints([Astrobee.JOINT_POS_LIMITS[1, 1], 0], force, wait) self.set_gripper_position(0, force, wait) unload def unload ( self ) -> None Remove the Astrobee from the simulation View Source def unload ( self ) -> None : \"\"\"Remove the Astrobee from the simulation\"\"\" self . client . removeBody ( self . id )","title":"Astrobee"},{"location":"reference/pyastrobee/core/astrobee/#module-pyastrobeecoreastrobee","text":"Manages the properties of the astrobee and all control-associated functions In general, we assume that we're working with Honey. Multiple astrobees can be loaded, but we assume that they all have the exact same configuration View Source \"\"\"Manages the properties of the astrobee and all control-associated functions In general, we assume that we're working with Honey. Multiple astrobees can be loaded, but we assume that they all have the exact same configuration \"\"\" from typing import Optional , Union from enum import Enum import pybullet from pybullet_utils.bullet_client import BulletClient import numpy as np import numpy.typing as npt from pyastrobee.utils.bullet_utils import initialize_pybullet , run_sim from pyastrobee.utils.transformations import ( make_transform_mat , invert_transform_mat , transform_point , ) from pyastrobee.utils.rotations import quat_to_rmat from pyastrobee.utils.poses import tmat_to_pos_quat , pos_quat_to_tmat from pyastrobee.config import astrobee_transforms from pyastrobee.config.astrobee_geom import COLLISION_RADIUS from pyastrobee.utils.python_utils import print_green from pyastrobee.utils.dynamics import ( inertial_transformation , state_matrix , control_matrix , ) class Astrobee : \"\"\"Astrobee class for managing control, states, and properties Args: pose (npt.ArrayLike, optional): Initial pose of the astrobee when loaded. Defaults to (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0) (At origin, pointed forward along x axis). arm_joints (npt.ArrayLike, optional): Initial position of the arm's joints. Defaults to (0.0, 0.0) (Hanging straight down) gripper_pos (float, optional): Initial gripper position, in [0, 100]. Defaults to 100 (fully open) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Raises: ConnectionError: If a pybullet server is not connected before initialization \"\"\" URDF = \"pyastrobee/assets/urdf/astrobee/astrobee.urdf\" NUM_JOINTS = 7 NUM_LINKS = 8 TRANSFORMS = astrobee_transforms # TODO figure out if this is the best way to store this info GRIPPER_JOINT_IDXS = [ 3 , 4 , 5 , 6 ] ARM_JOINT_IDXS = [ 1 , 2 ] # Joint limit information is extracted from the URDF # Joint pos limits are [lower, upper] for each joint JOINT_POS_LIMITS = np . array ( [ [ 0.0 , 0.0 ], # top aft (fixed) [ - 2.0944 , 1.57079 ], # arm proximal joint [ - 1.57079 , 1.57079 ], # arm distal joint [ 0.349066 , 0.698132 ], # gripper left proximal joint [ - 1.22173 , - 0.69813 ], # gripper left distal joint [ - 0.698132 , - 0.349066 ], # gripper right proximal joint [ 0.69813 , 1.22173 ], # gripper right distal joint ] ) JOINT_EFFORT_LIMITS = np . array ( [ 0.0 , # top aft (fixed) 1.0 , # arm proximal joint 1.0 , # arm distal joint 0.1 , # gripper left proximal joint 0.1 , # gripper left distal joint 0.1 , # gripper right proximal joint 0.1 , # gripper right distal joint ] ) JOINT_VEL_LIMITS = np . array ( [ 0.00 , # top aft (fixed) 0.12 , # arm proximal joint 0.12 , # arm distal joint 0.12 , # gripper left proximal joint 0.12 , # gripper left distal joint 0.12 , # gripper right proximal joint 0.12 , # gripper right distal joint ] ) # Bounding sphere for collision modeling COLLISION_RADIUS = COLLISION_RADIUS class Joints ( Enum ): \"\"\"Enumerates the different joints on the astrobee via their Pybullet index\"\"\" # Comments indicate the name of the joint in the URDF ARM_BASE = 0 # top_aft (fixed joint) ARM_PROXIMAL = 1 # top_aft_arm_proximal_joint ARM_DISTAL = 2 # top_aft_arm_distal_joint GRIPPER_LEFT_PROXIMAL = 3 # top_aft_gripper_left_proximal_joint GRIPPER_LEFT_DISTAL = 4 # top_aft_gripper_left_distal_joint GRIPPER_RIGHT_PROXIMAL = 5 # top_aft_gripper_right_proximal_joint GRIPPER_RIGHT_DISTAL = 6 # top_aft_gripper_right_distal_joint class Links ( Enum ): \"\"\"Enumerates the different links on the astrobee via their Pybullet index Note: the URDF technically has 8 links, but it appears that pybullet considers the very first link to be the base link \"\"\" # Comments indicate the name of the link in the URDF BODY = - 1 # honey_body ARM_BASE = 0 # honey_top_aft ARM_PROXIMAL = 1 # honey_top_aft_arm_proximal_link ARM_DISTAL = 2 # honey_top_aft_arm_distal_link GRIPPER_LEFT_PROXIMAL = 3 # honey_top_aft_gripper_left_proximal_link GRIPPER_LEFT_DISTAL = 4 # honey_top_aft_gripper_left_distal_link GRIPPER_RIGHT_PROXIMAL = 5 # honey_top_aft_gripper_right_proximal_link GRIPPER_RIGHT_DISTAL = 6 # honey_top_aft_gripper_right_distal_link def __init__ ( self , pose : npt . ArrayLike = ( 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 1.0 ), arm_joints : npt . ArrayLike = ( 0.0 , 0.0 ), gripper_pos : float = 100 , client : Optional [ BulletClient ] = None , ): self . client : pybullet = pybullet if client is None else client if not self . client . isConnected (): raise ConnectionError ( \"Need to connect to pybullet before initializing an astrobee\" ) self . id = self . client . loadURDF ( Astrobee . URDF , pose [: 3 ], pose [ 3 :], flags = pybullet . URDF_USE_INERTIA_FROM_FILE ) self . _dt = self . client . getPhysicsEngineParameters ()[ \"fixedTimeStep\" ] self . set_gripper_position ( gripper_pos , force = True ) self . set_arm_joints ( arm_joints , force = True ) # Initialize dynamics info with estimated numbers from NASA, we can recompute based on the sim state later # if desired. Values are from A Brief Guide to Astrobee self . _mass = 9.58 # kg self . _inertia = np . diag ([ 0.153 , 0.143 , 0.162 ]) # kg-m^2 self . _inv_inertia = np . linalg . inv ( self . _inertia ) self . _local_com_position = np . zeros ( 3 ) # Init, not accurate # TODO decide if we should recompute automatically??? # self.recompute_inertial_properties() print_green ( \"Astrobee is ready\" ) def unload ( self ) -> None : \"\"\"Remove the Astrobee from the simulation\"\"\" self . client . removeBody ( self . id ) @property def pose ( self ) -> np . ndarray : \"\"\"The current robot pose (position + XYZW quaternion) expressed in world frame Returns: np.ndarray: Position and quaternion, size (7,) \"\"\" pos , orn = self . client . getBasePositionAndOrientation ( self . id ) return np . concatenate ([ pos , orn ]) @property def tmat ( self ) -> np . ndarray : \"\"\"The current robot pose in world frame, expressed as a transformation matrix Returns: np.ndarray: Transformation matrix (Robot to World), shape (4,4) \"\"\" return pos_quat_to_tmat ( self . pose ) @property def position ( self ) -> np . ndarray : \"\"\"Just the position component of the full pose Returns: np.ndarray: (3,) position vector \"\"\" return self . pose [: 3 ] @property def orientation ( self ) -> np . ndarray : \"\"\"Just the quaternion component of the full pose Returns: np.ndarray: (4,) XYZW quaternion \"\"\" return self . pose [ 3 :] @property def rmat ( self ) -> np . ndarray : \"\"\"The orientation of the robot expressed as a rotation matrix Returns: np.ndarray: Rotation matrix (Robot to World), shape (3,3) \"\"\" return quat_to_rmat ( self . orientation ) @property def heading ( self ) -> np . ndarray : \"\"\"A unit vector in the forward (x) component of the astrobee Some notes: - This is NOT a full description of orientation since rotation about this axis is undefined - The arm is on the REAR side of the astrobee, not the front - The y vector points to the port (left) side of the astrobee, and the z vector is up Returns: np.ndarray: (3,) unit vector \"\"\" R_R2W = quat_to_rmat ( self . orientation ) # Robot to world return R_R2W [:, 0 ] # Robot frame x vector expressed in world @property def velocity ( self ) -> np . ndarray : \"\"\"Linear velocity of the Astrobee, with respect to the world frame xyz axes Returns: np.ndarray: [vx, vy, vz] linear velocities, shape (3,) \"\"\" lin_vel , _ = self . client . getBaseVelocity ( self . id ) return np . array ( lin_vel ) @property def angular_velocity ( self ) -> np . ndarray : \"\"\"Angular velocity of the Astrobee, about the world frame xyz axes Returns: np.ndarray: [wx, wy, wz] angular velocities, shape (3,) \"\"\" _ , ang_vel = self . client . getBaseVelocity ( self . id ) return np . array ( ang_vel ) @property def ee_pose ( self ) -> np . ndarray : \"\"\"The current end-effector pose (position + XYZW quaternion) expressed in world frame Returns: np.ndarray: Position and quaternion, size (7,) \"\"\" return tmat_to_pos_quat ( self . ee_tmat ) @property def ee_tmat ( self ) -> np . ndarray : \"\"\"The current end-effector transformation matrix (gripper-to-world) Returns: np.ndarray: Transformation matrix, shape (4, 4) \"\"\" T_G2D = Astrobee . TRANSFORMS . GRIPPER_TO_ARM_DISTAL # Gripper to distal T_D2W = self . get_link_transform ( Astrobee . Links . ARM_DISTAL . value ) # Distal to world return T_D2W @ T_G2D @property def joint_angles ( self ) -> np . ndarray : \"\"\"Angular positions (radians) of each joint on the Astrobee Returns: np.ndarray: Joint angles, shape (NUM_JOINTS,) \"\"\" # States: tuple[tuple], size (7, 4) # 7 corresponds to NUM_JOINTS # 4 corresponds to position, velocity, reaction forces, and applied torque states = self . client . getJointStates ( self . id , list ( range ( Astrobee . NUM_JOINTS ))) # Index 0: position return np . array ([ states [ i ][ 0 ] for i in range ( Astrobee . NUM_JOINTS )]) @property def joint_vels ( self ) -> np . ndarray : \"\"\"Angular velocities (radians/sec) of each joint on the Astrobee Returns: np.ndarray: Joint velocities, shape (NUM_JOINTS,) \"\"\" states = self . client . getJointStates ( self . id , list ( range ( Astrobee . NUM_JOINTS ))) # Index 1: velocity return np . array ([ states [ i ][ 1 ] for i in range ( Astrobee . NUM_JOINTS )]) @property def joint_torques ( self ) -> np . ndarray : \"\"\"Torques (N-m) applied by each joint on the Astrobee Returns: np.ndarray: Joint torques, shape (NUM_JOINTS,) \"\"\" states = self . client . getJointStates ( self . id , list ( range ( Astrobee . NUM_JOINTS ))) # Index 3: torque return np . array ([ states [ i ][ 3 ] for i in range ( Astrobee . NUM_JOINTS )]) @property def arm_joint_angles ( self ) -> np . ndarray : \"\"\"Gives the two joint angles associated with the proximal + distal joints of the arm Returns: np.ndarray: Arm joint angles, shape (2,) \"\"\" return self . joint_angles [ Astrobee . ARM_JOINT_IDXS ] @property def gripper_joint_angles ( self ) -> np . ndarray : \"\"\"Gives the four joint angles associated with the proximal + distal joints of the two gripper fingers Returns: np.ndarray: Gripper joint angles, shape (4,) \"\"\" return self . joint_angles [ Astrobee . GRIPPER_JOINT_IDXS ] @property def inertia ( self ) -> np . ndarray : \"\"\"Body inertia tensor for the Astrobee, shape (3, 3)\"\"\" return self . _inertia @property def inv_inertia ( self ) -> np . ndarray : \"\"\"Inverse of the Astrobee's body inertia tensor, shape (3, 3)\"\"\" return self . _inv_inertia @property def world_inertia ( self ) -> np . ndarray : \"\"\"World-frame inertia tensor of the Astrobee, shape (3, 3) This takes into account the current rotation of Astrobee \"\"\" R = self . rmat return R @ self . inertia @ R . T @property def world_inv_inertia ( self ) -> np . ndarray : \"\"\"Inverse of the world-frame inertia tensor of the Astrobee, shape (3, 3) This takes into account the current rotation of Astrobee \"\"\" R = self . rmat return R @ self . inv_inertia @ R . T @property def mass ( self ) -> float : \"\"\"Mass of the Astrobee\"\"\" return self . _mass @property def local_com_position ( self ) -> np . ndarray : \"\"\"Position of the center of mass of the robot w.r.t. the base, in local frame. Shape (3,)\"\"\" return self . _local_com_position @property def world_com_position ( self ) -> np . ndarray : \"\"\"Position of the center of mass of the robot, in world frame. Shape (3,)\"\"\" return transform_point ( self . tmat , self . local_com_position ) @property def state_space_matrices ( self ) -> tuple [ np . ndarray , np . ndarray ]: \"\"\"The state and control matrices A and B, such that x_dot = Ax + Bu We assume that the state x = [position, velocity, quaternion, angular velocity] \u2208 R13 and that the control u = [force, torque] \u2208 R6 We linearize the system about the current state Returns: tuple[np.ndarray, np.ndarray]: np.ndarray: A: State matrix, shape (13, 13) np.ndarray: B: Control matrix, shape (13, 6) \"\"\" # TODO: decide if using the true joint-angle-based inertia tensor _ , q , _ , w = self . dynamics_state R = self . rmat # Use inertias defined in the world frame inertia = R @ self . inertia @ R . T inv_inertia = R @ self . inv_inertia @ R . T return ( state_matrix ( q , w , inertia , inv_inertia ), control_matrix ( self . mass , inv_inertia ), ) @property def state_vector ( self ) -> np . ndarray : \"\"\"The state vector x, such that x_dot = Ax + Bu We compose the state as [position, velocity, quaternion, angular velocity] \u2208 R13 \"\"\" pos , orn = self . client . getBasePositionAndOrientation ( self . id ) lin_vel , ang_vel = self . client . getBaseVelocity ( self . id ) return np . concatenate ([ pos , lin_vel , orn , ang_vel ]) @property def dynamics_state ( self ) -> tuple [ np . ndarray , np . ndarray , np . ndarray , np . ndarray ]: \"\"\"Current state of the Astrobee's dynamics: Position, orientation, linear vel, and angular vel Returns: tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: np.ndarray: Position, shape (3,) np.ndarray: XYZW quaternion orientation, shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) \"\"\" pos , orn = self . client . getBasePositionAndOrientation ( self . id ) lin_vel , ang_vel = self . client . getBaseVelocity ( self . id ) return np . array ( pos ), np . array ( orn ), np . array ( lin_vel ), np . array ( ang_vel ) @property def mass_matrix ( self ) -> np . ndarray : \"\"\"Mass/Inertia matrix for the Astrobee, given its current configuration - This is used to determine the kinetic energy (K = (1/2) * qdot.T @ M @ qdot) or the relationship between joint accelerations and torque (M * joint_accels + centrifugal_coriolis_vec + gravity_vec = torque) Returns: np.ndarray: The mass matrix, shape (12, 12). (12 is the number of degrees of freedom of the Astrobee - 6 DOF for a floating base, plus 6 for the six non-fixed joints) \"\"\" # Inputs must be a lists (no numpy) or else pybullet will seg fault M = self . client . calculateMassMatrix ( self . id , list ( self . joint_angles )) return np . array ( M ) def get_jacobians ( self , link : Union [ Links , int ], local_pos : npt . ArrayLike = ( 0.0 , 0.0 , 0.0 ) ) -> tuple [ np . ndarray , np . ndarray ]: \"\"\"Calculate the linear and angular jacobians (Jv and Jw) for a point on a link - These relate joint motion and task-space motion: [v; w] = [Jv; Jw] * dq - These jacobians will have a 12 columns corresponding to 6 DOF from the Astrobee's floating base, plus another 6 DOF from the non-fixed joints Args: link (Union[Links, int]): Link or link index of interest. Common links: For the base, set this to -1. For the arm distal link, set this to 2 local_pos (npt.ArrayLike, optional): Position in the link's reference frame. Defaults to [0.0, 0.0, 0.0]. For the grasp point, use the position from the calibrated distal/grasp transformation Returns: tuple[np.ndarray, np.ndarray]: np.ndarray: Jv: Linear jacobian, shape (3, 12) np.ndarray: Jw: Angular jacobian, shape (3, 12) \"\"\" if isinstance ( link , Astrobee . Links ): link = link . value ndof = 6 # 7 joints, but 1 fixed # The quickstart guide says that the joint velocities and desired accelerations are just there # for an internal call to calculateInverseDynamics (and maybe aren't really meaningful?) desired_accels = ndof * [ 0.0 ] # All inputs must be lists (no numpy) or else pybullet will seg fault Jv , Jw = self . client . calculateJacobian ( self . id , link , list ( local_pos ), list ( self . joint_angles )[ 1 :], # Don't include the first fixed joint list ( self . joint_vels )[ 1 :], # Don't include the first fixed joint desired_accels , ) return np . array ( Jv ), np . array ( Jw ) def get_link_transform ( self , link_index : Union [ Links , int ]) -> np . ndarray : \"\"\"Calculates the transformation matrix (w.r.t the world) for a specified link Args: link_index (int): Index of the link on the robot Returns: np.ndarray: Transformation matrix (link to world). Shape = (4,4) \"\"\" if isinstance ( link_index , Astrobee . Links ): link_index = link_index . value # We have 8 links, indexed from -1 to 6 # Pybullet does not allow access to the base link (-1) through getLinkState # So, use this only for non-base links if link_index > 6 or link_index < 0 : raise ValueError ( f \"Invalid link index: { link_index } \" ) link_state = self . client . getLinkState ( self . id , link_index , computeForwardKinematics = True ) # First two link state values are linkWorldPosition, linkWorldOrientation # There are other state positions and orientations, but they're confusing. (TODO check on these) pos , quat = link_state [: 2 ] return make_transform_mat ( quat_to_rmat ( quat ), pos ) @property # Is this better as a property or as a \"getter\"? def gripper_position ( self ) -> int : \"\"\"The current position of the gripper, in range [0, 100] Returns: int: Position of the gripper, an integer between 0 (closed) and 100 (open) \"\"\" joint_states = self . client . getJointStates ( self . id , Astrobee . GRIPPER_JOINT_IDXS ) joint_angles = [ state [ 0 ] for state in joint_states ] l_angles = joint_angles [: 2 ] r_angles = joint_angles [ 2 :] l_closed , l_open , r_closed , r_open = self . _get_gripper_joint_ranges () l_pct = 100 * ( l_angles - l_closed ) / ( l_open - l_closed ) r_pct = 100 * ( r_angles - r_closed ) / ( r_open - r_closed ) return np . round ( np . average ( np . concatenate ([ l_pct , r_pct ]))) . astype ( int ) # TODO decide if we need finer-grain control of the individual joints, or if this integer-position is fine def set_gripper_position ( self , position : float , force : bool = False , wait : bool = False ) -> None : \"\"\"Sets the gripper to a position between 0 (fully closed) to 100 (fully open) Args: position (float): Gripper position, in range [0, 100] force (bool, optional): Whether to (non-physically) instantly reset the gripper position, instead of stepping the sim. Should only be used at initialization. Defaults to False wait (bool, optional): Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False \"\"\" if position < 0 or position > 100 : raise ValueError ( \"Position should be in range [0, 100]\" ) l_closed , l_open , r_closed , r_open = self . _get_gripper_joint_ranges () left_pos = l_closed + ( position / 100 ) * ( l_open - l_closed ) right_pos = r_closed + ( position / 100 ) * ( r_open - r_closed ) angle_cmd = [ * left_pos , * right_pos ] self . set_gripper_joints ( angle_cmd , force , wait ) def open_gripper ( self ) -> None : \"\"\"Fully opens the gripper\"\"\" self . set_gripper_position ( 100 ) # TODO add force/torque control? def close_gripper ( self ) -> None : \"\"\"Fully closes the gripper\"\"\" self . set_gripper_position ( 0 ) # TODO rework this? def _get_gripper_joint_ranges ( self , ) -> tuple [ np . ndarray , np . ndarray , np . ndarray , np . ndarray ]: \"\"\"Helper function to determine the range of motion (closed -> open) of the gripper joints - This is a bit confusing because of how the URDF specifies joint min/max and how this translates to an open/closed position on the gripper - For a fully-closed gripper, the right side joints are at their max, and the left side joints are at their min - Likewise, for a fully-open gripper, the right side is at the joint min, and the left at joint max Returns: tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: np.ndarray: Left-side gripper finger angles when closed. Shape (2,) np.ndarray: Left-side gripper finger angles when open. Shape (2,) np.ndarray: Right-side gripper finger angles when closed. Shape (2,) np.ndarray: Right-side gripper finger angles when open. Shape (2,) \"\"\" left_joints = Astrobee . GRIPPER_JOINT_IDXS [: 2 ] right_joints = Astrobee . GRIPPER_JOINT_IDXS [ 2 :] # As a numpy array, each row will correspond to a joint, and the two columns are [min, max] left_closed , left_open = Astrobee . JOINT_POS_LIMITS [ left_joints ] . T right_open , right_closed = Astrobee . JOINT_POS_LIMITS [ right_joints ] . T return left_closed , left_open , right_closed , right_open def set_joint_angles ( self , angles : npt . ArrayLike , indices : Optional [ npt . ArrayLike ] = None , force : bool = False , wait : bool = False , ): \"\"\"Sets the joint angles for the Astrobee (either all joints, or a specified subset) Args: angles (npt.ArrayLike): Desired joint angles, in radians indices (npt.ArrayLike, optional): Indices of the joints to control. Defaults to None, in which case we assume all 7 joints will be set. force (bool, optional): Whether to (non-physically) instantly reset the joint state. Should only be used at initialization. Defaults to False wait (bool, optional): Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False Raises: ValueError: If the number of angles provided do not match the number of indices ValueError: If the angles are out of the joint limits for the specified indices \"\"\" if indices is None : indices = list ( range ( Astrobee . NUM_JOINTS )) angles = np . atleast_1d ( angles ) # If scalar, ensure we don't have a 0-D array indices = np . atleast_1d ( indices ) if indices . shape != angles . shape : raise ValueError ( \"Number of angles must match with the number of provided indices\" ) if np . any ( angles < Astrobee . JOINT_POS_LIMITS [ indices , 0 ]) or np . any ( angles > Astrobee . JOINT_POS_LIMITS [ indices , 1 ] ): raise ValueError ( f \"Joint angle command is outside of joint limits. \\n Got: { angles } for joints { indices } \" ) if force : for ind , angle in zip ( indices , angles ): self . client . resetJointState ( self . id , ind , angle ) # Set the position control for the arm so Pybullet will correct for disturbances self . client . setJointMotorControlArray ( self . id , indices , self . client . POSITION_CONTROL , angles , forces = self . JOINT_EFFORT_LIMITS [ indices ], ) # Step the sim until the arm is at the desired angle, if waiting for it to reach the position if wait : tol = 0.01 # TODO TOTALLY ARBITRARY FOR NOW while np . any ( np . abs ( self . get_joint_angles ( indices ) - angles ) > tol ): self . client . stepSimulation () def get_joint_angles ( self , indices : Optional [ npt . ArrayLike ] = None ) -> np . ndarray : \"\"\"Gives the current joint angles for the Astrobee Args: indices (npt.ArrayLike, optional): Indices of the joints of interest. Defaults to None, in which case all joint angles will be returned Returns: np.ndarray: Joint angles (in radians), length = len(indices) or Astrobee.NUM_JOINTS \"\"\" states = self . client . getJointStates ( self . id , indices ) return np . array ([ state [ 0 ] for state in states ]) def set_arm_joints ( self , angles : npt . ArrayLike , force : bool = False , wait : bool = False ) -> None : \"\"\"Sets the joint angles for the arm (proximal + distal) Args: angles (npt.ArrayLike): Arm joint angles, length = 2 force (bool, optional): Whether to (non-physically) instantly reset the joint states. Should only be used at initialization. Defaults to False wait (bool, optional): Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False \"\"\" self . set_joint_angles ( angles , Astrobee . ARM_JOINT_IDXS , force , wait ) def set_gripper_joints ( self , angles : npt . ArrayLike , force : bool = False , wait : bool = False ) -> None : \"\"\"Sets the joint angles for the gripper (left + right, proximal + distal) Args: angles (npt.ArrayLike): Gripper joint angles, length = 4 force (bool, optional): Whether to (non-physically) instantly reset the gripper joints. Should only be used at initialization. Defaults to False wait (bool, optional): Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False \"\"\" self . set_joint_angles ( angles , Astrobee . GRIPPER_JOINT_IDXS , force , wait ) def reset_to_ee_pose ( self , pose : npt . ArrayLike ) -> None : \"\"\"Resets the position of the robot to achieve a target end-effector pose This will currently NOT adjust any of the joints in a \"smart\" way, it will just reset the position of the base given the current joint configuration Args: pose (npt.ArrayLike): Desired position + XYZW quaternion end-effector pose, shape (7,) \"\"\" # Notation: EE: End effector, B: Base, W: World des_EE2W = pos_quat_to_tmat ( pose ) cur_B2W = pos_quat_to_tmat ( self . pose ) cur_EE2W = pos_quat_to_tmat ( self . ee_pose ) cur_W2EE = invert_transform_mat ( cur_EE2W ) cur_B2EE = cur_W2EE @ cur_B2W des_B2W = des_EE2W @ cur_B2EE self . reset_to_base_pose ( tmat_to_pos_quat ( des_B2W )) def reset_to_base_pose ( self , pose : npt . ArrayLike ) -> None : \"\"\"Resets the base of the robot to a target pose Args: pose (npt.ArrayLike): Desired position + XYZW quaternion pose of the Astrobee's base, shape (7,) \"\"\" self . client . resetBasePositionAndOrientation ( self . id , pose [: 3 ], pose [ 3 :]) def localize ( self ): raise NotImplementedError () # TODO.. see dynamics state. Should have a noise parameter def recompute_inertial_properties ( self ) -> None : \"\"\"Calculate the inertial properties based on the current state of the robot in sim This is more accurate than the fixed, base-only values from NASA's documentation, but it is fairly expensive to compute and should NOT be done on every simulation step. This will update the mass, inertia, inv_inertia, and center of mass \"\"\" # Note: Mass will be fixed, but it is not necessarily the same value as provided by NASA mass = 0.0 inertia = np . zeros (( 3 , 3 )) com = np . zeros ( 3 ) T_B2W = self . tmat # Base to world for link in Astrobee . Links : link_info = pybullet . getDynamicsInfo ( self . id , link . value ) link_mass = link_info [ 0 ] link_inertia_diagonal = link_info [ 2 ] if link . value == - 1 : # Separate handling for base link inertia += np . diag ( link_inertia_diagonal ) com += link_mass * T_B2W [: 3 , 3 ] else : T_L2W = self . get_link_transform ( link . value ) # Link to world T_L2B = invert_transform_mat ( T_B2W ) @ T_L2W # Link to base inertia += inertial_transformation ( link_mass , np . diag ( link_inertia_diagonal ), T_L2B ) com += link_mass * T_L2W [: 3 , 3 ] mass += link_mass com /= mass self . _local_com_position = T_B2W [: 3 , : 3 ] . T @ ( com - T_B2W [: 3 , 3 ]) self . _mass = mass self . _inertia = inertia self . _inv_inertia = np . linalg . inv ( inertia ) def store_arm ( self , force : bool = False , wait : bool = False ): \"\"\"Folds the Astrobee's arm into its body Note: Storing the arm reduces the products of inertia, so this is the preferable configuration if not manipulating any objects Args: force (bool, optional): Whether to (non-physically) instantly reset the joints. Should only be used at initialization. Defaults to False wait (bool, optional): Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False \"\"\" self . set_arm_joints ([ Astrobee . JOINT_POS_LIMITS [ 1 , 1 ], 0 ], force , wait ) self . set_gripper_position ( 0 , force , wait ) def deploy_arm ( self , force : bool = False , wait : bool = False ): \"\"\"Sets the arm to the default position, with the gripper fully open Args: force (bool, optional): Whether to (non-physically) instantly reset the joints. Should only be used at initialization. Defaults to False wait (bool, optional): Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False \"\"\" self . set_arm_joints ([ 0 , 0 ], force , wait ) self . set_gripper_position ( 100 , force , wait ) @property def full_state ( self ) -> tuple [ np . ndarray , ... ]: \"\"\"All information required to fully reset the state of the Astrobee Returns: tuple[np.ndarray, ...]: np.ndarray: Position, shape (3,) np.ndarray: Orientation (XYZW quaternion), shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) np.ndarray: Joint positions, shape (NUM_JOINTS,) np.ndarray: Joint velocities, shape (NUM_JOINTS,) \"\"\" pos , orn = self . client . getBasePositionAndOrientation ( self . id ) vel , ang_vel = self . client . getBaseVelocity ( self . id ) joint_states = self . client . getJointStates ( self . id , list ( range ( Astrobee . NUM_JOINTS )) ) joint_positions = np . empty ( Astrobee . NUM_JOINTS ) joint_vels = np . empty ( Astrobee . NUM_JOINTS ) for i in range ( Astrobee . NUM_JOINTS ): joint_positions [ i ] = joint_states [ i ][ 0 ] joint_vels [ i ] = joint_states [ i ][ 1 ] return ( np . array ( pos ), np . array ( orn ), np . array ( vel ), np . array ( ang_vel ), joint_positions , joint_vels , ) def reset_full_state ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , vel : npt . ArrayLike , omega : npt . ArrayLike , q : npt . ArrayLike , qdot : npt . ArrayLike , ): \"\"\"Fully resets the state of the Astrobee Args: pos (npt.ArrayLike): Position, shape (3,) orn (npt.ArrayLike): Orientation (XYZW quaternion), shape (4,) vel (npt.ArrayLike): Linear velocity, shape (3,) omega (npt.ArrayLike): Angular velocity, shape (3,) q (npt.ArrayLike): Joint positions, shape (NUM_JOINTS,) qdot (npt.ArrayLike): Joint velocities, shape (NUM_JOINTS,) \"\"\" self . client . resetBasePositionAndOrientation ( self . id , pos , orn ) self . client . resetBaseVelocity ( self . id , vel , omega ) for i in range ( Astrobee . NUM_JOINTS ): self . client . resetJointState ( self . id , i , q [ i ], qdot [ i ]) @property def bounding_box ( self ) -> np . ndarray : \"\"\"Current axis-aligned bounding box of the Astrobee body (Not including the arm), shape (2, 3)\"\"\" return np . array ( self . client . getAABB ( self . id , - 1 )) def _main (): client = initialize_pybullet ( bg_color = [ 1 , 1 , 1 ]) robot = Astrobee () run_sim () if __name__ == \"__main__\" : _main ()","title":"Module pyastrobee.core.astrobee"},{"location":"reference/pyastrobee/core/astrobee/#variables","text":"COLLISION_RADIUS","title":"Variables"},{"location":"reference/pyastrobee/core/astrobee/#classes","text":"","title":"Classes"},{"location":"reference/pyastrobee/core/astrobee/#astrobee","text":"class Astrobee ( pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 1.0 ), arm_joints : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 0.0 , 0.0 ), gripper_pos : float = 100 , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) Astrobee class for managing control, states, and properties","title":"Astrobee"},{"location":"reference/pyastrobee/core/astrobee/#attributes","text":"Name Type Description Default pose npt.ArrayLike Initial pose of the astrobee when loaded. Defaults to (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0) (At origin, pointed forward along x axis). None arm_joints npt.ArrayLike Initial position of the arm's joints. Defaults to (0.0, 0.0) (Hanging straight down) None gripper_pos float Initial gripper position, in [0, 100]. Defaults to 100 (fully open) None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None View Source class Astrobee : \"\"\"Astrobee class for managing control, states, and properties Args: pose (npt.ArrayLike, optional): Initial pose of the astrobee when loaded. Defaults to (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0) (At origin, pointed forward along x axis). arm_joints (npt.ArrayLike, optional): Initial position of the arm's joints. Defaults to (0.0, 0.0) (Hanging straight down) gripper_pos (float, optional): Initial gripper position, in [0, 100]. Defaults to 100 (fully open) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Raises: ConnectionError: If a pybullet server is not connected before initialization \"\"\" URDF = \"pyastrobee/assets/urdf/astrobee/astrobee.urdf\" NUM_JOINTS = 7 NUM_LINKS = 8 TRANSFORMS = astrobee_transforms # TODO figure out if this is the best way to store this info GRIPPER_JOINT_IDXS = [ 3, 4, 5, 6 ] ARM_JOINT_IDXS = [ 1, 2 ] # Joint limit information is extracted from the URDF # Joint pos limits are [ lower, upper ] for each joint JOINT_POS_LIMITS = np . array ( [ [0.0, 0.0 ] , # top aft ( fixed ) [ -2.0944, 1.57079 ] , # arm proximal joint [ -1.57079, 1.57079 ] , # arm distal joint [ 0.349066, 0.698132 ] , # gripper left proximal joint [ -1.22173, -0.69813 ] , # gripper left distal joint [ -0.698132, -0.349066 ] , # gripper right proximal joint [ 0.69813, 1.22173 ] , # gripper right distal joint ] ) JOINT_EFFORT_LIMITS = np . array ( [ 0.0, # top aft (fixed) 1.0, # arm proximal joint 1.0, # arm distal joint 0.1, # gripper left proximal joint 0.1, # gripper left distal joint 0.1, # gripper right proximal joint 0.1, # gripper right distal joint ] ) JOINT_VEL_LIMITS = np . array ( [ 0.00, # top aft (fixed) 0.12, # arm proximal joint 0.12, # arm distal joint 0.12, # gripper left proximal joint 0.12, # gripper left distal joint 0.12, # gripper right proximal joint 0.12, # gripper right distal joint ] ) # Bounding sphere for collision modeling COLLISION_RADIUS = COLLISION_RADIUS class Joints ( Enum ) : \"\"\"Enumerates the different joints on the astrobee via their Pybullet index\"\"\" # Comments indicate the name of the joint in the URDF ARM_BASE = 0 # top_aft ( fixed joint ) ARM_PROXIMAL = 1 # top_aft_arm_proximal_joint ARM_DISTAL = 2 # top_aft_arm_distal_joint GRIPPER_LEFT_PROXIMAL = 3 # top_aft_gripper_left_proximal_joint GRIPPER_LEFT_DISTAL = 4 # top_aft_gripper_left_distal_joint GRIPPER_RIGHT_PROXIMAL = 5 # top_aft_gripper_right_proximal_joint GRIPPER_RIGHT_DISTAL = 6 # top_aft_gripper_right_distal_joint class Links ( Enum ) : \"\"\"Enumerates the different links on the astrobee via their Pybullet index Note: the URDF technically has 8 links, but it appears that pybullet considers the very first link to be the base link \"\"\" # Comments indicate the name of the link in the URDF BODY = - 1 # honey_body ARM_BASE = 0 # honey_top_aft ARM_PROXIMAL = 1 # honey_top_aft_arm_proximal_link ARM_DISTAL = 2 # honey_top_aft_arm_distal_link GRIPPER_LEFT_PROXIMAL = 3 # honey_top_aft_gripper_left_proximal_link GRIPPER_LEFT_DISTAL = 4 # honey_top_aft_gripper_left_distal_link GRIPPER_RIGHT_PROXIMAL = 5 # honey_top_aft_gripper_right_proximal_link GRIPPER_RIGHT_DISTAL = 6 # honey_top_aft_gripper_right_distal_link def __init__ ( self , pose : npt . ArrayLike = ( 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 1.0 ), arm_joints : npt . ArrayLike = ( 0.0 , 0.0 ), gripper_pos : float = 100 , client : Optional [ BulletClient ] = None , ) : self . client : pybullet = pybullet if client is None else client if not self . client . isConnected () : raise ConnectionError ( \"Need to connect to pybullet before initializing an astrobee\" ) self . id = self . client . loadURDF ( Astrobee . URDF , pose [ :3 ] , pose [ 3: ] , flags = pybullet . URDF_USE_INERTIA_FROM_FILE ) self . _dt = self . client . getPhysicsEngineParameters () [ \"fixedTimeStep\" ] self . set_gripper_position ( gripper_pos , force = True ) self . set_arm_joints ( arm_joints , force = True ) # Initialize dynamics info with estimated numbers from NASA , we can recompute based on the sim state later # if desired . Values are from A Brief Guide to Astrobee self . _mass = 9.58 # kg self . _inertia = np . diag ( [ 0.153, 0.143, 0.162 ] ) # kg - m ^ 2 self . _inv_inertia = np . linalg . inv ( self . _inertia ) self . _local_com_position = np . zeros ( 3 ) # Init , not accurate # TODO decide if we should recompute automatically ??? # self . recompute_inertial_properties () print_green ( \"Astrobee is ready\" ) def unload ( self ) -> None : \"\"\"Remove the Astrobee from the simulation\"\"\" self . client . removeBody ( self . id ) @property def pose ( self ) -> np . ndarray : \"\"\"The current robot pose (position + XYZW quaternion) expressed in world frame Returns: np.ndarray: Position and quaternion, size (7,) \"\"\" pos , orn = self . client . getBasePositionAndOrientation ( self . id ) return np . concatenate ( [ pos, orn ] ) @property def tmat ( self ) -> np . ndarray : \"\"\"The current robot pose in world frame, expressed as a transformation matrix Returns: np.ndarray: Transformation matrix (Robot to World), shape (4,4) \"\"\" return pos_quat_to_tmat ( self . pose ) @property def position ( self ) -> np . ndarray : \"\"\"Just the position component of the full pose Returns: np.ndarray: (3,) position vector \"\"\" return self . pose [ :3 ] @property def orientation ( self ) -> np . ndarray : \"\"\"Just the quaternion component of the full pose Returns: np.ndarray: (4,) XYZW quaternion \"\"\" return self . pose [ 3: ] @property def rmat ( self ) -> np . ndarray : \"\"\"The orientation of the robot expressed as a rotation matrix Returns: np.ndarray: Rotation matrix (Robot to World), shape (3,3) \"\"\" return quat_to_rmat ( self . orientation ) @property def heading ( self ) -> np . ndarray : \"\"\"A unit vector in the forward (x) component of the astrobee Some notes: - This is NOT a full description of orientation since rotation about this axis is undefined - The arm is on the REAR side of the astrobee, not the front - The y vector points to the port (left) side of the astrobee, and the z vector is up Returns: np.ndarray: (3,) unit vector \"\"\" R_R2W = quat_to_rmat ( self . orientation ) # Robot to world return R_R2W [ :, 0 ] # Robot frame x vector expressed in world @property def velocity ( self ) -> np . ndarray : \"\"\"Linear velocity of the Astrobee, with respect to the world frame xyz axes Returns: np.ndarray: [vx, vy, vz] linear velocities, shape (3,) \"\"\" lin_vel , _ = self . client . getBaseVelocity ( self . id ) return np . array ( lin_vel ) @property def angular_velocity ( self ) -> np . ndarray : \"\"\"Angular velocity of the Astrobee, about the world frame xyz axes Returns: np.ndarray: [wx, wy, wz] angular velocities, shape (3,) \"\"\" _ , ang_vel = self . client . getBaseVelocity ( self . id ) return np . array ( ang_vel ) @property def ee_pose ( self ) -> np . ndarray : \"\"\"The current end-effector pose (position + XYZW quaternion) expressed in world frame Returns: np.ndarray: Position and quaternion, size (7,) \"\"\" return tmat_to_pos_quat ( self . ee_tmat ) @property def ee_tmat ( self ) -> np . ndarray : \"\"\"The current end-effector transformation matrix (gripper-to-world) Returns: np.ndarray: Transformation matrix, shape (4, 4) \"\"\" T_G2D = Astrobee . TRANSFORMS . GRIPPER_TO_ARM_DISTAL # Gripper to distal T_D2W = self . get_link_transform ( Astrobee . Links . ARM_DISTAL . value ) # Distal to world return T_D2W @ T_G2D @property def joint_angles ( self ) -> np . ndarray : \"\"\"Angular positions (radians) of each joint on the Astrobee Returns: np.ndarray: Joint angles, shape (NUM_JOINTS,) \"\"\" # States : tuple [ tuple ] , size ( 7 , 4 ) # 7 corresponds to NUM_JOINTS # 4 corresponds to position , velocity , reaction forces , and applied torque states = self . client . getJointStates ( self . id , list ( range ( Astrobee . NUM_JOINTS ))) # Index 0 : position return np . array ( [ states[i ][ 0 ] for i in range ( Astrobee . NUM_JOINTS ) ] ) @property def joint_vels ( self ) -> np . ndarray : \"\"\"Angular velocities (radians/sec) of each joint on the Astrobee Returns: np.ndarray: Joint velocities, shape (NUM_JOINTS,) \"\"\" states = self . client . getJointStates ( self . id , list ( range ( Astrobee . NUM_JOINTS ))) # Index 1 : velocity return np . array ( [ states[i ][ 1 ] for i in range ( Astrobee . NUM_JOINTS ) ] ) @property def joint_torques ( self ) -> np . ndarray : \"\"\"Torques (N-m) applied by each joint on the Astrobee Returns: np.ndarray: Joint torques, shape (NUM_JOINTS,) \"\"\" states = self . client . getJointStates ( self . id , list ( range ( Astrobee . NUM_JOINTS ))) # Index 3 : torque return np . array ( [ states[i ][ 3 ] for i in range ( Astrobee . NUM_JOINTS ) ] ) @property def arm_joint_angles ( self ) -> np . ndarray : \"\"\"Gives the two joint angles associated with the proximal + distal joints of the arm Returns: np.ndarray: Arm joint angles, shape (2,) \"\"\" return self . joint_angles [ Astrobee.ARM_JOINT_IDXS ] @property def gripper_joint_angles ( self ) -> np . ndarray : \"\"\"Gives the four joint angles associated with the proximal + distal joints of the two gripper fingers Returns: np.ndarray: Gripper joint angles, shape (4,) \"\"\" return self . joint_angles [ Astrobee.GRIPPER_JOINT_IDXS ] @property def inertia ( self ) -> np . ndarray : \"\"\"Body inertia tensor for the Astrobee, shape (3, 3)\"\"\" return self . _inertia @property def inv_inertia ( self ) -> np . ndarray : \"\"\"Inverse of the Astrobee's body inertia tensor, shape (3, 3)\"\"\" return self . _inv_inertia @property def world_inertia ( self ) -> np . ndarray : \"\"\"World-frame inertia tensor of the Astrobee, shape (3, 3) This takes into account the current rotation of Astrobee \"\"\" R = self . rmat return R @ self . inertia @ R . T @property def world_inv_inertia ( self ) -> np . ndarray : \"\"\"Inverse of the world-frame inertia tensor of the Astrobee, shape (3, 3) This takes into account the current rotation of Astrobee \"\"\" R = self . rmat return R @ self . inv_inertia @ R . T @property def mass ( self ) -> float : \"\"\"Mass of the Astrobee\"\"\" return self . _mass @property def local_com_position ( self ) -> np . ndarray : \"\"\"Position of the center of mass of the robot w.r.t. the base, in local frame. Shape (3,)\"\"\" return self . _local_com_position @property def world_com_position ( self ) -> np . ndarray : \"\"\"Position of the center of mass of the robot, in world frame. Shape (3,)\"\"\" return transform_point ( self . tmat , self . local_com_position ) @property def state_space_matrices ( self ) -> tuple [ np.ndarray, np.ndarray ] : \"\"\"The state and control matrices A and B, such that x_dot = Ax + Bu We assume that the state x = [position, velocity, quaternion, angular velocity] \u2208 R13 and that the control u = [force, torque] \u2208 R6 We linearize the system about the current state Returns: tuple[np.ndarray, np.ndarray]: np.ndarray: A: State matrix, shape (13, 13) np.ndarray: B: Control matrix, shape (13, 6) \"\"\" # TODO : decide if using the true joint - angle - based inertia tensor _ , q , _ , w = self . dynamics_state R = self . rmat # Use inertias defined in the world frame inertia = R @ self . inertia @ R . T inv_inertia = R @ self . inv_inertia @ R . T return ( state_matrix ( q , w , inertia , inv_inertia ), control_matrix ( self . mass , inv_inertia ), ) @property def state_vector ( self ) -> np . ndarray : \"\"\"The state vector x, such that x_dot = Ax + Bu We compose the state as [position, velocity, quaternion, angular velocity] \u2208 R13 \"\"\" pos , orn = self . client . getBasePositionAndOrientation ( self . id ) lin_vel , ang_vel = self . client . getBaseVelocity ( self . id ) return np . concatenate ( [ pos, lin_vel, orn, ang_vel ] ) @property def dynamics_state ( self ) -> tuple [ np.ndarray, np.ndarray, np.ndarray, np.ndarray ] : \"\"\"Current state of the Astrobee's dynamics: Position, orientation, linear vel, and angular vel Returns: tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: np.ndarray: Position, shape (3,) np.ndarray: XYZW quaternion orientation, shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) \"\"\" pos , orn = self . client . getBasePositionAndOrientation ( self . id ) lin_vel , ang_vel = self . client . getBaseVelocity ( self . id ) return np . array ( pos ), np . array ( orn ), np . array ( lin_vel ), np . array ( ang_vel ) @property def mass_matrix ( self ) -> np . ndarray : \"\"\"Mass/Inertia matrix for the Astrobee, given its current configuration - This is used to determine the kinetic energy (K = (1/2) * qdot.T @ M @ qdot) or the relationship between joint accelerations and torque (M * joint_accels + centrifugal_coriolis_vec + gravity_vec = torque) Returns: np.ndarray: The mass matrix, shape (12, 12). (12 is the number of degrees of freedom of the Astrobee - 6 DOF for a floating base, plus 6 for the six non-fixed joints) \"\"\" # Inputs must be a lists ( no numpy ) or else pybullet will seg fault M = self . client . calculateMassMatrix ( self . id , list ( self . joint_angles )) return np . array ( M ) def get_jacobians ( self , link : Union [ Links, int ] , local_pos : npt . ArrayLike = ( 0.0 , 0.0 , 0.0 ) ) -> tuple [ np.ndarray, np.ndarray ] : \"\"\"Calculate the linear and angular jacobians (Jv and Jw) for a point on a link - These relate joint motion and task-space motion: [v; w] = [Jv; Jw] * dq - These jacobians will have a 12 columns corresponding to 6 DOF from the Astrobee's floating base, plus another 6 DOF from the non-fixed joints Args: link (Union[Links, int]): Link or link index of interest. Common links: For the base, set this to -1. For the arm distal link, set this to 2 local_pos (npt.ArrayLike, optional): Position in the link's reference frame. Defaults to [0.0, 0.0, 0.0]. For the grasp point, use the position from the calibrated distal/grasp transformation Returns: tuple[np.ndarray, np.ndarray]: np.ndarray: Jv: Linear jacobian, shape (3, 12) np.ndarray: Jw: Angular jacobian, shape (3, 12) \"\"\" if isinstance ( link , Astrobee . Links ) : link = link . value ndof = 6 # 7 joints , but 1 fixed # The quickstart guide says that the joint velocities and desired accelerations are just there # for an internal call to calculateInverseDynamics ( and maybe aren 't really meaningful?) desired_accels = ndof * [0.0] # All inputs must be lists (no numpy) or else pybullet will seg fault Jv, Jw = self.client.calculateJacobian( self.id, link, list(local_pos), list(self.joint_angles)[1:], # Don' t include the first fixed joint list ( self . joint_vels ) [ 1: ] , # Don 't include the first fixed joint desired_accels, ) return np.array(Jv), np.array(Jw) def get_link_transform(self, link_index: Union[Links, int]) -> np.ndarray: \"\"\"Calculates the transformation matrix (w.r.t the world) for a specified link Args: link_index (int): Index of the link on the robot Returns: np.ndarray: Transformation matrix (link to world). Shape = (4,4) \"\"\" if isinstance(link_index, Astrobee.Links): link_index = link_index.value # We have 8 links, indexed from -1 to 6 # Pybullet does not allow access to the base link (-1) through getLinkState # So, use this only for non-base links if link_index > 6 or link_index < 0: raise ValueError(f\"Invalid link index: {link_index}\") link_state = self.client.getLinkState( self.id, link_index, computeForwardKinematics=True ) # First two link state values are linkWorldPosition, linkWorldOrientation # There are other state positions and orientations, but they' re confusing . ( TODO check on these ) pos , quat = link_state [ :2 ] return make_transform_mat ( quat_to_rmat ( quat ), pos ) @property # Is this better as a property or as a \"getter\" ? def gripper_position ( self ) -> int : \"\"\"The current position of the gripper, in range [0, 100] Returns: int: Position of the gripper, an integer between 0 (closed) and 100 (open) \"\"\" joint_states = self . client . getJointStates ( self . id , Astrobee . GRIPPER_JOINT_IDXS ) joint_angles = [ state[0 ] for state in joint_states ] l_angles = joint_angles [ :2 ] r_angles = joint_angles [ 2: ] l_closed , l_open , r_closed , r_open = self . _get_gripper_joint_ranges () l_pct = 100 * ( l_angles - l_closed ) / ( l_open - l_closed ) r_pct = 100 * ( r_angles - r_closed ) / ( r_open - r_closed ) return np . round ( np . average ( np . concatenate ( [ l_pct, r_pct ] ))). astype ( int ) # TODO decide if we need finer - grain control of the individual joints , or if this integer - position is fine def set_gripper_position ( self , position : float , force : bool = False , wait : bool = False ) -> None : \"\"\"Sets the gripper to a position between 0 (fully closed) to 100 (fully open) Args: position (float): Gripper position, in range [0, 100] force (bool, optional): Whether to (non-physically) instantly reset the gripper position, instead of stepping the sim. Should only be used at initialization. Defaults to False wait (bool, optional): Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False \"\"\" if position < 0 or position > 100 : raise ValueError ( \"Position should be in range [0, 100]\" ) l_closed , l_open , r_closed , r_open = self . _get_gripper_joint_ranges () left_pos = l_closed + ( position / 100 ) * ( l_open - l_closed ) right_pos = r_closed + ( position / 100 ) * ( r_open - r_closed ) angle_cmd = [ *left_pos, *right_pos ] self . set_gripper_joints ( angle_cmd , force , wait ) def open_gripper ( self ) -> None : \"\"\"Fully opens the gripper\"\"\" self . set_gripper_position ( 100 ) # TODO add force / torque control ? def close_gripper ( self ) -> None : \"\"\"Fully closes the gripper\"\"\" self . set_gripper_position ( 0 ) # TODO rework this ? def _get_gripper_joint_ranges ( self , ) -> tuple [ np.ndarray, np.ndarray, np.ndarray, np.ndarray ] : \"\"\"Helper function to determine the range of motion (closed -> open) of the gripper joints - This is a bit confusing because of how the URDF specifies joint min/max and how this translates to an open/closed position on the gripper - For a fully-closed gripper, the right side joints are at their max, and the left side joints are at their min - Likewise, for a fully-open gripper, the right side is at the joint min, and the left at joint max Returns: tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: np.ndarray: Left-side gripper finger angles when closed. Shape (2,) np.ndarray: Left-side gripper finger angles when open. Shape (2,) np.ndarray: Right-side gripper finger angles when closed. Shape (2,) np.ndarray: Right-side gripper finger angles when open. Shape (2,) \"\"\" left_joints = Astrobee . GRIPPER_JOINT_IDXS [ :2 ] right_joints = Astrobee . GRIPPER_JOINT_IDXS [ 2: ] # As a numpy array , each row will correspond to a joint , and the two columns are [ min, max ] left_closed , left_open = Astrobee . JOINT_POS_LIMITS [ left_joints ] . T right_open , right_closed = Astrobee . JOINT_POS_LIMITS [ right_joints ] . T return left_closed , left_open , right_closed , right_open def set_joint_angles ( self , angles : npt . ArrayLike , indices : Optional [ npt.ArrayLike ] = None , force : bool = False , wait : bool = False , ) : \"\"\"Sets the joint angles for the Astrobee (either all joints, or a specified subset) Args: angles (npt.ArrayLike): Desired joint angles, in radians indices (npt.ArrayLike, optional): Indices of the joints to control. Defaults to None, in which case we assume all 7 joints will be set. force (bool, optional): Whether to (non-physically) instantly reset the joint state. Should only be used at initialization. Defaults to False wait (bool, optional): Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False Raises: ValueError: If the number of angles provided do not match the number of indices ValueError: If the angles are out of the joint limits for the specified indices \"\"\" if indices is None : indices = list ( range ( Astrobee . NUM_JOINTS )) angles = np . atleast_1d ( angles ) # If scalar , ensure we don 't have a 0-D array indices = np.atleast_1d(indices) if indices.shape != angles.shape: raise ValueError( \"Number of angles must match with the number of provided indices\" ) if np.any(angles < Astrobee.JOINT_POS_LIMITS[indices, 0]) or np.any( angles > Astrobee.JOINT_POS_LIMITS[indices, 1] ): raise ValueError( f\"Joint angle command is outside of joint limits.\\nGot: {angles} for joints {indices}\" ) if force: for ind, angle in zip(indices, angles): self.client.resetJointState(self.id, ind, angle) # Set the position control for the arm so Pybullet will correct for disturbances self.client.setJointMotorControlArray( self.id, indices, self.client.POSITION_CONTROL, angles, forces=self.JOINT_EFFORT_LIMITS[indices], ) # Step the sim until the arm is at the desired angle, if waiting for it to reach the position if wait: tol = 0.01 # TODO TOTALLY ARBITRARY FOR NOW while np.any(np.abs(self.get_joint_angles(indices) - angles) > tol): self.client.stepSimulation() def get_joint_angles(self, indices: Optional[npt.ArrayLike] = None) -> np.ndarray: \"\"\"Gives the current joint angles for the Astrobee Args: indices (npt.ArrayLike, optional): Indices of the joints of interest. Defaults to None, in which case all joint angles will be returned Returns: np.ndarray: Joint angles (in radians), length = len(indices) or Astrobee.NUM_JOINTS \"\"\" states = self.client.getJointStates(self.id, indices) return np.array([state[0] for state in states]) def set_arm_joints( self, angles: npt.ArrayLike, force: bool = False, wait: bool = False ) -> None: \"\"\"Sets the joint angles for the arm (proximal + distal) Args: angles (npt.ArrayLike): Arm joint angles, length = 2 force (bool, optional): Whether to (non-physically) instantly reset the joint states. Should only be used at initialization. Defaults to False wait (bool, optional): Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False \"\"\" self.set_joint_angles(angles, Astrobee.ARM_JOINT_IDXS, force, wait) def set_gripper_joints( self, angles: npt.ArrayLike, force: bool = False, wait: bool = False ) -> None: \"\"\"Sets the joint angles for the gripper (left + right, proximal + distal) Args: angles (npt.ArrayLike): Gripper joint angles, length = 4 force (bool, optional): Whether to (non-physically) instantly reset the gripper joints. Should only be used at initialization. Defaults to False wait (bool, optional): Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False \"\"\" self.set_joint_angles(angles, Astrobee.GRIPPER_JOINT_IDXS, force, wait) def reset_to_ee_pose(self, pose: npt.ArrayLike) -> None: \"\"\"Resets the position of the robot to achieve a target end-effector pose This will currently NOT adjust any of the joints in a \"smart\" way, it will just reset the position of the base given the current joint configuration Args: pose (npt.ArrayLike): Desired position + XYZW quaternion end-effector pose, shape (7,) \"\"\" # Notation: EE: End effector, B: Base, W: World des_EE2W = pos_quat_to_tmat(pose) cur_B2W = pos_quat_to_tmat(self.pose) cur_EE2W = pos_quat_to_tmat(self.ee_pose) cur_W2EE = invert_transform_mat(cur_EE2W) cur_B2EE = cur_W2EE @ cur_B2W des_B2W = des_EE2W @ cur_B2EE self.reset_to_base_pose(tmat_to_pos_quat(des_B2W)) def reset_to_base_pose(self, pose: npt.ArrayLike) -> None: \"\"\"Resets the base of the robot to a target pose Args: pose (npt.ArrayLike): Desired position + XYZW quaternion pose of the Astrobee' s base , shape ( 7 ,) \"\"\" self.client.resetBasePositionAndOrientation(self.id, pose[:3], pose[3:]) def localize(self): raise NotImplementedError() # TODO.. see dynamics state. Should have a noise parameter def recompute_inertial_properties(self) -> None: \"\"\" Calculate the inertial properties based on the current state of the robot in sim This is more accurate than the fixed , base - only values from NASA 's documentation, but it is fairly expensive to compute and should NOT be done on every simulation step. This will update the mass, inertia, inv_inertia, and center of mass \"\"\" # Note: Mass will be fixed, but it is not necessarily the same value as provided by NASA mass = 0.0 inertia = np.zeros((3, 3)) com = np.zeros(3) T_B2W = self.tmat # Base to world for link in Astrobee.Links: link_info = pybullet.getDynamicsInfo(self.id, link.value) link_mass = link_info[0] link_inertia_diagonal = link_info[2] if link.value == -1: # Separate handling for base link inertia += np.diag(link_inertia_diagonal) com += link_mass * T_B2W[:3, 3] else: T_L2W = self.get_link_transform(link.value) # Link to world T_L2B = invert_transform_mat(T_B2W) @ T_L2W # Link to base inertia += inertial_transformation( link_mass, np.diag(link_inertia_diagonal), T_L2B ) com += link_mass * T_L2W[:3, 3] mass += link_mass com /= mass self._local_com_position = T_B2W[:3, :3].T @ (com - T_B2W[:3, 3]) self._mass = mass self._inertia = inertia self._inv_inertia = np.linalg.inv(inertia) def store_arm(self, force: bool = False, wait: bool = False): \"\"\"Folds the Astrobee' s arm into its body Note : Storing the arm reduces the products of inertia , so this is the preferable configuration if not manipulating any objects Args : force ( bool , optional ) : Whether to ( non - physically ) instantly reset the joints . Should only be used at initialization . Defaults to False wait ( bool , optional ) : Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner . Defaults to False \"\"\" self.set_arm_joints([Astrobee.JOINT_POS_LIMITS[1, 1], 0], force, wait) self.set_gripper_position(0, force, wait) def deploy_arm(self, force: bool = False, wait: bool = False): \"\"\" Sets the arm to the default position , with the gripper fully open Args : force ( bool , optional ) : Whether to ( non - physically ) instantly reset the joints . Should only be used at initialization . Defaults to False wait ( bool , optional ) : Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner . Defaults to False \"\"\" self.set_arm_joints([0, 0], force, wait) self.set_gripper_position(100, force, wait) @property def full_state(self) -> tuple[np.ndarray, ...]: \"\"\" All information required to fully reset the state of the Astrobee Returns : tuple [ np.ndarray, ... ] : np . ndarray : Position , shape ( 3 ,) np . ndarray : Orientation ( XYZW quaternion ), shape ( 4 ,) np . ndarray : Linear velocity , shape ( 3 ,) np . ndarray : Angular velocity , shape ( 3 ,) np . ndarray : Joint positions , shape ( NUM_JOINTS ,) np . ndarray : Joint velocities , shape ( NUM_JOINTS ,) \"\"\" pos, orn = self.client.getBasePositionAndOrientation(self.id) vel, ang_vel = self.client.getBaseVelocity(self.id) joint_states = self.client.getJointStates( self.id, list(range(Astrobee.NUM_JOINTS)) ) joint_positions = np.empty(Astrobee.NUM_JOINTS) joint_vels = np.empty(Astrobee.NUM_JOINTS) for i in range(Astrobee.NUM_JOINTS): joint_positions[i] = joint_states[i][0] joint_vels[i] = joint_states[i][1] return ( np.array(pos), np.array(orn), np.array(vel), np.array(ang_vel), joint_positions, joint_vels, ) def reset_full_state( self, pos: npt.ArrayLike, orn: npt.ArrayLike, vel: npt.ArrayLike, omega: npt.ArrayLike, q: npt.ArrayLike, qdot: npt.ArrayLike, ): \"\"\" Fully resets the state of the Astrobee Args : pos ( npt . ArrayLike ) : Position , shape ( 3 ,) orn ( npt . ArrayLike ) : Orientation ( XYZW quaternion ), shape ( 4 ,) vel ( npt . ArrayLike ) : Linear velocity , shape ( 3 ,) omega ( npt . ArrayLike ) : Angular velocity , shape ( 3 ,) q ( npt . ArrayLike ) : Joint positions , shape ( NUM_JOINTS ,) qdot ( npt . ArrayLike ) : Joint velocities , shape ( NUM_JOINTS ,) \"\"\" self.client.resetBasePositionAndOrientation(self.id, pos, orn) self.client.resetBaseVelocity(self.id, vel, omega) for i in range(Astrobee.NUM_JOINTS): self.client.resetJointState(self.id, i, q[i], qdot[i]) @property def bounding_box(self) -> np.ndarray: \"\"\" Current axis - aligned bounding box of the Astrobee body ( Not including the arm ), shape ( 2 , 3 ) \"\" \" return np . array ( self . client . getAABB ( self . id , - 1 ))","title":"Attributes"},{"location":"reference/pyastrobee/core/astrobee/#class-variables","text":"ARM_JOINT_IDXS COLLISION_RADIUS GRIPPER_JOINT_IDXS JOINT_EFFORT_LIMITS JOINT_POS_LIMITS JOINT_VEL_LIMITS Joints Links NUM_JOINTS NUM_LINKS TRANSFORMS URDF","title":"Class variables"},{"location":"reference/pyastrobee/core/astrobee/#instance-variables","text":"angular_velocity Angular velocity of the Astrobee, about the world frame xyz axes arm_joint_angles Gives the two joint angles associated with the proximal + distal joints of the arm bounding_box Current axis-aligned bounding box of the Astrobee body (Not including the arm), shape (2, 3) dynamics_state Current state of the Astrobee's dynamics: Position, orientation, linear vel, and angular vel ee_pose The current end-effector pose (position + XYZW quaternion) expressed in world frame ee_tmat The current end-effector transformation matrix (gripper-to-world) full_state All information required to fully reset the state of the Astrobee gripper_joint_angles Gives the four joint angles associated with the proximal + distal joints of the two gripper fingers gripper_position The current position of the gripper, in range [0, 100] heading A unit vector in the forward (x) component of the astrobee Some notes: - This is NOT a full description of orientation since rotation about this axis is undefined - The arm is on the REAR side of the astrobee, not the front - The y vector points to the port (left) side of the astrobee, and the z vector is up inertia Body inertia tensor for the Astrobee, shape (3, 3) inv_inertia Inverse of the Astrobee's body inertia tensor, shape (3, 3) joint_angles Angular positions (radians) of each joint on the Astrobee joint_torques Torques (N-m) applied by each joint on the Astrobee joint_vels Angular velocities (radians/sec) of each joint on the Astrobee local_com_position Position of the center of mass of the robot w.r.t. the base, in local frame. Shape (3,) mass Mass of the Astrobee mass_matrix Mass/Inertia matrix for the Astrobee, given its current configuration This is used to determine the kinetic energy (K = (1/2) * qdot.T @ M @ qdot) or the relationship between joint accelerations and torque (M * joint_accels + centrifugal_coriolis_vec + gravity_vec = torque) orientation Just the quaternion component of the full pose pose The current robot pose (position + XYZW quaternion) expressed in world frame position Just the position component of the full pose rmat The orientation of the robot expressed as a rotation matrix state_space_matrices The state and control matrices A and B, such that x_dot = Ax + Bu We assume that the state x = [position, velocity, quaternion, angular velocity] \u2208 R13 and that the control u = [force, torque] \u2208 R6 We linearize the system about the current state state_vector The state vector x, such that x_dot = Ax + Bu We compose the state as [position, velocity, quaternion, angular velocity] \u2208 R13 tmat The current robot pose in world frame, expressed as a transformation matrix velocity Linear velocity of the Astrobee, with respect to the world frame xyz axes world_com_position Position of the center of mass of the robot, in world frame. Shape (3,) world_inertia World-frame inertia tensor of the Astrobee, shape (3, 3) This takes into account the current rotation of Astrobee world_inv_inertia Inverse of the world-frame inertia tensor of the Astrobee, shape (3, 3) This takes into account the current rotation of Astrobee","title":"Instance variables"},{"location":"reference/pyastrobee/core/astrobee/#methods","text":"","title":"Methods"},{"location":"reference/pyastrobee/core/astrobee/#close_gripper","text":"def close_gripper ( self ) -> None Fully closes the gripper View Source def close_gripper ( self ) -> None : \"\"\"Fully closes the gripper\"\"\" self . set_gripper_position ( 0 )","title":"close_gripper"},{"location":"reference/pyastrobee/core/astrobee/#deploy_arm","text":"def deploy_arm ( self , force : bool = False , wait : bool = False ) Sets the arm to the default position, with the gripper fully open Parameters: Name Type Description Default force bool Whether to (non-physically) instantly reset the joints. Should only be used at initialization. Defaults to False None wait bool Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False None View Source def deploy_arm(self, force: bool = False, wait: bool = False): \"\"\"Sets the arm to the default position, with the gripper fully open Args: force (bool, optional): Whether to (non-physically) instantly reset the joints. Should only be used at initialization. Defaults to False wait (bool, optional): Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False \"\"\" self.set_arm_joints([0, 0], force, wait) self.set_gripper_position(100, force, wait)","title":"deploy_arm"},{"location":"reference/pyastrobee/core/astrobee/#get_jacobians","text":"def get_jacobians ( self , link : Union [ pyastrobee . core . astrobee . Astrobee . Links , int ], local_pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 0.0 , 0.0 , 0.0 ) ) -> tuple [ numpy . ndarray , numpy . ndarray ] Calculate the linear and angular jacobians (Jv and Jw) for a point on a link These relate joint motion and task-space motion: [v; w] = [Jv; Jw] * dq These jacobians will have a 12 columns corresponding to 6 DOF from the Astrobee's floating base, plus another 6 DOF from the non-fixed joints Parameters: Name Type Description Default link Union[Links, int] Link or link index of interest. Common links: For the base, set this to -1. For the arm distal link, set this to 2 None local_pos npt.ArrayLike Position in the link's reference frame. Defaults to [0.0, 0.0, 0.0]. For the grasp point, use the position from the calibrated distal/grasp transformation [0.0, 0.0, 0.0] Returns: Type Description tuple[np.ndarray, np.ndarray] np.ndarray: Jv: Linear jacobian, shape (3, 12) np.ndarray: Jw: Angular jacobian, shape (3, 12) View Source def get_jacobians ( self , link : Union [ Links , int ] , local_pos : npt . ArrayLike = ( 0 . 0 , 0 . 0 , 0 . 0 ) ) - > tuple [ np.ndarray , np.ndarray ] : \"\"\"Calculate the linear and angular jacobians (Jv and Jw) for a point on a link - These relate joint motion and task-space motion: [ v ; w ] = [ Jv ; Jw ] * dq - These jacobians will have a 12 columns corresponding to 6 DOF from the Astrobee's floating base, plus another 6 DOF from the non-fixed joints Args: link (Union [ Links , int ] ): Link or link index of interest. Common links: For the base, set this to -1. For the arm distal link, set this to 2 local_pos (npt.ArrayLike, optional): Position in the link's reference frame. Defaults to [ 0.0 , 0.0 , 0.0 ] . For the grasp point, use the position from the calibrated distal/grasp transformation Returns: tuple [ np.ndarray , np.ndarray ] : np.ndarray: Jv: Linear jacobian, shape (3, 12) np.ndarray: Jw: Angular jacobian, shape (3, 12) \"\"\" if isinstance ( link , Astrobee . Links ): link = link . value ndof = 6 # 7 joints , but 1 fixed # The quickstart guide says that the joint velocities and desired accelerations are just there # for an internal call to calculateInverseDynamics ( and maybe aren 't really meaningful?) desired_accels = ndof * [ 0.0 ] # All inputs must be lists (no numpy) or else pybullet will seg fault Jv, Jw = self.client.calculateJacobian( self.id, link, list(local_pos), list(self.joint_angles) [ 1 : ] , # Don' t include the first fixed joint list ( self . joint_vels ) [ 1 : ] , # Don ' t include the first fixed joint desired_accels , ) return np . array ( Jv ), np . array ( Jw )","title":"get_jacobians"},{"location":"reference/pyastrobee/core/astrobee/#get_joint_angles","text":"def get_joint_angles ( self , indices : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None ) -> numpy . ndarray Gives the current joint angles for the Astrobee Parameters: Name Type Description Default indices npt.ArrayLike Indices of the joints of interest. Defaults to None, in which case all joint angles will be returned None Returns: Type Description np.ndarray Joint angles (in radians), length = len(indices) or Astrobee.NUM_JOINTS View Source def get_joint_angles ( self , indices : Optional [ npt . ArrayLike ] = None ) -> np . ndarray : \"\"\"Gives the current joint angles for the Astrobee Args: indices (npt.ArrayLike, optional): Indices of the joints of interest. Defaults to None, in which case all joint angles will be returned Returns: np.ndarray: Joint angles (in radians), length = len(indices) or Astrobee.NUM_JOINTS \"\"\" states = self . client . getJointStates ( self . id , indices ) return np . array ([ state [ 0 ] for state in states ])","title":"get_joint_angles"},{"location":"reference/pyastrobee/core/astrobee/#get_link_transform","text":"def get_link_transform ( self , link_index : Union [ pyastrobee . core . astrobee . Astrobee . Links , int ] ) -> numpy . ndarray Calculates the transformation matrix (w.r.t the world) for a specified link Parameters: Name Type Description Default link_index int Index of the link on the robot None Returns: Type Description np.ndarray Transformation matrix (link to world). Shape = (4,4) View Source def get_link_transform ( self , link_index : Union [ Links , int ]) -> np . ndarray : \"\"\"Calculates the transformation matrix (w.r.t the world) for a specified link Args: link_index (int): Index of the link on the robot Returns: np.ndarray: Transformation matrix (link to world). Shape = (4,4) \"\"\" if isinstance ( link_index , Astrobee . Links ) : link_index = link_index . value # We have 8 links , indexed from - 1 to 6 # Pybullet does not allow access to the base link ( - 1 ) through getLinkState # So , use this only for non - base links if link_index > 6 or link_index < 0 : raise ValueError ( f \"Invalid link index: {link_index}\" ) link_state = self . client . getLinkState ( self . id , link_index , computeForwardKinematics = True ) # First two link state values are linkWorldPosition , linkWorldOrientation # There are other state positions and orientations , but they 're confusing. (TODO check on these) pos, quat = link_state[:2] return make_transform_mat(quat_to_rmat(quat), pos)","title":"get_link_transform"},{"location":"reference/pyastrobee/core/astrobee/#localize","text":"def localize ( self ) View Source def localize(self): raise NotImplementedError() # TODO.. see dynamics state. Should have a noise parameter","title":"localize"},{"location":"reference/pyastrobee/core/astrobee/#open_gripper","text":"def open_gripper ( self ) -> None Fully opens the gripper View Source def open_gripper ( self ) -> None : \"\"\"Fully opens the gripper\"\"\" self . set_gripper_position ( 100 )","title":"open_gripper"},{"location":"reference/pyastrobee/core/astrobee/#recompute_inertial_properties","text":"def recompute_inertial_properties ( self ) -> None Calculate the inertial properties based on the current state of the robot in sim This is more accurate than the fixed, base-only values from NASA's documentation, but it is fairly expensive to compute and should NOT be done on every simulation step. This will update the mass, inertia, inv_inertia, and center of mass View Source def recompute_inertial_properties(self) -> None: \"\"\"Calculate the inertial properties based on the current state of the robot in sim This is more accurate than the fixed, base-only values from NASA's documentation, but it is fairly expensive to compute and should NOT be done on every simulation step. This will update the mass, inertia, inv_inertia, and center of mass \"\"\" # Note: Mass will be fixed, but it is not necessarily the same value as provided by NASA mass = 0.0 inertia = np.zeros((3, 3)) com = np.zeros(3) T_B2W = self.tmat # Base to world for link in Astrobee.Links: link_info = pybullet.getDynamicsInfo(self.id, link.value) link_mass = link_info[0] link_inertia_diagonal = link_info[2] if link.value == -1: # Separate handling for base link inertia += np.diag(link_inertia_diagonal) com += link_mass * T_B2W[:3, 3] else: T_L2W = self.get_link_transform(link.value) # Link to world T_L2B = invert_transform_mat(T_B2W) @ T_L2W # Link to base inertia += inertial_transformation( link_mass, np.diag(link_inertia_diagonal), T_L2B ) com += link_mass * T_L2W[:3, 3] mass += link_mass com /= mass self._local_com_position = T_B2W[:3, :3].T @ (com - T_B2W[:3, 3]) self._mass = mass self._inertia = inertia self._inv_inertia = np.linalg.inv(inertia)","title":"recompute_inertial_properties"},{"location":"reference/pyastrobee/core/astrobee/#reset_full_state","text":"def reset_full_state ( self , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], omega : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], q : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], qdot : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) Fully resets the state of the Astrobee Parameters: Name Type Description Default pos npt.ArrayLike Position, shape (3,) None orn npt.ArrayLike Orientation (XYZW quaternion), shape (4,) None vel npt.ArrayLike Linear velocity, shape (3,) None omega npt.ArrayLike Angular velocity, shape (3,) None q npt.ArrayLike Joint positions, shape (NUM_JOINTS,) None qdot npt.ArrayLike Joint velocities, shape (NUM_JOINTS,) None View Source def reset_full_state ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , vel : npt . ArrayLike , omega : npt . ArrayLike , q : npt . ArrayLike , qdot : npt . ArrayLike , ) : \"\"\"Fully resets the state of the Astrobee Args: pos (npt.ArrayLike): Position, shape (3,) orn (npt.ArrayLike): Orientation (XYZW quaternion), shape (4,) vel (npt.ArrayLike): Linear velocity, shape (3,) omega (npt.ArrayLike): Angular velocity, shape (3,) q (npt.ArrayLike): Joint positions, shape (NUM_JOINTS,) qdot (npt.ArrayLike): Joint velocities, shape (NUM_JOINTS,) \"\"\" self . client . resetBasePositionAndOrientation ( self . id , pos , orn ) self . client . resetBaseVelocity ( self . id , vel , omega ) for i in range ( Astrobee . NUM_JOINTS ) : self . client . resetJointState ( self . id , i , q [ i ] , qdot [ i ] )","title":"reset_full_state"},{"location":"reference/pyastrobee/core/astrobee/#reset_to_base_pose","text":"def reset_to_base_pose ( self , pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> None Resets the base of the robot to a target pose Parameters: Name Type Description Default pose npt.ArrayLike Desired position + XYZW quaternion pose of the Astrobee's base, shape (7,) None View Source def reset_to_base_pose ( self , pose : npt . ArrayLike ) -> None : \"\"\"Resets the base of the robot to a target pose Args: pose (npt.ArrayLike): Desired position + XYZW quaternion pose of the Astrobee' s base , shape ( 7 ,) \"\"\" self.client.resetBasePositionAndOrientation(self.id, pose[:3], pose[3:])","title":"reset_to_base_pose"},{"location":"reference/pyastrobee/core/astrobee/#reset_to_ee_pose","text":"def reset_to_ee_pose ( self , pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> None Resets the position of the robot to achieve a target end-effector pose This will currently NOT adjust any of the joints in a \"smart\" way, it will just reset the position of the base given the current joint configuration Parameters: Name Type Description Default pose npt.ArrayLike Desired position + XYZW quaternion end-effector pose, shape (7,) None View Source def reset_to_ee_pose ( self , pose : npt . ArrayLike ) -> None : \"\"\"Resets the position of the robot to achieve a target end-effector pose This will currently NOT adjust any of the joints in a \" smart \" way, it will just reset the position of the base given the current joint configuration Args: pose (npt.ArrayLike): Desired position + XYZW quaternion end-effector pose, shape (7,) \"\"\" # Notation : EE : End effector , B : Base , W : World des_EE2W = pos_quat_to_tmat ( pose ) cur_B2W = pos_quat_to_tmat ( self . pose ) cur_EE2W = pos_quat_to_tmat ( self . ee_pose ) cur_W2EE = invert_transform_mat ( cur_EE2W ) cur_B2EE = cur_W2EE @ cur_B2W des_B2W = des_EE2W @ cur_B2EE self . reset_to_base_pose ( tmat_to_pos_quat ( des_B2W ))","title":"reset_to_ee_pose"},{"location":"reference/pyastrobee/core/astrobee/#set_arm_joints","text":"def set_arm_joints ( self , angles : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], force : bool = False , wait : bool = False ) -> None Sets the joint angles for the arm (proximal + distal) Parameters: Name Type Description Default angles npt.ArrayLike Arm joint angles, length = 2 None force bool Whether to (non-physically) instantly reset the joint states. Should only be used at initialization. Defaults to False None wait bool Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False None View Source def set_arm_joints ( self , angles : npt . ArrayLike , force : bool = False , wait : bool = False ) -> None : \"\"\"Sets the joint angles for the arm (proximal + distal) Args: angles (npt.ArrayLike): Arm joint angles, length = 2 force (bool, optional): Whether to (non-physically) instantly reset the joint states. Should only be used at initialization. Defaults to False wait (bool, optional): Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False \"\"\" self . set_joint_angles ( angles , Astrobee . ARM_JOINT_IDXS , force , wait )","title":"set_arm_joints"},{"location":"reference/pyastrobee/core/astrobee/#set_gripper_joints","text":"def set_gripper_joints ( self , angles : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], force : bool = False , wait : bool = False ) -> None Sets the joint angles for the gripper (left + right, proximal + distal) Parameters: Name Type Description Default angles npt.ArrayLike Gripper joint angles, length = 4 None force bool Whether to (non-physically) instantly reset the gripper joints. Should only be used at initialization. Defaults to False None wait bool Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False None View Source def set_gripper_joints ( self , angles : npt . ArrayLike , force : bool = False , wait : bool = False ) -> None : \"\"\"Sets the joint angles for the gripper (left + right, proximal + distal) Args: angles (npt.ArrayLike): Gripper joint angles, length = 4 force (bool, optional): Whether to (non-physically) instantly reset the gripper joints. Should only be used at initialization. Defaults to False wait (bool, optional): Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False \"\"\" self . set_joint_angles ( angles , Astrobee . GRIPPER_JOINT_IDXS , force , wait )","title":"set_gripper_joints"},{"location":"reference/pyastrobee/core/astrobee/#set_gripper_position","text":"def set_gripper_position ( self , position : float , force : bool = False , wait : bool = False ) -> None Sets the gripper to a position between 0 (fully closed) to 100 (fully open) Parameters: Name Type Description Default position float Gripper position, in range [0, 100] None force bool Whether to (non-physically) instantly reset the gripper position, instead of stepping the sim. Should only be used at initialization. Defaults to False None wait bool Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False None View Source def set_gripper_position( self, position: float, force: bool = False, wait: bool = False ) -> None: \"\"\"Sets the gripper to a position between 0 (fully closed) to 100 (fully open) Args: position (float): Gripper position, in range [0, 100] force (bool, optional): Whether to (non-physically) instantly reset the gripper position, instead of stepping the sim. Should only be used at initialization. Defaults to False wait (bool, optional): Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False \"\"\" if position < 0 or position > 100: raise ValueError(\"Position should be in range [0, 100]\") l_closed, l_open, r_closed, r_open = self._get_gripper_joint_ranges() left_pos = l_closed + (position / 100) * (l_open - l_closed) right_pos = r_closed + (position / 100) * (r_open - r_closed) angle_cmd = [*left_pos, *right_pos] self.set_gripper_joints(angle_cmd, force, wait)","title":"set_gripper_position"},{"location":"reference/pyastrobee/core/astrobee/#set_joint_angles","text":"def set_joint_angles ( self , angles : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], indices : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , force : bool = False , wait : bool = False ) Sets the joint angles for the Astrobee (either all joints, or a specified subset) Parameters: Name Type Description Default angles npt.ArrayLike Desired joint angles, in radians None indices npt.ArrayLike Indices of the joints to control. Defaults to None, in which case we assume all 7 joints will be set. None force bool Whether to (non-physically) instantly reset the joint state. Should only be used at initialization. Defaults to False None wait bool Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False None Raises: Type Description ValueError If the number of angles provided do not match the number of indices ValueError If the angles are out of the joint limits for the specified indices View Source def set_joint_angles ( self , angles : npt . ArrayLike , indices : Optional [ npt.ArrayLike ] = None , force : bool = False , wait : bool = False , ) : \"\"\"Sets the joint angles for the Astrobee (either all joints, or a specified subset) Args: angles (npt.ArrayLike): Desired joint angles, in radians indices (npt.ArrayLike, optional): Indices of the joints to control. Defaults to None, in which case we assume all 7 joints will be set. force (bool, optional): Whether to (non-physically) instantly reset the joint state. Should only be used at initialization. Defaults to False wait (bool, optional): Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False Raises: ValueError: If the number of angles provided do not match the number of indices ValueError: If the angles are out of the joint limits for the specified indices \"\"\" if indices is None : indices = list ( range ( Astrobee . NUM_JOINTS )) angles = np . atleast_1d ( angles ) # If scalar , ensure we don ' t have a 0 - D array indices = np . atleast_1d ( indices ) if indices . shape != angles . shape : raise ValueError ( \"Number of angles must match with the number of provided indices\" ) if np . any ( angles < Astrobee . JOINT_POS_LIMITS [ indices, 0 ] ) or np . any ( angles > Astrobee . JOINT_POS_LIMITS [ indices, 1 ] ) : raise ValueError ( f \"Joint angle command is outside of joint limits.\\nGot: {angles} for joints {indices}\" ) if force : for ind , angle in zip ( indices , angles ) : self . client . resetJointState ( self . id , ind , angle ) # Set the position control for the arm so Pybullet will correct for disturbances self . client . setJointMotorControlArray ( self . id , indices , self . client . POSITION_CONTROL , angles , forces = self . JOINT_EFFORT_LIMITS [ indices ] , ) # Step the sim until the arm is at the desired angle , if waiting for it to reach the position if wait : tol = 0.01 # TODO TOTALLY ARBITRARY FOR NOW while np . any ( np . abs ( self . get_joint_angles ( indices ) - angles ) > tol ) : self . client . stepSimulation ()","title":"set_joint_angles"},{"location":"reference/pyastrobee/core/astrobee/#store_arm","text":"def store_arm ( self , force : bool = False , wait : bool = False ) Folds the Astrobee's arm into its body Note: Storing the arm reduces the products of inertia, so this is the preferable configuration if not manipulating any objects Parameters: Name Type Description Default force bool Whether to (non-physically) instantly reset the joints. Should only be used at initialization. Defaults to False None wait bool Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False None View Source def store_arm(self, force: bool = False, wait: bool = False): \"\"\"Folds the Astrobee's arm into its body Note: Storing the arm reduces the products of inertia, so this is the preferable configuration if not manipulating any objects Args: force (bool, optional): Whether to (non-physically) instantly reset the joints. Should only be used at initialization. Defaults to False wait (bool, optional): Whether to wait until the arm reaches the desired state by stepping the sim forwards in a blocking manner. Defaults to False \"\"\" self.set_arm_joints([Astrobee.JOINT_POS_LIMITS[1, 1], 0], force, wait) self.set_gripper_position(0, force, wait)","title":"store_arm"},{"location":"reference/pyastrobee/core/astrobee/#unload","text":"def unload ( self ) -> None Remove the Astrobee from the simulation View Source def unload ( self ) -> None : \"\"\"Remove the Astrobee from the simulation\"\"\" self . client . removeBody ( self . id )","title":"unload"},{"location":"reference/pyastrobee/core/composite_bag/","text":"Module pyastrobee.core.composite_bag Modeling a deformable cargo bag as an interconnected series of smaller rigid bodies via constraints Documentation for inherited methods can be found in the base class View Source \"\"\"Modeling a deformable cargo bag as an interconnected series of smaller rigid bodies via constraints Documentation for inherited methods can be found in the base class \"\"\" import time from typing import Optional from collections import defaultdict import numpy as np import numpy.typing as npt import pybullet from pybullet_utils.bullet_client import BulletClient from pyastrobee.core.abstract_bag import CargoBag from pyastrobee.core.astrobee import Astrobee from pyastrobee.utils.bullet_utils import create_box from pyastrobee.utils.transformations import make_transform_mat , transform_point from pyastrobee.utils.rotations import quat_to_rmat from pyastrobee.core.constraint_bag import ( form_constraint_grasp , UNIT_CONSTRAINT_STRUCTURES , ) class CompositeCargoBag ( CargoBag ): \"\"\"Class for loading and managing properties associated with the composite cargo bags Args: bag_name (str): Type of cargo bag to load. Single handle: \"front_handle\", \"right_handle\", \"top_handle\". Dual handle: \"front_back_handle\", \"right_left_handle\", \"top_bottom_handle\" mass (float): Mass of the cargo bag, in kg pos (npt.ArrayLike): Initial XYZ position to load the bag. Defaults to (0, 0, 0) orn (npt.ArrayLike): Initial XYZW quaternion to load the bag. Defaults to (0, 0, 0, 1) divisions (tuple[int, int, int]): Number of smaller sub-blocks along each dimension (length, width, height) of the bag's main compartment. Must be three positive odd integers. client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" def __init__ ( self , bag_name : str , mass : float , pos : npt . ArrayLike = ( 0 , 0 , 0 ), orn : npt . ArrayLike = ( 0 , 0 , 0 , 1 ), divisions : tuple [ int , int , int ] = ( 3 , 3 , 3 ), client : Optional [ BulletClient ] = None , ): if ( len ( divisions ) != 3 or any ( d <= 0 for d in divisions ) or any ( d % 2 != 1 for d in divisions ) or any ( not isinstance ( d , int ) for d in divisions ) ): raise ValueError ( f \"Invalid divisions: These must be three positive odd integers. \\n Got: { divisions } \" ) self . divisions = divisions self . handle_block_force_scale = 5 self . block_force_scale = 0.5 super () . __init__ ( bag_name , mass , pos , orn , client ) self . _handle_constraints = {} @property def corner_positions ( self ) -> list [ np . ndarray ]: # TODO: currently, this assumes that there is no deformation going on # Should we do something smarter by looking at the corners of each of the corner boxes? return super () . corner_positions def unload ( self ) -> None : self . detach () for block_id in self . block_ids : self . client . removeBody ( block_id ) self . block_ids = None self . handle_block_ids = None self . center_block_id = None self . corner_block_ids = None self . ijk_to_id = None self . id = None def _attach ( self , robot : Astrobee , handle_index : int ) -> None : # We'll use the same handle modeling as with the constraint bag # BUT we'll attach to the handle block rather than the center point of the bag, # so we need to update the grasp transformation handle_id = self . handle_block_ids [ handle_index ] handle_ijk = self . id_to_ijk [ handle_id ] original_grasp_transform = self . grasp_transforms [ handle_index ] orig_rmat = original_grasp_transform [: 3 , : 3 ] pos = self . _center_aligned_block_structure ()[ handle_ijk ] adjusted_grasp_transform = make_transform_mat ( orig_rmat , pos ) structure_scaling = 0.05 structure_type = \"tetrahedron\" self . constraint_structure = ( UNIT_CONSTRAINT_STRUCTURES [ structure_type ] * structure_scaling ) primary_constraint_force = 3 secondary_constraint_force = 2 max_forces = np . concatenate ( [ [ primary_constraint_force ], secondary_constraint_force * np . ones ( len ( self . constraint_structure ) - 1 ), ] ) constraints = form_constraint_grasp ( robot , handle_id , adjusted_grasp_transform , structure_type , structure_scaling , max_forces , client = self . client , ) self . _handle_constraints . update ({ robot . id : constraints }) self . _attached . append ( robot . id ) def detach ( self ) -> None : # return super().detach() for robot_id , cids in self . _handle_constraints . items (): for cid in cids : self . client . removeConstraint ( cid ) self . _attached = [] self . _handle_constraints = {} def detach_robot ( self , robot_id : int ) -> None : if robot_id not in self . _handle_constraints : raise ValueError ( \"Cannot detach robot: ID unknown\" ) for cid in self . _handle_constraints [ robot_id ]: self . client . removeConstraint ( cid ) self . _attached . remove ( robot_id ) self . _handle_constraints . pop ( robot_id ) def reset_dynamics ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , lin_vel : npt . ArrayLike , ang_vel : npt . ArrayLike , ) -> None : block_positions = self . get_init_block_positions ( pos , orn ) for block_ijk , block_id in self . ijk_to_id . items (): self . client . resetBasePositionAndOrientation ( block_id , block_positions [ block_ijk ], orn ) r = block_positions [ block_ijk ] - pos self . client . resetBaseVelocity ( block_id , lin_vel + np . cross ( ang_vel , r ), ang_vel , ) def get_init_block_positions ( self , pos : npt . ArrayLike , orn : npt . ArrayLike ) -> dict [ tuple [ int , int , int ], np . ndarray ]: \"\"\"Gives the initial positions of the centers of the blocks in world frame Args: pos (npt.ArrayLike): Position to load the center of the bag orn (npt.ArrayLike): Orientation to load the bag (XYZW quaternion) Returns: dict[tuple[int, int, int], np.ndarray]: Map from block (i, j, k) index to its world frame position \"\"\" # Deformation free rmat = quat_to_rmat ( orn ) center_tmat = make_transform_mat ( rmat , pos ) positions = self . _center_aligned_block_structure () for block_ijk in positions : positions [ block_ijk ] = transform_point ( center_tmat , positions [ block_ijk ]) return positions def _corner_aligned_block_structure ( self ) -> dict [ tuple [ int , int , int ], np . ndarray ]: \"\"\"Gives the initial positions of the centers of the blocks w.r.t the bottom corner of the box in local frame Returns: dict[tuple[int, int, int], np.ndarray]: Map from block (i, j, k) index to its local frame position \"\"\" nx , ny , nz = self . divisions l = self . LENGTH / nx w = self . WIDTH / ny h = self . HEIGHT / nz positions = {} for i in range ( nx ): for j in range ( ny ): for k in range ( nz ): positions [( i , j , k )] = np . array ( [( 2 * i + 1 ) * l / 2 , ( 2 * j + 1 ) * w / 2 , ( 2 * k + 1 ) * h / 2 ] ) return positions def _center_aligned_block_structure ( self ) -> dict [ tuple [ int , int , int ], np . ndarray ]: \"\"\"Gives the initial positions of the centers of the blocks w.r.t the center of the box in local frame Returns: dict[tuple[int, int, int], np.ndarray]: Map from block (i, j, k) index to its local frame position \"\"\" # Simple translation, no rotation required positions = self . _corner_aligned_block_structure () corner_to_center = np . array ([ self . LENGTH / 2 , self . WIDTH / 2 , self . HEIGHT / 2 ]) for block_ijk in positions : positions [ block_ijk ] -= corner_to_center return positions def _load ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , ) -> int : # Number of blocks in each dimension nx , ny , nz = self . divisions num_blocks = nx * ny * nz # Dimension of the blocks along each axis l = self . LENGTH / nx w = self . WIDTH / ny h = self . HEIGHT / nz # Mass of each individual block m = self . mass / num_blocks # Create the blocks self . block_ids = [] self . handle_block_ids = [] self . corner_block_ids = [] self . center_block_id = None self . ijk_to_id = {} self . id_to_ijk = {} if self . name == \"top_handle\" : handle_ijks = [( nx // 2 , ny // 2 , nz - 1 )] elif self . name == \"front_handle\" : handle_ijks = [( nx // 2 , 0 , nz // 2 )] elif self . name == \"right_handle\" : handle_ijks = [( nx - 1 , ny // 2 , nz // 2 )] elif self . name == \"top_bottom_handle\" : handle_ijks = [( nx // 2 , ny // 2 , nz - 1 ), ( nx // 2 , ny // 2 , 0 )] elif self . name == \"front_back_handle\" : handle_ijks = [( nx // 2 , 0 , nz // 2 ), ( nx // 2 , ny - 1 , nz // 2 )] elif self . name == \"right_left_handle\" : handle_ijks = [( nx - 1 , ny // 2 , nz // 2 ), ( 0 , ny // 2 , nz // 2 )] center_block_ijk = ( nx // 2 , ny // 2 , nz // 2 ) block_to_center = {} block_positions = self . get_init_block_positions ( pos , orn ) for i in range ( nx ): for j in range ( ny ): for k in range ( nz ): is_handle_block = ( i , j , k ) in handle_ijks is_corner_block = ( ( i in { 0 , nx - 1 }) and ( j in { 0 , ny - 1 }) and ( k in { 0 , nz - 1 }) ) is_center_block = ( i , j , k ) == center_block_ijk if is_handle_block : rgba = ( 1 , 0 , 0 , 1 ) elif is_corner_block : rgba = ( 0 , 1 , 0 , 1 ) elif is_center_block : rgba = ( 0 , 0 , 1 , 1 ) else : rgba = ( 1 , 1 , 1 , 1 ) local_pos = np . array ( [( 2 * i + 1 ) * l / 2 , ( 2 * j + 1 ) * w / 2 , ( 2 * k + 1 ) * h / 2 ] ) block_id = create_box ( block_positions [( i , j , k )], orn , m , ( l , w , h ), True , rgba , ) self . ijk_to_id [( i , j , k )] = block_id self . id_to_ijk [ block_id ] = ( i , j , k ) self . block_ids . append ( block_id ) block_to_center [ block_id ] = ( np . array ([ self . LENGTH / 2 , self . WIDTH / 2 , self . HEIGHT / 2 ]) - local_pos ) if is_handle_block : self . handle_block_ids . append ( block_id ) if is_corner_block : self . corner_block_ids . append ( block_id ) if is_center_block : self . center_block_id = block_id # Form constraints between the blocks # We constrain each block to the central block, with the handle blocks having a larger force cids = [] center_block_id = self . ijk_to_id [ center_block_ijk ] for i in range ( nx ): for j in range ( ny ): for k in range ( nz ): is_handle_block = ( i , j , k ) in handle_ijks is_center_block = ( i , j , k ) == center_block_ijk if not is_center_block : cid = self . client . createConstraint ( center_block_id , - 1 , self . ijk_to_id [( i , j , k )], - 1 , self . client . JOINT_FIXED , ( 0 , 0 , 1 ), ( 0 , 0 , 0 ), # Center block origin block_to_center [ self . ijk_to_id [( i , j , k )]], ( 0 , 0 , 0 , 1 ), ( 0 , 0 , 0 , 1 ), ) cids . append ( cid ) # TODO TUNE THESE FORCES constraint_force = self . mass * ( self . handle_block_force_scale if is_handle_block else self . block_force_scale ) self . client . changeConstraint ( cid , maxForce = constraint_force ) # Disable internal collisions between adjacent blocks # Define neighbors via a kind of voxel grid (like a Rubiks cube without the central block) neighbors = defaultdict ( list ) for i in range ( nx ): for j in range ( ny ): for k in range ( nz ): # Find the 26 neighboring voxel coordinates for delta_i in [ - 1 , 0 , 1 ]: for delta_j in [ - 1 , 0 , 1 ]: for delta_k in [ - 1 , 0 , 1 ]: if delta_i == 0 and delta_j == 0 and delta_k == 0 : pass # Skip the center point else : # Add the neighbor if it is within the bounds of the box ni = i + delta_i nj = j + delta_j nk = k + delta_k if 0 <= ni < nx and 0 <= nj < ny and 0 <= nk < nz : neighbors [( i , j , k )] . append (( ni , nj , nk )) # Get all unique pairs between neighboring blocks pairs = set () for ijk , neighbor_ijks in neighbors . items (): for nijk in neighbor_ijks : # Ensure no duplicate pairs in the reverse order if ( nijk , ijk ) not in pairs : pairs . add (( ijk , nijk )) for pair in pairs : # Disable collision pybullet . setCollisionFilterPair ( self . ijk_to_id [ pair [ 0 ]], self . ijk_to_id [ pair [ 1 ]], - 1 , - 1 , 0 ) # Correct the handle block ID order # We build the blocks in order of increasing xyz position, but the way we've ordered the handles in the # two-handle bags are top->bottom, front->back, right->left which don't necessarily adhere to this order if self . num_handles == 2 : # Reverse the order for the bags where the first handle is not at the minimum of the relevant dimension # Note: the front/back handle bag adheres to the correct order since the front handle is at min y if self . name in { \"top_bottom_handle\" , \"right_left_handle\" }: self . handle_block_ids = self . handle_block_ids [:: - 1 ] # We need an ID to assign to the object # In general, the center block makes the most sense because we can query this for dynamics info of the bag return self . center_block_id @property def bounding_box ( self ) -> np . ndarray : # TODO see if there is a simpler way to handle this # We can't use the standard method because it would just give the AABB of the center block lower = np . inf * np . ones ( 3 ) upper = - np . inf * np . ones ( 3 ) for block_id in self . corner_block_ids : aabb = self . client . getAABB ( block_id , - 1 ) lower = np . minimum ( lower , aabb [ 0 ]) upper = np . maximum ( upper , aabb [ 1 ]) # TODO convert to Box instance? return np . array ([ lower , upper ]) def get_local_constraint_pos ( self , handle_index : int ) -> np . ndarray : \"\"\"Determine the position of the handle's constraints in the bag frame Args: handle_index (int): Index of the handle of interest Returns: np.ndarray: Constraint positions, shape (n_constraints, 3) \"\"\" return np . array ( [ transform_point ( self . grasp_transforms [ handle_index ], pt ) for pt in self . constraint_structure ] ) def get_world_constraint_pos ( self , handle_index : int ) -> np . ndarray : \"\"\"Determine the position of the handle's constraints in the world frame Args: handle_index (int): Index of the handle of interest Returns: np.ndarray: Constraint positions, shape (n_constraints, 3) \"\"\" tmat = self . tmat local_constraint_pos = self . get_local_constraint_pos ( handle_index ) return np . array ([ transform_point ( tmat , pos ) for pos in local_constraint_pos ]) def _main (): # pylint: disable=import-outside-toplevel from pyastrobee.utils.bullet_utils import load_floor name = \"top_handle\" pos = ( 0 , 0 , 1 ) orn = ( 0 , 0 , 0 , 1 ) mass = 5 divisions = ( 3 , 3 , 3 ) pybullet . connect ( pybullet . GUI ) # pybullet.setGravity(0, 0, -9.81) load_floor () robot = Astrobee () # robot2 = Astrobee() bag = CompositeCargoBag ( name , mass , pos , orn , divisions ) # bag.attach_to([robot, robot2]) bag . attach_to ( robot ) while True : pybullet . stepSimulation () time . sleep ( 1 / 120 ) if __name__ == \"__main__\" : _main () Variables UNIT_CONSTRAINT_STRUCTURES Classes CompositeCargoBag class CompositeCargoBag ( bag_name : str , mass : float , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 0 , 0 , 0 ), orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 0 , 0 , 0 , 1 ), divisions : tuple [ int , int , int ] = ( 3 , 3 , 3 ), client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) Class for loading and managing properties associated with the composite cargo bags Attributes Name Type Description Default bag_name str Type of cargo bag to load. Single handle: \"front_handle\", \"right_handle\", \"top_handle\". Dual handle: \"front_back_handle\", \"right_left_handle\", \"top_bottom_handle\" None mass float Mass of the cargo bag, in kg None pos npt.ArrayLike Initial XYZ position to load the bag. Defaults to (0, 0, 0) None orn npt.ArrayLike Initial XYZW quaternion to load the bag. Defaults to (0, 0, 0, 1) None divisions tuple[int, int, int] Number of smaller sub-blocks along each dimension (length, width, height) of the bag's main compartment. Must be three positive odd integers. None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None View Source class CompositeCargoBag ( CargoBag ): \"\"\"Class for loading and managing properties associated with the composite cargo bags Args: bag_name (str): Type of cargo bag to load. Single handle: \"front_handle\", \"right_handle\", \"top_handle\". Dual handle: \"front_back_handle\", \"right_left_handle\", \"top_bottom_handle\" mass (float): Mass of the cargo bag, in kg pos (npt.ArrayLike): Initial XYZ position to load the bag. Defaults to (0, 0, 0) orn (npt.ArrayLike): Initial XYZW quaternion to load the bag. Defaults to (0, 0, 0, 1) divisions (tuple[int, int, int]): Number of smaller sub-blocks along each dimension (length, width, height) of the bag's main compartment. Must be three positive odd integers. client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" def __init__ ( self , bag_name : str , mass : float , pos : npt . ArrayLike = ( 0 , 0 , 0 ), orn : npt . ArrayLike = ( 0 , 0 , 0 , 1 ), divisions : tuple [ int , int , int ] = ( 3 , 3 , 3 ), client : Optional [ BulletClient ] = None , ): if ( len ( divisions ) != 3 or any ( d <= 0 for d in divisions ) or any ( d % 2 != 1 for d in divisions ) or any ( not isinstance ( d , int ) for d in divisions ) ): raise ValueError ( f \"Invalid divisions: These must be three positive odd integers. \\n Got: {divisions}\" ) self . divisions = divisions self . handle_block_force_scale = 5 self . block_force_scale = 0.5 super () . __init__ ( bag_name , mass , pos , orn , client ) self . _handle_constraints = {} @ property def corner_positions ( self ) -> list [ np . ndarray ]: # TODO: currently, this assumes that there is no deformation going on # Should we do something smarter by looking at the corners of each of the corner boxes? return super () . corner_positions def unload ( self ) -> None : self . detach () for block_id in self . block_ids : self . client . removeBody ( block_id ) self . block_ids = None self . handle_block_ids = None self . center_block_id = None self . corner_block_ids = None self . ijk_to_id = None self . id = None def _attach ( self , robot : Astrobee , handle_index : int ) -> None : # We'll use the same handle modeling as with the constraint bag # BUT we'll attach to the handle block rather than the center point of the bag, # so we need to update the grasp transformation handle_id = self . handle_block_ids [ handle_index ] handle_ijk = self . id_to_ijk [ handle_id ] original_grasp_transform = self . grasp_transforms [ handle_index ] orig_rmat = original_grasp_transform [: 3 , : 3 ] pos = self . _center_aligned_block_structure ()[ handle_ijk ] adjusted_grasp_transform = make_transform_mat ( orig_rmat , pos ) structure_scaling = 0.05 structure_type = \"tetrahedron\" self . constraint_structure = ( UNIT_CONSTRAINT_STRUCTURES [ structure_type ] * structure_scaling ) primary_constraint_force = 3 secondary_constraint_force = 2 max_forces = np . concatenate ( [ [ primary_constraint_force ], secondary_constraint_force * np . ones ( len ( self . constraint_structure ) - 1 ), ] ) constraints = form_constraint_grasp ( robot , handle_id , adjusted_grasp_transform , structure_type , structure_scaling , max_forces , client = self . client , ) self . _handle_constraints . update ({ robot . id : constraints }) self . _attached . append ( robot . id ) def detach ( self ) -> None : # return super().detach() for robot_id , cids in self . _handle_constraints . items (): for cid in cids : self . client . removeConstraint ( cid ) self . _attached = [] self . _handle_constraints = {} def detach_robot ( self , robot_id : int ) -> None : if robot_id not in self . _handle_constraints : raise ValueError ( \"Cannot detach robot: ID unknown\" ) for cid in self . _handle_constraints [ robot_id ]: self . client . removeConstraint ( cid ) self . _attached . remove ( robot_id ) self . _handle_constraints . pop ( robot_id ) def reset_dynamics ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , lin_vel : npt . ArrayLike , ang_vel : npt . ArrayLike , ) -> None : block_positions = self . get_init_block_positions ( pos , orn ) for block_ijk , block_id in self . ijk_to_id . items (): self . client . resetBasePositionAndOrientation ( block_id , block_positions [ block_ijk ], orn ) r = block_positions [ block_ijk ] - pos self . client . resetBaseVelocity ( block_id , lin_vel + np . cross ( ang_vel , r ), ang_vel , ) def get_init_block_positions ( self , pos : npt . ArrayLike , orn : npt . ArrayLike ) -> dict [ tuple [ int , int , int ], np . ndarray ]: \"\"\"Gives the initial positions of the centers of the blocks in world frame Args: pos (npt.ArrayLike): Position to load the center of the bag orn (npt.ArrayLike): Orientation to load the bag (XYZW quaternion) Returns: dict[tuple[int, int, int], np.ndarray]: Map from block (i, j, k) index to its world frame position \"\"\" # Deformation free rmat = quat_to_rmat ( orn ) center_tmat = make_transform_mat ( rmat , pos ) positions = self . _center_aligned_block_structure () for block_ijk in positions : positions [ block_ijk ] = transform_point ( center_tmat , positions [ block_ijk ]) return positions def _corner_aligned_block_structure ( self ) -> dict [ tuple [ int , int , int ], np . ndarray ]: \"\"\"Gives the initial positions of the centers of the blocks w.r.t the bottom corner of the box in local frame Returns: dict[tuple[int, int, int], np.ndarray]: Map from block (i, j, k) index to its local frame position \"\"\" nx , ny , nz = self . divisions l = self . LENGTH / nx w = self . WIDTH / ny h = self . HEIGHT / nz positions = {} for i in range ( nx ): for j in range ( ny ): for k in range ( nz ): positions [( i , j , k )] = np . array ( [( 2 * i + 1 ) * l / 2 , ( 2 * j + 1 ) * w / 2 , ( 2 * k + 1 ) * h / 2 ] ) return positions def _center_aligned_block_structure ( self ) -> dict [ tuple [ int , int , int ], np . ndarray ]: \"\"\"Gives the initial positions of the centers of the blocks w.r.t the center of the box in local frame Returns: dict[tuple[int, int, int], np.ndarray]: Map from block (i, j, k) index to its local frame position \"\"\" # Simple translation, no rotation required positions = self . _corner_aligned_block_structure () corner_to_center = np . array ([ self . LENGTH / 2 , self . WIDTH / 2 , self . HEIGHT / 2 ]) for block_ijk in positions : positions [ block_ijk ] -= corner_to_center return positions def _load ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , ) -> int : # Number of blocks in each dimension nx , ny , nz = self . divisions num_blocks = nx * ny * nz # Dimension of the blocks along each axis l = self . LENGTH / nx w = self . WIDTH / ny h = self . HEIGHT / nz # Mass of each individual block m = self . mass / num_blocks # Create the blocks self . block_ids = [] self . handle_block_ids = [] self . corner_block_ids = [] self . center_block_id = None self . ijk_to_id = {} self . id_to_ijk = {} if self . name == \"top_handle\" : handle_ijks = [( nx // 2 , ny // 2 , nz - 1 )] elif self . name == \"front_handle\" : handle_ijks = [( nx // 2 , 0 , nz // 2 )] elif self . name == \"right_handle\" : handle_ijks = [( nx - 1 , ny // 2 , nz // 2 )] elif self . name == \"top_bottom_handle\" : handle_ijks = [( nx // 2 , ny // 2 , nz - 1 ), ( nx // 2 , ny // 2 , 0 )] elif self . name == \"front_back_handle\" : handle_ijks = [( nx // 2 , 0 , nz // 2 ), ( nx // 2 , ny - 1 , nz // 2 )] elif self . name == \"right_left_handle\" : handle_ijks = [( nx - 1 , ny // 2 , nz // 2 ), ( 0 , ny // 2 , nz // 2 )] center_block_ijk = ( nx // 2 , ny // 2 , nz // 2 ) block_to_center = {} block_positions = self . get_init_block_positions ( pos , orn ) for i in range ( nx ): for j in range ( ny ): for k in range ( nz ): is_handle_block = ( i , j , k ) in handle_ijks is_corner_block = ( ( i in { 0 , nx - 1 }) and ( j in { 0 , ny - 1 }) and ( k in { 0 , nz - 1 }) ) is_center_block = ( i , j , k ) == center_block_ijk if is_handle_block : rgba = ( 1 , 0 , 0 , 1 ) elif is_corner_block : rgba = ( 0 , 1 , 0 , 1 ) elif is_center_block : rgba = ( 0 , 0 , 1 , 1 ) else : rgba = ( 1 , 1 , 1 , 1 ) local_pos = np . array ( [( 2 * i + 1 ) * l / 2 , ( 2 * j + 1 ) * w / 2 , ( 2 * k + 1 ) * h / 2 ] ) block_id = create_box ( block_positions [( i , j , k )], orn , m , ( l , w , h ), True , rgba , ) self . ijk_to_id [( i , j , k )] = block_id self . id_to_ijk [ block_id ] = ( i , j , k ) self . block_ids . append ( block_id ) block_to_center [ block_id ] = ( np . array ([ self . LENGTH / 2 , self . WIDTH / 2 , self . HEIGHT / 2 ]) - local_pos ) if is_handle_block : self . handle_block_ids . append ( block_id ) if is_corner_block : self . corner_block_ids . append ( block_id ) if is_center_block : self . center_block_id = block_id # Form constraints between the blocks # We constrain each block to the central block, with the handle blocks having a larger force cids = [] center_block_id = self . ijk_to_id [ center_block_ijk ] for i in range ( nx ): for j in range ( ny ): for k in range ( nz ): is_handle_block = ( i , j , k ) in handle_ijks is_center_block = ( i , j , k ) == center_block_ijk if not is_center_block : cid = self . client . createConstraint ( center_block_id , - 1 , self . ijk_to_id [( i , j , k )], - 1 , self . client . JOINT_FIXED , ( 0 , 0 , 1 ), ( 0 , 0 , 0 ), # Center block origin block_to_center [ self . ijk_to_id [( i , j , k )]], ( 0 , 0 , 0 , 1 ), ( 0 , 0 , 0 , 1 ), ) cids . append ( cid ) # TODO TUNE THESE FORCES constraint_force = self . mass * ( self . handle_block_force_scale if is_handle_block else self . block_force_scale ) self . client . changeConstraint ( cid , maxForce = constraint_force ) # Disable internal collisions between adjacent blocks # Define neighbors via a kind of voxel grid (like a Rubiks cube without the central block) neighbors = defaultdict ( list ) for i in range ( nx ): for j in range ( ny ): for k in range ( nz ): # Find the 26 neighboring voxel coordinates for delta_i in [ - 1 , 0 , 1 ]: for delta_j in [ - 1 , 0 , 1 ]: for delta_k in [ - 1 , 0 , 1 ]: if delta_i == 0 and delta_j == 0 and delta_k == 0 : pass # Skip the center point else : # Add the neighbor if it is within the bounds of the box ni = i + delta_i nj = j + delta_j nk = k + delta_k if 0 <= ni < nx and 0 <= nj < ny and 0 <= nk < nz : neighbors [( i , j , k )] . append (( ni , nj , nk )) # Get all unique pairs between neighboring blocks pairs = set () for ijk , neighbor_ijks in neighbors . items (): for nijk in neighbor_ijks : # Ensure no duplicate pairs in the reverse order if ( nijk , ijk ) not in pairs : pairs . add (( ijk , nijk )) for pair in pairs : # Disable collision pybullet . setCollisionFilterPair ( self . ijk_to_id [ pair [ 0 ]], self . ijk_to_id [ pair [ 1 ]], - 1 , - 1 , 0 ) # Correct the handle block ID order # We build the blocks in order of increasing xyz position, but the way we've ordered the handles in the # two-handle bags are top->bottom, front->back, right->left which don't necessarily adhere to this order if self . num_handles == 2 : # Reverse the order for the bags where the first handle is not at the minimum of the relevant dimension # Note: the front/back handle bag adheres to the correct order since the front handle is at min y if self . name in { \"top_bottom_handle\" , \"right_left_handle\" }: self . handle_block_ids = self . handle_block_ids [:: - 1 ] # We need an ID to assign to the object # In general, the center block makes the most sense because we can query this for dynamics info of the bag return self . center_block_id @ property def bounding_box ( self ) -> np . ndarray : # TODO see if there is a simpler way to handle this # We can't use the standard method because it would just give the AABB of the center block lower = np . inf * np . ones ( 3 ) upper = - np . inf * np . ones ( 3 ) for block_id in self . corner_block_ids : aabb = self . client . getAABB ( block_id , - 1 ) lower = np . minimum ( lower , aabb [ 0 ]) upper = np . maximum ( upper , aabb [ 1 ]) # TODO convert to Box instance? return np . array ([ lower , upper ]) def get_local_constraint_pos ( self , handle_index : int ) -> np . ndarray : \"\"\"Determine the position of the handle's constraints in the bag frame Args: handle_index (int): Index of the handle of interest Returns: np.ndarray: Constraint positions, shape (n_constraints, 3) \"\"\" return np . array ( [ transform_point ( self . grasp_transforms [ handle_index ], pt ) for pt in self . constraint_structure ] ) def get_world_constraint_pos ( self , handle_index : int ) -> np . ndarray : \"\"\"Determine the position of the handle's constraints in the world frame Args: handle_index (int): Index of the handle of interest Returns: np.ndarray: Constraint positions, shape (n_constraints, 3) \"\"\" tmat = self . tmat local_constraint_pos = self . get_local_constraint_pos ( handle_index ) return np . array ([ transform_point ( tmat , pos ) for pos in local_constraint_pos ]) Ancestors (in MRO) pyastrobee.core.abstract_bag.CargoBag abc.ABC Class variables BAG_NAMES DUAL_HANDLE_BAGS HANDLE_TRANSFORMS HEIGHT LENGTH MESH_DIR SINGLE_HANDLE_BAGS URDF_DIR WIDTH Instance variables angular_velocity Current [wx, wy, wz] angular velocity of the cargo bag's COM frame If both velocity and angular velocity are desired, use the dynamics_state property instead attached ID(s) of the robot (or robots) grasping the bag. Empty if no robots are attached bounding_box corner_positions dynamics_state Current state of the bag dynamics: Position, orientation, linear vel, and angular vel grasp_transforms Transformation matrices \"handle to bag\" representing the grasp locations on the handles to the bag COM In the case of a single-handled bag, this list will only have one entry mass Mass of the cargo bag name Type of cargo bag num_handles Number of handles on the cargo bag orientation Current XYZW quaternion orientation of the cargo bag's COM frame pose Current position + XYZW quaternion pose of the bag position Current XYZ position of the origin (COM frame) of the cargo bag tmat Current transformation matrix for the cargo bag: (Bag to world) velocity Current [vx, vy, vz] velocity of the cargo bag's COM frame If both velocity and angular velocity are desired, use the dynamics_state property instead Methods attach_to def attach_to ( self , robot_or_robots : Union [ pyastrobee . core . astrobee . Astrobee , list [ pyastrobee . core . astrobee . Astrobee ], tuple [ pyastrobee . core . astrobee . Astrobee ]], object_to_move : str = 'robot' ) -> None Attaches a robot (or multiple robots) to the handle(s) of the bag Parameters: Name Type Description Default robot_or_robots Union[Astrobee, list[Astrobee], tuple[Astrobee]] Robot(s) to attach to the bag None object_to_move str Either \"robot\" or \"bag\". This dictates what object will get its position reset in order to make the grasp connection. In general, it makes more sense to move the robot to the bag (default behavior) None Raises: Type Description ValueError For invalid inputs, or if the bag does not have enough handles for each robot NotImplementedError Multi-robot case with >2 robots View Source def attach_to ( self , robot_or_robots : Union [ Astrobee, list[Astrobee ] , tuple [ Astrobee ] ] , object_to_move : str = \"robot\" , ) -> None : \"\"\"Attaches a robot (or multiple robots) to the handle(s) of the bag Args: robot_or_robots (Union[Astrobee, list[Astrobee], tuple[Astrobee]]): Robot(s) to attach to the bag object_to_move (str, optional): Either \" robot \" or \" bag \". This dictates what object will get its position reset in order to make the grasp connection. In general, it makes more sense to move the robot to the bag (default behavior) Raises: ValueError: For invalid inputs, or if the bag does not have enough handles for each robot NotImplementedError: Multi-robot case with >2 robots \"\"\" # Handle inputs if isinstance ( robot_or_robots , Astrobee ) : # Single robot num_robots = 1 elif isinstance ( robot_or_robots , ( list , tuple )) : # Multi - robot if not all ( isinstance ( r , Astrobee ) for r in robot_or_robots ) : raise ValueError ( \"Non-Astrobee input detected\" ) num_robots = len ( robot_or_robots ) if self . num_handles < num_robots : raise ValueError ( f \"Bag does not have enough handles to support {num_robots} robots\" ) if num_robots == 1 : # Edge case : Unpack the list if only one robot robot_or_robots = robot_or_robots [ 0 ] else : raise ValueError ( \"Invalid input: Must provide either an Astrobee or a list of multiple Astrobees\" ) if object_to_move not in { \"robot\" , \"bag\" }: raise ValueError ( \"Invalid object to move: Must be either 'robot' or 'bag'.\" ) bag_to_world = pos_quat_to_tmat ( self . pose ) if num_robots == 1 : robot = robot_or_robots # Unpack list if object_to_move == \"robot\" : # Reset the position of the robot to interface with the handle handle_to_bag = self . grasp_transforms [ 0 ] handle_to_world = bag_to_world @ handle_to_bag handle_pose = tmat_to_pos_quat ( handle_to_world ) robot . reset_to_ee_pose ( handle_pose ) else : # Move the bag to the robot self . reset_to_handle_pose ( robot . ee_pose ) self . _attach ( robot , 0 ) elif num_robots == 2 : robot_1 , robot_2 = robot_or_robots # Unpack list if object_to_move == \"robot\" : # Reset the position of each robot to interface with the two handles handle_1_to_bag = self . grasp_transforms [ 0 ] handle_2_to_bag = self . grasp_transforms [ 1 ] handle_1_to_world = bag_to_world @ handle_1_to_bag handle_2_to_world = bag_to_world @ handle_2_to_bag robot_1 . reset_to_ee_pose ( tmat_to_pos_quat ( handle_1_to_world )) robot_2 . reset_to_ee_pose ( tmat_to_pos_quat ( handle_2_to_world )) self . _attach ( robot_1 , 0 ) self . _attach ( robot_2 , 1 ) else : # Move the bag while leaving the robots static raise NotImplementedError ( \"Attaching the bag to multiple robots requires moving at least 1 robot\" ) else : raise NotImplementedError ( \"The multi-robot case is only implemented for 2 Astrobees\" ) detach def detach ( self ) -> None Detach all connections to the bag View Source def detach ( self ) -> None : # return super().detach() for robot_id , cids in self . _handle_constraints . items (): for cid in cids : self . client . removeConstraint ( cid ) self . _attached = [] self . _handle_constraints = {} detach_robot def detach_robot ( self , robot_id : int ) -> None Detaches a specific robot from the bag Parameters: Name Type Description Default robot_id int Pybullet ID of the robot to detach None View Source def detach_robot ( self , robot_id : int ) -> None : if robot_id not in self . _handle_constraints : raise ValueError ( \"Cannot detach robot: ID unknown\" ) for cid in self . _handle_constraints [ robot_id ] : self . client . removeConstraint ( cid ) self . _attached . remove ( robot_id ) self . _handle_constraints . pop ( robot_id ) get_init_block_positions def get_init_block_positions ( self , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> dict [ tuple [ int , int , int ], numpy . ndarray ] Gives the initial positions of the centers of the blocks in world frame Parameters: Name Type Description Default pos npt.ArrayLike Position to load the center of the bag None orn npt.ArrayLike Orientation to load the bag (XYZW quaternion) None Returns: Type Description dict[tuple[int, int, int], np.ndarray] Map from block (i, j, k) index to its world frame position View Source def get_init_block_positions ( self , pos : npt . ArrayLike , orn : npt . ArrayLike ) -> dict [ tuple[int, int, int ] , np . ndarray ]: \"\"\"Gives the initial positions of the centers of the blocks in world frame Args: pos (npt.ArrayLike): Position to load the center of the bag orn (npt.ArrayLike): Orientation to load the bag (XYZW quaternion) Returns: dict[tuple[int, int, int], np.ndarray]: Map from block (i, j, k) index to its world frame position \"\"\" # Deformation free rmat = quat_to_rmat ( orn ) center_tmat = make_transform_mat ( rmat , pos ) positions = self . _center_aligned_block_structure () for block_ijk in positions : positions [ block_ijk ] = transform_point ( center_tmat , positions [ block_ijk ] ) return positions get_local_constraint_pos def get_local_constraint_pos ( self , handle_index : int ) -> numpy . ndarray Determine the position of the handle's constraints in the bag frame Parameters: Name Type Description Default handle_index int Index of the handle of interest None Returns: Type Description np.ndarray Constraint positions, shape (n_constraints, 3) View Source def get_local_constraint_pos ( self , handle_index : int ) -> np . ndarray : \"\"\"Determine the position of the handle's constraints in the bag frame Args: handle_index (int): Index of the handle of interest Returns: np.ndarray: Constraint positions, shape (n_constraints, 3) \"\"\" return np . array ( [ transform_point(self.grasp_transforms[handle_index ] , pt ) for pt in self . constraint_structure ] ) get_world_constraint_pos def get_world_constraint_pos ( self , handle_index : int ) -> numpy . ndarray Determine the position of the handle's constraints in the world frame Parameters: Name Type Description Default handle_index int Index of the handle of interest None Returns: Type Description np.ndarray Constraint positions, shape (n_constraints, 3) View Source def get_world_constraint_pos ( self , handle_index : int ) -> np . ndarray : \"\"\"Determine the position of the handle's constraints in the world frame Args: handle_index (int): Index of the handle of interest Returns: np.ndarray: Constraint positions, shape (n_constraints, 3) \"\"\" tmat = self . tmat local_constraint_pos = self . get_local_constraint_pos ( handle_index ) return np . array ([ transform_point ( tmat , pos ) for pos in local_constraint_pos ]) reset_dynamics def reset_dynamics ( self , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], lin_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], ang_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> None Resets the pose and velocities of the bag Parameters: Name Type Description Default pos npt.ArrayLike Position, shape (3,) None orn npt.ArrayLike XYZW quaternion orientation, shape (4,) None lin_vel npt.ArrayLike Linear velocity, shape (3,) None ang_vel npt.ArrayLike Angular velocity, shape (3,) None View Source def reset_dynamics ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , lin_vel : npt . ArrayLike , ang_vel : npt . ArrayLike , ) -> None : block_positions = self . get_init_block_positions ( pos , orn ) for block_ijk , block_id in self . ijk_to_id . items () : self . client . resetBasePositionAndOrientation ( block_id , block_positions [ block_ijk ] , orn ) r = block_positions [ block_ijk ] - pos self . client . resetBaseVelocity ( block_id , lin_vel + np . cross ( ang_vel , r ), ang_vel , ) reset_to_handle_pose def reset_to_handle_pose ( self , handle_pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], handle_index : int = 0 ) -> None Resets the position of the bag so that the handle is positioned at a desired pose Parameters: Name Type Description Default handle_pose npt.ArrayLike Desired pose of the handle (\"handle-to-world\"), shape (7,) None handle_index int Index of the handle to align to the desired pose. Defaults to 0. 0 View Source def reset_to_handle_pose ( self , handle_pose : npt . ArrayLike , handle_index : int = 0 ) -> None : \"\"\"Resets the position of the bag so that the handle is positioned at a desired pose Args: handle_pose (npt.ArrayLike): Desired pose of the handle (\" handle - to - world \"), shape (7,) handle_index (int, optional): Index of the handle to align to the desired pose. Defaults to 0. \"\"\" handle_to_world = pos_quat_to_tmat ( handle_pose ) bag_to_handle = invert_transform_mat ( self . grasp_transforms [ handle_index ] ) bag_to_world = handle_to_world @ bag_to_handle bag_pose = tmat_to_pos_quat ( bag_to_world ) # This assumes that we want the bag to be stationary self . reset_dynamics ( bag_pose [ :3 ] , bag_pose [ 3: ] , np . zeros ( 3 ), np . zeros ( 3 )) unload def unload ( self ) -> None Removes the cargo bag from the simulation View Source def unload ( self ) -> None : self . detach () for block_id in self . block_ids : self . client . removeBody ( block_id ) self . block_ids = None self . handle_block_ids = None self . center_block_id = None self . corner_block_ids = None self . ijk_to_id = None self . id = None","title":"Composite Bag"},{"location":"reference/pyastrobee/core/composite_bag/#module-pyastrobeecorecomposite_bag","text":"Modeling a deformable cargo bag as an interconnected series of smaller rigid bodies via constraints Documentation for inherited methods can be found in the base class View Source \"\"\"Modeling a deformable cargo bag as an interconnected series of smaller rigid bodies via constraints Documentation for inherited methods can be found in the base class \"\"\" import time from typing import Optional from collections import defaultdict import numpy as np import numpy.typing as npt import pybullet from pybullet_utils.bullet_client import BulletClient from pyastrobee.core.abstract_bag import CargoBag from pyastrobee.core.astrobee import Astrobee from pyastrobee.utils.bullet_utils import create_box from pyastrobee.utils.transformations import make_transform_mat , transform_point from pyastrobee.utils.rotations import quat_to_rmat from pyastrobee.core.constraint_bag import ( form_constraint_grasp , UNIT_CONSTRAINT_STRUCTURES , ) class CompositeCargoBag ( CargoBag ): \"\"\"Class for loading and managing properties associated with the composite cargo bags Args: bag_name (str): Type of cargo bag to load. Single handle: \"front_handle\", \"right_handle\", \"top_handle\". Dual handle: \"front_back_handle\", \"right_left_handle\", \"top_bottom_handle\" mass (float): Mass of the cargo bag, in kg pos (npt.ArrayLike): Initial XYZ position to load the bag. Defaults to (0, 0, 0) orn (npt.ArrayLike): Initial XYZW quaternion to load the bag. Defaults to (0, 0, 0, 1) divisions (tuple[int, int, int]): Number of smaller sub-blocks along each dimension (length, width, height) of the bag's main compartment. Must be three positive odd integers. client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" def __init__ ( self , bag_name : str , mass : float , pos : npt . ArrayLike = ( 0 , 0 , 0 ), orn : npt . ArrayLike = ( 0 , 0 , 0 , 1 ), divisions : tuple [ int , int , int ] = ( 3 , 3 , 3 ), client : Optional [ BulletClient ] = None , ): if ( len ( divisions ) != 3 or any ( d <= 0 for d in divisions ) or any ( d % 2 != 1 for d in divisions ) or any ( not isinstance ( d , int ) for d in divisions ) ): raise ValueError ( f \"Invalid divisions: These must be three positive odd integers. \\n Got: { divisions } \" ) self . divisions = divisions self . handle_block_force_scale = 5 self . block_force_scale = 0.5 super () . __init__ ( bag_name , mass , pos , orn , client ) self . _handle_constraints = {} @property def corner_positions ( self ) -> list [ np . ndarray ]: # TODO: currently, this assumes that there is no deformation going on # Should we do something smarter by looking at the corners of each of the corner boxes? return super () . corner_positions def unload ( self ) -> None : self . detach () for block_id in self . block_ids : self . client . removeBody ( block_id ) self . block_ids = None self . handle_block_ids = None self . center_block_id = None self . corner_block_ids = None self . ijk_to_id = None self . id = None def _attach ( self , robot : Astrobee , handle_index : int ) -> None : # We'll use the same handle modeling as with the constraint bag # BUT we'll attach to the handle block rather than the center point of the bag, # so we need to update the grasp transformation handle_id = self . handle_block_ids [ handle_index ] handle_ijk = self . id_to_ijk [ handle_id ] original_grasp_transform = self . grasp_transforms [ handle_index ] orig_rmat = original_grasp_transform [: 3 , : 3 ] pos = self . _center_aligned_block_structure ()[ handle_ijk ] adjusted_grasp_transform = make_transform_mat ( orig_rmat , pos ) structure_scaling = 0.05 structure_type = \"tetrahedron\" self . constraint_structure = ( UNIT_CONSTRAINT_STRUCTURES [ structure_type ] * structure_scaling ) primary_constraint_force = 3 secondary_constraint_force = 2 max_forces = np . concatenate ( [ [ primary_constraint_force ], secondary_constraint_force * np . ones ( len ( self . constraint_structure ) - 1 ), ] ) constraints = form_constraint_grasp ( robot , handle_id , adjusted_grasp_transform , structure_type , structure_scaling , max_forces , client = self . client , ) self . _handle_constraints . update ({ robot . id : constraints }) self . _attached . append ( robot . id ) def detach ( self ) -> None : # return super().detach() for robot_id , cids in self . _handle_constraints . items (): for cid in cids : self . client . removeConstraint ( cid ) self . _attached = [] self . _handle_constraints = {} def detach_robot ( self , robot_id : int ) -> None : if robot_id not in self . _handle_constraints : raise ValueError ( \"Cannot detach robot: ID unknown\" ) for cid in self . _handle_constraints [ robot_id ]: self . client . removeConstraint ( cid ) self . _attached . remove ( robot_id ) self . _handle_constraints . pop ( robot_id ) def reset_dynamics ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , lin_vel : npt . ArrayLike , ang_vel : npt . ArrayLike , ) -> None : block_positions = self . get_init_block_positions ( pos , orn ) for block_ijk , block_id in self . ijk_to_id . items (): self . client . resetBasePositionAndOrientation ( block_id , block_positions [ block_ijk ], orn ) r = block_positions [ block_ijk ] - pos self . client . resetBaseVelocity ( block_id , lin_vel + np . cross ( ang_vel , r ), ang_vel , ) def get_init_block_positions ( self , pos : npt . ArrayLike , orn : npt . ArrayLike ) -> dict [ tuple [ int , int , int ], np . ndarray ]: \"\"\"Gives the initial positions of the centers of the blocks in world frame Args: pos (npt.ArrayLike): Position to load the center of the bag orn (npt.ArrayLike): Orientation to load the bag (XYZW quaternion) Returns: dict[tuple[int, int, int], np.ndarray]: Map from block (i, j, k) index to its world frame position \"\"\" # Deformation free rmat = quat_to_rmat ( orn ) center_tmat = make_transform_mat ( rmat , pos ) positions = self . _center_aligned_block_structure () for block_ijk in positions : positions [ block_ijk ] = transform_point ( center_tmat , positions [ block_ijk ]) return positions def _corner_aligned_block_structure ( self ) -> dict [ tuple [ int , int , int ], np . ndarray ]: \"\"\"Gives the initial positions of the centers of the blocks w.r.t the bottom corner of the box in local frame Returns: dict[tuple[int, int, int], np.ndarray]: Map from block (i, j, k) index to its local frame position \"\"\" nx , ny , nz = self . divisions l = self . LENGTH / nx w = self . WIDTH / ny h = self . HEIGHT / nz positions = {} for i in range ( nx ): for j in range ( ny ): for k in range ( nz ): positions [( i , j , k )] = np . array ( [( 2 * i + 1 ) * l / 2 , ( 2 * j + 1 ) * w / 2 , ( 2 * k + 1 ) * h / 2 ] ) return positions def _center_aligned_block_structure ( self ) -> dict [ tuple [ int , int , int ], np . ndarray ]: \"\"\"Gives the initial positions of the centers of the blocks w.r.t the center of the box in local frame Returns: dict[tuple[int, int, int], np.ndarray]: Map from block (i, j, k) index to its local frame position \"\"\" # Simple translation, no rotation required positions = self . _corner_aligned_block_structure () corner_to_center = np . array ([ self . LENGTH / 2 , self . WIDTH / 2 , self . HEIGHT / 2 ]) for block_ijk in positions : positions [ block_ijk ] -= corner_to_center return positions def _load ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , ) -> int : # Number of blocks in each dimension nx , ny , nz = self . divisions num_blocks = nx * ny * nz # Dimension of the blocks along each axis l = self . LENGTH / nx w = self . WIDTH / ny h = self . HEIGHT / nz # Mass of each individual block m = self . mass / num_blocks # Create the blocks self . block_ids = [] self . handle_block_ids = [] self . corner_block_ids = [] self . center_block_id = None self . ijk_to_id = {} self . id_to_ijk = {} if self . name == \"top_handle\" : handle_ijks = [( nx // 2 , ny // 2 , nz - 1 )] elif self . name == \"front_handle\" : handle_ijks = [( nx // 2 , 0 , nz // 2 )] elif self . name == \"right_handle\" : handle_ijks = [( nx - 1 , ny // 2 , nz // 2 )] elif self . name == \"top_bottom_handle\" : handle_ijks = [( nx // 2 , ny // 2 , nz - 1 ), ( nx // 2 , ny // 2 , 0 )] elif self . name == \"front_back_handle\" : handle_ijks = [( nx // 2 , 0 , nz // 2 ), ( nx // 2 , ny - 1 , nz // 2 )] elif self . name == \"right_left_handle\" : handle_ijks = [( nx - 1 , ny // 2 , nz // 2 ), ( 0 , ny // 2 , nz // 2 )] center_block_ijk = ( nx // 2 , ny // 2 , nz // 2 ) block_to_center = {} block_positions = self . get_init_block_positions ( pos , orn ) for i in range ( nx ): for j in range ( ny ): for k in range ( nz ): is_handle_block = ( i , j , k ) in handle_ijks is_corner_block = ( ( i in { 0 , nx - 1 }) and ( j in { 0 , ny - 1 }) and ( k in { 0 , nz - 1 }) ) is_center_block = ( i , j , k ) == center_block_ijk if is_handle_block : rgba = ( 1 , 0 , 0 , 1 ) elif is_corner_block : rgba = ( 0 , 1 , 0 , 1 ) elif is_center_block : rgba = ( 0 , 0 , 1 , 1 ) else : rgba = ( 1 , 1 , 1 , 1 ) local_pos = np . array ( [( 2 * i + 1 ) * l / 2 , ( 2 * j + 1 ) * w / 2 , ( 2 * k + 1 ) * h / 2 ] ) block_id = create_box ( block_positions [( i , j , k )], orn , m , ( l , w , h ), True , rgba , ) self . ijk_to_id [( i , j , k )] = block_id self . id_to_ijk [ block_id ] = ( i , j , k ) self . block_ids . append ( block_id ) block_to_center [ block_id ] = ( np . array ([ self . LENGTH / 2 , self . WIDTH / 2 , self . HEIGHT / 2 ]) - local_pos ) if is_handle_block : self . handle_block_ids . append ( block_id ) if is_corner_block : self . corner_block_ids . append ( block_id ) if is_center_block : self . center_block_id = block_id # Form constraints between the blocks # We constrain each block to the central block, with the handle blocks having a larger force cids = [] center_block_id = self . ijk_to_id [ center_block_ijk ] for i in range ( nx ): for j in range ( ny ): for k in range ( nz ): is_handle_block = ( i , j , k ) in handle_ijks is_center_block = ( i , j , k ) == center_block_ijk if not is_center_block : cid = self . client . createConstraint ( center_block_id , - 1 , self . ijk_to_id [( i , j , k )], - 1 , self . client . JOINT_FIXED , ( 0 , 0 , 1 ), ( 0 , 0 , 0 ), # Center block origin block_to_center [ self . ijk_to_id [( i , j , k )]], ( 0 , 0 , 0 , 1 ), ( 0 , 0 , 0 , 1 ), ) cids . append ( cid ) # TODO TUNE THESE FORCES constraint_force = self . mass * ( self . handle_block_force_scale if is_handle_block else self . block_force_scale ) self . client . changeConstraint ( cid , maxForce = constraint_force ) # Disable internal collisions between adjacent blocks # Define neighbors via a kind of voxel grid (like a Rubiks cube without the central block) neighbors = defaultdict ( list ) for i in range ( nx ): for j in range ( ny ): for k in range ( nz ): # Find the 26 neighboring voxel coordinates for delta_i in [ - 1 , 0 , 1 ]: for delta_j in [ - 1 , 0 , 1 ]: for delta_k in [ - 1 , 0 , 1 ]: if delta_i == 0 and delta_j == 0 and delta_k == 0 : pass # Skip the center point else : # Add the neighbor if it is within the bounds of the box ni = i + delta_i nj = j + delta_j nk = k + delta_k if 0 <= ni < nx and 0 <= nj < ny and 0 <= nk < nz : neighbors [( i , j , k )] . append (( ni , nj , nk )) # Get all unique pairs between neighboring blocks pairs = set () for ijk , neighbor_ijks in neighbors . items (): for nijk in neighbor_ijks : # Ensure no duplicate pairs in the reverse order if ( nijk , ijk ) not in pairs : pairs . add (( ijk , nijk )) for pair in pairs : # Disable collision pybullet . setCollisionFilterPair ( self . ijk_to_id [ pair [ 0 ]], self . ijk_to_id [ pair [ 1 ]], - 1 , - 1 , 0 ) # Correct the handle block ID order # We build the blocks in order of increasing xyz position, but the way we've ordered the handles in the # two-handle bags are top->bottom, front->back, right->left which don't necessarily adhere to this order if self . num_handles == 2 : # Reverse the order for the bags where the first handle is not at the minimum of the relevant dimension # Note: the front/back handle bag adheres to the correct order since the front handle is at min y if self . name in { \"top_bottom_handle\" , \"right_left_handle\" }: self . handle_block_ids = self . handle_block_ids [:: - 1 ] # We need an ID to assign to the object # In general, the center block makes the most sense because we can query this for dynamics info of the bag return self . center_block_id @property def bounding_box ( self ) -> np . ndarray : # TODO see if there is a simpler way to handle this # We can't use the standard method because it would just give the AABB of the center block lower = np . inf * np . ones ( 3 ) upper = - np . inf * np . ones ( 3 ) for block_id in self . corner_block_ids : aabb = self . client . getAABB ( block_id , - 1 ) lower = np . minimum ( lower , aabb [ 0 ]) upper = np . maximum ( upper , aabb [ 1 ]) # TODO convert to Box instance? return np . array ([ lower , upper ]) def get_local_constraint_pos ( self , handle_index : int ) -> np . ndarray : \"\"\"Determine the position of the handle's constraints in the bag frame Args: handle_index (int): Index of the handle of interest Returns: np.ndarray: Constraint positions, shape (n_constraints, 3) \"\"\" return np . array ( [ transform_point ( self . grasp_transforms [ handle_index ], pt ) for pt in self . constraint_structure ] ) def get_world_constraint_pos ( self , handle_index : int ) -> np . ndarray : \"\"\"Determine the position of the handle's constraints in the world frame Args: handle_index (int): Index of the handle of interest Returns: np.ndarray: Constraint positions, shape (n_constraints, 3) \"\"\" tmat = self . tmat local_constraint_pos = self . get_local_constraint_pos ( handle_index ) return np . array ([ transform_point ( tmat , pos ) for pos in local_constraint_pos ]) def _main (): # pylint: disable=import-outside-toplevel from pyastrobee.utils.bullet_utils import load_floor name = \"top_handle\" pos = ( 0 , 0 , 1 ) orn = ( 0 , 0 , 0 , 1 ) mass = 5 divisions = ( 3 , 3 , 3 ) pybullet . connect ( pybullet . GUI ) # pybullet.setGravity(0, 0, -9.81) load_floor () robot = Astrobee () # robot2 = Astrobee() bag = CompositeCargoBag ( name , mass , pos , orn , divisions ) # bag.attach_to([robot, robot2]) bag . attach_to ( robot ) while True : pybullet . stepSimulation () time . sleep ( 1 / 120 ) if __name__ == \"__main__\" : _main ()","title":"Module pyastrobee.core.composite_bag"},{"location":"reference/pyastrobee/core/composite_bag/#variables","text":"UNIT_CONSTRAINT_STRUCTURES","title":"Variables"},{"location":"reference/pyastrobee/core/composite_bag/#classes","text":"","title":"Classes"},{"location":"reference/pyastrobee/core/composite_bag/#compositecargobag","text":"class CompositeCargoBag ( bag_name : str , mass : float , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 0 , 0 , 0 ), orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 0 , 0 , 0 , 1 ), divisions : tuple [ int , int , int ] = ( 3 , 3 , 3 ), client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) Class for loading and managing properties associated with the composite cargo bags","title":"CompositeCargoBag"},{"location":"reference/pyastrobee/core/composite_bag/#attributes","text":"Name Type Description Default bag_name str Type of cargo bag to load. Single handle: \"front_handle\", \"right_handle\", \"top_handle\". Dual handle: \"front_back_handle\", \"right_left_handle\", \"top_bottom_handle\" None mass float Mass of the cargo bag, in kg None pos npt.ArrayLike Initial XYZ position to load the bag. Defaults to (0, 0, 0) None orn npt.ArrayLike Initial XYZW quaternion to load the bag. Defaults to (0, 0, 0, 1) None divisions tuple[int, int, int] Number of smaller sub-blocks along each dimension (length, width, height) of the bag's main compartment. Must be three positive odd integers. None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None View Source class CompositeCargoBag ( CargoBag ): \"\"\"Class for loading and managing properties associated with the composite cargo bags Args: bag_name (str): Type of cargo bag to load. Single handle: \"front_handle\", \"right_handle\", \"top_handle\". Dual handle: \"front_back_handle\", \"right_left_handle\", \"top_bottom_handle\" mass (float): Mass of the cargo bag, in kg pos (npt.ArrayLike): Initial XYZ position to load the bag. Defaults to (0, 0, 0) orn (npt.ArrayLike): Initial XYZW quaternion to load the bag. Defaults to (0, 0, 0, 1) divisions (tuple[int, int, int]): Number of smaller sub-blocks along each dimension (length, width, height) of the bag's main compartment. Must be three positive odd integers. client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" def __init__ ( self , bag_name : str , mass : float , pos : npt . ArrayLike = ( 0 , 0 , 0 ), orn : npt . ArrayLike = ( 0 , 0 , 0 , 1 ), divisions : tuple [ int , int , int ] = ( 3 , 3 , 3 ), client : Optional [ BulletClient ] = None , ): if ( len ( divisions ) != 3 or any ( d <= 0 for d in divisions ) or any ( d % 2 != 1 for d in divisions ) or any ( not isinstance ( d , int ) for d in divisions ) ): raise ValueError ( f \"Invalid divisions: These must be three positive odd integers. \\n Got: {divisions}\" ) self . divisions = divisions self . handle_block_force_scale = 5 self . block_force_scale = 0.5 super () . __init__ ( bag_name , mass , pos , orn , client ) self . _handle_constraints = {} @ property def corner_positions ( self ) -> list [ np . ndarray ]: # TODO: currently, this assumes that there is no deformation going on # Should we do something smarter by looking at the corners of each of the corner boxes? return super () . corner_positions def unload ( self ) -> None : self . detach () for block_id in self . block_ids : self . client . removeBody ( block_id ) self . block_ids = None self . handle_block_ids = None self . center_block_id = None self . corner_block_ids = None self . ijk_to_id = None self . id = None def _attach ( self , robot : Astrobee , handle_index : int ) -> None : # We'll use the same handle modeling as with the constraint bag # BUT we'll attach to the handle block rather than the center point of the bag, # so we need to update the grasp transformation handle_id = self . handle_block_ids [ handle_index ] handle_ijk = self . id_to_ijk [ handle_id ] original_grasp_transform = self . grasp_transforms [ handle_index ] orig_rmat = original_grasp_transform [: 3 , : 3 ] pos = self . _center_aligned_block_structure ()[ handle_ijk ] adjusted_grasp_transform = make_transform_mat ( orig_rmat , pos ) structure_scaling = 0.05 structure_type = \"tetrahedron\" self . constraint_structure = ( UNIT_CONSTRAINT_STRUCTURES [ structure_type ] * structure_scaling ) primary_constraint_force = 3 secondary_constraint_force = 2 max_forces = np . concatenate ( [ [ primary_constraint_force ], secondary_constraint_force * np . ones ( len ( self . constraint_structure ) - 1 ), ] ) constraints = form_constraint_grasp ( robot , handle_id , adjusted_grasp_transform , structure_type , structure_scaling , max_forces , client = self . client , ) self . _handle_constraints . update ({ robot . id : constraints }) self . _attached . append ( robot . id ) def detach ( self ) -> None : # return super().detach() for robot_id , cids in self . _handle_constraints . items (): for cid in cids : self . client . removeConstraint ( cid ) self . _attached = [] self . _handle_constraints = {} def detach_robot ( self , robot_id : int ) -> None : if robot_id not in self . _handle_constraints : raise ValueError ( \"Cannot detach robot: ID unknown\" ) for cid in self . _handle_constraints [ robot_id ]: self . client . removeConstraint ( cid ) self . _attached . remove ( robot_id ) self . _handle_constraints . pop ( robot_id ) def reset_dynamics ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , lin_vel : npt . ArrayLike , ang_vel : npt . ArrayLike , ) -> None : block_positions = self . get_init_block_positions ( pos , orn ) for block_ijk , block_id in self . ijk_to_id . items (): self . client . resetBasePositionAndOrientation ( block_id , block_positions [ block_ijk ], orn ) r = block_positions [ block_ijk ] - pos self . client . resetBaseVelocity ( block_id , lin_vel + np . cross ( ang_vel , r ), ang_vel , ) def get_init_block_positions ( self , pos : npt . ArrayLike , orn : npt . ArrayLike ) -> dict [ tuple [ int , int , int ], np . ndarray ]: \"\"\"Gives the initial positions of the centers of the blocks in world frame Args: pos (npt.ArrayLike): Position to load the center of the bag orn (npt.ArrayLike): Orientation to load the bag (XYZW quaternion) Returns: dict[tuple[int, int, int], np.ndarray]: Map from block (i, j, k) index to its world frame position \"\"\" # Deformation free rmat = quat_to_rmat ( orn ) center_tmat = make_transform_mat ( rmat , pos ) positions = self . _center_aligned_block_structure () for block_ijk in positions : positions [ block_ijk ] = transform_point ( center_tmat , positions [ block_ijk ]) return positions def _corner_aligned_block_structure ( self ) -> dict [ tuple [ int , int , int ], np . ndarray ]: \"\"\"Gives the initial positions of the centers of the blocks w.r.t the bottom corner of the box in local frame Returns: dict[tuple[int, int, int], np.ndarray]: Map from block (i, j, k) index to its local frame position \"\"\" nx , ny , nz = self . divisions l = self . LENGTH / nx w = self . WIDTH / ny h = self . HEIGHT / nz positions = {} for i in range ( nx ): for j in range ( ny ): for k in range ( nz ): positions [( i , j , k )] = np . array ( [( 2 * i + 1 ) * l / 2 , ( 2 * j + 1 ) * w / 2 , ( 2 * k + 1 ) * h / 2 ] ) return positions def _center_aligned_block_structure ( self ) -> dict [ tuple [ int , int , int ], np . ndarray ]: \"\"\"Gives the initial positions of the centers of the blocks w.r.t the center of the box in local frame Returns: dict[tuple[int, int, int], np.ndarray]: Map from block (i, j, k) index to its local frame position \"\"\" # Simple translation, no rotation required positions = self . _corner_aligned_block_structure () corner_to_center = np . array ([ self . LENGTH / 2 , self . WIDTH / 2 , self . HEIGHT / 2 ]) for block_ijk in positions : positions [ block_ijk ] -= corner_to_center return positions def _load ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , ) -> int : # Number of blocks in each dimension nx , ny , nz = self . divisions num_blocks = nx * ny * nz # Dimension of the blocks along each axis l = self . LENGTH / nx w = self . WIDTH / ny h = self . HEIGHT / nz # Mass of each individual block m = self . mass / num_blocks # Create the blocks self . block_ids = [] self . handle_block_ids = [] self . corner_block_ids = [] self . center_block_id = None self . ijk_to_id = {} self . id_to_ijk = {} if self . name == \"top_handle\" : handle_ijks = [( nx // 2 , ny // 2 , nz - 1 )] elif self . name == \"front_handle\" : handle_ijks = [( nx // 2 , 0 , nz // 2 )] elif self . name == \"right_handle\" : handle_ijks = [( nx - 1 , ny // 2 , nz // 2 )] elif self . name == \"top_bottom_handle\" : handle_ijks = [( nx // 2 , ny // 2 , nz - 1 ), ( nx // 2 , ny // 2 , 0 )] elif self . name == \"front_back_handle\" : handle_ijks = [( nx // 2 , 0 , nz // 2 ), ( nx // 2 , ny - 1 , nz // 2 )] elif self . name == \"right_left_handle\" : handle_ijks = [( nx - 1 , ny // 2 , nz // 2 ), ( 0 , ny // 2 , nz // 2 )] center_block_ijk = ( nx // 2 , ny // 2 , nz // 2 ) block_to_center = {} block_positions = self . get_init_block_positions ( pos , orn ) for i in range ( nx ): for j in range ( ny ): for k in range ( nz ): is_handle_block = ( i , j , k ) in handle_ijks is_corner_block = ( ( i in { 0 , nx - 1 }) and ( j in { 0 , ny - 1 }) and ( k in { 0 , nz - 1 }) ) is_center_block = ( i , j , k ) == center_block_ijk if is_handle_block : rgba = ( 1 , 0 , 0 , 1 ) elif is_corner_block : rgba = ( 0 , 1 , 0 , 1 ) elif is_center_block : rgba = ( 0 , 0 , 1 , 1 ) else : rgba = ( 1 , 1 , 1 , 1 ) local_pos = np . array ( [( 2 * i + 1 ) * l / 2 , ( 2 * j + 1 ) * w / 2 , ( 2 * k + 1 ) * h / 2 ] ) block_id = create_box ( block_positions [( i , j , k )], orn , m , ( l , w , h ), True , rgba , ) self . ijk_to_id [( i , j , k )] = block_id self . id_to_ijk [ block_id ] = ( i , j , k ) self . block_ids . append ( block_id ) block_to_center [ block_id ] = ( np . array ([ self . LENGTH / 2 , self . WIDTH / 2 , self . HEIGHT / 2 ]) - local_pos ) if is_handle_block : self . handle_block_ids . append ( block_id ) if is_corner_block : self . corner_block_ids . append ( block_id ) if is_center_block : self . center_block_id = block_id # Form constraints between the blocks # We constrain each block to the central block, with the handle blocks having a larger force cids = [] center_block_id = self . ijk_to_id [ center_block_ijk ] for i in range ( nx ): for j in range ( ny ): for k in range ( nz ): is_handle_block = ( i , j , k ) in handle_ijks is_center_block = ( i , j , k ) == center_block_ijk if not is_center_block : cid = self . client . createConstraint ( center_block_id , - 1 , self . ijk_to_id [( i , j , k )], - 1 , self . client . JOINT_FIXED , ( 0 , 0 , 1 ), ( 0 , 0 , 0 ), # Center block origin block_to_center [ self . ijk_to_id [( i , j , k )]], ( 0 , 0 , 0 , 1 ), ( 0 , 0 , 0 , 1 ), ) cids . append ( cid ) # TODO TUNE THESE FORCES constraint_force = self . mass * ( self . handle_block_force_scale if is_handle_block else self . block_force_scale ) self . client . changeConstraint ( cid , maxForce = constraint_force ) # Disable internal collisions between adjacent blocks # Define neighbors via a kind of voxel grid (like a Rubiks cube without the central block) neighbors = defaultdict ( list ) for i in range ( nx ): for j in range ( ny ): for k in range ( nz ): # Find the 26 neighboring voxel coordinates for delta_i in [ - 1 , 0 , 1 ]: for delta_j in [ - 1 , 0 , 1 ]: for delta_k in [ - 1 , 0 , 1 ]: if delta_i == 0 and delta_j == 0 and delta_k == 0 : pass # Skip the center point else : # Add the neighbor if it is within the bounds of the box ni = i + delta_i nj = j + delta_j nk = k + delta_k if 0 <= ni < nx and 0 <= nj < ny and 0 <= nk < nz : neighbors [( i , j , k )] . append (( ni , nj , nk )) # Get all unique pairs between neighboring blocks pairs = set () for ijk , neighbor_ijks in neighbors . items (): for nijk in neighbor_ijks : # Ensure no duplicate pairs in the reverse order if ( nijk , ijk ) not in pairs : pairs . add (( ijk , nijk )) for pair in pairs : # Disable collision pybullet . setCollisionFilterPair ( self . ijk_to_id [ pair [ 0 ]], self . ijk_to_id [ pair [ 1 ]], - 1 , - 1 , 0 ) # Correct the handle block ID order # We build the blocks in order of increasing xyz position, but the way we've ordered the handles in the # two-handle bags are top->bottom, front->back, right->left which don't necessarily adhere to this order if self . num_handles == 2 : # Reverse the order for the bags where the first handle is not at the minimum of the relevant dimension # Note: the front/back handle bag adheres to the correct order since the front handle is at min y if self . name in { \"top_bottom_handle\" , \"right_left_handle\" }: self . handle_block_ids = self . handle_block_ids [:: - 1 ] # We need an ID to assign to the object # In general, the center block makes the most sense because we can query this for dynamics info of the bag return self . center_block_id @ property def bounding_box ( self ) -> np . ndarray : # TODO see if there is a simpler way to handle this # We can't use the standard method because it would just give the AABB of the center block lower = np . inf * np . ones ( 3 ) upper = - np . inf * np . ones ( 3 ) for block_id in self . corner_block_ids : aabb = self . client . getAABB ( block_id , - 1 ) lower = np . minimum ( lower , aabb [ 0 ]) upper = np . maximum ( upper , aabb [ 1 ]) # TODO convert to Box instance? return np . array ([ lower , upper ]) def get_local_constraint_pos ( self , handle_index : int ) -> np . ndarray : \"\"\"Determine the position of the handle's constraints in the bag frame Args: handle_index (int): Index of the handle of interest Returns: np.ndarray: Constraint positions, shape (n_constraints, 3) \"\"\" return np . array ( [ transform_point ( self . grasp_transforms [ handle_index ], pt ) for pt in self . constraint_structure ] ) def get_world_constraint_pos ( self , handle_index : int ) -> np . ndarray : \"\"\"Determine the position of the handle's constraints in the world frame Args: handle_index (int): Index of the handle of interest Returns: np.ndarray: Constraint positions, shape (n_constraints, 3) \"\"\" tmat = self . tmat local_constraint_pos = self . get_local_constraint_pos ( handle_index ) return np . array ([ transform_point ( tmat , pos ) for pos in local_constraint_pos ])","title":"Attributes"},{"location":"reference/pyastrobee/core/composite_bag/#ancestors-in-mro","text":"pyastrobee.core.abstract_bag.CargoBag abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/pyastrobee/core/composite_bag/#class-variables","text":"BAG_NAMES DUAL_HANDLE_BAGS HANDLE_TRANSFORMS HEIGHT LENGTH MESH_DIR SINGLE_HANDLE_BAGS URDF_DIR WIDTH","title":"Class variables"},{"location":"reference/pyastrobee/core/composite_bag/#instance-variables","text":"angular_velocity Current [wx, wy, wz] angular velocity of the cargo bag's COM frame If both velocity and angular velocity are desired, use the dynamics_state property instead attached ID(s) of the robot (or robots) grasping the bag. Empty if no robots are attached bounding_box corner_positions dynamics_state Current state of the bag dynamics: Position, orientation, linear vel, and angular vel grasp_transforms Transformation matrices \"handle to bag\" representing the grasp locations on the handles to the bag COM In the case of a single-handled bag, this list will only have one entry mass Mass of the cargo bag name Type of cargo bag num_handles Number of handles on the cargo bag orientation Current XYZW quaternion orientation of the cargo bag's COM frame pose Current position + XYZW quaternion pose of the bag position Current XYZ position of the origin (COM frame) of the cargo bag tmat Current transformation matrix for the cargo bag: (Bag to world) velocity Current [vx, vy, vz] velocity of the cargo bag's COM frame If both velocity and angular velocity are desired, use the dynamics_state property instead","title":"Instance variables"},{"location":"reference/pyastrobee/core/composite_bag/#methods","text":"","title":"Methods"},{"location":"reference/pyastrobee/core/composite_bag/#attach_to","text":"def attach_to ( self , robot_or_robots : Union [ pyastrobee . core . astrobee . Astrobee , list [ pyastrobee . core . astrobee . Astrobee ], tuple [ pyastrobee . core . astrobee . Astrobee ]], object_to_move : str = 'robot' ) -> None Attaches a robot (or multiple robots) to the handle(s) of the bag Parameters: Name Type Description Default robot_or_robots Union[Astrobee, list[Astrobee], tuple[Astrobee]] Robot(s) to attach to the bag None object_to_move str Either \"robot\" or \"bag\". This dictates what object will get its position reset in order to make the grasp connection. In general, it makes more sense to move the robot to the bag (default behavior) None Raises: Type Description ValueError For invalid inputs, or if the bag does not have enough handles for each robot NotImplementedError Multi-robot case with >2 robots View Source def attach_to ( self , robot_or_robots : Union [ Astrobee, list[Astrobee ] , tuple [ Astrobee ] ] , object_to_move : str = \"robot\" , ) -> None : \"\"\"Attaches a robot (or multiple robots) to the handle(s) of the bag Args: robot_or_robots (Union[Astrobee, list[Astrobee], tuple[Astrobee]]): Robot(s) to attach to the bag object_to_move (str, optional): Either \" robot \" or \" bag \". This dictates what object will get its position reset in order to make the grasp connection. In general, it makes more sense to move the robot to the bag (default behavior) Raises: ValueError: For invalid inputs, or if the bag does not have enough handles for each robot NotImplementedError: Multi-robot case with >2 robots \"\"\" # Handle inputs if isinstance ( robot_or_robots , Astrobee ) : # Single robot num_robots = 1 elif isinstance ( robot_or_robots , ( list , tuple )) : # Multi - robot if not all ( isinstance ( r , Astrobee ) for r in robot_or_robots ) : raise ValueError ( \"Non-Astrobee input detected\" ) num_robots = len ( robot_or_robots ) if self . num_handles < num_robots : raise ValueError ( f \"Bag does not have enough handles to support {num_robots} robots\" ) if num_robots == 1 : # Edge case : Unpack the list if only one robot robot_or_robots = robot_or_robots [ 0 ] else : raise ValueError ( \"Invalid input: Must provide either an Astrobee or a list of multiple Astrobees\" ) if object_to_move not in { \"robot\" , \"bag\" }: raise ValueError ( \"Invalid object to move: Must be either 'robot' or 'bag'.\" ) bag_to_world = pos_quat_to_tmat ( self . pose ) if num_robots == 1 : robot = robot_or_robots # Unpack list if object_to_move == \"robot\" : # Reset the position of the robot to interface with the handle handle_to_bag = self . grasp_transforms [ 0 ] handle_to_world = bag_to_world @ handle_to_bag handle_pose = tmat_to_pos_quat ( handle_to_world ) robot . reset_to_ee_pose ( handle_pose ) else : # Move the bag to the robot self . reset_to_handle_pose ( robot . ee_pose ) self . _attach ( robot , 0 ) elif num_robots == 2 : robot_1 , robot_2 = robot_or_robots # Unpack list if object_to_move == \"robot\" : # Reset the position of each robot to interface with the two handles handle_1_to_bag = self . grasp_transforms [ 0 ] handle_2_to_bag = self . grasp_transforms [ 1 ] handle_1_to_world = bag_to_world @ handle_1_to_bag handle_2_to_world = bag_to_world @ handle_2_to_bag robot_1 . reset_to_ee_pose ( tmat_to_pos_quat ( handle_1_to_world )) robot_2 . reset_to_ee_pose ( tmat_to_pos_quat ( handle_2_to_world )) self . _attach ( robot_1 , 0 ) self . _attach ( robot_2 , 1 ) else : # Move the bag while leaving the robots static raise NotImplementedError ( \"Attaching the bag to multiple robots requires moving at least 1 robot\" ) else : raise NotImplementedError ( \"The multi-robot case is only implemented for 2 Astrobees\" )","title":"attach_to"},{"location":"reference/pyastrobee/core/composite_bag/#detach","text":"def detach ( self ) -> None Detach all connections to the bag View Source def detach ( self ) -> None : # return super().detach() for robot_id , cids in self . _handle_constraints . items (): for cid in cids : self . client . removeConstraint ( cid ) self . _attached = [] self . _handle_constraints = {}","title":"detach"},{"location":"reference/pyastrobee/core/composite_bag/#detach_robot","text":"def detach_robot ( self , robot_id : int ) -> None Detaches a specific robot from the bag Parameters: Name Type Description Default robot_id int Pybullet ID of the robot to detach None View Source def detach_robot ( self , robot_id : int ) -> None : if robot_id not in self . _handle_constraints : raise ValueError ( \"Cannot detach robot: ID unknown\" ) for cid in self . _handle_constraints [ robot_id ] : self . client . removeConstraint ( cid ) self . _attached . remove ( robot_id ) self . _handle_constraints . pop ( robot_id )","title":"detach_robot"},{"location":"reference/pyastrobee/core/composite_bag/#get_init_block_positions","text":"def get_init_block_positions ( self , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> dict [ tuple [ int , int , int ], numpy . ndarray ] Gives the initial positions of the centers of the blocks in world frame Parameters: Name Type Description Default pos npt.ArrayLike Position to load the center of the bag None orn npt.ArrayLike Orientation to load the bag (XYZW quaternion) None Returns: Type Description dict[tuple[int, int, int], np.ndarray] Map from block (i, j, k) index to its world frame position View Source def get_init_block_positions ( self , pos : npt . ArrayLike , orn : npt . ArrayLike ) -> dict [ tuple[int, int, int ] , np . ndarray ]: \"\"\"Gives the initial positions of the centers of the blocks in world frame Args: pos (npt.ArrayLike): Position to load the center of the bag orn (npt.ArrayLike): Orientation to load the bag (XYZW quaternion) Returns: dict[tuple[int, int, int], np.ndarray]: Map from block (i, j, k) index to its world frame position \"\"\" # Deformation free rmat = quat_to_rmat ( orn ) center_tmat = make_transform_mat ( rmat , pos ) positions = self . _center_aligned_block_structure () for block_ijk in positions : positions [ block_ijk ] = transform_point ( center_tmat , positions [ block_ijk ] ) return positions","title":"get_init_block_positions"},{"location":"reference/pyastrobee/core/composite_bag/#get_local_constraint_pos","text":"def get_local_constraint_pos ( self , handle_index : int ) -> numpy . ndarray Determine the position of the handle's constraints in the bag frame Parameters: Name Type Description Default handle_index int Index of the handle of interest None Returns: Type Description np.ndarray Constraint positions, shape (n_constraints, 3) View Source def get_local_constraint_pos ( self , handle_index : int ) -> np . ndarray : \"\"\"Determine the position of the handle's constraints in the bag frame Args: handle_index (int): Index of the handle of interest Returns: np.ndarray: Constraint positions, shape (n_constraints, 3) \"\"\" return np . array ( [ transform_point(self.grasp_transforms[handle_index ] , pt ) for pt in self . constraint_structure ] )","title":"get_local_constraint_pos"},{"location":"reference/pyastrobee/core/composite_bag/#get_world_constraint_pos","text":"def get_world_constraint_pos ( self , handle_index : int ) -> numpy . ndarray Determine the position of the handle's constraints in the world frame Parameters: Name Type Description Default handle_index int Index of the handle of interest None Returns: Type Description np.ndarray Constraint positions, shape (n_constraints, 3) View Source def get_world_constraint_pos ( self , handle_index : int ) -> np . ndarray : \"\"\"Determine the position of the handle's constraints in the world frame Args: handle_index (int): Index of the handle of interest Returns: np.ndarray: Constraint positions, shape (n_constraints, 3) \"\"\" tmat = self . tmat local_constraint_pos = self . get_local_constraint_pos ( handle_index ) return np . array ([ transform_point ( tmat , pos ) for pos in local_constraint_pos ])","title":"get_world_constraint_pos"},{"location":"reference/pyastrobee/core/composite_bag/#reset_dynamics","text":"def reset_dynamics ( self , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], lin_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], ang_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> None Resets the pose and velocities of the bag Parameters: Name Type Description Default pos npt.ArrayLike Position, shape (3,) None orn npt.ArrayLike XYZW quaternion orientation, shape (4,) None lin_vel npt.ArrayLike Linear velocity, shape (3,) None ang_vel npt.ArrayLike Angular velocity, shape (3,) None View Source def reset_dynamics ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , lin_vel : npt . ArrayLike , ang_vel : npt . ArrayLike , ) -> None : block_positions = self . get_init_block_positions ( pos , orn ) for block_ijk , block_id in self . ijk_to_id . items () : self . client . resetBasePositionAndOrientation ( block_id , block_positions [ block_ijk ] , orn ) r = block_positions [ block_ijk ] - pos self . client . resetBaseVelocity ( block_id , lin_vel + np . cross ( ang_vel , r ), ang_vel , )","title":"reset_dynamics"},{"location":"reference/pyastrobee/core/composite_bag/#reset_to_handle_pose","text":"def reset_to_handle_pose ( self , handle_pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], handle_index : int = 0 ) -> None Resets the position of the bag so that the handle is positioned at a desired pose Parameters: Name Type Description Default handle_pose npt.ArrayLike Desired pose of the handle (\"handle-to-world\"), shape (7,) None handle_index int Index of the handle to align to the desired pose. Defaults to 0. 0 View Source def reset_to_handle_pose ( self , handle_pose : npt . ArrayLike , handle_index : int = 0 ) -> None : \"\"\"Resets the position of the bag so that the handle is positioned at a desired pose Args: handle_pose (npt.ArrayLike): Desired pose of the handle (\" handle - to - world \"), shape (7,) handle_index (int, optional): Index of the handle to align to the desired pose. Defaults to 0. \"\"\" handle_to_world = pos_quat_to_tmat ( handle_pose ) bag_to_handle = invert_transform_mat ( self . grasp_transforms [ handle_index ] ) bag_to_world = handle_to_world @ bag_to_handle bag_pose = tmat_to_pos_quat ( bag_to_world ) # This assumes that we want the bag to be stationary self . reset_dynamics ( bag_pose [ :3 ] , bag_pose [ 3: ] , np . zeros ( 3 ), np . zeros ( 3 ))","title":"reset_to_handle_pose"},{"location":"reference/pyastrobee/core/composite_bag/#unload","text":"def unload ( self ) -> None Removes the cargo bag from the simulation View Source def unload ( self ) -> None : self . detach () for block_id in self . block_ids : self . client . removeBody ( block_id ) self . block_ids = None self . handle_block_ids = None self . center_block_id = None self . corner_block_ids = None self . ijk_to_id = None self . id = None","title":"unload"},{"location":"reference/pyastrobee/core/constraint_bag/","text":"Module pyastrobee.core.constraint_bag Modeling a cargo bag as a single rigid box with a handle constructed from multiple point-to-point constraints Documentation for inherited methods can be found in the base class View Source \"\"\"Modeling a cargo bag as a single rigid box with a handle constructed from multiple point-to-point constraints Documentation for inherited methods can be found in the base class \"\"\" import time from typing import Optional import numpy as np import numpy.typing as npt import pybullet from pybullet_utils.bullet_client import BulletClient from pyastrobee.core.astrobee import Astrobee from pyastrobee.core.abstract_bag import CargoBag from pyastrobee.utils.bullet_utils import create_box from pyastrobee.utils.transformations import transform_point from pyastrobee.utils.python_utils import print_green from pyastrobee.utils.bullet_utils import initialize_pybullet # Different geometries of the constraint \"constellation\" # First point is the central (primary) constraint # Notes: tetrahedron seems to give a bit better behavior than diamond -- diamond will sometimes \"snap\" into place, # which doesn't really make sense for a handle. Plus, tetrahedron has fewer constraints, which is better for sim UNIT_CONSTRAINT_STRUCTURES = { \"diamond\" : np . array ( [ [ 0 , 0 , 0 ], [ 1 , 0 , 0 ], [ - 1 , 0 , 0 ], [ 0 , 1 , 0 ], [ 0 , - 1 , 0 ], [ 0 , 0 , 1 ], [ 0 , 0 , - 1 ], ] ), \"tetrahedron\" : np . array ( [ [ 0 , 0 , 0 ], [ - 1 / 3 , np . sqrt ( 8 / 9 ), 0 ], [ - 1 / 3 , - np . sqrt ( 2 / 9 ), np . sqrt ( 2 / 3 )], [ - 1 / 3 , - np . sqrt ( 2 / 9 ), - np . sqrt ( 2 / 3 )], [ 1 , 0 , 0 ], ] ), \"xy_cross\" : np . array ( [ [ 0 , 0 , 0 ], [ 1 , 0 , 0 ], [ - 1 , 0 , 0 ], [ 0 , 1 , 0 ], [ 0 , - 1 , 0 ], ] ), \"xz_cross\" : np . array ( [ [ 0 , 0 , 0 ], [ 1 , 0 , 0 ], [ - 1 , 0 , 0 ], [ 0 , 0 , 1 ], [ 0 , 0 , - 1 ], ] ), \"yz_cross\" : np . array ( [ [ 0 , 0 , 0 ], [ 0 , 1 , 0 ], [ 0 , - 1 , 0 ], [ 0 , 0 , 1 ], [ 0 , 0 , - 1 ], ] ), \"x_inline\" : np . array ( [ [ 0 , 0 , 0 ], [ 1 , 0 , 0 ], [ - 1 , 0 , 0 ], ] ), \"y_inline\" : np . array ( [ [ 0 , 0 , 0 ], [ 0 , 1 , 0 ], [ 0 , - 1 , 0 ], ] ), \"z_inline\" : np . array ( [ [ 0 , 0 , 0 ], [ 0 , 0 , 1 ], [ 0 , 0 , - 1 ], ] ), } class ConstraintCargoBag ( CargoBag ): \"\"\"Class for loading and managing properties associated with the constraint-based cargo bags Args: bag_name (str): Type of cargo bag to load. Single handle: \"front_handle\", \"right_handle\", \"top_handle\". Dual handle: \"front_back_handle\", \"right_left_handle\", \"top_bottom_handle\" mass (float): Mass of the cargo bag, in kg pos (npt.ArrayLike, optional): Initial XYZ position to load the bag. Defaults to (0, 0, 0) orn (npt.ArrayLike, optional): Initial XYZW quaternion to load the bag. Defaults to (0, 0, 0, 1) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" def __init__ ( self , bag_name : str , mass : float , pos : npt . ArrayLike = ( 0 , 0 , 0 ), orn : npt . ArrayLike = ( 0 , 0 , 0 , 1 ), client : BulletClient | None = None , ): # Set up the geometric structure of the constraint-based handle self . constraint_scaling = 0.05 self . constraint_structure_type = \"tetrahedron\" self . constraint_structure = ( UNIT_CONSTRAINT_STRUCTURES [ self . constraint_structure_type ] * self . constraint_scaling ) # Define the forces applied by the constraints self . primary_constraint_force = 3 self . secondary_constraint_force = 2 self . max_constraint_forces = np . concatenate ( [ [ self . primary_constraint_force ], self . secondary_constraint_force * np . ones ( len ( self . constraint_structure ) - 1 ), ] ) self . _constraints = {} self . num_contraints = len ( self . constraint_structure ) super () . __init__ ( bag_name , mass , pos , orn , client ) print_green ( \"Bag is ready\" ) # Implement abstract methods def _load ( self , pos : npt . ArrayLike , orn : npt . ArrayLike ) -> int : return create_box ( pos , orn , self . mass , ( self . LENGTH , self . WIDTH , self . HEIGHT ), True , ( 1 , 1 , 1 , 1 ), ) def _attach ( self , robot : Astrobee , handle_index : int ) -> None : # Disable collisions with the arm for stability when resetting the position w.r.t the deformable for link_id in [ robot . Links . GRIPPER_LEFT_DISTAL . value , robot . Links . GRIPPER_RIGHT_DISTAL . value , robot . Links . GRIPPER_LEFT_PROXIMAL . value , robot . Links . GRIPPER_RIGHT_PROXIMAL . value , robot . Links . ARM_DISTAL . value , robot . Links . ARM_PROXIMAL . value , ]: self . client . setCollisionFilterPair ( robot . id , self . id , link_id , - 1 , 0 ) constraints = form_constraint_grasp ( robot , self . id , self . grasp_transforms [ handle_index ], self . constraint_structure_type , self . constraint_scaling , self . max_constraint_forces , client = self . client , ) self . _constraints . update ({ robot . id : constraints }) self . _attached . append ( robot . id ) def detach ( self ) -> None : for robot_id , cids in self . constraints . items (): for cid in cids : self . client . removeConstraint ( cid ) self . _attached = [] self . _constraints = {} def detach_robot ( self , robot_id : int ) -> None : if robot_id not in self . constraints : raise ValueError ( \"Cannot detach robot: ID unknown\" ) for cid in self . constraints [ robot_id ]: self . client . removeConstraint ( cid ) self . _attached . remove ( robot_id ) self . _constraints . pop ( robot_id ) # Functions and properties specific to the constraint-based bag @property def constraints ( self ) -> dict [ int , list [ int ]]: \"\"\"Constraints between the robot(s) and the handle(s). Key: robot ID; Value: list of constraint IDs\"\"\" return self . _constraints def get_local_constraint_pos ( self , handle_index : int ) -> np . ndarray : \"\"\"Determine the position of the handle's constraints in the bag frame Args: handle_index (int): Index of the handle of interest Returns: np.ndarray: Constraint positions, shape (n_constraints, 3) \"\"\" return np . array ( [ transform_point ( self . grasp_transforms [ handle_index ], pt ) for pt in self . constraint_structure ] ) def get_world_constraint_pos ( self , handle_index : int ) -> np . ndarray : \"\"\"Determine the position of the handle's constraints in the world frame Args: handle_index (int): Index of the handle of interest Returns: np.ndarray: Constraint positions, shape (n_constraints, 3) \"\"\" tmat = self . tmat local_constraint_pos = self . get_local_constraint_pos ( handle_index ) return np . array ([ transform_point ( tmat , pos ) for pos in local_constraint_pos ]) @property def constraint_forces ( self ) -> dict [ int , float ]: \"\"\"Forces on each constraint. Key: constraint ID; Value: Force, shape (3,)\"\"\" # NOTE: this dictionary will maintain insertion order so we can also associate # these constraint forces in the same order as the original structure forces = {} for robot_id , cids in self . constraints . items (): for cid in cids : forces [ cid ] = self . client . getConstraintState ( cid ) return forces def form_constraint_grasp ( robot : Astrobee , body_id : int , grasp_transform : np . ndarray , structure_type : str , structure_scaling : float , max_forces : list [ float ], client : Optional [ BulletClient ] = None , ) -> list [ int ]: \"\"\"Connects the Astrobee's gripper to an object via point-to-point constraints to mimic a non-rigid grasp NOTE: Depending on the grasp transform used, it may be recommended to disable collisions between the Astrobee gripper and the object before forming these constraints Args: robot (Astrobee): Astrobee performing the grasp body_id (int): Pybullet ID of the object being grasped grasp_transform (np.ndarray): Transformation matrix defining the grasp pose w.r.t the base frame of the object structure_type (str, optional): Type of geometry to construct the series of constraints. Defaults to \"tetrahedron\". Other options include \"diamond\" structure_scaling (float, optional): Scale on the size of the constraint structure (if set to 1, the constraints will be spaced along a unit (1 meter) sphere). Defaults to 0.05. max_forces (list[float]): Maximum applied force for each constraint. Length must match with the number of constraints in the desired structure type client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: list[int]: Pybullet IDs of the constraints \"\"\" client : pybullet = pybullet if client is None else client constraint_structure = ( UNIT_CONSTRAINT_STRUCTURES [ structure_type ] * structure_scaling ) if len ( max_forces ) != len ( constraint_structure ): raise ValueError ( f \"Invalid number of forces: Must be of length { len ( constraint_structure ) } \" + f \"for structure type { structure_type } . \\n Got: { max_forces } \" ) body_local_constraint_pos = np . array ( [ transform_point ( grasp_transform , pt ) for pt in constraint_structure ] ) robot_local_constraint_pos = np . array ( [ transform_point ( Astrobee . TRANSFORMS . GRIPPER_TO_ARM_DISTAL , pt ) for pt in constraint_structure ] ) constraints = [] for i in range ( len ( constraint_structure )): cid = client . createConstraint ( robot . id , robot . Links . ARM_DISTAL . value , body_id , - 1 , client . JOINT_POINT2POINT , ( 0 , 0 , 1 ), robot_local_constraint_pos [ i ], body_local_constraint_pos [ i ], ) client . changeConstraint ( cid , maxForce = max_forces [ i ]) constraints . append ( cid ) return constraints def _main (): client = initialize_pybullet ( bg_color = ( 0.5 , 0.5 , 1 )) client . configureDebugVisualizer ( client . COV_ENABLE_WIREFRAME , 1 ) robot = Astrobee () # robot2 = Astrobee() bag = ConstraintCargoBag ( \"top_handle\" , 10 ) # bag.attach_to([robot, robot2]) bag . attach_to ( robot ) points_uid = None while True : forces = np . array ( list ( bag . constraint_forces . values ())) force_mags = np . linalg . norm ( forces , axis = 1 ) rgbs = [] for i in range ( bag . num_contraints ): r = min ( 1 , force_mags [ i ] / bag . max_constraint_forces [ i ]) rgbs . append (( r , 1 - r , 0 )) world_constraint_pos = bag . get_world_constraint_pos ( 0 ) if points_uid is None : points_uid = client . addUserDebugPoints ( world_constraint_pos , rgbs , 10 , 0 ) else : points_uid = client . addUserDebugPoints ( world_constraint_pos , rgbs , 10 , 0 , replaceItemUniqueId = points_uid ) client . stepSimulation () time . sleep ( 1 / 120 ) if __name__ == \"__main__\" : _main () Variables UNIT_CONSTRAINT_STRUCTURES Functions form_constraint_grasp def form_constraint_grasp ( robot : pyastrobee . core . astrobee . Astrobee , body_id : int , grasp_transform : numpy . ndarray , structure_type : str , structure_scaling : float , max_forces : list [ float ], client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> list [ int ] Connects the Astrobee's gripper to an object via point-to-point constraints to mimic a non-rigid grasp NOTE: Depending on the grasp transform used, it may be recommended to disable collisions between the Astrobee gripper and the object before forming these constraints Parameters: Name Type Description Default robot Astrobee Astrobee performing the grasp None body_id int Pybullet ID of the object being grasped None grasp_transform np.ndarray Transformation matrix defining the grasp pose w.r.t the base frame of the object None structure_type str Type of geometry to construct the series of constraints. Defaults to \"tetrahedron\". Other options include \"diamond\" None structure_scaling float Scale on the size of the constraint structure (if set to 1, the constraints will be spaced along a unit (1 meter) sphere). Defaults to 0.05. None max_forces list[float] Maximum applied force for each constraint. Length must match with the number of constraints in the desired structure type None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Returns: Type Description list[int] Pybullet IDs of the constraints View Source def form_constraint_grasp ( robot : Astrobee , body_id : int , grasp_transform : np . ndarray , structure_type : str , structure_scaling : float , max_forces : list [ float ] , client : Optional [ BulletClient ] = None , ) -> list [ int ] : \"\"\"Connects the Astrobee's gripper to an object via point-to-point constraints to mimic a non-rigid grasp NOTE: Depending on the grasp transform used, it may be recommended to disable collisions between the Astrobee gripper and the object before forming these constraints Args: robot (Astrobee): Astrobee performing the grasp body_id (int): Pybullet ID of the object being grasped grasp_transform (np.ndarray): Transformation matrix defining the grasp pose w.r.t the base frame of the object structure_type (str, optional): Type of geometry to construct the series of constraints. Defaults to \" tetrahedron \". Other options include \" diamond \" structure_scaling (float, optional): Scale on the size of the constraint structure (if set to 1, the constraints will be spaced along a unit (1 meter) sphere). Defaults to 0.05. max_forces (list[float]): Maximum applied force for each constraint. Length must match with the number of constraints in the desired structure type client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: list[int]: Pybullet IDs of the constraints \"\"\" client : pybullet = pybullet if client is None else client constraint_structure = ( UNIT_CONSTRAINT_STRUCTURES [ structure_type ] * structure_scaling ) if len ( max_forces ) != len ( constraint_structure ) : raise ValueError ( f \"Invalid number of forces: Must be of length {len(constraint_structure)} \" + f \"for structure type {structure_type}.\\nGot: {max_forces}\" ) body_local_constraint_pos = np . array ( [ transform_point(grasp_transform, pt) for pt in constraint_structure ] ) robot_local_constraint_pos = np . array ( [ transform_point(Astrobee.TRANSFORMS.GRIPPER_TO_ARM_DISTAL, pt) for pt in constraint_structure ] ) constraints = [] for i in range ( len ( constraint_structure )) : cid = client . createConstraint ( robot . id , robot . Links . ARM_DISTAL . value , body_id , - 1 , client . JOINT_POINT2POINT , ( 0 , 0 , 1 ), robot_local_constraint_pos [ i ] , body_local_constraint_pos [ i ] , ) client . changeConstraint ( cid , maxForce = max_forces [ i ] ) constraints . append ( cid ) return constraints Classes ConstraintCargoBag class ConstraintCargoBag ( bag_name : str , mass : float , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 0 , 0 , 0 ), orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 0 , 0 , 0 , 1 ), client : pybullet_utils . bullet_client . BulletClient | None = None ) Class for loading and managing properties associated with the constraint-based cargo bags Attributes Name Type Description Default bag_name str Type of cargo bag to load. Single handle: \"front_handle\", \"right_handle\", \"top_handle\". Dual handle: \"front_back_handle\", \"right_left_handle\", \"top_bottom_handle\" None mass float Mass of the cargo bag, in kg None pos npt.ArrayLike Initial XYZ position to load the bag. Defaults to (0, 0, 0) None orn npt.ArrayLike Initial XYZW quaternion to load the bag. Defaults to (0, 0, 0, 1) None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None View Source class ConstraintCargoBag ( CargoBag ): \"\"\"Class for loading and managing properties associated with the constraint-based cargo bags Args: bag_name (str): Type of cargo bag to load. Single handle: \"front_handle\", \"right_handle\", \"top_handle\". Dual handle: \"front_back_handle\", \"right_left_handle\", \"top_bottom_handle\" mass (float): Mass of the cargo bag, in kg pos (npt.ArrayLike, optional): Initial XYZ position to load the bag. Defaults to (0, 0, 0) orn (npt.ArrayLike, optional): Initial XYZW quaternion to load the bag. Defaults to (0, 0, 0, 1) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" def __init__ ( self , bag_name : str , mass : float , pos : npt . ArrayLike = ( 0 , 0 , 0 ), orn : npt . ArrayLike = ( 0 , 0 , 0 , 1 ), client : BulletClient | None = None , ): # Set up the geometric structure of the constraint-based handle self . constraint_scaling = 0.05 self . constraint_structure_type = \"tetrahedron\" self . constraint_structure = ( UNIT_CONSTRAINT_STRUCTURES [ self . constraint_structure_type ] * self . constraint_scaling ) # Define the forces applied by the constraints self . primary_constraint_force = 3 self . secondary_constraint_force = 2 self . max_constraint_forces = np . concatenate ( [ [ self . primary_constraint_force ], self . secondary_constraint_force * np . ones ( len ( self . constraint_structure ) - 1 ), ] ) self . _constraints = {} self . num_contraints = len ( self . constraint_structure ) super () . __init__ ( bag_name , mass , pos , orn , client ) print_green ( \"Bag is ready\" ) # Implement abstract methods def _load ( self , pos : npt . ArrayLike , orn : npt . ArrayLike ) -> int : return create_box ( pos , orn , self . mass , ( self . LENGTH , self . WIDTH , self . HEIGHT ), True , ( 1 , 1 , 1 , 1 ), ) def _attach ( self , robot : Astrobee , handle_index : int ) -> None : # Disable collisions with the arm for stability when resetting the position w.r.t the deformable for link_id in [ robot . Links . GRIPPER_LEFT_DISTAL . value , robot . Links . GRIPPER_RIGHT_DISTAL . value , robot . Links . GRIPPER_LEFT_PROXIMAL . value , robot . Links . GRIPPER_RIGHT_PROXIMAL . value , robot . Links . ARM_DISTAL . value , robot . Links . ARM_PROXIMAL . value , ]: self . client . setCollisionFilterPair ( robot . id , self . id , link_id , - 1 , 0 ) constraints = form_constraint_grasp ( robot , self . id , self . grasp_transforms [ handle_index ], self . constraint_structure_type , self . constraint_scaling , self . max_constraint_forces , client = self . client , ) self . _constraints . update ({ robot . id : constraints }) self . _attached . append ( robot . id ) def detach ( self ) -> None : for robot_id , cids in self . constraints . items (): for cid in cids : self . client . removeConstraint ( cid ) self . _attached = [] self . _constraints = {} def detach_robot ( self , robot_id : int ) -> None : if robot_id not in self . constraints : raise ValueError ( \"Cannot detach robot: ID unknown\" ) for cid in self . constraints [ robot_id ]: self . client . removeConstraint ( cid ) self . _attached . remove ( robot_id ) self . _constraints . pop ( robot_id ) # Functions and properties specific to the constraint-based bag @ property def constraints ( self ) -> dict [ int , list [ int ]]: \"\"\"Constraints between the robot(s) and the handle(s). Key: robot ID; Value: list of constraint IDs\"\"\" return self . _constraints def get_local_constraint_pos ( self , handle_index : int ) -> np . ndarray : \"\"\"Determine the position of the handle's constraints in the bag frame Args: handle_index (int): Index of the handle of interest Returns: np.ndarray: Constraint positions, shape (n_constraints, 3) \"\"\" return np . array ( [ transform_point ( self . grasp_transforms [ handle_index ], pt ) for pt in self . constraint_structure ] ) def get_world_constraint_pos ( self , handle_index : int ) -> np . ndarray : \"\"\"Determine the position of the handle's constraints in the world frame Args: handle_index (int): Index of the handle of interest Returns: np.ndarray: Constraint positions, shape (n_constraints, 3) \"\"\" tmat = self . tmat local_constraint_pos = self . get_local_constraint_pos ( handle_index ) return np . array ([ transform_point ( tmat , pos ) for pos in local_constraint_pos ]) @ property def constraint_forces ( self ) -> dict [ int , float ]: \"\"\"Forces on each constraint. Key: constraint ID; Value: Force, shape (3,)\"\"\" # NOTE: this dictionary will maintain insertion order so we can also associate # these constraint forces in the same order as the original structure forces = {} for robot_id , cids in self . constraints . items (): for cid in cids : forces [ cid ] = self . client . getConstraintState ( cid ) return forces Ancestors (in MRO) pyastrobee.core.abstract_bag.CargoBag abc.ABC Class variables BAG_NAMES DUAL_HANDLE_BAGS HANDLE_TRANSFORMS HEIGHT LENGTH MESH_DIR SINGLE_HANDLE_BAGS URDF_DIR WIDTH Instance variables angular_velocity Current [wx, wy, wz] angular velocity of the cargo bag's COM frame If both velocity and angular velocity are desired, use the dynamics_state property instead attached ID(s) of the robot (or robots) grasping the bag. Empty if no robots are attached bounding_box Current axis-aligned bounding box of the bag (or just the main compartment), shape (2, 3) constraint_forces Forces on each constraint. Key: constraint ID; Value: Force, shape (3,) constraints Constraints between the robot(s) and the handle(s). Key: robot ID; Value: list of constraint IDs corner_positions Positions of the 8 corners of the main compartment of the bag, shape (8, 3) dynamics_state Current state of the bag dynamics: Position, orientation, linear vel, and angular vel grasp_transforms Transformation matrices \"handle to bag\" representing the grasp locations on the handles to the bag COM In the case of a single-handled bag, this list will only have one entry mass Mass of the cargo bag name Type of cargo bag num_handles Number of handles on the cargo bag orientation Current XYZW quaternion orientation of the cargo bag's COM frame pose Current position + XYZW quaternion pose of the bag position Current XYZ position of the origin (COM frame) of the cargo bag tmat Current transformation matrix for the cargo bag: (Bag to world) velocity Current [vx, vy, vz] velocity of the cargo bag's COM frame If both velocity and angular velocity are desired, use the dynamics_state property instead Methods attach_to def attach_to ( self , robot_or_robots : Union [ pyastrobee . core . astrobee . Astrobee , list [ pyastrobee . core . astrobee . Astrobee ], tuple [ pyastrobee . core . astrobee . Astrobee ]], object_to_move : str = 'robot' ) -> None Attaches a robot (or multiple robots) to the handle(s) of the bag Parameters: Name Type Description Default robot_or_robots Union[Astrobee, list[Astrobee], tuple[Astrobee]] Robot(s) to attach to the bag None object_to_move str Either \"robot\" or \"bag\". This dictates what object will get its position reset in order to make the grasp connection. In general, it makes more sense to move the robot to the bag (default behavior) None Raises: Type Description ValueError For invalid inputs, or if the bag does not have enough handles for each robot NotImplementedError Multi-robot case with >2 robots View Source def attach_to ( self , robot_or_robots : Union [ Astrobee, list[Astrobee ] , tuple [ Astrobee ] ] , object_to_move : str = \"robot\" , ) -> None : \"\"\"Attaches a robot (or multiple robots) to the handle(s) of the bag Args: robot_or_robots (Union[Astrobee, list[Astrobee], tuple[Astrobee]]): Robot(s) to attach to the bag object_to_move (str, optional): Either \" robot \" or \" bag \". This dictates what object will get its position reset in order to make the grasp connection. In general, it makes more sense to move the robot to the bag (default behavior) Raises: ValueError: For invalid inputs, or if the bag does not have enough handles for each robot NotImplementedError: Multi-robot case with >2 robots \"\"\" # Handle inputs if isinstance ( robot_or_robots , Astrobee ) : # Single robot num_robots = 1 elif isinstance ( robot_or_robots , ( list , tuple )) : # Multi - robot if not all ( isinstance ( r , Astrobee ) for r in robot_or_robots ) : raise ValueError ( \"Non-Astrobee input detected\" ) num_robots = len ( robot_or_robots ) if self . num_handles < num_robots : raise ValueError ( f \"Bag does not have enough handles to support {num_robots} robots\" ) if num_robots == 1 : # Edge case : Unpack the list if only one robot robot_or_robots = robot_or_robots [ 0 ] else : raise ValueError ( \"Invalid input: Must provide either an Astrobee or a list of multiple Astrobees\" ) if object_to_move not in { \"robot\" , \"bag\" }: raise ValueError ( \"Invalid object to move: Must be either 'robot' or 'bag'.\" ) bag_to_world = pos_quat_to_tmat ( self . pose ) if num_robots == 1 : robot = robot_or_robots # Unpack list if object_to_move == \"robot\" : # Reset the position of the robot to interface with the handle handle_to_bag = self . grasp_transforms [ 0 ] handle_to_world = bag_to_world @ handle_to_bag handle_pose = tmat_to_pos_quat ( handle_to_world ) robot . reset_to_ee_pose ( handle_pose ) else : # Move the bag to the robot self . reset_to_handle_pose ( robot . ee_pose ) self . _attach ( robot , 0 ) elif num_robots == 2 : robot_1 , robot_2 = robot_or_robots # Unpack list if object_to_move == \"robot\" : # Reset the position of each robot to interface with the two handles handle_1_to_bag = self . grasp_transforms [ 0 ] handle_2_to_bag = self . grasp_transforms [ 1 ] handle_1_to_world = bag_to_world @ handle_1_to_bag handle_2_to_world = bag_to_world @ handle_2_to_bag robot_1 . reset_to_ee_pose ( tmat_to_pos_quat ( handle_1_to_world )) robot_2 . reset_to_ee_pose ( tmat_to_pos_quat ( handle_2_to_world )) self . _attach ( robot_1 , 0 ) self . _attach ( robot_2 , 1 ) else : # Move the bag while leaving the robots static raise NotImplementedError ( \"Attaching the bag to multiple robots requires moving at least 1 robot\" ) else : raise NotImplementedError ( \"The multi-robot case is only implemented for 2 Astrobees\" ) detach def detach ( self ) -> None Detach all connections to the bag View Source def detach ( self ) -> None : for robot_id , cids in self . constraints . items (): for cid in cids : self . client . removeConstraint ( cid ) self . _attached = [] self . _constraints = {} detach_robot def detach_robot ( self , robot_id : int ) -> None Detaches a specific robot from the bag Parameters: Name Type Description Default robot_id int Pybullet ID of the robot to detach None View Source def detach_robot ( self , robot_id : int ) -> None : if robot_id not in self . constraints : raise ValueError ( \"Cannot detach robot: ID unknown\" ) for cid in self . constraints [ robot_id ] : self . client . removeConstraint ( cid ) self . _attached . remove ( robot_id ) self . _constraints . pop ( robot_id ) get_local_constraint_pos def get_local_constraint_pos ( self , handle_index : int ) -> numpy . ndarray Determine the position of the handle's constraints in the bag frame Parameters: Name Type Description Default handle_index int Index of the handle of interest None Returns: Type Description np.ndarray Constraint positions, shape (n_constraints, 3) View Source def get_local_constraint_pos ( self , handle_index : int ) -> np . ndarray : \"\"\"Determine the position of the handle's constraints in the bag frame Args: handle_index (int): Index of the handle of interest Returns: np.ndarray: Constraint positions, shape (n_constraints, 3) \"\"\" return np . array ( [ transform_point(self.grasp_transforms[handle_index ] , pt ) for pt in self . constraint_structure ] ) get_world_constraint_pos def get_world_constraint_pos ( self , handle_index : int ) -> numpy . ndarray Determine the position of the handle's constraints in the world frame Parameters: Name Type Description Default handle_index int Index of the handle of interest None Returns: Type Description np.ndarray Constraint positions, shape (n_constraints, 3) View Source def get_world_constraint_pos ( self , handle_index : int ) -> np . ndarray : \"\"\"Determine the position of the handle's constraints in the world frame Args: handle_index (int): Index of the handle of interest Returns: np.ndarray: Constraint positions, shape (n_constraints, 3) \"\"\" tmat = self . tmat local_constraint_pos = self . get_local_constraint_pos ( handle_index ) return np . array ([ transform_point ( tmat , pos ) for pos in local_constraint_pos ]) reset_dynamics def reset_dynamics ( self , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], lin_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], ang_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> None Resets the pose and velocities of the bag Parameters: Name Type Description Default pos npt.ArrayLike Position, shape (3,) None orn npt.ArrayLike XYZW quaternion orientation, shape (4,) None lin_vel npt.ArrayLike Linear velocity, shape (3,) None ang_vel npt.ArrayLike Angular velocity, shape (3,) None View Source def reset_dynamics ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , lin_vel : npt . ArrayLike , ang_vel : npt . ArrayLike , ) -> None : \"\"\"Resets the pose and velocities of the bag Args: pos (npt.ArrayLike): Position, shape (3,) orn (npt.ArrayLike): XYZW quaternion orientation, shape (4,) lin_vel (npt.ArrayLike): Linear velocity, shape (3,) ang_vel (npt.ArrayLike): Angular velocity, shape (3,) \"\"\" self . client . resetBasePositionAndOrientation ( self . id , pos , orn ) self . client . resetBaseVelocity ( self . id , lin_vel , ang_vel ) reset_to_handle_pose def reset_to_handle_pose ( self , handle_pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], handle_index : int = 0 ) -> None Resets the position of the bag so that the handle is positioned at a desired pose Parameters: Name Type Description Default handle_pose npt.ArrayLike Desired pose of the handle (\"handle-to-world\"), shape (7,) None handle_index int Index of the handle to align to the desired pose. Defaults to 0. 0 View Source def reset_to_handle_pose ( self , handle_pose : npt . ArrayLike , handle_index : int = 0 ) -> None : \"\"\"Resets the position of the bag so that the handle is positioned at a desired pose Args: handle_pose (npt.ArrayLike): Desired pose of the handle (\" handle - to - world \"), shape (7,) handle_index (int, optional): Index of the handle to align to the desired pose. Defaults to 0. \"\"\" handle_to_world = pos_quat_to_tmat ( handle_pose ) bag_to_handle = invert_transform_mat ( self . grasp_transforms [ handle_index ] ) bag_to_world = handle_to_world @ bag_to_handle bag_pose = tmat_to_pos_quat ( bag_to_world ) # This assumes that we want the bag to be stationary self . reset_dynamics ( bag_pose [ :3 ] , bag_pose [ 3: ] , np . zeros ( 3 ), np . zeros ( 3 )) unload def unload ( self ) -> None Removes the cargo bag from the simulation View Source def unload ( self ) -> None : \"\"\"Removes the cargo bag from the simulation\"\"\" self . detach () self . client . removeBody ( self . id ) self . id = None","title":"Constraint Bag"},{"location":"reference/pyastrobee/core/constraint_bag/#module-pyastrobeecoreconstraint_bag","text":"Modeling a cargo bag as a single rigid box with a handle constructed from multiple point-to-point constraints Documentation for inherited methods can be found in the base class View Source \"\"\"Modeling a cargo bag as a single rigid box with a handle constructed from multiple point-to-point constraints Documentation for inherited methods can be found in the base class \"\"\" import time from typing import Optional import numpy as np import numpy.typing as npt import pybullet from pybullet_utils.bullet_client import BulletClient from pyastrobee.core.astrobee import Astrobee from pyastrobee.core.abstract_bag import CargoBag from pyastrobee.utils.bullet_utils import create_box from pyastrobee.utils.transformations import transform_point from pyastrobee.utils.python_utils import print_green from pyastrobee.utils.bullet_utils import initialize_pybullet # Different geometries of the constraint \"constellation\" # First point is the central (primary) constraint # Notes: tetrahedron seems to give a bit better behavior than diamond -- diamond will sometimes \"snap\" into place, # which doesn't really make sense for a handle. Plus, tetrahedron has fewer constraints, which is better for sim UNIT_CONSTRAINT_STRUCTURES = { \"diamond\" : np . array ( [ [ 0 , 0 , 0 ], [ 1 , 0 , 0 ], [ - 1 , 0 , 0 ], [ 0 , 1 , 0 ], [ 0 , - 1 , 0 ], [ 0 , 0 , 1 ], [ 0 , 0 , - 1 ], ] ), \"tetrahedron\" : np . array ( [ [ 0 , 0 , 0 ], [ - 1 / 3 , np . sqrt ( 8 / 9 ), 0 ], [ - 1 / 3 , - np . sqrt ( 2 / 9 ), np . sqrt ( 2 / 3 )], [ - 1 / 3 , - np . sqrt ( 2 / 9 ), - np . sqrt ( 2 / 3 )], [ 1 , 0 , 0 ], ] ), \"xy_cross\" : np . array ( [ [ 0 , 0 , 0 ], [ 1 , 0 , 0 ], [ - 1 , 0 , 0 ], [ 0 , 1 , 0 ], [ 0 , - 1 , 0 ], ] ), \"xz_cross\" : np . array ( [ [ 0 , 0 , 0 ], [ 1 , 0 , 0 ], [ - 1 , 0 , 0 ], [ 0 , 0 , 1 ], [ 0 , 0 , - 1 ], ] ), \"yz_cross\" : np . array ( [ [ 0 , 0 , 0 ], [ 0 , 1 , 0 ], [ 0 , - 1 , 0 ], [ 0 , 0 , 1 ], [ 0 , 0 , - 1 ], ] ), \"x_inline\" : np . array ( [ [ 0 , 0 , 0 ], [ 1 , 0 , 0 ], [ - 1 , 0 , 0 ], ] ), \"y_inline\" : np . array ( [ [ 0 , 0 , 0 ], [ 0 , 1 , 0 ], [ 0 , - 1 , 0 ], ] ), \"z_inline\" : np . array ( [ [ 0 , 0 , 0 ], [ 0 , 0 , 1 ], [ 0 , 0 , - 1 ], ] ), } class ConstraintCargoBag ( CargoBag ): \"\"\"Class for loading and managing properties associated with the constraint-based cargo bags Args: bag_name (str): Type of cargo bag to load. Single handle: \"front_handle\", \"right_handle\", \"top_handle\". Dual handle: \"front_back_handle\", \"right_left_handle\", \"top_bottom_handle\" mass (float): Mass of the cargo bag, in kg pos (npt.ArrayLike, optional): Initial XYZ position to load the bag. Defaults to (0, 0, 0) orn (npt.ArrayLike, optional): Initial XYZW quaternion to load the bag. Defaults to (0, 0, 0, 1) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" def __init__ ( self , bag_name : str , mass : float , pos : npt . ArrayLike = ( 0 , 0 , 0 ), orn : npt . ArrayLike = ( 0 , 0 , 0 , 1 ), client : BulletClient | None = None , ): # Set up the geometric structure of the constraint-based handle self . constraint_scaling = 0.05 self . constraint_structure_type = \"tetrahedron\" self . constraint_structure = ( UNIT_CONSTRAINT_STRUCTURES [ self . constraint_structure_type ] * self . constraint_scaling ) # Define the forces applied by the constraints self . primary_constraint_force = 3 self . secondary_constraint_force = 2 self . max_constraint_forces = np . concatenate ( [ [ self . primary_constraint_force ], self . secondary_constraint_force * np . ones ( len ( self . constraint_structure ) - 1 ), ] ) self . _constraints = {} self . num_contraints = len ( self . constraint_structure ) super () . __init__ ( bag_name , mass , pos , orn , client ) print_green ( \"Bag is ready\" ) # Implement abstract methods def _load ( self , pos : npt . ArrayLike , orn : npt . ArrayLike ) -> int : return create_box ( pos , orn , self . mass , ( self . LENGTH , self . WIDTH , self . HEIGHT ), True , ( 1 , 1 , 1 , 1 ), ) def _attach ( self , robot : Astrobee , handle_index : int ) -> None : # Disable collisions with the arm for stability when resetting the position w.r.t the deformable for link_id in [ robot . Links . GRIPPER_LEFT_DISTAL . value , robot . Links . GRIPPER_RIGHT_DISTAL . value , robot . Links . GRIPPER_LEFT_PROXIMAL . value , robot . Links . GRIPPER_RIGHT_PROXIMAL . value , robot . Links . ARM_DISTAL . value , robot . Links . ARM_PROXIMAL . value , ]: self . client . setCollisionFilterPair ( robot . id , self . id , link_id , - 1 , 0 ) constraints = form_constraint_grasp ( robot , self . id , self . grasp_transforms [ handle_index ], self . constraint_structure_type , self . constraint_scaling , self . max_constraint_forces , client = self . client , ) self . _constraints . update ({ robot . id : constraints }) self . _attached . append ( robot . id ) def detach ( self ) -> None : for robot_id , cids in self . constraints . items (): for cid in cids : self . client . removeConstraint ( cid ) self . _attached = [] self . _constraints = {} def detach_robot ( self , robot_id : int ) -> None : if robot_id not in self . constraints : raise ValueError ( \"Cannot detach robot: ID unknown\" ) for cid in self . constraints [ robot_id ]: self . client . removeConstraint ( cid ) self . _attached . remove ( robot_id ) self . _constraints . pop ( robot_id ) # Functions and properties specific to the constraint-based bag @property def constraints ( self ) -> dict [ int , list [ int ]]: \"\"\"Constraints between the robot(s) and the handle(s). Key: robot ID; Value: list of constraint IDs\"\"\" return self . _constraints def get_local_constraint_pos ( self , handle_index : int ) -> np . ndarray : \"\"\"Determine the position of the handle's constraints in the bag frame Args: handle_index (int): Index of the handle of interest Returns: np.ndarray: Constraint positions, shape (n_constraints, 3) \"\"\" return np . array ( [ transform_point ( self . grasp_transforms [ handle_index ], pt ) for pt in self . constraint_structure ] ) def get_world_constraint_pos ( self , handle_index : int ) -> np . ndarray : \"\"\"Determine the position of the handle's constraints in the world frame Args: handle_index (int): Index of the handle of interest Returns: np.ndarray: Constraint positions, shape (n_constraints, 3) \"\"\" tmat = self . tmat local_constraint_pos = self . get_local_constraint_pos ( handle_index ) return np . array ([ transform_point ( tmat , pos ) for pos in local_constraint_pos ]) @property def constraint_forces ( self ) -> dict [ int , float ]: \"\"\"Forces on each constraint. Key: constraint ID; Value: Force, shape (3,)\"\"\" # NOTE: this dictionary will maintain insertion order so we can also associate # these constraint forces in the same order as the original structure forces = {} for robot_id , cids in self . constraints . items (): for cid in cids : forces [ cid ] = self . client . getConstraintState ( cid ) return forces def form_constraint_grasp ( robot : Astrobee , body_id : int , grasp_transform : np . ndarray , structure_type : str , structure_scaling : float , max_forces : list [ float ], client : Optional [ BulletClient ] = None , ) -> list [ int ]: \"\"\"Connects the Astrobee's gripper to an object via point-to-point constraints to mimic a non-rigid grasp NOTE: Depending on the grasp transform used, it may be recommended to disable collisions between the Astrobee gripper and the object before forming these constraints Args: robot (Astrobee): Astrobee performing the grasp body_id (int): Pybullet ID of the object being grasped grasp_transform (np.ndarray): Transformation matrix defining the grasp pose w.r.t the base frame of the object structure_type (str, optional): Type of geometry to construct the series of constraints. Defaults to \"tetrahedron\". Other options include \"diamond\" structure_scaling (float, optional): Scale on the size of the constraint structure (if set to 1, the constraints will be spaced along a unit (1 meter) sphere). Defaults to 0.05. max_forces (list[float]): Maximum applied force for each constraint. Length must match with the number of constraints in the desired structure type client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: list[int]: Pybullet IDs of the constraints \"\"\" client : pybullet = pybullet if client is None else client constraint_structure = ( UNIT_CONSTRAINT_STRUCTURES [ structure_type ] * structure_scaling ) if len ( max_forces ) != len ( constraint_structure ): raise ValueError ( f \"Invalid number of forces: Must be of length { len ( constraint_structure ) } \" + f \"for structure type { structure_type } . \\n Got: { max_forces } \" ) body_local_constraint_pos = np . array ( [ transform_point ( grasp_transform , pt ) for pt in constraint_structure ] ) robot_local_constraint_pos = np . array ( [ transform_point ( Astrobee . TRANSFORMS . GRIPPER_TO_ARM_DISTAL , pt ) for pt in constraint_structure ] ) constraints = [] for i in range ( len ( constraint_structure )): cid = client . createConstraint ( robot . id , robot . Links . ARM_DISTAL . value , body_id , - 1 , client . JOINT_POINT2POINT , ( 0 , 0 , 1 ), robot_local_constraint_pos [ i ], body_local_constraint_pos [ i ], ) client . changeConstraint ( cid , maxForce = max_forces [ i ]) constraints . append ( cid ) return constraints def _main (): client = initialize_pybullet ( bg_color = ( 0.5 , 0.5 , 1 )) client . configureDebugVisualizer ( client . COV_ENABLE_WIREFRAME , 1 ) robot = Astrobee () # robot2 = Astrobee() bag = ConstraintCargoBag ( \"top_handle\" , 10 ) # bag.attach_to([robot, robot2]) bag . attach_to ( robot ) points_uid = None while True : forces = np . array ( list ( bag . constraint_forces . values ())) force_mags = np . linalg . norm ( forces , axis = 1 ) rgbs = [] for i in range ( bag . num_contraints ): r = min ( 1 , force_mags [ i ] / bag . max_constraint_forces [ i ]) rgbs . append (( r , 1 - r , 0 )) world_constraint_pos = bag . get_world_constraint_pos ( 0 ) if points_uid is None : points_uid = client . addUserDebugPoints ( world_constraint_pos , rgbs , 10 , 0 ) else : points_uid = client . addUserDebugPoints ( world_constraint_pos , rgbs , 10 , 0 , replaceItemUniqueId = points_uid ) client . stepSimulation () time . sleep ( 1 / 120 ) if __name__ == \"__main__\" : _main ()","title":"Module pyastrobee.core.constraint_bag"},{"location":"reference/pyastrobee/core/constraint_bag/#variables","text":"UNIT_CONSTRAINT_STRUCTURES","title":"Variables"},{"location":"reference/pyastrobee/core/constraint_bag/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/core/constraint_bag/#form_constraint_grasp","text":"def form_constraint_grasp ( robot : pyastrobee . core . astrobee . Astrobee , body_id : int , grasp_transform : numpy . ndarray , structure_type : str , structure_scaling : float , max_forces : list [ float ], client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> list [ int ] Connects the Astrobee's gripper to an object via point-to-point constraints to mimic a non-rigid grasp NOTE: Depending on the grasp transform used, it may be recommended to disable collisions between the Astrobee gripper and the object before forming these constraints Parameters: Name Type Description Default robot Astrobee Astrobee performing the grasp None body_id int Pybullet ID of the object being grasped None grasp_transform np.ndarray Transformation matrix defining the grasp pose w.r.t the base frame of the object None structure_type str Type of geometry to construct the series of constraints. Defaults to \"tetrahedron\". Other options include \"diamond\" None structure_scaling float Scale on the size of the constraint structure (if set to 1, the constraints will be spaced along a unit (1 meter) sphere). Defaults to 0.05. None max_forces list[float] Maximum applied force for each constraint. Length must match with the number of constraints in the desired structure type None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Returns: Type Description list[int] Pybullet IDs of the constraints View Source def form_constraint_grasp ( robot : Astrobee , body_id : int , grasp_transform : np . ndarray , structure_type : str , structure_scaling : float , max_forces : list [ float ] , client : Optional [ BulletClient ] = None , ) -> list [ int ] : \"\"\"Connects the Astrobee's gripper to an object via point-to-point constraints to mimic a non-rigid grasp NOTE: Depending on the grasp transform used, it may be recommended to disable collisions between the Astrobee gripper and the object before forming these constraints Args: robot (Astrobee): Astrobee performing the grasp body_id (int): Pybullet ID of the object being grasped grasp_transform (np.ndarray): Transformation matrix defining the grasp pose w.r.t the base frame of the object structure_type (str, optional): Type of geometry to construct the series of constraints. Defaults to \" tetrahedron \". Other options include \" diamond \" structure_scaling (float, optional): Scale on the size of the constraint structure (if set to 1, the constraints will be spaced along a unit (1 meter) sphere). Defaults to 0.05. max_forces (list[float]): Maximum applied force for each constraint. Length must match with the number of constraints in the desired structure type client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: list[int]: Pybullet IDs of the constraints \"\"\" client : pybullet = pybullet if client is None else client constraint_structure = ( UNIT_CONSTRAINT_STRUCTURES [ structure_type ] * structure_scaling ) if len ( max_forces ) != len ( constraint_structure ) : raise ValueError ( f \"Invalid number of forces: Must be of length {len(constraint_structure)} \" + f \"for structure type {structure_type}.\\nGot: {max_forces}\" ) body_local_constraint_pos = np . array ( [ transform_point(grasp_transform, pt) for pt in constraint_structure ] ) robot_local_constraint_pos = np . array ( [ transform_point(Astrobee.TRANSFORMS.GRIPPER_TO_ARM_DISTAL, pt) for pt in constraint_structure ] ) constraints = [] for i in range ( len ( constraint_structure )) : cid = client . createConstraint ( robot . id , robot . Links . ARM_DISTAL . value , body_id , - 1 , client . JOINT_POINT2POINT , ( 0 , 0 , 1 ), robot_local_constraint_pos [ i ] , body_local_constraint_pos [ i ] , ) client . changeConstraint ( cid , maxForce = max_forces [ i ] ) constraints . append ( cid ) return constraints","title":"form_constraint_grasp"},{"location":"reference/pyastrobee/core/constraint_bag/#classes","text":"","title":"Classes"},{"location":"reference/pyastrobee/core/constraint_bag/#constraintcargobag","text":"class ConstraintCargoBag ( bag_name : str , mass : float , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 0 , 0 , 0 ), orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 0 , 0 , 0 , 1 ), client : pybullet_utils . bullet_client . BulletClient | None = None ) Class for loading and managing properties associated with the constraint-based cargo bags","title":"ConstraintCargoBag"},{"location":"reference/pyastrobee/core/constraint_bag/#attributes","text":"Name Type Description Default bag_name str Type of cargo bag to load. Single handle: \"front_handle\", \"right_handle\", \"top_handle\". Dual handle: \"front_back_handle\", \"right_left_handle\", \"top_bottom_handle\" None mass float Mass of the cargo bag, in kg None pos npt.ArrayLike Initial XYZ position to load the bag. Defaults to (0, 0, 0) None orn npt.ArrayLike Initial XYZW quaternion to load the bag. Defaults to (0, 0, 0, 1) None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None View Source class ConstraintCargoBag ( CargoBag ): \"\"\"Class for loading and managing properties associated with the constraint-based cargo bags Args: bag_name (str): Type of cargo bag to load. Single handle: \"front_handle\", \"right_handle\", \"top_handle\". Dual handle: \"front_back_handle\", \"right_left_handle\", \"top_bottom_handle\" mass (float): Mass of the cargo bag, in kg pos (npt.ArrayLike, optional): Initial XYZ position to load the bag. Defaults to (0, 0, 0) orn (npt.ArrayLike, optional): Initial XYZW quaternion to load the bag. Defaults to (0, 0, 0, 1) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" def __init__ ( self , bag_name : str , mass : float , pos : npt . ArrayLike = ( 0 , 0 , 0 ), orn : npt . ArrayLike = ( 0 , 0 , 0 , 1 ), client : BulletClient | None = None , ): # Set up the geometric structure of the constraint-based handle self . constraint_scaling = 0.05 self . constraint_structure_type = \"tetrahedron\" self . constraint_structure = ( UNIT_CONSTRAINT_STRUCTURES [ self . constraint_structure_type ] * self . constraint_scaling ) # Define the forces applied by the constraints self . primary_constraint_force = 3 self . secondary_constraint_force = 2 self . max_constraint_forces = np . concatenate ( [ [ self . primary_constraint_force ], self . secondary_constraint_force * np . ones ( len ( self . constraint_structure ) - 1 ), ] ) self . _constraints = {} self . num_contraints = len ( self . constraint_structure ) super () . __init__ ( bag_name , mass , pos , orn , client ) print_green ( \"Bag is ready\" ) # Implement abstract methods def _load ( self , pos : npt . ArrayLike , orn : npt . ArrayLike ) -> int : return create_box ( pos , orn , self . mass , ( self . LENGTH , self . WIDTH , self . HEIGHT ), True , ( 1 , 1 , 1 , 1 ), ) def _attach ( self , robot : Astrobee , handle_index : int ) -> None : # Disable collisions with the arm for stability when resetting the position w.r.t the deformable for link_id in [ robot . Links . GRIPPER_LEFT_DISTAL . value , robot . Links . GRIPPER_RIGHT_DISTAL . value , robot . Links . GRIPPER_LEFT_PROXIMAL . value , robot . Links . GRIPPER_RIGHT_PROXIMAL . value , robot . Links . ARM_DISTAL . value , robot . Links . ARM_PROXIMAL . value , ]: self . client . setCollisionFilterPair ( robot . id , self . id , link_id , - 1 , 0 ) constraints = form_constraint_grasp ( robot , self . id , self . grasp_transforms [ handle_index ], self . constraint_structure_type , self . constraint_scaling , self . max_constraint_forces , client = self . client , ) self . _constraints . update ({ robot . id : constraints }) self . _attached . append ( robot . id ) def detach ( self ) -> None : for robot_id , cids in self . constraints . items (): for cid in cids : self . client . removeConstraint ( cid ) self . _attached = [] self . _constraints = {} def detach_robot ( self , robot_id : int ) -> None : if robot_id not in self . constraints : raise ValueError ( \"Cannot detach robot: ID unknown\" ) for cid in self . constraints [ robot_id ]: self . client . removeConstraint ( cid ) self . _attached . remove ( robot_id ) self . _constraints . pop ( robot_id ) # Functions and properties specific to the constraint-based bag @ property def constraints ( self ) -> dict [ int , list [ int ]]: \"\"\"Constraints between the robot(s) and the handle(s). Key: robot ID; Value: list of constraint IDs\"\"\" return self . _constraints def get_local_constraint_pos ( self , handle_index : int ) -> np . ndarray : \"\"\"Determine the position of the handle's constraints in the bag frame Args: handle_index (int): Index of the handle of interest Returns: np.ndarray: Constraint positions, shape (n_constraints, 3) \"\"\" return np . array ( [ transform_point ( self . grasp_transforms [ handle_index ], pt ) for pt in self . constraint_structure ] ) def get_world_constraint_pos ( self , handle_index : int ) -> np . ndarray : \"\"\"Determine the position of the handle's constraints in the world frame Args: handle_index (int): Index of the handle of interest Returns: np.ndarray: Constraint positions, shape (n_constraints, 3) \"\"\" tmat = self . tmat local_constraint_pos = self . get_local_constraint_pos ( handle_index ) return np . array ([ transform_point ( tmat , pos ) for pos in local_constraint_pos ]) @ property def constraint_forces ( self ) -> dict [ int , float ]: \"\"\"Forces on each constraint. Key: constraint ID; Value: Force, shape (3,)\"\"\" # NOTE: this dictionary will maintain insertion order so we can also associate # these constraint forces in the same order as the original structure forces = {} for robot_id , cids in self . constraints . items (): for cid in cids : forces [ cid ] = self . client . getConstraintState ( cid ) return forces","title":"Attributes"},{"location":"reference/pyastrobee/core/constraint_bag/#ancestors-in-mro","text":"pyastrobee.core.abstract_bag.CargoBag abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/pyastrobee/core/constraint_bag/#class-variables","text":"BAG_NAMES DUAL_HANDLE_BAGS HANDLE_TRANSFORMS HEIGHT LENGTH MESH_DIR SINGLE_HANDLE_BAGS URDF_DIR WIDTH","title":"Class variables"},{"location":"reference/pyastrobee/core/constraint_bag/#instance-variables","text":"angular_velocity Current [wx, wy, wz] angular velocity of the cargo bag's COM frame If both velocity and angular velocity are desired, use the dynamics_state property instead attached ID(s) of the robot (or robots) grasping the bag. Empty if no robots are attached bounding_box Current axis-aligned bounding box of the bag (or just the main compartment), shape (2, 3) constraint_forces Forces on each constraint. Key: constraint ID; Value: Force, shape (3,) constraints Constraints between the robot(s) and the handle(s). Key: robot ID; Value: list of constraint IDs corner_positions Positions of the 8 corners of the main compartment of the bag, shape (8, 3) dynamics_state Current state of the bag dynamics: Position, orientation, linear vel, and angular vel grasp_transforms Transformation matrices \"handle to bag\" representing the grasp locations on the handles to the bag COM In the case of a single-handled bag, this list will only have one entry mass Mass of the cargo bag name Type of cargo bag num_handles Number of handles on the cargo bag orientation Current XYZW quaternion orientation of the cargo bag's COM frame pose Current position + XYZW quaternion pose of the bag position Current XYZ position of the origin (COM frame) of the cargo bag tmat Current transformation matrix for the cargo bag: (Bag to world) velocity Current [vx, vy, vz] velocity of the cargo bag's COM frame If both velocity and angular velocity are desired, use the dynamics_state property instead","title":"Instance variables"},{"location":"reference/pyastrobee/core/constraint_bag/#methods","text":"","title":"Methods"},{"location":"reference/pyastrobee/core/constraint_bag/#attach_to","text":"def attach_to ( self , robot_or_robots : Union [ pyastrobee . core . astrobee . Astrobee , list [ pyastrobee . core . astrobee . Astrobee ], tuple [ pyastrobee . core . astrobee . Astrobee ]], object_to_move : str = 'robot' ) -> None Attaches a robot (or multiple robots) to the handle(s) of the bag Parameters: Name Type Description Default robot_or_robots Union[Astrobee, list[Astrobee], tuple[Astrobee]] Robot(s) to attach to the bag None object_to_move str Either \"robot\" or \"bag\". This dictates what object will get its position reset in order to make the grasp connection. In general, it makes more sense to move the robot to the bag (default behavior) None Raises: Type Description ValueError For invalid inputs, or if the bag does not have enough handles for each robot NotImplementedError Multi-robot case with >2 robots View Source def attach_to ( self , robot_or_robots : Union [ Astrobee, list[Astrobee ] , tuple [ Astrobee ] ] , object_to_move : str = \"robot\" , ) -> None : \"\"\"Attaches a robot (or multiple robots) to the handle(s) of the bag Args: robot_or_robots (Union[Astrobee, list[Astrobee], tuple[Astrobee]]): Robot(s) to attach to the bag object_to_move (str, optional): Either \" robot \" or \" bag \". This dictates what object will get its position reset in order to make the grasp connection. In general, it makes more sense to move the robot to the bag (default behavior) Raises: ValueError: For invalid inputs, or if the bag does not have enough handles for each robot NotImplementedError: Multi-robot case with >2 robots \"\"\" # Handle inputs if isinstance ( robot_or_robots , Astrobee ) : # Single robot num_robots = 1 elif isinstance ( robot_or_robots , ( list , tuple )) : # Multi - robot if not all ( isinstance ( r , Astrobee ) for r in robot_or_robots ) : raise ValueError ( \"Non-Astrobee input detected\" ) num_robots = len ( robot_or_robots ) if self . num_handles < num_robots : raise ValueError ( f \"Bag does not have enough handles to support {num_robots} robots\" ) if num_robots == 1 : # Edge case : Unpack the list if only one robot robot_or_robots = robot_or_robots [ 0 ] else : raise ValueError ( \"Invalid input: Must provide either an Astrobee or a list of multiple Astrobees\" ) if object_to_move not in { \"robot\" , \"bag\" }: raise ValueError ( \"Invalid object to move: Must be either 'robot' or 'bag'.\" ) bag_to_world = pos_quat_to_tmat ( self . pose ) if num_robots == 1 : robot = robot_or_robots # Unpack list if object_to_move == \"robot\" : # Reset the position of the robot to interface with the handle handle_to_bag = self . grasp_transforms [ 0 ] handle_to_world = bag_to_world @ handle_to_bag handle_pose = tmat_to_pos_quat ( handle_to_world ) robot . reset_to_ee_pose ( handle_pose ) else : # Move the bag to the robot self . reset_to_handle_pose ( robot . ee_pose ) self . _attach ( robot , 0 ) elif num_robots == 2 : robot_1 , robot_2 = robot_or_robots # Unpack list if object_to_move == \"robot\" : # Reset the position of each robot to interface with the two handles handle_1_to_bag = self . grasp_transforms [ 0 ] handle_2_to_bag = self . grasp_transforms [ 1 ] handle_1_to_world = bag_to_world @ handle_1_to_bag handle_2_to_world = bag_to_world @ handle_2_to_bag robot_1 . reset_to_ee_pose ( tmat_to_pos_quat ( handle_1_to_world )) robot_2 . reset_to_ee_pose ( tmat_to_pos_quat ( handle_2_to_world )) self . _attach ( robot_1 , 0 ) self . _attach ( robot_2 , 1 ) else : # Move the bag while leaving the robots static raise NotImplementedError ( \"Attaching the bag to multiple robots requires moving at least 1 robot\" ) else : raise NotImplementedError ( \"The multi-robot case is only implemented for 2 Astrobees\" )","title":"attach_to"},{"location":"reference/pyastrobee/core/constraint_bag/#detach","text":"def detach ( self ) -> None Detach all connections to the bag View Source def detach ( self ) -> None : for robot_id , cids in self . constraints . items (): for cid in cids : self . client . removeConstraint ( cid ) self . _attached = [] self . _constraints = {}","title":"detach"},{"location":"reference/pyastrobee/core/constraint_bag/#detach_robot","text":"def detach_robot ( self , robot_id : int ) -> None Detaches a specific robot from the bag Parameters: Name Type Description Default robot_id int Pybullet ID of the robot to detach None View Source def detach_robot ( self , robot_id : int ) -> None : if robot_id not in self . constraints : raise ValueError ( \"Cannot detach robot: ID unknown\" ) for cid in self . constraints [ robot_id ] : self . client . removeConstraint ( cid ) self . _attached . remove ( robot_id ) self . _constraints . pop ( robot_id )","title":"detach_robot"},{"location":"reference/pyastrobee/core/constraint_bag/#get_local_constraint_pos","text":"def get_local_constraint_pos ( self , handle_index : int ) -> numpy . ndarray Determine the position of the handle's constraints in the bag frame Parameters: Name Type Description Default handle_index int Index of the handle of interest None Returns: Type Description np.ndarray Constraint positions, shape (n_constraints, 3) View Source def get_local_constraint_pos ( self , handle_index : int ) -> np . ndarray : \"\"\"Determine the position of the handle's constraints in the bag frame Args: handle_index (int): Index of the handle of interest Returns: np.ndarray: Constraint positions, shape (n_constraints, 3) \"\"\" return np . array ( [ transform_point(self.grasp_transforms[handle_index ] , pt ) for pt in self . constraint_structure ] )","title":"get_local_constraint_pos"},{"location":"reference/pyastrobee/core/constraint_bag/#get_world_constraint_pos","text":"def get_world_constraint_pos ( self , handle_index : int ) -> numpy . ndarray Determine the position of the handle's constraints in the world frame Parameters: Name Type Description Default handle_index int Index of the handle of interest None Returns: Type Description np.ndarray Constraint positions, shape (n_constraints, 3) View Source def get_world_constraint_pos ( self , handle_index : int ) -> np . ndarray : \"\"\"Determine the position of the handle's constraints in the world frame Args: handle_index (int): Index of the handle of interest Returns: np.ndarray: Constraint positions, shape (n_constraints, 3) \"\"\" tmat = self . tmat local_constraint_pos = self . get_local_constraint_pos ( handle_index ) return np . array ([ transform_point ( tmat , pos ) for pos in local_constraint_pos ])","title":"get_world_constraint_pos"},{"location":"reference/pyastrobee/core/constraint_bag/#reset_dynamics","text":"def reset_dynamics ( self , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], lin_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], ang_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> None Resets the pose and velocities of the bag Parameters: Name Type Description Default pos npt.ArrayLike Position, shape (3,) None orn npt.ArrayLike XYZW quaternion orientation, shape (4,) None lin_vel npt.ArrayLike Linear velocity, shape (3,) None ang_vel npt.ArrayLike Angular velocity, shape (3,) None View Source def reset_dynamics ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , lin_vel : npt . ArrayLike , ang_vel : npt . ArrayLike , ) -> None : \"\"\"Resets the pose and velocities of the bag Args: pos (npt.ArrayLike): Position, shape (3,) orn (npt.ArrayLike): XYZW quaternion orientation, shape (4,) lin_vel (npt.ArrayLike): Linear velocity, shape (3,) ang_vel (npt.ArrayLike): Angular velocity, shape (3,) \"\"\" self . client . resetBasePositionAndOrientation ( self . id , pos , orn ) self . client . resetBaseVelocity ( self . id , lin_vel , ang_vel )","title":"reset_dynamics"},{"location":"reference/pyastrobee/core/constraint_bag/#reset_to_handle_pose","text":"def reset_to_handle_pose ( self , handle_pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], handle_index : int = 0 ) -> None Resets the position of the bag so that the handle is positioned at a desired pose Parameters: Name Type Description Default handle_pose npt.ArrayLike Desired pose of the handle (\"handle-to-world\"), shape (7,) None handle_index int Index of the handle to align to the desired pose. Defaults to 0. 0 View Source def reset_to_handle_pose ( self , handle_pose : npt . ArrayLike , handle_index : int = 0 ) -> None : \"\"\"Resets the position of the bag so that the handle is positioned at a desired pose Args: handle_pose (npt.ArrayLike): Desired pose of the handle (\" handle - to - world \"), shape (7,) handle_index (int, optional): Index of the handle to align to the desired pose. Defaults to 0. \"\"\" handle_to_world = pos_quat_to_tmat ( handle_pose ) bag_to_handle = invert_transform_mat ( self . grasp_transforms [ handle_index ] ) bag_to_world = handle_to_world @ bag_to_handle bag_pose = tmat_to_pos_quat ( bag_to_world ) # This assumes that we want the bag to be stationary self . reset_dynamics ( bag_pose [ :3 ] , bag_pose [ 3: ] , np . zeros ( 3 ), np . zeros ( 3 ))","title":"reset_to_handle_pose"},{"location":"reference/pyastrobee/core/constraint_bag/#unload","text":"def unload ( self ) -> None Removes the cargo bag from the simulation View Source def unload ( self ) -> None : \"\"\"Removes the cargo bag from the simulation\"\"\" self . detach () self . client . removeBody ( self . id ) self . id = None","title":"unload"},{"location":"reference/pyastrobee/core/deformable_bag/","text":"Module pyastrobee.core.deformable_bag Deformable cargo bag, implemented via a tetrahedral (volumetric) mesh Documentation for inherited methods can be found in the base class View Source \"\"\"Deformable cargo bag, implemented via a tetrahedral (volumetric) mesh Documentation for inherited methods can be found in the base class \"\"\" # TODO !! Fix the softbody velocity issue # TODO ! the unloading mechanic is currently broken since it only removes the softbody and not the visual # TODO If the reliability of the softbody position/orientation is not good, use the get_bag_frame() function I made # TODO decide if the bag_props import can be handled better import time from typing import Optional from pybullet_utils.bullet_client import BulletClient import numpy as np import numpy.typing as npt from pyastrobee.core.abstract_bag import CargoBag import pyastrobee.config.bag_properties as bag_props from pyastrobee.core.astrobee import Astrobee from pyastrobee.utils.bullet_utils import ( load_deformable_object , create_anchor , initialize_pybullet , ) from pyastrobee.utils.mesh_utils import get_mesh_data , get_closest_mesh_vertex from pyastrobee.utils.python_utils import print_green , flatten from pyastrobee.utils.quaternions import quats_to_angular_velocities from pyastrobee.utils.poses import pos_quat_to_tmat from pyastrobee.utils.transformations import transform_point class DeformableCargoBag ( CargoBag ): \"\"\"Class for loading and managing properties associated with the deformable cargo bags Args: bag_name (str): Type of cargo bag to load. Single handle: \"front_handle\", \"right_handle\", \"top_handle\". Dual handle: \"front_back_handle\", \"right_left_handle\", \"top_bottom_handle\" mass (float): Mass of the cargo bag, in kg pos (npt.ArrayLike, optional): Initial XYZ position to load the bag. Defaults to (0, 0, 0) orn (npt.ArrayLike, optional): Initial XYZW quaternion to load the bag. Defaults to (0, 0, 0, 1) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" _objs = [ CargoBag . MESH_DIR + name + \".obj\" for name in CargoBag . BAG_NAMES ] _vtks = [ CargoBag . MESH_DIR + name + \".vtk\" for name in CargoBag . BAG_NAMES ] OBJS = dict ( zip ( CargoBag . BAG_NAMES , _objs )) VTKS = dict ( zip ( CargoBag . BAG_NAMES , _vtks )) BAG_CORNER_VERTS = { \"front_handle\" : bag_props . FRONT_HANDLE_BAG_CORNERS , \"right_handle\" : bag_props . RIGHT_HANDLE_BAG_CORNERS , \"top_handle\" : bag_props . TOP_HANDLE_BAG_CORNERS , \"front_back_handle\" : bag_props . FRONT_BACK_HANDLE_BAG_CORNERS , \"right_left_handle\" : bag_props . RIGHT_LEFT_HANDLE_BAG_CORNERS , \"top_bottom_handle\" : bag_props . TOP_BOTTOM_HANDLE_BAG_CORNERS , } def __init__ ( self , bag_name : str , mass : float , pos : npt . ArrayLike = ( 0 , 0 , 0 ), orn : npt . ArrayLike = ( 0 , 0 , 0 , 1 ), client : Optional [ BulletClient ] = None , ): super () . __init__ ( bag_name , mass , pos , orn , client ) # Initializations self . _anchors = {} self . _anchor_objects = {} self . _mesh_vertices = None self . _num_mesh_vertices = None print_green ( \"Bag is ready\" ) # Read-only physical properties defined at initialization of the bag @property def num_mesh_vertices ( self ) -> int : \"\"\"Number of vertices in the bag's mesh\"\"\" if self . id is None : raise AttributeError ( \"Mesh has not been loaded\" ) if self . _num_mesh_vertices is None : self . _num_mesh_vertices , self . _mesh_vertices = get_mesh_data ( self . id , self . client ) return self . _num_mesh_vertices @property def mesh_vertices ( self ) -> np . ndarray : \"\"\"Positions of the mesh vertices, shape (n, 3)\"\"\" if self . id is None : raise AttributeError ( \"Mesh has not been loaded\" ) self . _num_mesh_vertices , self . _mesh_vertices = get_mesh_data ( self . id , self . client ) return self . _mesh_vertices @property def bending_stiffness ( self ) -> float : \"\"\"Softbody bending stiffness parameter\"\"\" return bag_props . BENDING_STIFFNESS @property def damping_stiffness ( self ) -> float : \"\"\"Softbody damping stiffness parameter\"\"\" return bag_props . DAMPING_STIFFNESS @property def elastic_stiffness ( self ) -> float : \"\"\"Softbody elastic stiffness parameter\"\"\" return bag_props . ELASTIC_STIFFNESS @property def friction_coeff ( self ) -> float : \"\"\"Softbody friction coefficient\"\"\" return bag_props . FRICTION_COEFF @property def anchors ( self ) -> tuple [ list [ int ], list [ int ]]: \"\"\"Anchor IDs and IDs of their associated visual geometries\"\"\" # Unpack the list of lists in the anchor dictionaries return flatten ( self . _anchors . values ()), flatten ( self . _anchor_objects . values ()) @property def obj_file ( self ) -> str : \"\"\"Path to the .OBJ triangular mesh file\"\"\" return self . OBJS [ self . _name ] @property def vtk_file ( self ) -> str : \"\"\"Path to the .VTK tetrahedral mesh file\"\"\" return self . VTKS [ self . _name ] # NOTE: Any methods associated with velocity or angular velocity have special handling for the deformable @property def velocity ( self ) -> np . ndarray : \"\"\"Current [vx, vy, vz] velocity of the cargo bag's COM frame - If both velocity and angular velocity are desired, use the dynamics_state property instead \"\"\" return self . dynamics_state [ 2 ] @property def angular_velocity ( self ) -> np . ndarray : \"\"\"Current [wx, wy, wz] angular velocity of the cargo bag's COM frame - If both velocity and angular velocity are desired, use the dynamics_state property instead \"\"\" return self . dynamics_state [ 3 ] @property def dynamics_state ( self ) -> tuple [ np . ndarray , np . ndarray , np . ndarray , np . ndarray ]: \"\"\"Current state of the bag dynamics: Position, orientation, linear vel, and angular vel - NOTE this moves the simulation forward by 1 step - Bullet's velocity definition for softbodies is incorrect or not implemented. I've tried implementing this myself in the C++, but it is also not reliable. So instead, we'll need to step the sim in this call to do our own calculations Returns: tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: np.ndarray: Position, shape (3,) np.ndarray: XYZW quaternion orientation, shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) \"\"\" old_pos , old_orn = self . client . getBasePositionAndOrientation ( self . id ) # Step the sim to get a second reference frame we can use to determine velocity # This is not ideal, but it's the best way to do this until Pybullet's getBaseVelocity for softbodies works self . client . stepSimulation () new_pos , new_orn = self . client . getBasePositionAndOrientation ( self . id ) lin_vel = np . subtract ( new_pos , old_pos ) / self . _dt ang_vel = quats_to_angular_velocities ( np . row_stack ([ old_orn , new_orn ]), self . _dt ) if ang_vel . ndim > 1 : ang_vel = ang_vel [ 0 , :] # Return the stepped-ahead position since it's the most recent state we know about return ( np . array ( new_pos ), np . array ( new_orn ), np . array ( lin_vel ), np . array ( ang_vel ), ) # TODO decide if the non-mesh-based implementation from CargoBag works with the deformable?? @property def corner_positions ( self ) -> list [ np . ndarray ]: return self . mesh_vertices [ self . BAG_CORNER_VERTS [ self . name ]] def _load ( self , pos : npt . ArrayLike , orn : npt . ArrayLike ) -> int : texture = None scale = 1 self_collision = False return load_deformable_object ( self . obj_file , texture , scale , pos , orn , self . mass , self . bending_stiffness , self . damping_stiffness , self . elastic_stiffness , self . friction_coeff , self_collision , self . vtk_file , self . client , ) def _attach ( self , robot : Astrobee , handle_index : int ) -> None : del handle_index # Unused for the deformable bag # Generate the constraints between the bag and the robot # Originally, we made two anchors at the vertices closest to the gripper points # But, this seemed too \"floppy\" so I tried using 4 anchors # However, 4 anchors introduced weird disturbance forces when things weren't perfectly # symmetric and in the locations where they were expected to be # First, find the points on the mesh on either side # of the handle (Using the left/right gripper link frames as reference points), then create the anchors pos_1 = robot . get_link_transform ( robot . Links . GRIPPER_LEFT_DISTAL )[: 3 , 3 ] # pos_2 = robot.get_link_transform(robot.Links.GRIPPER_RIGHT_DISTAL)[:3, 3] ee_tmat = pos_quat_to_tmat ( robot . ee_pose ) # Dist from grasp position to the link dist = np . linalg . norm ( ee_tmat [: 3 , 3 ] - pos_1 ) # First two points correspond to the left and right side of the gripper, second two are front and back local_pts = ( np . array ( [ # [0, 1, 0], # Uncomment to change the configuration # [0, -1, 0], [ 0 , 0 , 1 ], [ 0 , 0 , - 1 ], ] ) * dist ) world_pts = [ transform_point ( ee_tmat , pt ) for pt in local_pts ] anchor_ids = [] geom_ids = [] for pt in world_pts : v_pos , v_id = get_closest_mesh_vertex ( pt , self . mesh_vertices ) a_id , g_id = create_anchor ( self . id , v_id , robot . id , robot . Links . ARM_DISTAL . value , add_geom = True , geom_pos = v_pos , client = self . client , ) anchor_ids . append ( a_id ) geom_ids . append ( g_id ) self . _anchors . update ({ robot . id : anchor_ids }) self . _anchor_objects . update ({ robot . id : geom_ids }) self . _attached . append ( robot . id ) def detach ( self ) -> None : anchors , anchor_objects = self . anchors for cid in anchors : self . client . removeConstraint ( cid ) for obj in anchor_objects : self . client . removeBody ( obj ) self . _anchors = {} self . _anchor_objects = {} self . _attached = [] def detach_robot ( self , robot_id : int ) -> None : if robot_id not in self . attached : raise ValueError ( \"Cannot detach robot: ID unknown\" ) for cid in self . _anchors [ robot_id ]: self . client . removeConstraint ( cid ) for obj in self . _anchor_objects [ robot_id ]: self . client . removeBody ( obj ) self . _anchors . pop ( robot_id ) self . _anchor_objects . pop ( robot_id ) self . _attached . remove ( robot_id ) def _main (): # Very simple example of loading the bag and attaching a robot client = initialize_pybullet ( bg_color = ( 0.5 , 0.5 , 0.75 )) robot = Astrobee () bag = DeformableCargoBag ( \"top_handle_symmetric\" , 10 ) bag . attach_to ( robot ) while True : client . stepSimulation () time . sleep ( 1 / 120 ) if __name__ == \"__main__\" : _main () Classes DeformableCargoBag class DeformableCargoBag ( bag_name : str , mass : float , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 0 , 0 , 0 ), orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 0 , 0 , 0 , 1 ), client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) Class for loading and managing properties associated with the deformable cargo bags Attributes Name Type Description Default bag_name str Type of cargo bag to load. Single handle: \"front_handle\", \"right_handle\", \"top_handle\". Dual handle: \"front_back_handle\", \"right_left_handle\", \"top_bottom_handle\" None mass float Mass of the cargo bag, in kg None pos npt.ArrayLike Initial XYZ position to load the bag. Defaults to (0, 0, 0) None orn npt.ArrayLike Initial XYZW quaternion to load the bag. Defaults to (0, 0, 0, 1) None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None View Source class DeformableCargoBag ( CargoBag ): \"\"\"Class for loading and managing properties associated with the deformable cargo bags Args: bag_name (str): Type of cargo bag to load. Single handle: \"front_handle\", \"right_handle\", \"top_handle\". Dual handle: \"front_back_handle\", \"right_left_handle\", \"top_bottom_handle\" mass (float): Mass of the cargo bag, in kg pos (npt.ArrayLike, optional): Initial XYZ position to load the bag. Defaults to (0, 0, 0) orn (npt.ArrayLike, optional): Initial XYZW quaternion to load the bag. Defaults to (0, 0, 0, 1) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" _objs = [ CargoBag . MESH_DIR + name + \".obj\" for name in CargoBag . BAG_NAMES ] _vtks = [ CargoBag . MESH_DIR + name + \".vtk\" for name in CargoBag . BAG_NAMES ] OBJS = dict ( zip ( CargoBag . BAG_NAMES , _objs )) VTKS = dict ( zip ( CargoBag . BAG_NAMES , _vtks )) BAG_CORNER_VERTS = { \"front_handle\" : bag_props . FRONT_HANDLE_BAG_CORNERS , \"right_handle\" : bag_props . RIGHT_HANDLE_BAG_CORNERS , \"top_handle\" : bag_props . TOP_HANDLE_BAG_CORNERS , \"front_back_handle\" : bag_props . FRONT_BACK_HANDLE_BAG_CORNERS , \"right_left_handle\" : bag_props . RIGHT_LEFT_HANDLE_BAG_CORNERS , \"top_bottom_handle\" : bag_props . TOP_BOTTOM_HANDLE_BAG_CORNERS , } def __init__ ( self , bag_name : str , mass : float , pos : npt . ArrayLike = ( 0 , 0 , 0 ), orn : npt . ArrayLike = ( 0 , 0 , 0 , 1 ), client : Optional [ BulletClient ] = None , ): super () . __init__ ( bag_name , mass , pos , orn , client ) # Initializations self . _anchors = {} self . _anchor_objects = {} self . _mesh_vertices = None self . _num_mesh_vertices = None print_green ( \"Bag is ready\" ) # Read-only physical properties defined at initialization of the bag @ property def num_mesh_vertices ( self ) -> int : \"\"\"Number of vertices in the bag's mesh\"\"\" if self . id is None : raise AttributeError ( \"Mesh has not been loaded\" ) if self . _num_mesh_vertices is None : self . _num_mesh_vertices , self . _mesh_vertices = get_mesh_data ( self . id , self . client ) return self . _num_mesh_vertices @ property def mesh_vertices ( self ) -> np . ndarray : \"\"\"Positions of the mesh vertices, shape (n, 3)\"\"\" if self . id is None : raise AttributeError ( \"Mesh has not been loaded\" ) self . _num_mesh_vertices , self . _mesh_vertices = get_mesh_data ( self . id , self . client ) return self . _mesh_vertices @ property def bending_stiffness ( self ) -> float : \"\"\"Softbody bending stiffness parameter\"\"\" return bag_props . BENDING_STIFFNESS @ property def damping_stiffness ( self ) -> float : \"\"\"Softbody damping stiffness parameter\"\"\" return bag_props . DAMPING_STIFFNESS @ property def elastic_stiffness ( self ) -> float : \"\"\"Softbody elastic stiffness parameter\"\"\" return bag_props . ELASTIC_STIFFNESS @ property def friction_coeff ( self ) -> float : \"\"\"Softbody friction coefficient\"\"\" return bag_props . FRICTION_COEFF @ property def anchors ( self ) -> tuple [ list [ int ], list [ int ]]: \"\"\"Anchor IDs and IDs of their associated visual geometries\"\"\" # Unpack the list of lists in the anchor dictionaries return flatten ( self . _anchors . values ()), flatten ( self . _anchor_objects . values ()) @ property def obj_file ( self ) -> str : \"\"\"Path to the .OBJ triangular mesh file\"\"\" return self . OBJS [ self . _name ] @ property def vtk_file ( self ) -> str : \"\"\"Path to the .VTK tetrahedral mesh file\"\"\" return self . VTKS [ self . _name ] # NOTE: Any methods associated with velocity or angular velocity have special handling for the deformable @ property def velocity ( self ) -> np . ndarray : \"\"\"Current [vx, vy, vz] velocity of the cargo bag's COM frame - If both velocity and angular velocity are desired, use the dynamics_state property instead \"\"\" return self . dynamics_state [ 2 ] @ property def angular_velocity ( self ) -> np . ndarray : \"\"\"Current [wx, wy, wz] angular velocity of the cargo bag's COM frame - If both velocity and angular velocity are desired, use the dynamics_state property instead \"\"\" return self . dynamics_state [ 3 ] @ property def dynamics_state ( self ) -> tuple [ np . ndarray , np . ndarray , np . ndarray , np . ndarray ]: \"\"\"Current state of the bag dynamics: Position, orientation, linear vel, and angular vel - NOTE this moves the simulation forward by 1 step - Bullet's velocity definition for softbodies is incorrect or not implemented. I've tried implementing this myself in the C++, but it is also not reliable. So instead, we'll need to step the sim in this call to do our own calculations Returns: tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: np.ndarray: Position, shape (3,) np.ndarray: XYZW quaternion orientation, shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) \"\"\" old_pos , old_orn = self . client . getBasePositionAndOrientation ( self . id ) # Step the sim to get a second reference frame we can use to determine velocity # This is not ideal, but it's the best way to do this until Pybullet's getBaseVelocity for softbodies works self . client . stepSimulation () new_pos , new_orn = self . client . getBasePositionAndOrientation ( self . id ) lin_vel = np . subtract ( new_pos , old_pos ) / self . _dt ang_vel = quats_to_angular_velocities ( np . row_stack ([ old_orn , new_orn ]), self . _dt ) if ang_vel . ndim > 1 : ang_vel = ang_vel [ 0 , :] # Return the stepped-ahead position since it's the most recent state we know about return ( np . array ( new_pos ), np . array ( new_orn ), np . array ( lin_vel ), np . array ( ang_vel ), ) # TODO decide if the non-mesh-based implementation from CargoBag works with the deformable?? @ property def corner_positions ( self ) -> list [ np . ndarray ]: return self . mesh_vertices [ self . BAG_CORNER_VERTS [ self . name ]] def _load ( self , pos : npt . ArrayLike , orn : npt . ArrayLike ) -> int : texture = None scale = 1 self_collision = False return load_deformable_object ( self . obj_file , texture , scale , pos , orn , self . mass , self . bending_stiffness , self . damping_stiffness , self . elastic_stiffness , self . friction_coeff , self_collision , self . vtk_file , self . client , ) def _attach ( self , robot : Astrobee , handle_index : int ) -> None : del handle_index # Unused for the deformable bag # Generate the constraints between the bag and the robot # Originally, we made two anchors at the vertices closest to the gripper points # But, this seemed too \"floppy\" so I tried using 4 anchors # However, 4 anchors introduced weird disturbance forces when things weren't perfectly # symmetric and in the locations where they were expected to be # First, find the points on the mesh on either side # of the handle (Using the left/right gripper link frames as reference points), then create the anchors pos_1 = robot . get_link_transform ( robot . Links . GRIPPER_LEFT_DISTAL )[: 3 , 3 ] # pos_2 = robot.get_link_transform(robot.Links.GRIPPER_RIGHT_DISTAL)[:3, 3] ee_tmat = pos_quat_to_tmat ( robot . ee_pose ) # Dist from grasp position to the link dist = np . linalg . norm ( ee_tmat [: 3 , 3 ] - pos_1 ) # First two points correspond to the left and right side of the gripper, second two are front and back local_pts = ( np . array ( [ # [0, 1, 0], # Uncomment to change the configuration # [0, -1, 0], [ 0 , 0 , 1 ], [ 0 , 0 , - 1 ], ] ) * dist ) world_pts = [ transform_point ( ee_tmat , pt ) for pt in local_pts ] anchor_ids = [] geom_ids = [] for pt in world_pts : v_pos , v_id = get_closest_mesh_vertex ( pt , self . mesh_vertices ) a_id , g_id = create_anchor ( self . id , v_id , robot . id , robot . Links . ARM_DISTAL . value , add_geom = True , geom_pos = v_pos , client = self . client , ) anchor_ids . append ( a_id ) geom_ids . append ( g_id ) self . _anchors . update ({ robot . id : anchor_ids }) self . _anchor_objects . update ({ robot . id : geom_ids }) self . _attached . append ( robot . id ) def detach ( self ) -> None : anchors , anchor_objects = self . anchors for cid in anchors : self . client . removeConstraint ( cid ) for obj in anchor_objects : self . client . removeBody ( obj ) self . _anchors = {} self . _anchor_objects = {} self . _attached = [] def detach_robot ( self , robot_id : int ) -> None : if robot_id not in self . attached : raise ValueError ( \"Cannot detach robot: ID unknown\" ) for cid in self . _anchors [ robot_id ]: self . client . removeConstraint ( cid ) for obj in self . _anchor_objects [ robot_id ]: self . client . removeBody ( obj ) self . _anchors . pop ( robot_id ) self . _anchor_objects . pop ( robot_id ) self . _attached . remove ( robot_id ) Ancestors (in MRO) pyastrobee.core.abstract_bag.CargoBag abc.ABC Class variables BAG_CORNER_VERTS BAG_NAMES DUAL_HANDLE_BAGS HANDLE_TRANSFORMS HEIGHT LENGTH MESH_DIR OBJS SINGLE_HANDLE_BAGS URDF_DIR VTKS WIDTH Instance variables anchors Anchor IDs and IDs of their associated visual geometries angular_velocity Current [wx, wy, wz] angular velocity of the cargo bag's COM frame If both velocity and angular velocity are desired, use the dynamics_state property instead attached ID(s) of the robot (or robots) grasping the bag. Empty if no robots are attached bending_stiffness Softbody bending stiffness parameter bounding_box Current axis-aligned bounding box of the bag (or just the main compartment), shape (2, 3) corner_positions damping_stiffness Softbody damping stiffness parameter dynamics_state Current state of the bag dynamics: Position, orientation, linear vel, and angular vel NOTE this moves the simulation forward by 1 step Bullet's velocity definition for softbodies is incorrect or not implemented. I've tried implementing this myself in the C++, but it is also not reliable. So instead, we'll need to step the sim in this call to do our own calculations elastic_stiffness Softbody elastic stiffness parameter friction_coeff Softbody friction coefficient grasp_transforms Transformation matrices \"handle to bag\" representing the grasp locations on the handles to the bag COM In the case of a single-handled bag, this list will only have one entry mass Mass of the cargo bag mesh_vertices Positions of the mesh vertices, shape (n, 3) name Type of cargo bag num_handles Number of handles on the cargo bag num_mesh_vertices Number of vertices in the bag's mesh obj_file Path to the .OBJ triangular mesh file orientation Current XYZW quaternion orientation of the cargo bag's COM frame pose Current position + XYZW quaternion pose of the bag position Current XYZ position of the origin (COM frame) of the cargo bag tmat Current transformation matrix for the cargo bag: (Bag to world) velocity Current [vx, vy, vz] velocity of the cargo bag's COM frame If both velocity and angular velocity are desired, use the dynamics_state property instead vtk_file Path to the .VTK tetrahedral mesh file Methods attach_to def attach_to ( self , robot_or_robots : Union [ pyastrobee . core . astrobee . Astrobee , list [ pyastrobee . core . astrobee . Astrobee ], tuple [ pyastrobee . core . astrobee . Astrobee ]], object_to_move : str = 'robot' ) -> None Attaches a robot (or multiple robots) to the handle(s) of the bag Parameters: Name Type Description Default robot_or_robots Union[Astrobee, list[Astrobee], tuple[Astrobee]] Robot(s) to attach to the bag None object_to_move str Either \"robot\" or \"bag\". This dictates what object will get its position reset in order to make the grasp connection. In general, it makes more sense to move the robot to the bag (default behavior) None Raises: Type Description ValueError For invalid inputs, or if the bag does not have enough handles for each robot NotImplementedError Multi-robot case with >2 robots View Source def attach_to ( self , robot_or_robots : Union [ Astrobee, list[Astrobee ] , tuple [ Astrobee ] ] , object_to_move : str = \"robot\" , ) -> None : \"\"\"Attaches a robot (or multiple robots) to the handle(s) of the bag Args: robot_or_robots (Union[Astrobee, list[Astrobee], tuple[Astrobee]]): Robot(s) to attach to the bag object_to_move (str, optional): Either \" robot \" or \" bag \". This dictates what object will get its position reset in order to make the grasp connection. In general, it makes more sense to move the robot to the bag (default behavior) Raises: ValueError: For invalid inputs, or if the bag does not have enough handles for each robot NotImplementedError: Multi-robot case with >2 robots \"\"\" # Handle inputs if isinstance ( robot_or_robots , Astrobee ) : # Single robot num_robots = 1 elif isinstance ( robot_or_robots , ( list , tuple )) : # Multi - robot if not all ( isinstance ( r , Astrobee ) for r in robot_or_robots ) : raise ValueError ( \"Non-Astrobee input detected\" ) num_robots = len ( robot_or_robots ) if self . num_handles < num_robots : raise ValueError ( f \"Bag does not have enough handles to support {num_robots} robots\" ) if num_robots == 1 : # Edge case : Unpack the list if only one robot robot_or_robots = robot_or_robots [ 0 ] else : raise ValueError ( \"Invalid input: Must provide either an Astrobee or a list of multiple Astrobees\" ) if object_to_move not in { \"robot\" , \"bag\" }: raise ValueError ( \"Invalid object to move: Must be either 'robot' or 'bag'.\" ) bag_to_world = pos_quat_to_tmat ( self . pose ) if num_robots == 1 : robot = robot_or_robots # Unpack list if object_to_move == \"robot\" : # Reset the position of the robot to interface with the handle handle_to_bag = self . grasp_transforms [ 0 ] handle_to_world = bag_to_world @ handle_to_bag handle_pose = tmat_to_pos_quat ( handle_to_world ) robot . reset_to_ee_pose ( handle_pose ) else : # Move the bag to the robot self . reset_to_handle_pose ( robot . ee_pose ) self . _attach ( robot , 0 ) elif num_robots == 2 : robot_1 , robot_2 = robot_or_robots # Unpack list if object_to_move == \"robot\" : # Reset the position of each robot to interface with the two handles handle_1_to_bag = self . grasp_transforms [ 0 ] handle_2_to_bag = self . grasp_transforms [ 1 ] handle_1_to_world = bag_to_world @ handle_1_to_bag handle_2_to_world = bag_to_world @ handle_2_to_bag robot_1 . reset_to_ee_pose ( tmat_to_pos_quat ( handle_1_to_world )) robot_2 . reset_to_ee_pose ( tmat_to_pos_quat ( handle_2_to_world )) self . _attach ( robot_1 , 0 ) self . _attach ( robot_2 , 1 ) else : # Move the bag while leaving the robots static raise NotImplementedError ( \"Attaching the bag to multiple robots requires moving at least 1 robot\" ) else : raise NotImplementedError ( \"The multi-robot case is only implemented for 2 Astrobees\" ) detach def detach ( self ) -> None Detach all connections to the bag View Source def detach ( self ) -> None : anchors , anchor_objects = self . anchors for cid in anchors : self . client . removeConstraint ( cid ) for obj in anchor_objects : self . client . removeBody ( obj ) self . _anchors = {} self . _anchor_objects = {} self . _attached = [] detach_robot def detach_robot ( self , robot_id : int ) -> None Detaches a specific robot from the bag Parameters: Name Type Description Default robot_id int Pybullet ID of the robot to detach None View Source def detach_robot ( self , robot_id : int ) -> None : if robot_id not in self . attached : raise ValueError ( \"Cannot detach robot: ID unknown\" ) for cid in self . _anchors [ robot_id ] : self . client . removeConstraint ( cid ) for obj in self . _anchor_objects [ robot_id ] : self . client . removeBody ( obj ) self . _anchors . pop ( robot_id ) self . _anchor_objects . pop ( robot_id ) self . _attached . remove ( robot_id ) reset_dynamics def reset_dynamics ( self , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], lin_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], ang_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> None Resets the pose and velocities of the bag Parameters: Name Type Description Default pos npt.ArrayLike Position, shape (3,) None orn npt.ArrayLike XYZW quaternion orientation, shape (4,) None lin_vel npt.ArrayLike Linear velocity, shape (3,) None ang_vel npt.ArrayLike Angular velocity, shape (3,) None View Source def reset_dynamics ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , lin_vel : npt . ArrayLike , ang_vel : npt . ArrayLike , ) -> None : \"\"\"Resets the pose and velocities of the bag Args: pos (npt.ArrayLike): Position, shape (3,) orn (npt.ArrayLike): XYZW quaternion orientation, shape (4,) lin_vel (npt.ArrayLike): Linear velocity, shape (3,) ang_vel (npt.ArrayLike): Angular velocity, shape (3,) \"\"\" self . client . resetBasePositionAndOrientation ( self . id , pos , orn ) self . client . resetBaseVelocity ( self . id , lin_vel , ang_vel ) reset_to_handle_pose def reset_to_handle_pose ( self , handle_pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], handle_index : int = 0 ) -> None Resets the position of the bag so that the handle is positioned at a desired pose Parameters: Name Type Description Default handle_pose npt.ArrayLike Desired pose of the handle (\"handle-to-world\"), shape (7,) None handle_index int Index of the handle to align to the desired pose. Defaults to 0. 0 View Source def reset_to_handle_pose ( self , handle_pose : npt . ArrayLike , handle_index : int = 0 ) -> None : \"\"\"Resets the position of the bag so that the handle is positioned at a desired pose Args: handle_pose (npt.ArrayLike): Desired pose of the handle (\" handle - to - world \"), shape (7,) handle_index (int, optional): Index of the handle to align to the desired pose. Defaults to 0. \"\"\" handle_to_world = pos_quat_to_tmat ( handle_pose ) bag_to_handle = invert_transform_mat ( self . grasp_transforms [ handle_index ] ) bag_to_world = handle_to_world @ bag_to_handle bag_pose = tmat_to_pos_quat ( bag_to_world ) # This assumes that we want the bag to be stationary self . reset_dynamics ( bag_pose [ :3 ] , bag_pose [ 3: ] , np . zeros ( 3 ), np . zeros ( 3 )) unload def unload ( self ) -> None Removes the cargo bag from the simulation View Source def unload ( self ) -> None : \"\"\"Removes the cargo bag from the simulation\"\"\" self . detach () self . client . removeBody ( self . id ) self . id = None","title":"Deformable Bag"},{"location":"reference/pyastrobee/core/deformable_bag/#module-pyastrobeecoredeformable_bag","text":"Deformable cargo bag, implemented via a tetrahedral (volumetric) mesh Documentation for inherited methods can be found in the base class View Source \"\"\"Deformable cargo bag, implemented via a tetrahedral (volumetric) mesh Documentation for inherited methods can be found in the base class \"\"\" # TODO !! Fix the softbody velocity issue # TODO ! the unloading mechanic is currently broken since it only removes the softbody and not the visual # TODO If the reliability of the softbody position/orientation is not good, use the get_bag_frame() function I made # TODO decide if the bag_props import can be handled better import time from typing import Optional from pybullet_utils.bullet_client import BulletClient import numpy as np import numpy.typing as npt from pyastrobee.core.abstract_bag import CargoBag import pyastrobee.config.bag_properties as bag_props from pyastrobee.core.astrobee import Astrobee from pyastrobee.utils.bullet_utils import ( load_deformable_object , create_anchor , initialize_pybullet , ) from pyastrobee.utils.mesh_utils import get_mesh_data , get_closest_mesh_vertex from pyastrobee.utils.python_utils import print_green , flatten from pyastrobee.utils.quaternions import quats_to_angular_velocities from pyastrobee.utils.poses import pos_quat_to_tmat from pyastrobee.utils.transformations import transform_point class DeformableCargoBag ( CargoBag ): \"\"\"Class for loading and managing properties associated with the deformable cargo bags Args: bag_name (str): Type of cargo bag to load. Single handle: \"front_handle\", \"right_handle\", \"top_handle\". Dual handle: \"front_back_handle\", \"right_left_handle\", \"top_bottom_handle\" mass (float): Mass of the cargo bag, in kg pos (npt.ArrayLike, optional): Initial XYZ position to load the bag. Defaults to (0, 0, 0) orn (npt.ArrayLike, optional): Initial XYZW quaternion to load the bag. Defaults to (0, 0, 0, 1) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" _objs = [ CargoBag . MESH_DIR + name + \".obj\" for name in CargoBag . BAG_NAMES ] _vtks = [ CargoBag . MESH_DIR + name + \".vtk\" for name in CargoBag . BAG_NAMES ] OBJS = dict ( zip ( CargoBag . BAG_NAMES , _objs )) VTKS = dict ( zip ( CargoBag . BAG_NAMES , _vtks )) BAG_CORNER_VERTS = { \"front_handle\" : bag_props . FRONT_HANDLE_BAG_CORNERS , \"right_handle\" : bag_props . RIGHT_HANDLE_BAG_CORNERS , \"top_handle\" : bag_props . TOP_HANDLE_BAG_CORNERS , \"front_back_handle\" : bag_props . FRONT_BACK_HANDLE_BAG_CORNERS , \"right_left_handle\" : bag_props . RIGHT_LEFT_HANDLE_BAG_CORNERS , \"top_bottom_handle\" : bag_props . TOP_BOTTOM_HANDLE_BAG_CORNERS , } def __init__ ( self , bag_name : str , mass : float , pos : npt . ArrayLike = ( 0 , 0 , 0 ), orn : npt . ArrayLike = ( 0 , 0 , 0 , 1 ), client : Optional [ BulletClient ] = None , ): super () . __init__ ( bag_name , mass , pos , orn , client ) # Initializations self . _anchors = {} self . _anchor_objects = {} self . _mesh_vertices = None self . _num_mesh_vertices = None print_green ( \"Bag is ready\" ) # Read-only physical properties defined at initialization of the bag @property def num_mesh_vertices ( self ) -> int : \"\"\"Number of vertices in the bag's mesh\"\"\" if self . id is None : raise AttributeError ( \"Mesh has not been loaded\" ) if self . _num_mesh_vertices is None : self . _num_mesh_vertices , self . _mesh_vertices = get_mesh_data ( self . id , self . client ) return self . _num_mesh_vertices @property def mesh_vertices ( self ) -> np . ndarray : \"\"\"Positions of the mesh vertices, shape (n, 3)\"\"\" if self . id is None : raise AttributeError ( \"Mesh has not been loaded\" ) self . _num_mesh_vertices , self . _mesh_vertices = get_mesh_data ( self . id , self . client ) return self . _mesh_vertices @property def bending_stiffness ( self ) -> float : \"\"\"Softbody bending stiffness parameter\"\"\" return bag_props . BENDING_STIFFNESS @property def damping_stiffness ( self ) -> float : \"\"\"Softbody damping stiffness parameter\"\"\" return bag_props . DAMPING_STIFFNESS @property def elastic_stiffness ( self ) -> float : \"\"\"Softbody elastic stiffness parameter\"\"\" return bag_props . ELASTIC_STIFFNESS @property def friction_coeff ( self ) -> float : \"\"\"Softbody friction coefficient\"\"\" return bag_props . FRICTION_COEFF @property def anchors ( self ) -> tuple [ list [ int ], list [ int ]]: \"\"\"Anchor IDs and IDs of their associated visual geometries\"\"\" # Unpack the list of lists in the anchor dictionaries return flatten ( self . _anchors . values ()), flatten ( self . _anchor_objects . values ()) @property def obj_file ( self ) -> str : \"\"\"Path to the .OBJ triangular mesh file\"\"\" return self . OBJS [ self . _name ] @property def vtk_file ( self ) -> str : \"\"\"Path to the .VTK tetrahedral mesh file\"\"\" return self . VTKS [ self . _name ] # NOTE: Any methods associated with velocity or angular velocity have special handling for the deformable @property def velocity ( self ) -> np . ndarray : \"\"\"Current [vx, vy, vz] velocity of the cargo bag's COM frame - If both velocity and angular velocity are desired, use the dynamics_state property instead \"\"\" return self . dynamics_state [ 2 ] @property def angular_velocity ( self ) -> np . ndarray : \"\"\"Current [wx, wy, wz] angular velocity of the cargo bag's COM frame - If both velocity and angular velocity are desired, use the dynamics_state property instead \"\"\" return self . dynamics_state [ 3 ] @property def dynamics_state ( self ) -> tuple [ np . ndarray , np . ndarray , np . ndarray , np . ndarray ]: \"\"\"Current state of the bag dynamics: Position, orientation, linear vel, and angular vel - NOTE this moves the simulation forward by 1 step - Bullet's velocity definition for softbodies is incorrect or not implemented. I've tried implementing this myself in the C++, but it is also not reliable. So instead, we'll need to step the sim in this call to do our own calculations Returns: tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: np.ndarray: Position, shape (3,) np.ndarray: XYZW quaternion orientation, shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) \"\"\" old_pos , old_orn = self . client . getBasePositionAndOrientation ( self . id ) # Step the sim to get a second reference frame we can use to determine velocity # This is not ideal, but it's the best way to do this until Pybullet's getBaseVelocity for softbodies works self . client . stepSimulation () new_pos , new_orn = self . client . getBasePositionAndOrientation ( self . id ) lin_vel = np . subtract ( new_pos , old_pos ) / self . _dt ang_vel = quats_to_angular_velocities ( np . row_stack ([ old_orn , new_orn ]), self . _dt ) if ang_vel . ndim > 1 : ang_vel = ang_vel [ 0 , :] # Return the stepped-ahead position since it's the most recent state we know about return ( np . array ( new_pos ), np . array ( new_orn ), np . array ( lin_vel ), np . array ( ang_vel ), ) # TODO decide if the non-mesh-based implementation from CargoBag works with the deformable?? @property def corner_positions ( self ) -> list [ np . ndarray ]: return self . mesh_vertices [ self . BAG_CORNER_VERTS [ self . name ]] def _load ( self , pos : npt . ArrayLike , orn : npt . ArrayLike ) -> int : texture = None scale = 1 self_collision = False return load_deformable_object ( self . obj_file , texture , scale , pos , orn , self . mass , self . bending_stiffness , self . damping_stiffness , self . elastic_stiffness , self . friction_coeff , self_collision , self . vtk_file , self . client , ) def _attach ( self , robot : Astrobee , handle_index : int ) -> None : del handle_index # Unused for the deformable bag # Generate the constraints between the bag and the robot # Originally, we made two anchors at the vertices closest to the gripper points # But, this seemed too \"floppy\" so I tried using 4 anchors # However, 4 anchors introduced weird disturbance forces when things weren't perfectly # symmetric and in the locations where they were expected to be # First, find the points on the mesh on either side # of the handle (Using the left/right gripper link frames as reference points), then create the anchors pos_1 = robot . get_link_transform ( robot . Links . GRIPPER_LEFT_DISTAL )[: 3 , 3 ] # pos_2 = robot.get_link_transform(robot.Links.GRIPPER_RIGHT_DISTAL)[:3, 3] ee_tmat = pos_quat_to_tmat ( robot . ee_pose ) # Dist from grasp position to the link dist = np . linalg . norm ( ee_tmat [: 3 , 3 ] - pos_1 ) # First two points correspond to the left and right side of the gripper, second two are front and back local_pts = ( np . array ( [ # [0, 1, 0], # Uncomment to change the configuration # [0, -1, 0], [ 0 , 0 , 1 ], [ 0 , 0 , - 1 ], ] ) * dist ) world_pts = [ transform_point ( ee_tmat , pt ) for pt in local_pts ] anchor_ids = [] geom_ids = [] for pt in world_pts : v_pos , v_id = get_closest_mesh_vertex ( pt , self . mesh_vertices ) a_id , g_id = create_anchor ( self . id , v_id , robot . id , robot . Links . ARM_DISTAL . value , add_geom = True , geom_pos = v_pos , client = self . client , ) anchor_ids . append ( a_id ) geom_ids . append ( g_id ) self . _anchors . update ({ robot . id : anchor_ids }) self . _anchor_objects . update ({ robot . id : geom_ids }) self . _attached . append ( robot . id ) def detach ( self ) -> None : anchors , anchor_objects = self . anchors for cid in anchors : self . client . removeConstraint ( cid ) for obj in anchor_objects : self . client . removeBody ( obj ) self . _anchors = {} self . _anchor_objects = {} self . _attached = [] def detach_robot ( self , robot_id : int ) -> None : if robot_id not in self . attached : raise ValueError ( \"Cannot detach robot: ID unknown\" ) for cid in self . _anchors [ robot_id ]: self . client . removeConstraint ( cid ) for obj in self . _anchor_objects [ robot_id ]: self . client . removeBody ( obj ) self . _anchors . pop ( robot_id ) self . _anchor_objects . pop ( robot_id ) self . _attached . remove ( robot_id ) def _main (): # Very simple example of loading the bag and attaching a robot client = initialize_pybullet ( bg_color = ( 0.5 , 0.5 , 0.75 )) robot = Astrobee () bag = DeformableCargoBag ( \"top_handle_symmetric\" , 10 ) bag . attach_to ( robot ) while True : client . stepSimulation () time . sleep ( 1 / 120 ) if __name__ == \"__main__\" : _main ()","title":"Module pyastrobee.core.deformable_bag"},{"location":"reference/pyastrobee/core/deformable_bag/#classes","text":"","title":"Classes"},{"location":"reference/pyastrobee/core/deformable_bag/#deformablecargobag","text":"class DeformableCargoBag ( bag_name : str , mass : float , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 0 , 0 , 0 ), orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 0 , 0 , 0 , 1 ), client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) Class for loading and managing properties associated with the deformable cargo bags","title":"DeformableCargoBag"},{"location":"reference/pyastrobee/core/deformable_bag/#attributes","text":"Name Type Description Default bag_name str Type of cargo bag to load. Single handle: \"front_handle\", \"right_handle\", \"top_handle\". Dual handle: \"front_back_handle\", \"right_left_handle\", \"top_bottom_handle\" None mass float Mass of the cargo bag, in kg None pos npt.ArrayLike Initial XYZ position to load the bag. Defaults to (0, 0, 0) None orn npt.ArrayLike Initial XYZW quaternion to load the bag. Defaults to (0, 0, 0, 1) None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None View Source class DeformableCargoBag ( CargoBag ): \"\"\"Class for loading and managing properties associated with the deformable cargo bags Args: bag_name (str): Type of cargo bag to load. Single handle: \"front_handle\", \"right_handle\", \"top_handle\". Dual handle: \"front_back_handle\", \"right_left_handle\", \"top_bottom_handle\" mass (float): Mass of the cargo bag, in kg pos (npt.ArrayLike, optional): Initial XYZ position to load the bag. Defaults to (0, 0, 0) orn (npt.ArrayLike, optional): Initial XYZW quaternion to load the bag. Defaults to (0, 0, 0, 1) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" _objs = [ CargoBag . MESH_DIR + name + \".obj\" for name in CargoBag . BAG_NAMES ] _vtks = [ CargoBag . MESH_DIR + name + \".vtk\" for name in CargoBag . BAG_NAMES ] OBJS = dict ( zip ( CargoBag . BAG_NAMES , _objs )) VTKS = dict ( zip ( CargoBag . BAG_NAMES , _vtks )) BAG_CORNER_VERTS = { \"front_handle\" : bag_props . FRONT_HANDLE_BAG_CORNERS , \"right_handle\" : bag_props . RIGHT_HANDLE_BAG_CORNERS , \"top_handle\" : bag_props . TOP_HANDLE_BAG_CORNERS , \"front_back_handle\" : bag_props . FRONT_BACK_HANDLE_BAG_CORNERS , \"right_left_handle\" : bag_props . RIGHT_LEFT_HANDLE_BAG_CORNERS , \"top_bottom_handle\" : bag_props . TOP_BOTTOM_HANDLE_BAG_CORNERS , } def __init__ ( self , bag_name : str , mass : float , pos : npt . ArrayLike = ( 0 , 0 , 0 ), orn : npt . ArrayLike = ( 0 , 0 , 0 , 1 ), client : Optional [ BulletClient ] = None , ): super () . __init__ ( bag_name , mass , pos , orn , client ) # Initializations self . _anchors = {} self . _anchor_objects = {} self . _mesh_vertices = None self . _num_mesh_vertices = None print_green ( \"Bag is ready\" ) # Read-only physical properties defined at initialization of the bag @ property def num_mesh_vertices ( self ) -> int : \"\"\"Number of vertices in the bag's mesh\"\"\" if self . id is None : raise AttributeError ( \"Mesh has not been loaded\" ) if self . _num_mesh_vertices is None : self . _num_mesh_vertices , self . _mesh_vertices = get_mesh_data ( self . id , self . client ) return self . _num_mesh_vertices @ property def mesh_vertices ( self ) -> np . ndarray : \"\"\"Positions of the mesh vertices, shape (n, 3)\"\"\" if self . id is None : raise AttributeError ( \"Mesh has not been loaded\" ) self . _num_mesh_vertices , self . _mesh_vertices = get_mesh_data ( self . id , self . client ) return self . _mesh_vertices @ property def bending_stiffness ( self ) -> float : \"\"\"Softbody bending stiffness parameter\"\"\" return bag_props . BENDING_STIFFNESS @ property def damping_stiffness ( self ) -> float : \"\"\"Softbody damping stiffness parameter\"\"\" return bag_props . DAMPING_STIFFNESS @ property def elastic_stiffness ( self ) -> float : \"\"\"Softbody elastic stiffness parameter\"\"\" return bag_props . ELASTIC_STIFFNESS @ property def friction_coeff ( self ) -> float : \"\"\"Softbody friction coefficient\"\"\" return bag_props . FRICTION_COEFF @ property def anchors ( self ) -> tuple [ list [ int ], list [ int ]]: \"\"\"Anchor IDs and IDs of their associated visual geometries\"\"\" # Unpack the list of lists in the anchor dictionaries return flatten ( self . _anchors . values ()), flatten ( self . _anchor_objects . values ()) @ property def obj_file ( self ) -> str : \"\"\"Path to the .OBJ triangular mesh file\"\"\" return self . OBJS [ self . _name ] @ property def vtk_file ( self ) -> str : \"\"\"Path to the .VTK tetrahedral mesh file\"\"\" return self . VTKS [ self . _name ] # NOTE: Any methods associated with velocity or angular velocity have special handling for the deformable @ property def velocity ( self ) -> np . ndarray : \"\"\"Current [vx, vy, vz] velocity of the cargo bag's COM frame - If both velocity and angular velocity are desired, use the dynamics_state property instead \"\"\" return self . dynamics_state [ 2 ] @ property def angular_velocity ( self ) -> np . ndarray : \"\"\"Current [wx, wy, wz] angular velocity of the cargo bag's COM frame - If both velocity and angular velocity are desired, use the dynamics_state property instead \"\"\" return self . dynamics_state [ 3 ] @ property def dynamics_state ( self ) -> tuple [ np . ndarray , np . ndarray , np . ndarray , np . ndarray ]: \"\"\"Current state of the bag dynamics: Position, orientation, linear vel, and angular vel - NOTE this moves the simulation forward by 1 step - Bullet's velocity definition for softbodies is incorrect or not implemented. I've tried implementing this myself in the C++, but it is also not reliable. So instead, we'll need to step the sim in this call to do our own calculations Returns: tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: np.ndarray: Position, shape (3,) np.ndarray: XYZW quaternion orientation, shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) \"\"\" old_pos , old_orn = self . client . getBasePositionAndOrientation ( self . id ) # Step the sim to get a second reference frame we can use to determine velocity # This is not ideal, but it's the best way to do this until Pybullet's getBaseVelocity for softbodies works self . client . stepSimulation () new_pos , new_orn = self . client . getBasePositionAndOrientation ( self . id ) lin_vel = np . subtract ( new_pos , old_pos ) / self . _dt ang_vel = quats_to_angular_velocities ( np . row_stack ([ old_orn , new_orn ]), self . _dt ) if ang_vel . ndim > 1 : ang_vel = ang_vel [ 0 , :] # Return the stepped-ahead position since it's the most recent state we know about return ( np . array ( new_pos ), np . array ( new_orn ), np . array ( lin_vel ), np . array ( ang_vel ), ) # TODO decide if the non-mesh-based implementation from CargoBag works with the deformable?? @ property def corner_positions ( self ) -> list [ np . ndarray ]: return self . mesh_vertices [ self . BAG_CORNER_VERTS [ self . name ]] def _load ( self , pos : npt . ArrayLike , orn : npt . ArrayLike ) -> int : texture = None scale = 1 self_collision = False return load_deformable_object ( self . obj_file , texture , scale , pos , orn , self . mass , self . bending_stiffness , self . damping_stiffness , self . elastic_stiffness , self . friction_coeff , self_collision , self . vtk_file , self . client , ) def _attach ( self , robot : Astrobee , handle_index : int ) -> None : del handle_index # Unused for the deformable bag # Generate the constraints between the bag and the robot # Originally, we made two anchors at the vertices closest to the gripper points # But, this seemed too \"floppy\" so I tried using 4 anchors # However, 4 anchors introduced weird disturbance forces when things weren't perfectly # symmetric and in the locations where they were expected to be # First, find the points on the mesh on either side # of the handle (Using the left/right gripper link frames as reference points), then create the anchors pos_1 = robot . get_link_transform ( robot . Links . GRIPPER_LEFT_DISTAL )[: 3 , 3 ] # pos_2 = robot.get_link_transform(robot.Links.GRIPPER_RIGHT_DISTAL)[:3, 3] ee_tmat = pos_quat_to_tmat ( robot . ee_pose ) # Dist from grasp position to the link dist = np . linalg . norm ( ee_tmat [: 3 , 3 ] - pos_1 ) # First two points correspond to the left and right side of the gripper, second two are front and back local_pts = ( np . array ( [ # [0, 1, 0], # Uncomment to change the configuration # [0, -1, 0], [ 0 , 0 , 1 ], [ 0 , 0 , - 1 ], ] ) * dist ) world_pts = [ transform_point ( ee_tmat , pt ) for pt in local_pts ] anchor_ids = [] geom_ids = [] for pt in world_pts : v_pos , v_id = get_closest_mesh_vertex ( pt , self . mesh_vertices ) a_id , g_id = create_anchor ( self . id , v_id , robot . id , robot . Links . ARM_DISTAL . value , add_geom = True , geom_pos = v_pos , client = self . client , ) anchor_ids . append ( a_id ) geom_ids . append ( g_id ) self . _anchors . update ({ robot . id : anchor_ids }) self . _anchor_objects . update ({ robot . id : geom_ids }) self . _attached . append ( robot . id ) def detach ( self ) -> None : anchors , anchor_objects = self . anchors for cid in anchors : self . client . removeConstraint ( cid ) for obj in anchor_objects : self . client . removeBody ( obj ) self . _anchors = {} self . _anchor_objects = {} self . _attached = [] def detach_robot ( self , robot_id : int ) -> None : if robot_id not in self . attached : raise ValueError ( \"Cannot detach robot: ID unknown\" ) for cid in self . _anchors [ robot_id ]: self . client . removeConstraint ( cid ) for obj in self . _anchor_objects [ robot_id ]: self . client . removeBody ( obj ) self . _anchors . pop ( robot_id ) self . _anchor_objects . pop ( robot_id ) self . _attached . remove ( robot_id )","title":"Attributes"},{"location":"reference/pyastrobee/core/deformable_bag/#ancestors-in-mro","text":"pyastrobee.core.abstract_bag.CargoBag abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/pyastrobee/core/deformable_bag/#class-variables","text":"BAG_CORNER_VERTS BAG_NAMES DUAL_HANDLE_BAGS HANDLE_TRANSFORMS HEIGHT LENGTH MESH_DIR OBJS SINGLE_HANDLE_BAGS URDF_DIR VTKS WIDTH","title":"Class variables"},{"location":"reference/pyastrobee/core/deformable_bag/#instance-variables","text":"anchors Anchor IDs and IDs of their associated visual geometries angular_velocity Current [wx, wy, wz] angular velocity of the cargo bag's COM frame If both velocity and angular velocity are desired, use the dynamics_state property instead attached ID(s) of the robot (or robots) grasping the bag. Empty if no robots are attached bending_stiffness Softbody bending stiffness parameter bounding_box Current axis-aligned bounding box of the bag (or just the main compartment), shape (2, 3) corner_positions damping_stiffness Softbody damping stiffness parameter dynamics_state Current state of the bag dynamics: Position, orientation, linear vel, and angular vel NOTE this moves the simulation forward by 1 step Bullet's velocity definition for softbodies is incorrect or not implemented. I've tried implementing this myself in the C++, but it is also not reliable. So instead, we'll need to step the sim in this call to do our own calculations elastic_stiffness Softbody elastic stiffness parameter friction_coeff Softbody friction coefficient grasp_transforms Transformation matrices \"handle to bag\" representing the grasp locations on the handles to the bag COM In the case of a single-handled bag, this list will only have one entry mass Mass of the cargo bag mesh_vertices Positions of the mesh vertices, shape (n, 3) name Type of cargo bag num_handles Number of handles on the cargo bag num_mesh_vertices Number of vertices in the bag's mesh obj_file Path to the .OBJ triangular mesh file orientation Current XYZW quaternion orientation of the cargo bag's COM frame pose Current position + XYZW quaternion pose of the bag position Current XYZ position of the origin (COM frame) of the cargo bag tmat Current transformation matrix for the cargo bag: (Bag to world) velocity Current [vx, vy, vz] velocity of the cargo bag's COM frame If both velocity and angular velocity are desired, use the dynamics_state property instead vtk_file Path to the .VTK tetrahedral mesh file","title":"Instance variables"},{"location":"reference/pyastrobee/core/deformable_bag/#methods","text":"","title":"Methods"},{"location":"reference/pyastrobee/core/deformable_bag/#attach_to","text":"def attach_to ( self , robot_or_robots : Union [ pyastrobee . core . astrobee . Astrobee , list [ pyastrobee . core . astrobee . Astrobee ], tuple [ pyastrobee . core . astrobee . Astrobee ]], object_to_move : str = 'robot' ) -> None Attaches a robot (or multiple robots) to the handle(s) of the bag Parameters: Name Type Description Default robot_or_robots Union[Astrobee, list[Astrobee], tuple[Astrobee]] Robot(s) to attach to the bag None object_to_move str Either \"robot\" or \"bag\". This dictates what object will get its position reset in order to make the grasp connection. In general, it makes more sense to move the robot to the bag (default behavior) None Raises: Type Description ValueError For invalid inputs, or if the bag does not have enough handles for each robot NotImplementedError Multi-robot case with >2 robots View Source def attach_to ( self , robot_or_robots : Union [ Astrobee, list[Astrobee ] , tuple [ Astrobee ] ] , object_to_move : str = \"robot\" , ) -> None : \"\"\"Attaches a robot (or multiple robots) to the handle(s) of the bag Args: robot_or_robots (Union[Astrobee, list[Astrobee], tuple[Astrobee]]): Robot(s) to attach to the bag object_to_move (str, optional): Either \" robot \" or \" bag \". This dictates what object will get its position reset in order to make the grasp connection. In general, it makes more sense to move the robot to the bag (default behavior) Raises: ValueError: For invalid inputs, or if the bag does not have enough handles for each robot NotImplementedError: Multi-robot case with >2 robots \"\"\" # Handle inputs if isinstance ( robot_or_robots , Astrobee ) : # Single robot num_robots = 1 elif isinstance ( robot_or_robots , ( list , tuple )) : # Multi - robot if not all ( isinstance ( r , Astrobee ) for r in robot_or_robots ) : raise ValueError ( \"Non-Astrobee input detected\" ) num_robots = len ( robot_or_robots ) if self . num_handles < num_robots : raise ValueError ( f \"Bag does not have enough handles to support {num_robots} robots\" ) if num_robots == 1 : # Edge case : Unpack the list if only one robot robot_or_robots = robot_or_robots [ 0 ] else : raise ValueError ( \"Invalid input: Must provide either an Astrobee or a list of multiple Astrobees\" ) if object_to_move not in { \"robot\" , \"bag\" }: raise ValueError ( \"Invalid object to move: Must be either 'robot' or 'bag'.\" ) bag_to_world = pos_quat_to_tmat ( self . pose ) if num_robots == 1 : robot = robot_or_robots # Unpack list if object_to_move == \"robot\" : # Reset the position of the robot to interface with the handle handle_to_bag = self . grasp_transforms [ 0 ] handle_to_world = bag_to_world @ handle_to_bag handle_pose = tmat_to_pos_quat ( handle_to_world ) robot . reset_to_ee_pose ( handle_pose ) else : # Move the bag to the robot self . reset_to_handle_pose ( robot . ee_pose ) self . _attach ( robot , 0 ) elif num_robots == 2 : robot_1 , robot_2 = robot_or_robots # Unpack list if object_to_move == \"robot\" : # Reset the position of each robot to interface with the two handles handle_1_to_bag = self . grasp_transforms [ 0 ] handle_2_to_bag = self . grasp_transforms [ 1 ] handle_1_to_world = bag_to_world @ handle_1_to_bag handle_2_to_world = bag_to_world @ handle_2_to_bag robot_1 . reset_to_ee_pose ( tmat_to_pos_quat ( handle_1_to_world )) robot_2 . reset_to_ee_pose ( tmat_to_pos_quat ( handle_2_to_world )) self . _attach ( robot_1 , 0 ) self . _attach ( robot_2 , 1 ) else : # Move the bag while leaving the robots static raise NotImplementedError ( \"Attaching the bag to multiple robots requires moving at least 1 robot\" ) else : raise NotImplementedError ( \"The multi-robot case is only implemented for 2 Astrobees\" )","title":"attach_to"},{"location":"reference/pyastrobee/core/deformable_bag/#detach","text":"def detach ( self ) -> None Detach all connections to the bag View Source def detach ( self ) -> None : anchors , anchor_objects = self . anchors for cid in anchors : self . client . removeConstraint ( cid ) for obj in anchor_objects : self . client . removeBody ( obj ) self . _anchors = {} self . _anchor_objects = {} self . _attached = []","title":"detach"},{"location":"reference/pyastrobee/core/deformable_bag/#detach_robot","text":"def detach_robot ( self , robot_id : int ) -> None Detaches a specific robot from the bag Parameters: Name Type Description Default robot_id int Pybullet ID of the robot to detach None View Source def detach_robot ( self , robot_id : int ) -> None : if robot_id not in self . attached : raise ValueError ( \"Cannot detach robot: ID unknown\" ) for cid in self . _anchors [ robot_id ] : self . client . removeConstraint ( cid ) for obj in self . _anchor_objects [ robot_id ] : self . client . removeBody ( obj ) self . _anchors . pop ( robot_id ) self . _anchor_objects . pop ( robot_id ) self . _attached . remove ( robot_id )","title":"detach_robot"},{"location":"reference/pyastrobee/core/deformable_bag/#reset_dynamics","text":"def reset_dynamics ( self , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], lin_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], ang_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> None Resets the pose and velocities of the bag Parameters: Name Type Description Default pos npt.ArrayLike Position, shape (3,) None orn npt.ArrayLike XYZW quaternion orientation, shape (4,) None lin_vel npt.ArrayLike Linear velocity, shape (3,) None ang_vel npt.ArrayLike Angular velocity, shape (3,) None View Source def reset_dynamics ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , lin_vel : npt . ArrayLike , ang_vel : npt . ArrayLike , ) -> None : \"\"\"Resets the pose and velocities of the bag Args: pos (npt.ArrayLike): Position, shape (3,) orn (npt.ArrayLike): XYZW quaternion orientation, shape (4,) lin_vel (npt.ArrayLike): Linear velocity, shape (3,) ang_vel (npt.ArrayLike): Angular velocity, shape (3,) \"\"\" self . client . resetBasePositionAndOrientation ( self . id , pos , orn ) self . client . resetBaseVelocity ( self . id , lin_vel , ang_vel )","title":"reset_dynamics"},{"location":"reference/pyastrobee/core/deformable_bag/#reset_to_handle_pose","text":"def reset_to_handle_pose ( self , handle_pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], handle_index : int = 0 ) -> None Resets the position of the bag so that the handle is positioned at a desired pose Parameters: Name Type Description Default handle_pose npt.ArrayLike Desired pose of the handle (\"handle-to-world\"), shape (7,) None handle_index int Index of the handle to align to the desired pose. Defaults to 0. 0 View Source def reset_to_handle_pose ( self , handle_pose : npt . ArrayLike , handle_index : int = 0 ) -> None : \"\"\"Resets the position of the bag so that the handle is positioned at a desired pose Args: handle_pose (npt.ArrayLike): Desired pose of the handle (\" handle - to - world \"), shape (7,) handle_index (int, optional): Index of the handle to align to the desired pose. Defaults to 0. \"\"\" handle_to_world = pos_quat_to_tmat ( handle_pose ) bag_to_handle = invert_transform_mat ( self . grasp_transforms [ handle_index ] ) bag_to_world = handle_to_world @ bag_to_handle bag_pose = tmat_to_pos_quat ( bag_to_world ) # This assumes that we want the bag to be stationary self . reset_dynamics ( bag_pose [ :3 ] , bag_pose [ 3: ] , np . zeros ( 3 ), np . zeros ( 3 ))","title":"reset_to_handle_pose"},{"location":"reference/pyastrobee/core/deformable_bag/#unload","text":"def unload ( self ) -> None Removes the cargo bag from the simulation View Source def unload ( self ) -> None : \"\"\"Removes the cargo bag from the simulation\"\"\" self . detach () self . client . removeBody ( self . id ) self . id = None","title":"unload"},{"location":"reference/pyastrobee/core/environments/","text":"Module pyastrobee.core.environments Gym and vectorized environments for the Astrobee/ISS/Cargo setup NOTE: - Class variables DO NOT get updated in vectorized environments (for instance, modifying the value in a non-vectorized environment will be reflected in all non-vectorized environments, but not the vectorized ones. You'd have to explicitly call the set_attr method for that) View Source \"\"\"Gym and vectorized environments for the Astrobee/ISS/Cargo setup NOTE: - Class variables DO NOT get updated in vectorized environments (for instance, modifying the value in a non-vectorized environment will be reflected in all non-vectorized environments, but not the vectorized ones. You'd have to explicitly call the set_attr method for that) \"\"\" # TODO # - See if there is a faster way to save/restore state in the case that we're using the rigid bag # - Add ability to save/restore state from a state ID (saved in memory) -- ONLY if this is useful # - Use terminated/truncated as a stopping parameter # - Should the reset() function reset the simulation back to an initial saved state? # - Decide if the base AstrobeeEnv should have cleanup functionality import os from pathlib import Path from typing import Optional , Any , Callable , Dict , Type , Union from datetime import datetime from enum import Enum import numpy as np import numpy.typing as npt import gymnasium as gym from gymnasium.core import ObsType , ActType from stable_baselines3.common.monitor import Monitor from stable_baselines3.common.env_util import DummyVecEnv , SubprocVecEnv , VecEnv from stable_baselines3.common.vec_env.patch_gym import _patch_env from pyastrobee.control.force_torque_control import ForceTorqueController from pyastrobee.utils.bullet_utils import initialize_pybullet from pyastrobee.core.astrobee import Astrobee from pyastrobee.core.iss import ISS from pyastrobee.core.abstract_bag import CargoBag from pyastrobee.core.deformable_bag import DeformableCargoBag from pyastrobee.core.constraint_bag import ConstraintCargoBag from pyastrobee.control.metrics import safe_set_cost from pyastrobee.trajectories.sampling import generate_trajs , sample_state from pyastrobee.utils.debug_visualizer import remove_debug_objects from pyastrobee.utils.boxes import check_box_containment , visualize_3D_box from pyastrobee.config.iss_safe_boxes import FULL_SAFE_SET from pyastrobee.utils.quaternions import quaternion_dist from pyastrobee.control.metrics import robot_and_bag_termination_criteria from pyastrobee.config.astrobee_motion import MAX_FORCE_MAGNITUDE , MAX_TORQUE_MAGNITUDE from pyastrobee.trajectories.trajectory import Trajectory , ArmTrajectory from pyastrobee.utils.transformations import invert_transform_mat from pyastrobee.trajectories.planner import local_planner from pyastrobee.trajectories.trajectory import concatenate_trajs class AstrobeeEnv ( gym . Env ): \"\"\"Base Astrobee environment containing the Astrobee, ISS, and a cargo bag Args: use_gui (bool): Whether or not to use the GUI as opposed to headless. robot_pose (npt.ArrayLike, optional): Starting position + XYZW quaternion pose of the Astrobee, shape (7,) bag_name (str, optional): Type of cargo bag to load. Defaults to \"top_handle\". bag_mass (float): Mass of the cargo bag, in kg. Defaults to 10 bag_type (type[CargoBag]): Class of cargo bag to use in the environment. Defaults to DeformableCargoBag load_full_iss (bool, optional): Whether to load the ISS (expensive, not necessarily required for rollouts) or just work with the safe set information. Defaults to True (load the ISS) \"\"\" SAVE_STATE_DIR = \"artifacts/saved_states/\" SAVE_STATE_PATHS = [] def __init__ ( self , use_gui : bool , robot_pose : npt . ArrayLike = ( 0 , 0 , 0 , 0 , 0 , 0 , 1 ), bag_name : str = \"top_handle_symmetric\" , bag_mass : float = 10 , bag_type : type [ CargoBag ] = DeformableCargoBag , load_full_iss : bool = True , ): self . client = initialize_pybullet ( use_gui ) self . safe_set = FULL_SAFE_SET if load_full_iss : self . iss = ISS ( client = self . client ) elif use_gui : for box in self . safe_set . values (): visualize_3D_box ( box , rgba = ( 1 , 0 , 0 , 0.3 )) self . robot = Astrobee ( robot_pose , client = self . client ) self . bag = bag_type ( bag_name , bag_mass , client = self . client ) self . bag . reset_to_handle_pose ( self . robot . ee_pose ) self . bag . attach_to ( self . robot , object_to_move = \"bag\" ) self . dt = self . client . getPhysicsEngineParameters ()[ \"fixedTimeStep\" ] # Dummy parameters for gym/stable baselines compatibility # TODO make custom gym.spaces.space.Space subclasses for these? self . observation_space = gym . spaces . Discrete ( 3 ) # temporary, unused self . action_space = gym . spaces . Discrete ( 3 ) # temporary, unused # Step the simulation once to get the bag in the right place self . client . stepSimulation () def reset ( self , seed : Optional [ int ] = None , options : Optional [ dict [ str , Any ]] = None ) -> tuple [ ObsType , dict [ str , Any ]]: # Implementation of Gym template method reset(): See Gym for full method docstring # Gym states this must be the first line of the reset() method super () . reset ( seed = seed ) return self . _get_obs (), self . _get_info () # Initial state observation def _get_obs ( self ) -> ObsType : \"\"\"Translates the environment's state into an observation Returns: ObsType: Observation \"\"\" # This function setup was recommended in the gym documentation return None , None # Dummy value for now def _get_info ( self ) -> dict [ str , Any ]: \"\"\"Provide auxiliary information associated with an observation Returns: dict[str, Any]: Additional observation information \"\"\" # This function setup was recommended in the gym documentation return {} # Dummy value for now def step ( self , action : ActType ) -> tuple [ ObsType , float , bool , bool , dict [ str , Any ]]: # Implementation of Gym template method step(): See Gym for full method docstring # Note: The return parameters differ slightly from step() for a vectorized environment # In this base environment, we will just step the pybullet simulation and return a dummy value for reward # The MPC environment can add more specific MPC/control functionality here self . client . stepSimulation () reward = 0 observation = self . _get_obs () terminated = False # If at the terminal state truncated = False # If stopping the sim before the terminal state info = self . _get_info () return observation , reward , terminated , truncated , info def step_simulation ( self ): \"\"\"Single pybullet simulation step\"\"\" self . client . stepSimulation () def close ( self ): # Implementation of Gym template method close(): See Gym for full method docstring self . client . disconnect () def save_state ( self ) -> str : \"\"\"Saves the current simulation state to disk - Note: saved states are not currently overwritten (could lead to issues with parallel environments?). But, these can be cleared out at the end of the simulation period Returns: str: Path to the saved state file \"\"\" # Autogenerate a unique filename/path and save to it filename = \"state_\" + datetime . now () . strftime ( \"%Y%m %d _%H%M%S_ %f \" ) filepath = AstrobeeEnv . SAVE_STATE_DIR + filename + \".bullet\" self . client . saveBullet ( filepath ) AstrobeeEnv . SAVE_STATE_PATHS . append ( filepath ) return filepath def restore_state ( self , filename : str ) -> None : \"\"\"Restores the simulation to a saved state file Args: filename (str): Path to a .bullet saved state within the saved state directory \"\"\" filename = self . _check_state_file ( filename ) self . client . restoreState ( fileName = filename ) def _check_state_file ( self , filename : str ) -> str : \"\"\"Helper function: Validates that a saved state file exists Args: filename (str): Path to a .bullet saved state within the saved state directory Returns: str: Validated path \"\"\" path = Path ( filename ) if path . suffix != \".bullet\" : raise ValueError ( f \"Invalid filename: { filename } . \\n Not a .bullet saved state file\" ) if path . parent != Path ( AstrobeeEnv . SAVE_STATE_DIR ): raise ValueError ( f \"Invalid filename: { filename } . \\n Check that the filename points to within the saved state directory\" ) if path . is_file (): return str ( path ) raise FileNotFoundError ( f \"Could not find file: { filename } \" ) def send_client_command ( self , * args , ** kwargs ) -> Any : \"\"\"Send a command to the environment's pybullet client For instance, we can use pybullet.getBasePositionAndOrientation with this as send_client_command(\"getBasePositionAndOrientation\", body_id) Returns: Any: The return from the Pybullet command \"\"\" attr = getattr ( self . client , args [ 0 ]) if isinstance ( attr , Callable ): return attr ( * args [ 1 :], ** kwargs ) return attr class AstrobeeMPCEnv ( AstrobeeEnv ): \"\"\"Astrobee environment for MPC: Contains additional controller parameters and functions associated with MPC, on top of the base Astrobee environment capability Args: use_gui (bool): Whether or not to use the GUI as opposed to headless. is_primary (bool): Whether or not this environment is the main simulation (True) or if it is one of the vectorized environments for evaluating a rollout (False) robot_pose (npt.ArrayLike, optional): Starting position + XYZW quaternion pose of the Astrobee, shape (7,) bag_name (str, optional): Type of cargo bag to load. Defaults to \"top_handle\". bag_mass (float): Mass of the cargo bag, in kg. Defaults to 10 bag_type (type[CargoBag]): Class of cargo bag to use in the environment. Defaults to DeformableCargoBag load_full_iss (bool, optional): Whether to load the ISS (expensive, not necessarily required for rollouts) or just work with the safe set information. Defaults to True (load the ISS) nominal_rollouts (bool, optional): If True, will roll-out a trajectory based on the nominal target. If False, will sample a trajectory about the nominal target. Defaults to False. cleanup (bool, optional): Whether or not to delete all saved states when the simulation ends. Defaults to True. \"\"\" class FlightStates ( Enum ): # STARTING = \"starting\" NOMINAL = \"nominal\" SLOWING = \"slowing\" STOPPING = \"stopping\" def __init__ ( self , use_gui : bool , is_primary : bool , robot_pose : npt . ArrayLike = ( 0 , 0 , 0 , 0 , 0 , 0 , 1 ), bag_name : str = \"top_handle\" , bag_mass : float = 10 , bag_type : type [ CargoBag ] = DeformableCargoBag , load_full_iss : bool = True , nominal_rollouts : bool = False , cleanup : bool = True , ): super () . __init__ ( use_gui , robot_pose , bag_name , bag_mass , bag_type , load_full_iss ) # TODO figure out how to handle controller parameters # Just fixing the gains here for now # TODO should these be functions of the bag mass??? kp , kv , kq , kw = 20 , 5 , 5 , 0.1 # TODO make parameters p = self . bag . position - self . robot . position self . controller = ForceTorqueController ( self . robot . id , self . robot . mass + bag_mass , # self.robot.inertia, self . robot . inertia + bag_mass * ( np . dot ( p , p ) * np . eye ( 3 ) - np . outer ( p , p ) ), # TODO parallel axis theorem for bag?? test this kp , kv , kq , kw , self . dt , max_force = MAX_FORCE_MAGNITUDE * 10 , # TODO REMOVE THIS SCALING FACTOR max_torque = MAX_TORQUE_MAGNITUDE * 10 , client = self . client , ) # Sampling parameters (TODO these need refinement) self . pos_stdev = 0.1 self . orn_stdev = 0.1 self . vel_stdev = 0.1 self . ang_vel_stdev = 0.1 self . accel_stdev = 0.1 self . alpha_stdev = 0.1 # Store last acceleration commands # Update through set_attr self . last_accel_cmd = np . zeros ( 3 ) # init self . last_alpha_cmd = np . zeros ( 3 ) # init # Frequency at which we query our \"stay away from the walls\" cost function self . safe_set_eval_freq = 10 # Hz # Keep track of any temporary debug visualizer IDs self . debug_viz_ids = () # Keep track of whether we're stopping or in a nominal flight mode self . flight_state = self . FlightStates . NOMINAL # init # (effectively the rollout duration, should be a constant) - TODO IMPROVE THIS self . planning_duration = None # Store where we want the Astrobee to be at the end of the MPC run to determine if we are done self . goal_pose = None # init # HACK - improve how this is handled self . arm_traj_plan = None self . _is_primary_env = is_primary self . _is_debugging_env = not is_primary and use_gui self . _nominal_rollouts = nominal_rollouts self . _cleanup = cleanup self . traj_plan = None # Init self . target_pos = None # Init self . target_orn = None # Init self . target_vel = None # Init self . target_omega = None # Init self . target_duration = None # Init @property def is_primary_simulation ( self ) -> bool : \"\"\"Whether this environment is running the primary planning/control simulation or is a separate (likely vectorized) environment for evaluating rollouts\"\"\" return self . _is_primary_env @property def is_debugging_simulation ( self ) -> bool : \"\"\"Whether this is an environment launched in debug mode\"\"\" return self . _is_debugging_env def set_arm_traj ( self , traj : ArmTrajectory ): # TODO IMPROVE THIS self . arm_traj_plan = traj def set_planning_duration ( self , duration ): # TODO improve this self . planning_duration = duration def set_flight_state ( self , state : Union [ str , FlightStates ]): \"\"\"Set the current flight state: for instance, whether we are in nominal operating mode, stopping, ... Args: state (Union[str, FlightStates]): A flight state or its string representation (i.e. \"nominal\", \"stopping\", ...) \"\"\" # TODO add check that it is valid # TODO should we store the state as the string or the Enum???? if isinstance ( state , str ): self . flight_state = self . FlightStates ( state ) elif isinstance ( state , self . FlightStates ): self . flight_state = state else : raise ValueError ( \"Flight state not recognized\" ) def set_target_state ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , vel : npt . ArrayLike , omega : npt . ArrayLike , accel : npt . ArrayLike , alpha : npt . ArrayLike , duration : float , ) -> None : \"\"\"Set the target dynamics state for planning/sampling trajectories and determining penalties Args: pos (npt.ArrayLike): Desired position, shape (3,) orn (npt.ArrayLike): Desired XYZW quaternion orientation, shape (4,) vel (npt.ArrayLike): Desired linear velocity, shape (3,) omega (npt.ArrayLike): Desired angular velocity, shape (3,) accel (npt.ArrayLike): Desired linear acceleration, shape (3,) alpha (npt.ArrayLike): Desired angular acceleration, shape (3,) duration (float): Amount of time to pass before achieving this desired state \"\"\" self . target_pos = pos self . target_orn = orn self . target_vel = vel self . target_omega = omega self . target_accel = accel self . target_alpha = alpha self . target_duration = duration def sample_trajectory ( self ) -> None : \"\"\"Samples a trajectory about the nominal target. - If the nominal_rollouts parameter is True for this environment, the final state of the trajectory will be exactly the nominal value (no noise added when sampling) - This should just be called in the vectorized rollout environments (not the main environment) since the main environment will use the best trajectory from the rollout envs \"\"\" if self . is_primary_simulation : raise ValueError ( \"Trajectory sampling should only occur in one of parallel environments for evaluation purposes\" ) pos , orn , vel , omega = self . robot . dynamics_state # Time sampling parameters (TODO refine these, move them somewhere else) time_stdev = 1 # Note: ensure that this is a positive value post-sampling min_time = 1 n_timesteps = round ( self . planning_duration / self . dt ) # Nominal if self . flight_state == self . FlightStates . NOMINAL : end_state = ( [ self . target_pos , self . target_orn , self . target_vel , self . target_omega , self . target_accel , self . target_alpha , ] if self . _nominal_rollouts else sample_state ( self . target_pos , self . target_orn , self . target_vel , self . target_omega , self . last_accel_cmd , self . last_alpha_cmd , self . pos_stdev , self . orn_stdev , self . vel_stdev , self . ang_vel_stdev , self . accel_stdev , self . alpha_stdev , ) ) duration = self . target_duration elif self . flight_state == self . FlightStates . SLOWING : end_state = ( [ self . target_pos , self . target_orn , self . target_vel , self . target_omega , self . target_accel , self . target_alpha , ] if self . _nominal_rollouts else sample_state ( self . target_pos , self . target_orn , self . target_vel , self . target_omega , self . last_accel_cmd , self . last_alpha_cmd , self . pos_stdev / 3 , self . orn_stdev / 3 , self . vel_stdev / 3 , self . ang_vel_stdev / 3 , self . accel_stdev / 3 , self . alpha_stdev / 3 , ) ) duration = ( self . target_duration if self . _nominal_rollouts else np . maximum ( np . random . normal ( self . target_duration , time_stdev ), min_time ) ) elif self . flight_state == self . FlightStates . STOPPING : end_state = [ self . target_pos , self . target_orn , self . target_vel , self . target_omega , self . target_accel , self . target_alpha , ] duration = ( self . planning_duration if self . _nominal_rollouts else np . maximum ( np . random . normal ( self . planning_duration , time_stdev ), min_time ) ) else : raise AttributeError ( \"Flight state not recognized\" ) traj = local_planner ( pos , orn , vel , omega , self . last_accel_cmd , self . last_alpha_cmd , * end_state , duration , self . dt , ) if traj . num_timesteps == n_timesteps : self . traj_plan = traj else : # Traj is either too long or too short, so adjust it if traj . num_timesteps > n_timesteps : self . traj_plan = traj . get_segment ( 0 , n_timesteps ) else : # Less than # Create a trajectory at the stopped position for the remaining timesteps remaining_timesteps = n_timesteps - traj . num_timesteps stop_traj = Trajectory ( traj . positions [ - 1 ] * np . ones (( remaining_timesteps , 1 )), traj . quaternions [ - 1 ] * np . ones (( remaining_timesteps , 1 )), np . zeros (( remaining_timesteps , 3 )), np . zeros (( remaining_timesteps , 3 )), np . zeros (( remaining_timesteps , 3 )), np . zeros (( remaining_timesteps , 3 )), np . arange ( remaining_timesteps ) * self . dt , ) self . traj_plan = concatenate_trajs ( traj , stop_traj ) self . sampled_end_state = ( self . traj_plan . positions [ - 1 ], self . traj_plan . quaternions [ - 1 ], self . traj_plan . linear_velocities [ - 1 ], self . traj_plan . angular_velocities [ - 1 ], ) def _get_obs ( self ) -> ObsType : if self . is_primary_simulation : return self . robot . full_state , self . bag . dynamics_state else : return None , None def step ( self , action : ActType ) -> tuple [ ObsType , float , bool , bool , dict [ str , Any ]]: # Note: For MPC, this is less so a \"step\" than a \"rollout\" function. The trajectory should be sampled # before calling this function # TODO use the action parameter to pass in a trajectory to follow? terminated = False # init (If at the terminal state) truncated = False # init (If stopping the sim before the terminal state) if self . traj_plan is None : raise ValueError ( \"Trajectory has not been planned\" ) # Follow the trajectory. NOTE: This is effectively the same as the follow_traj() function in the controller, # but accessing the loop directly allows us to do more with the data at each step # TODO decide how to handle the stopping criteria if not self . traj_plan . num_timesteps == self . arm_traj_plan . num_timesteps : raise ValueError ( \"Mismatched time info between base and arm trajs\" ) # If this is the primary simulation, we just follow the best trajectory we have # Rewrd for the primary simulation doesn't mean anything, so no computation needed inertia_update_freq = 5 steps_per_inertia_update = round ( 1 / ( self . traj_plan . timestep * inertia_update_freq ) ) if self . is_primary_simulation : for i in range ( self . traj_plan . num_timesteps ): pos , orn , lin_vel , ang_vel = self . controller . get_current_state () self . controller . step ( pos , lin_vel , orn , ang_vel , self . traj_plan . positions [ i , :], self . traj_plan . linear_velocities [ i , :], self . traj_plan . linear_accels [ i , :], self . traj_plan . quaternions [ i , :], self . traj_plan . angular_velocities [ i , :], self . traj_plan . angular_accels [ i , :], ) self . robot . set_joint_angles ( self . arm_traj_plan . angles [ i , :], self . arm_traj_plan . joint_ids ) # TODO THIS KINDA SUCKS if i % steps_per_inertia_update == 0 : T_R2W = self . robot . tmat T_B2W = self . bag . tmat T_B2R = invert_transform_mat ( T_R2W ) @ T_B2W p = T_B2R [: 3 , 3 ] self . controller . inertia = self . robot . inertia + self . bag . mass * ( np . dot ( p , p ) * np . eye ( 3 ) - np . outer ( p , p ) ) reward = 0 else : # We are in a rollout environment # So, follow the trajectory, but also keep track of a bunch of things so that we can compute the reward robot_safe_set_cost = 0 # init bag_safe_set_cost = 0 # init stabilization_cost = 0 tracking_cost = 0 bag_vel_cost = 0 steps_per_safe_set_eval = round ( 1 / ( self . traj_plan . timestep * self . safe_set_eval_freq ) ) # TODO IMPROVE THIS # the thought here was that if we're stopping (or slowing) we care more about the overall positioning # rather than just staying in the middle of the modules safe_set_weight = ( 1 if self . flight_state == self . FlightStates . NOMINAL else 0.1 ) for i in range ( self . traj_plan . num_timesteps ): # Note: the traj log gets updated whenever we access the current state pos , orn , lin_vel , ang_vel = self . controller . get_current_state () self . controller . step ( pos , lin_vel , orn , ang_vel , self . traj_plan . positions [ i , :], self . traj_plan . linear_velocities [ i , :], self . traj_plan . linear_accels [ i , :], self . traj_plan . quaternions [ i , :], self . traj_plan . angular_velocities [ i , :], self . traj_plan . angular_accels [ i , :], ) self . robot . set_joint_angles ( self . arm_traj_plan . angles [ i , :], self . arm_traj_plan . joint_ids ) # TODO THIS KINDA SUCKS if i % steps_per_inertia_update == 0 : T_R2W = self . robot . tmat T_B2W = self . bag . tmat T_B2R = invert_transform_mat ( T_R2W ) @ T_B2W p = T_B2R [: 3 , 3 ] self . controller . inertia = self . robot . inertia + self . bag . mass * ( np . dot ( p , p ) * np . eye ( 3 ) - np . outer ( p , p ) ) # *** COST FUNCTION *** # Perform collision checking on every timestep robot_bb = self . robot . bounding_box bag_bb = self . bag . bounding_box robot_is_safe = check_box_containment ( robot_bb , self . safe_set . values ()) bag_is_safe = check_box_containment ( bag_bb , self . safe_set . values ()) # If either the robot or bag collided, stop the simulation and return an effectively infinite cost # (Very large but not infinity to maintain sorting order in the edge case that all rollouts collide) if not robot_is_safe : robot_safe_set_cost += 10000 truncated = True # break if not bag_is_safe : bag_safe_set_cost += 10000 truncated = True # break # These \"stay away from the walls\" costs are somewhat expensive to compute and don't necessarily need # to be done every timestep. TODO just use the local description of the safe set, not the full thing if i % steps_per_safe_set_eval == 0 : robot_safe_set_cost += safe_set_weight * safe_set_cost ( robot_bb [ 0 ], self . safe_set . values () ) robot_safe_set_cost += safe_set_weight * safe_set_cost ( robot_bb [ 1 ], self . safe_set . values () ) bag_safe_set_cost += safe_set_weight * safe_set_cost ( bag_bb [ 0 ], self . safe_set . values () ) bag_safe_set_cost += safe_set_weight * safe_set_cost ( bag_bb [ 1 ], self . safe_set . values () ) bag_pos , bag_orn , bag_vel , bag_ang_vel = self . bag . dynamics_state # Penalizing bag velocities perpendicular to the robot's velocity at end of rollout if self . flight_state == self . FlightStates . NOMINAL : bag_vel_cost = 300 * ( np . linalg . norm ( bag_vel ) - np . dot ( lin_vel / np . linalg . norm ( lin_vel ), bag_vel ) ) # End-of-rollout additional cost function evaluations # 1) Stabilize the motion of the bag with respect to the robot # 2) Position the robot so it's stopped at the goal pose # Both of these are only relevant when we're at the end of the nominal trajectory # TODO tune all of the scaling factors on the costs if self . flight_state == self . FlightStates . STOPPING : angular_term = np . linalg . norm ( ang_vel - bag_ang_vel ) r_r2b = bag_pos - pos # Vector from robot to bag linear_term = np . linalg . norm ( lin_vel - bag_vel + np . cross ( ang_vel , r_r2b ) ) stabilization_cost += 500 * ( linear_term + angular_term ) # TODO make this a separate function? # Adding back in a tracking cost component # If we are stopping then we know that the target state is the goal pos_error = np . linalg . norm ( pos - self . target_pos ) orn_error = quaternion_dist ( orn , self . target_orn ) vel_error = np . linalg . norm ( lin_vel - self . target_vel ) ang_vel_error = np . linalg . norm ( ang_vel - self . target_omega ) if self . is_debugging_simulation : print ( \"Position error: \" , pos_error ) print ( \"Orn error: \" , orn_error ) print ( \"Vel error: \" , vel_error ) print ( \"Ang vel error: \" , ang_vel_error ) tracking_cost += ( 200 * pos_error + 100 * orn_error + 200 * vel_error + 100 * ang_vel_error ) else : stabilization_cost = 0 tracking_cost = 0 if self . is_debugging_simulation : print ( \"Robot safe set cost: \" , robot_safe_set_cost ) print ( \"Bag safe set cost: \" , bag_safe_set_cost ) print ( \"Stabilization cost: \" , stabilization_cost ) print ( \"Tracking cost: \" , tracking_cost ) print ( \"Bag velocity cost: \" , bag_vel_cost ) reward = - 1 * ( robot_safe_set_cost + bag_safe_set_cost + stabilization_cost + tracking_cost + bag_vel_cost ) # Observe the robot/bag state in the main env, dummy value if in rollout env observation = self . _get_obs () # Evaluate if we have stabilized the robot and the bag at the end of the trajectory # (main env only since that's what we care about and we don't want to waste compute) if ( self . flight_state == self . FlightStates . STOPPING and self . is_primary_simulation and robot_and_bag_termination_criteria ( observation [ 0 ], observation [ 1 ], self . goal_pose ) ): terminated = True # TODO: If we change the observation function to return the state of the robot and the bag, # we can determine the \"terminated\" parameter! # But note that we should only really do the observation in the main env info = self . _get_info () return observation , reward , terminated , truncated , info def close ( self ): self . client . disconnect () if self . is_primary_simulation and self . _cleanup : # Delete all of the previous saved states at the end of the simulation process # TODO: decide if each session should have its own directory? for path in Path ( AstrobeeMPCEnv . SAVE_STATE_DIR ) . glob ( \"*.bullet\" ): path . unlink () def save_state ( self ) -> str : # Ensure that any simulations strictly for evaluating rollouts cannot save their state if not self . is_primary_simulation : raise PermissionError ( \"Only the primary simulation can save the state\" ) return super () . save_state () def get_robot_state ( self ) -> tuple [ np . ndarray , ... ]: \"\"\"Returns the full state information for the Astrobee in the environment (Base pos/orn/vels, joint angles/vels) Returns: tuple[np.ndarray, ...]: np.ndarray: Position, shape (3,) np.ndarray: Orientation (XYZW quaternion), shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) np.ndarray: Joint positions, shape (NUM_JOINTS,) np.ndarray: Joint velocities, shape (NUM_JOINTS,) \"\"\" return self . robot . full_state def get_bag_state ( self ) -> tuple [ np . ndarray , ... ]: \"\"\"Returns the dynamics state information for the bag in the environment (pos/orn/vels) Returns: tuple[np.ndarray, ...]: np.ndarray: Position, shape (3,) np.ndarray: XYZW quaternion orientation, shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) \"\"\" return self . bag . dynamics_state def reset_robot_state ( self , state : tuple [ np . ndarray , ... ]) -> None : \"\"\"Fully resets the state of the Astrobee in the environment Args: state (tuple[np.ndarray, ...]): Full Astrobee state information containing: np.ndarray: Position, shape (3,) np.ndarray: Orientation (XYZW quaternion), shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) np.ndarray: Joint positions, shape (NUM_JOINTS,) np.ndarray: Joint velocities, shape (NUM_JOINTS,) \"\"\" assert len ( state ) == 6 assert len ( state [ 0 ]) == 3 assert len ( state [ 1 ]) == 4 assert len ( state [ 2 ]) == 3 assert len ( state [ 3 ]) == 3 assert len ( state [ 4 ]) == Astrobee . NUM_JOINTS assert len ( state [ 5 ]) == Astrobee . NUM_JOINTS self . robot . reset_full_state ( * state ) def reset_bag_state ( self , state : tuple [ np . ndarray , ... ]) -> None : \"\"\"Resets the dynamics of the bag in the environment Args: state (tuple[np.ndarray, ...]): Dynamics info of the bag, containing: np.ndarray: Position, shape (3,) np.ndarray: Orientation (XYZW quaternion), shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) \"\"\" assert len ( state ) == 4 assert len ( state [ 0 ]) == 3 assert len ( state [ 1 ]) == 4 assert len ( state [ 2 ]) == 3 assert len ( state [ 3 ]) == 3 self . bag . reset_dynamics ( * state ) def show_traj_plan ( self , n : Optional [ int ]) -> None : \"\"\"Displays the planned trajectory on the current pybullet client GUI (if enabled) Args: n (Optional[int]): Number of frames to plot, if plotting all of the frames is not desired. Defaults to None (plot all frames) \"\"\" if self . traj_plan is None : raise ValueError ( \"No trajectory available to visualize\" ) self . debug_viz_ids = self . traj_plan . visualize ( n , client = self . client ) def unshow_traj_plan ( self ) -> None : \"\"\"Removes a displayed trajectory from the pybullet client GUI\"\"\" if len ( self . debug_viz_ids ) == 0 : return remove_debug_objects ( self . debug_viz_ids , self . client ) self . debug_viz_ids = () def make_vec_env ( env_id : Union [ str , Callable [ ... , gym . Env ]], n_envs : int = 1 , seed : Optional [ int ] = None , start_index : int = 0 , monitor_dir : Optional [ str ] = None , wrapper_class : Optional [ Callable [[ gym . Env ], gym . Env ]] = None , env_kwargs : Optional [ Dict [ str , Any ]] = None , vec_env_cls : Optional [ Type [ Union [ DummyVecEnv , SubprocVecEnv ]]] = None , vec_env_kwargs : Optional [ Dict [ str , Any ]] = None , monitor_kwargs : Optional [ Dict [ str , Any ]] = None , wrapper_kwargs : Optional [ Dict [ str , Any ]] = None , per_env_kwargs : Optional [ Dict [ int , Dict [ str , Any ]]] = None , # NEW ) -> VecEnv : \"\"\"Modified version of make_vec_env from Stable Baselines (SB3) to allow for specifying input parameters on a per-environment basis The main changes are any lines associated with the per_env_kwargs input. Updated SB3 docstring below: Create a wrapped, monitored ``VecEnv``. By default it uses a ``DummyVecEnv`` which is usually faster than a ``SubprocVecEnv``. :param env_id: either the env ID, the env class or a callable returning an env :param n_envs: the number of environments you wish to have in parallel :param seed: the initial seed for the random number generator :param start_index: start rank index :param monitor_dir: Path to a folder where the monitor files will be saved. If None, no file will be written, however, the env will still be wrapped in a Monitor wrapper to provide additional information about training. :param wrapper_class: Additional wrapper to use on the environment. This can also be a function with single argument that wraps the environment in many things. Note: the wrapper specified by this parameter will be applied after the ``Monitor`` wrapper. if some cases (e.g. with TimeLimit wrapper) this can lead to undesired behavior. See here for more details: https://github.com/DLR-RM/stable-baselines3/issues/894 :param env_kwargs: Optional keyword argument to pass to the env constructor :param vec_env_cls: A custom ``VecEnv`` class constructor. Default: None. :param vec_env_kwargs: Keyword arguments to pass to the ``VecEnv`` class constructor. :param monitor_kwargs: Keyword arguments to pass to the ``Monitor`` class constructor. :param wrapper_kwargs: Keyword arguments to pass to the ``Wrapper`` class constructor. :param per_env_kwargs: Like env-kwargs, keyword arguments fore the env constructor, but keyed to allow for different initialization on a per-env basis via the env's rank. These override any default values set via the env_kwargs input :return: The wrapped environment \"\"\" env_kwargs = env_kwargs or {} vec_env_kwargs = vec_env_kwargs or {} monitor_kwargs = monitor_kwargs or {} wrapper_kwargs = wrapper_kwargs or {} per_env_kwargs = per_env_kwargs or {} assert vec_env_kwargs is not None # for mypy def make_env ( rank : int ) -> Callable [[], gym . Env ]: def _init () -> gym . Env : # For type checker: assert monitor_kwargs is not None assert wrapper_kwargs is not None assert env_kwargs is not None this_env_kwargs = env_kwargs | per_env_kwargs . get ( rank , {}) if isinstance ( env_id , str ): # if the render mode was not specified, we set it to `rgb_array` as default. kwargs = { \"render_mode\" : \"rgb_array\" } kwargs . update ( this_env_kwargs ) try : env = gym . make ( env_id , ** kwargs ) # type: ignore[arg-type] except TypeError : env = gym . make ( env_id , ** this_env_kwargs ) else : env = env_id ( ** this_env_kwargs ) # Patch to support gym 0.21/0.26 and gymnasium env = _patch_env ( env ) if seed is not None : # Note: here we only seed the action space # We will seed the env at the next reset env . action_space . seed ( seed + rank ) # Wrap the env in a Monitor wrapper # to have additional training information monitor_path = ( os . path . join ( monitor_dir , str ( rank )) if monitor_dir is not None else None ) # Create the monitor folder if needed if monitor_path is not None and monitor_dir is not None : os . makedirs ( monitor_dir , exist_ok = True ) env = Monitor ( env , filename = monitor_path , ** monitor_kwargs ) # Optionally, wrap the environment with the provided wrapper if wrapper_class is not None : env = wrapper_class ( env , ** wrapper_kwargs ) return env return _init # No custom VecEnv is passed if vec_env_cls is None : # Default: use a DummyVecEnv vec_env_cls = DummyVecEnv vec_env = vec_env_cls ( [ make_env ( i + start_index ) for i in range ( n_envs )], ** vec_env_kwargs ) # Prepare the seeds for the first reset vec_env . seed ( seed ) return vec_env def _test_envs (): \"\"\"Run a quick test of the environment generation methods\"\"\" # Create one primary non-vectorized environment main_env = AstrobeeEnv ( use_gui = True ) # Create a few vectorized environments n_vec_envs = 4 env_kwargs = { \"use_gui\" : False } # Let one vectorized environment use the GUI for debugging per_env_kwargs = { 0 : { \"use_gui\" : True }} vec_envs = make_vec_env ( AstrobeeEnv , n_vec_envs , env_kwargs = env_kwargs , vec_env_cls = SubprocVecEnv if n_vec_envs > 1 else DummyVecEnv , per_env_kwargs = per_env_kwargs , ) try : # Reset has to be called first main_env . reset () vec_envs . reset () # Call step with dummy action values, note difference in return parameters observation , reward , terminated , truncated , info = main_env . step ( 0 ) observation , reward , done , info = vec_envs . step ( np . zeros ( n_vec_envs )) input ( \"Stepped. Press Enter to finish\" ) finally : # Terminate pybullet processes, delete any saved states main_env . close () vec_envs . close () if __name__ == \"__main__\" : _test_envs () Variables FULL_SAFE_SET MAX_FORCE_MAGNITUDE MAX_TORQUE_MAGNITUDE Functions make_vec_env def make_vec_env ( env_id : Union [ str , Callable [ ... , gymnasium . core . Env ]], n_envs : int = 1 , seed : Optional [ int ] = None , start_index : int = 0 , monitor_dir : Optional [ str ] = None , wrapper_class : Optional [ Callable [[ gymnasium . core . Env ], gymnasium . core . Env ]] = None , env_kwargs : Optional [ Dict [ str , Any ]] = None , vec_env_cls : Optional [ Type [ Union [ stable_baselines3 . common . vec_env . dummy_vec_env . DummyVecEnv , stable_baselines3 . common . vec_env . subproc_vec_env . SubprocVecEnv ]]] = None , vec_env_kwargs : Optional [ Dict [ str , Any ]] = None , monitor_kwargs : Optional [ Dict [ str , Any ]] = None , wrapper_kwargs : Optional [ Dict [ str , Any ]] = None , per_env_kwargs : Optional [ Dict [ int , Dict [ str , Any ]]] = None ) -> stable_baselines3 . common . vec_env . base_vec_env . VecEnv Modified version of make_vec_env from Stable Baselines (SB3) to allow for specifying input parameters on a per-environment basis The main changes are any lines associated with the per_env_kwargs input. Updated SB3 docstring below: Create a wrapped, monitored VecEnv . By default it uses a DummyVecEnv which is usually faster than a SubprocVecEnv . Parameters: Name Type Description Default env_id None either the env ID, the env class or a callable returning an env None n_envs None the number of environments you wish to have in parallel None seed None the initial seed for the random number generator None start_index None start rank index None monitor_dir None Path to a folder where the monitor files will be saved. If None, no file will be written, however, the env will still be wrapped in a Monitor wrapper to provide additional information about training. None wrapper_class None Additional wrapper to use on the environment. This can also be a function with single argument that wraps the environment in many things. Note: the wrapper specified by this parameter will be applied after the Monitor wrapper. if some cases (e.g. with TimeLimit wrapper) this can lead to undesired behavior. See here for more details: https://github.com/DLR-RM/stable-baselines3/issues/894 None env_kwargs None Optional keyword argument to pass to the env constructor None vec_env_cls None A custom VecEnv class constructor. Default: None. None vec_env_kwargs None Keyword arguments to pass to the VecEnv class constructor. None monitor_kwargs None Keyword arguments to pass to the Monitor class constructor. None wrapper_kwargs None Keyword arguments to pass to the Wrapper class constructor. None per_env_kwargs None Like env-kwargs, keyword arguments fore the env constructor, but keyed to allow for different initialization on a per-env basis via the env's rank. These override any default values set via the env_kwargs input None Returns: Type Description None The wrapped environment View Source def make_vec_env ( env_id : Union [ str , Callable [ ..., gym . Env ]] , n_envs : int = 1 , seed : Optional [ int ] = None , start_index : int = 0 , monitor_dir : Optional [ str ] = None , wrapper_class : Optional [ Callable [[ gym . Env ] , gym . Env ]] = None , env_kwargs : Optional [ Dict [ str , Any ]] = None , vec_env_cls : Optional [ Type [ Union [ DummyVecEnv , SubprocVecEnv ]]] = None , vec_env_kwargs : Optional [ Dict [ str , Any ]] = None , monitor_kwargs : Optional [ Dict [ str , Any ]] = None , wrapper_kwargs : Optional [ Dict [ str , Any ]] = None , per_env_kwargs : Optional [ Dict [ int , Dict [ str , Any ]]] = None , # NEW ) -> VecEnv : \" \"\" Modified version of make_vec_env from Stable Baselines (SB3) to allow for specifying input parameters on a per-environment basis The main changes are any lines associated with the per_env_kwargs input. Updated SB3 docstring below: Create a wrapped, monitored ``VecEnv``. By default it uses a ``DummyVecEnv`` which is usually faster than a ``SubprocVecEnv``. :param env_id: either the env ID, the env class or a callable returning an env :param n_envs: the number of environments you wish to have in parallel :param seed: the initial seed for the random number generator :param start_index: start rank index :param monitor_dir: Path to a folder where the monitor files will be saved. If None, no file will be written, however, the env will still be wrapped in a Monitor wrapper to provide additional information about training. :param wrapper_class: Additional wrapper to use on the environment. This can also be a function with single argument that wraps the environment in many things. Note: the wrapper specified by this parameter will be applied after the ``Monitor`` wrapper. if some cases (e.g. with TimeLimit wrapper) this can lead to undesired behavior. See here for more details: https://github.com/DLR-RM/stable-baselines3/issues/894 :param env_kwargs: Optional keyword argument to pass to the env constructor :param vec_env_cls: A custom ``VecEnv`` class constructor. Default: None. :param vec_env_kwargs: Keyword arguments to pass to the ``VecEnv`` class constructor. :param monitor_kwargs: Keyword arguments to pass to the ``Monitor`` class constructor. :param wrapper_kwargs: Keyword arguments to pass to the ``Wrapper`` class constructor. :param per_env_kwargs: Like env-kwargs, keyword arguments fore the env constructor, but keyed to allow for different initialization on a per-env basis via the env's rank. These override any default values set via the env_kwargs input :return: The wrapped environment \"\" \" env_kwargs = env_kwargs or {} vec_env_kwargs = vec_env_kwargs or {} monitor_kwargs = monitor_kwargs or {} wrapper_kwargs = wrapper_kwargs or {} per_env_kwargs = per_env_kwargs or {} assert vec_env_kwargs is not None # for mypy def make_env ( rank : int ) -> Callable [[] , gym . Env ] : def _init () -> gym . Env : # For type checker: assert monitor_kwargs is not None assert wrapper_kwargs is not None assert env_kwargs is not None this_env_kwargs = env_kwargs | per_env_kwargs . get ( rank , {} ) if isinstance ( env_id , str ) : # if the render mode was not specified, we set it to `rgb_array` as default. kwargs = { \"render_mode\" : \"rgb_array\" } kwargs . update ( this_env_kwargs ) try : env = gym . make ( env_id , ** kwargs ) # type: ignore[arg-type] except TypeError : env = gym . make ( env_id , ** this_env_kwargs ) else : env = env_id ( ** this_env_kwargs ) # Patch to support gym 0.21/0.26 and gymnasium env = _patch_env ( env ) if seed is not None : # Note: here we only seed the action space # We will seed the env at the next reset env . action_space . seed ( seed + rank ) # Wrap the env in a Monitor wrapper # to have additional training information monitor_path = ( os . path . join ( monitor_dir , str ( rank )) if monitor_dir is not None else None ) # Create the monitor folder if needed if monitor_path is not None and monitor_dir is not None : os . makedirs ( monitor_dir , exist_ok = True ) env = Monitor ( env , filename = monitor_path , ** monitor_kwargs ) # Optionally, wrap the environment with the provided wrapper if wrapper_class is not None : env = wrapper_class ( env , ** wrapper_kwargs ) return env return _init # No custom VecEnv is passed if vec_env_cls is None : # Default: use a DummyVecEnv vec_env_cls = DummyVecEnv vec_env = vec_env_cls ( [ make_env ( i + start_index ) for i in range ( n_envs ) ] , ** vec_env_kwargs ) # Prepare the seeds for the first reset vec_env . seed ( seed ) return vec_env Classes AstrobeeEnv class AstrobeeEnv ( use_gui : bool , robot_pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 0 , 0 , 0 , 0 , 0 , 0 , 1 ), bag_name : str = 'top_handle_symmetric' , bag_mass : float = 10 , bag_type : type [ pyastrobee . core . abstract_bag . CargoBag ] = < class ' pyastrobee . core . deformable_bag . DeformableCargoBag '>, load_full_iss : bool = True ) Base Astrobee environment containing the Astrobee, ISS, and a cargo bag Attributes Name Type Description Default use_gui bool Whether or not to use the GUI as opposed to headless. None robot_pose npt.ArrayLike Starting position + XYZW quaternion pose of the Astrobee, shape (7,) None bag_name str Type of cargo bag to load. Defaults to \"top_handle\". \"top_handle\" bag_mass float Mass of the cargo bag, in kg. Defaults to 10 None bag_type type[CargoBag] Class of cargo bag to use in the environment. Defaults to DeformableCargoBag None load_full_iss bool Whether to load the ISS (expensive, not necessarily required for rollouts) or just work with the safe set information. Defaults to True (load the ISS) None View Source class AstrobeeEnv ( gym . Env ) : \"\"\"Base Astrobee environment containing the Astrobee, ISS, and a cargo bag Args: use_gui (bool): Whether or not to use the GUI as opposed to headless. robot_pose (npt.ArrayLike, optional): Starting position + XYZW quaternion pose of the Astrobee, shape (7,) bag_name (str, optional): Type of cargo bag to load. Defaults to \" top_handle \". bag_mass (float): Mass of the cargo bag, in kg. Defaults to 10 bag_type (type[CargoBag]): Class of cargo bag to use in the environment. Defaults to DeformableCargoBag load_full_iss (bool, optional): Whether to load the ISS (expensive, not necessarily required for rollouts) or just work with the safe set information. Defaults to True (load the ISS) \"\"\" SAVE_STATE_DIR = \"artifacts/saved_states/\" SAVE_STATE_PATHS = [] def __init__ ( self , use_gui : bool , robot_pose : npt . ArrayLike = ( 0 , 0 , 0 , 0 , 0 , 0 , 1 ), bag_name : str = \"top_handle_symmetric\" , bag_mass : float = 10 , bag_type : type [ CargoBag ] = DeformableCargoBag , load_full_iss : bool = True , ) : self . client = initialize_pybullet ( use_gui ) self . safe_set = FULL_SAFE_SET if load_full_iss : self . iss = ISS ( client = self . client ) elif use_gui : for box in self . safe_set . values () : visualize_3D_box ( box , rgba = ( 1 , 0 , 0 , 0.3 )) self . robot = Astrobee ( robot_pose , client = self . client ) self . bag = bag_type ( bag_name , bag_mass , client = self . client ) self . bag . reset_to_handle_pose ( self . robot . ee_pose ) self . bag . attach_to ( self . robot , object_to_move = \"bag\" ) self . dt = self . client . getPhysicsEngineParameters () [ \"fixedTimeStep\" ] # Dummy parameters for gym / stable baselines compatibility # TODO make custom gym . spaces . space . Space subclasses for these ? self . observation_space = gym . spaces . Discrete ( 3 ) # temporary , unused self . action_space = gym . spaces . Discrete ( 3 ) # temporary , unused # Step the simulation once to get the bag in the right place self . client . stepSimulation () def reset ( self , seed : Optional [ int ] = None , options : Optional [ dict[str, Any ] ] = None ) -> tuple [ ObsType, dict[str, Any ] ]: # Implementation of Gym template method reset () : See Gym for full method docstring # Gym states this must be the first line of the reset () method super (). reset ( seed = seed ) return self . _get_obs (), self . _get_info () # Initial state observation def _get_obs ( self ) -> ObsType : \"\"\"Translates the environment's state into an observation Returns: ObsType: Observation \"\"\" # This function setup was recommended in the gym documentation return None , None # Dummy value for now def _get_info ( self ) -> dict [ str, Any ] : \"\"\"Provide auxiliary information associated with an observation Returns: dict[str, Any]: Additional observation information \"\"\" # This function setup was recommended in the gym documentation return {} # Dummy value for now def step ( self , action : ActType ) -> tuple [ ObsType, float, bool, bool, dict[str, Any ] ]: # Implementation of Gym template method step () : See Gym for full method docstring # Note : The return parameters differ slightly from step () for a vectorized environment # In this base environment , we will just step the pybullet simulation and return a dummy value for reward # The MPC environment can add more specific MPC / control functionality here self . client . stepSimulation () reward = 0 observation = self . _get_obs () terminated = False # If at the terminal state truncated = False # If stopping the sim before the terminal state info = self . _get_info () return observation , reward , terminated , truncated , info def step_simulation ( self ) : \"\"\"Single pybullet simulation step\"\"\" self . client . stepSimulation () def close ( self ) : # Implementation of Gym template method close () : See Gym for full method docstring self . client . disconnect () def save_state ( self ) -> str : \"\"\"Saves the current simulation state to disk - Note: saved states are not currently overwritten (could lead to issues with parallel environments?). But, these can be cleared out at the end of the simulation period Returns: str: Path to the saved state file \"\"\" # Autogenerate a unique filename / path and save to it filename = \"state_\" + datetime . now (). strftime ( \"%Y%m%d_%H%M%S_%f\" ) filepath = AstrobeeEnv . SAVE_STATE_DIR + filename + \".bullet\" self . client . saveBullet ( filepath ) AstrobeeEnv . SAVE_STATE_PATHS . append ( filepath ) return filepath def restore_state ( self , filename : str ) -> None : \"\"\"Restores the simulation to a saved state file Args: filename (str): Path to a .bullet saved state within the saved state directory \"\"\" filename = self . _check_state_file ( filename ) self . client . restoreState ( fileName = filename ) def _check_state_file ( self , filename : str ) -> str : \"\"\"Helper function: Validates that a saved state file exists Args: filename (str): Path to a .bullet saved state within the saved state directory Returns: str: Validated path \"\"\" path = Path ( filename ) if path . suffix != \".bullet\" : raise ValueError ( f \"Invalid filename: {filename}.\\nNot a .bullet saved state file\" ) if path . parent != Path ( AstrobeeEnv . SAVE_STATE_DIR ) : raise ValueError ( f \"Invalid filename: {filename}.\\nCheck that the filename points to within the saved state directory\" ) if path . is_file () : return str ( path ) raise FileNotFoundError ( f \"Could not find file: {filename}\" ) def send_client_command ( self , * args , ** kwargs ) -> Any : \"\"\"Send a command to the environment's pybullet client For instance, we can use pybullet.getBasePositionAndOrientation with this as send_client_command(\" getBasePositionAndOrientation \", body_id) Returns: Any: The return from the Pybullet command \"\"\" attr = getattr ( self . client , args [ 0 ] ) if isinstance ( attr , Callable ) : return attr ( * args [ 1: ] , ** kwargs ) return attr Ancestors (in MRO) gymnasium.core.Env typing.Generic Descendants pyastrobee.core.environments.AstrobeeMPCEnv Class variables SAVE_STATE_DIR SAVE_STATE_PATHS metadata render_mode reward_range spec Instance variables np_random Returns the environment's internal :attr: _np_random that if not set will initialise with a random seed. unwrapped Returns the base non-wrapped environment. Methods close def close ( self ) After the user has finished using the environment, close contains the code necessary to \"clean up\" the environment. This is critical for closing rendering windows, database or HTTP connections. Calling close on an already closed environment has no effect and won't raise an error. View Source def close ( self ) : # Implementation of Gym template method close () : See Gym for full method docstring self . client . disconnect () get_wrapper_attr def get_wrapper_attr ( self , name : 'str' ) -> 'Any' Gets the attribute name from the environment. View Source def get_wrapper_attr ( self , name : str ) -> Any : \" \"\" Gets the attribute `name` from the environment. \"\" \" return getattr ( self , name ) render def render ( self ) -> 'RenderFrame | list[RenderFrame] | None' Compute the render frames as specified by :attr: render_mode during the initialization of the environment. The environment's :attr: metadata render modes ( env.metadata[\"render_modes\"] ) should contain the possible ways to implement the render modes. In addition, list versions for most render modes is achieved through gymnasium.make which automatically applies a wrapper to collect rendered frames. Note: As the :attr: render_mode is known during __init__ , the objects used to render the environment state should be initialised in __init__ . By convention, if the :attr: render_mode is: None (default): no render is computed. \"human\": The environment is continuously rendered in the current display or terminal, usually for human consumption. This rendering should occur during :meth: step and :meth: render doesn't need to be called. Returns None . \"rgb_array\": Return a single frame representing the current state of the environment. A frame is a np.ndarray with shape (x, y, 3) representing RGB values for an x-by-y pixel image. \"ansi\": Return a strings ( str ) or StringIO.StringIO containing a terminal-style text representation for each time step. The text can include newlines and ANSI escape sequences (e.g. for colors). \"rgb_array_list\" and \"ansi_list\": List based version of render modes are possible (except Human) through the wrapper, :py:class: gymnasium.wrappers.RenderCollection that is automatically applied during gymnasium.make(..., render_mode=\"rgb_array_list\") . The frames collected are popped after :meth: render is called or :meth: reset . Note: Make sure that your class's :attr: metadata \"render_modes\" key includes the list of supported modes. .. versionchanged:: 0.25.0 The render function was changed to no longer accept parameters, rather these parameters should be specified in the environment initialised, i.e., ``gymnasium.make(\"CartPole-v1\", render_mode=\"human\")`` View Source def render ( self ) -> RenderFrame | list [ RenderFrame ] | None : \" \"\" Compute the render frames as specified by :attr:`render_mode` during the initialization of the environment. The environment's :attr:`metadata` render modes (`env.metadata[\" render_modes \"]`) should contain the possible ways to implement the render modes. In addition, list versions for most render modes is achieved through `gymnasium.make` which automatically applies a wrapper to collect rendered frames. Note: As the :attr:`render_mode` is known during ``__init__``, the objects used to render the environment state should be initialised in ``__init__``. By convention, if the :attr:`render_mode` is: - None (default): no render is computed. - \" human \": The environment is continuously rendered in the current display or terminal, usually for human consumption. This rendering should occur during :meth:`step` and :meth:`render` doesn't need to be called. Returns ``None``. - \" rgb_array \": Return a single frame representing the current state of the environment. A frame is a ``np.ndarray`` with shape ``(x, y, 3)`` representing RGB values for an x-by-y pixel image. - \" ansi \": Return a strings (``str``) or ``StringIO.StringIO`` containing a terminal-style text representation for each time step. The text can include newlines and ANSI escape sequences (e.g. for colors). - \" rgb_array_list \" and \" ansi_list \": List based version of render modes are possible (except Human) through the wrapper, :py:class:`gymnasium.wrappers.RenderCollection` that is automatically applied during ``gymnasium.make(..., render_mode=\" rgb_array_list \")``. The frames collected are popped after :meth:`render` is called or :meth:`reset`. Note: Make sure that your class's :attr:`metadata` ``\" render_modes \"`` key includes the list of supported modes. .. versionchanged:: 0.25.0 The render function was changed to no longer accept parameters, rather these parameters should be specified in the environment initialised, i.e., ``gymnasium.make(\" CartPole - v1 \", render_mode=\" human \")`` \"\" \" raise NotImplementedError reset def reset ( self , seed : Optional [ int ] = None , options : Optional [ dict [ str , Any ]] = None ) -> tuple [ ~ ObsType , dict [ str , typing . Any ]] Resets the environment to an initial internal state, returning an initial observation and info. This method generates a new starting state often with some randomness to ensure that the agent explores the state space and learns a generalised policy about the environment. This randomness can be controlled with the seed parameter otherwise if the environment already has a random number generator and :meth: reset is called with seed=None , the RNG is not reset. Therefore, :meth: reset should (in the typical use case) be called with a seed right after initialization and then never again. For Custom environments, the first line of :meth: reset should be super().reset(seed=seed) which implements the seeding correctly. .. versionchanged:: v0.25 The `` return_info `` parameter was removed and now info is expected to be returned . Parameters: Name Type Description Default seed optional int The seed that is used to initialize the environment's PRNG ( np_random ). If the environment does not already have a PRNG and seed=None (the default option) is passed, a seed will be chosen from some source of entropy (e.g. timestamp or /dev/urandom). However, if the environment already has a PRNG and seed=None is passed, the PRNG will not be reset. If you pass an integer, the PRNG will be reset even if it already exists. Usually, you want to pass an integer right after the environment has been initialized and then never again . Please refer to the minimal example above to see this paradigm in action. None options optional dict Additional information to specify how the environment is reset (optional, depending on the specific environment) None Returns: Type Description None observation (ObsType): Observation of the initial state. This will be an element of :attr: observation_space (typically a numpy array) and is analogous to the observation returned by :meth: step . info (dictionary): This dictionary contains auxiliary information complementing observation . It should be analogous to the info returned by :meth: step . View Source def reset ( self , seed : Optional [ int ] = None , options : Optional [ dict[str, Any ] ] = None ) -> tuple [ ObsType, dict[str, Any ] ]: # Implementation of Gym template method reset () : See Gym for full method docstring # Gym states this must be the first line of the reset () method super (). reset ( seed = seed ) return self . _get_obs (), self . _get_info () # Initial state observation restore_state def restore_state ( self , filename : str ) -> None Restores the simulation to a saved state file Parameters: Name Type Description Default filename str Path to a .bullet saved state within the saved state directory None View Source def restore_state ( self , filename : str ) -> None : \"\"\"Restores the simulation to a saved state file Args: filename (str): Path to a .bullet saved state within the saved state directory \"\"\" filename = self . _check_state_file ( filename ) self . client . restoreState ( fileName = filename ) save_state def save_state ( self ) -> str Saves the current simulation state to disk Note: saved states are not currently overwritten (could lead to issues with parallel environments?). But, these can be cleared out at the end of the simulation period Returns: Type Description str Path to the saved state file View Source def save_state ( self ) -> str : \"\"\"Saves the current simulation state to disk - Note: saved states are not currently overwritten (could lead to issues with parallel environments?). But, these can be cleared out at the end of the simulation period Returns: str: Path to the saved state file \"\"\" # Autogenerate a unique filename / path and save to it filename = \"state_\" + datetime . now (). strftime ( \"%Y%m%d_%H%M%S_%f\" ) filepath = AstrobeeEnv . SAVE_STATE_DIR + filename + \".bullet\" self . client . saveBullet ( filepath ) AstrobeeEnv . SAVE_STATE_PATHS . append ( filepath ) return filepath send_client_command def send_client_command ( self , * args , ** kwargs ) -> Any Send a command to the environment's pybullet client For instance, we can use pybullet.getBasePositionAndOrientation with this as send_client_command(\"getBasePositionAndOrientation\", body_id) Returns: Type Description Any The return from the Pybullet command View Source def send_client_command(self, *args, * *kwargs) -> Any: \"\"\"Send a command to the environment's pybullet client For instance, we can use pybullet.getBasePositionAndOrientation with this as send_client_command(\"getBasePositionAndOrientation\", body_id) Returns: Any: The return from the Pybullet command \"\"\" attr = getattr(self.client, args[0]) if isinstance(attr, Callable): return attr(*args[1:], **kwargs) return attr step def step ( self , action : ~ ActType ) -> tuple [ ~ ObsType , float , bool , bool , dict [ str , typing . Any ]] Run one timestep of the environment's dynamics using the agent actions. When the end of an episode is reached ( terminated or truncated ), it is necessary to call :meth: reset to reset this environment's state for the next episode. .. versionchanged:: 0.26 The Step API was changed removing `` done `` in favor of `` terminated `` and `` truncated `` to make it clearer to users when the environment had terminated or truncated which is critical for reinforcement learning bootstrapping algorithms . Parameters: Name Type Description Default action ActType an action provided by the agent to update the environment state. None Returns: Type Description None observation (ObsType): An element of the environment's :attr: observation_space as the next observation due to the agent actions. An example is a numpy array containing the positions and velocities of the pole in CartPole. reward (SupportsFloat): The reward as a result of taking the action. terminated (bool): Whether the agent reaches the terminal state (as defined under the MDP of the task) which can be positive or negative. An example is reaching the goal state or moving into the lava from the Sutton and Barton, Gridworld. If true, the user needs to call :meth: reset . truncated (bool): Whether the truncation condition outside the scope of the MDP is satisfied. Typically, this is a timelimit, but could also be used to indicate an agent physically going out of bounds. Can be used to end the episode prematurely before a terminal state is reached. If true, the user needs to call :meth: reset . info (dict): Contains auxiliary diagnostic information (helpful for debugging, learning, and logging). This might, for instance, contain: metrics that describe the agent's performance state, variables that are hidden from observations, or individual reward terms that are combined to produce the total reward. In OpenAI Gym <v26, it contains \"TimeLimit.truncated\" to distinguish truncation and termination, however this is deprecated in favour of returning terminated and truncated variables. done (bool): (Deprecated) A boolean value for if the episode has ended, in which case further :meth: step calls will return undefined results. This was removed in OpenAI Gym v26 in favor of terminated and truncated attributes. A done signal may be emitted for different reasons: Maybe the task underlying the environment was solved successfully, a certain timelimit was exceeded, or the physics simulation has entered an invalid state. View Source def step ( self , action : ActType ) -> tuple [ ObsType , float , bool , bool , dict [ str , Any ]] : # Implementation of Gym template method step () : See Gym for full method docstring # Note : The return parameters differ slightly from step () for a vectorized environment # In this base environment , we will just step the pybullet simulation and return a dummy value for reward # The MPC environment can add more specific MPC / control functionality here self . client . stepSimulation () reward = 0 observation = self . _get_obs () terminated = False # If at the terminal state truncated = False # If stopping the sim before the terminal state info = self . _get_info () return observation , reward , terminated , truncated , info step_simulation def step_simulation ( self ) Single pybullet simulation step View Source def step_simulation(self): \"\"\"Single pybullet simulation step\"\"\" self.client.stepSimulation() AstrobeeMPCEnv class AstrobeeMPCEnv ( use_gui : bool , is_primary : bool , robot_pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 0 , 0 , 0 , 0 , 0 , 0 , 1 ), bag_name : str = 'top_handle' , bag_mass : float = 10 , bag_type : type [ pyastrobee . core . abstract_bag . CargoBag ] = < class ' pyastrobee . core . deformable_bag . DeformableCargoBag '>, load_full_iss : bool = True , nominal_rollouts : bool = False , cleanup : bool = True ) Astrobee environment for MPC: Contains additional controller parameters and functions associated with MPC, on top of the base Astrobee environment capability Attributes Name Type Description Default use_gui bool Whether or not to use the GUI as opposed to headless. None is_primary bool Whether or not this environment is the main simulation (True) or if it is one of the vectorized environments for evaluating a rollout (False) None robot_pose npt.ArrayLike Starting position + XYZW quaternion pose of the Astrobee, shape (7,) None bag_name str Type of cargo bag to load. Defaults to \"top_handle\". \"top_handle\" bag_mass float Mass of the cargo bag, in kg. Defaults to 10 None bag_type type[CargoBag] Class of cargo bag to use in the environment. Defaults to DeformableCargoBag None load_full_iss bool Whether to load the ISS (expensive, not necessarily required for rollouts) or just work with the safe set information. Defaults to True (load the ISS) None nominal_rollouts bool If True, will roll-out a trajectory based on the nominal target. If False, will sample a trajectory about the nominal target. Defaults to False. None cleanup bool Whether or not to delete all saved states when the simulation ends. Defaults to True. True View Source class AstrobeeMPCEnv ( AstrobeeEnv ): \"\"\"Astrobee environment for MPC: Contains additional controller parameters and functions associated with MPC, on top of the base Astrobee environment capability Args: use_gui (bool): Whether or not to use the GUI as opposed to headless. is_primary (bool): Whether or not this environment is the main simulation (True) or if it is one of the vectorized environments for evaluating a rollout (False) robot_pose (npt.ArrayLike, optional): Starting position + XYZW quaternion pose of the Astrobee, shape (7,) bag_name (str, optional): Type of cargo bag to load. Defaults to \"top_handle\". bag_mass (float): Mass of the cargo bag, in kg. Defaults to 10 bag_type (type[CargoBag]): Class of cargo bag to use in the environment. Defaults to DeformableCargoBag load_full_iss (bool, optional): Whether to load the ISS (expensive, not necessarily required for rollouts) or just work with the safe set information. Defaults to True (load the ISS) nominal_rollouts (bool, optional): If True, will roll-out a trajectory based on the nominal target. If False, will sample a trajectory about the nominal target. Defaults to False. cleanup (bool, optional): Whether or not to delete all saved states when the simulation ends. Defaults to True. \"\"\" class FlightStates ( Enum ): # STARTING = \"starting\" NOMINAL = \"nominal\" SLOWING = \"slowing\" STOPPING = \"stopping\" def __init__ ( self , use_gui : bool , is_primary : bool , robot_pose : npt . ArrayLike = ( 0 , 0 , 0 , 0 , 0 , 0 , 1 ), bag_name : str = \"top_handle\" , bag_mass : float = 10 , bag_type : type [ CargoBag ] = DeformableCargoBag , load_full_iss : bool = True , nominal_rollouts : bool = False , cleanup : bool = True , ): super () . __init__ ( use_gui , robot_pose , bag_name , bag_mass , bag_type , load_full_iss ) # TODO figure out how to handle controller parameters # Just fixing the gains here for now # TODO should these be functions of the bag mass??? kp , kv , kq , kw = 20 , 5 , 5 , 0.1 # TODO make parameters p = self . bag . position - self . robot . position self . controller = ForceTorqueController ( self . robot . id , self . robot . mass + bag_mass , # self.robot.inertia, self . robot . inertia + bag_mass * ( np . dot ( p , p ) * np . eye ( 3 ) - np . outer ( p , p ) ), # TODO parallel axis theorem for bag?? test this kp , kv , kq , kw , self . dt , max_force = MAX_FORCE_MAGNITUDE * 10 , # TODO REMOVE THIS SCALING FACTOR max_torque = MAX_TORQUE_MAGNITUDE * 10 , client = self . client , ) # Sampling parameters (TODO these need refinement) self . pos_stdev = 0.1 self . orn_stdev = 0.1 self . vel_stdev = 0.1 self . ang_vel_stdev = 0.1 self . accel_stdev = 0.1 self . alpha_stdev = 0.1 # Store last acceleration commands # Update through set_attr self . last_accel_cmd = np . zeros ( 3 ) # init self . last_alpha_cmd = np . zeros ( 3 ) # init # Frequency at which we query our \"stay away from the walls\" cost function self . safe_set_eval_freq = 10 # Hz # Keep track of any temporary debug visualizer IDs self . debug_viz_ids = () # Keep track of whether we're stopping or in a nominal flight mode self . flight_state = self . FlightStates . NOMINAL # init # (effectively the rollout duration, should be a constant) - TODO IMPROVE THIS self . planning_duration = None # Store where we want the Astrobee to be at the end of the MPC run to determine if we are done self . goal_pose = None # init # HACK - improve how this is handled self . arm_traj_plan = None self . _is_primary_env = is_primary self . _is_debugging_env = not is_primary and use_gui self . _nominal_rollouts = nominal_rollouts self . _cleanup = cleanup self . traj_plan = None # Init self . target_pos = None # Init self . target_orn = None # Init self . target_vel = None # Init self . target_omega = None # Init self . target_duration = None # Init @ property def is_primary_simulation ( self ) -> bool : \"\"\"Whether this environment is running the primary planning/control simulation or is a separate (likely vectorized) environment for evaluating rollouts\"\"\" return self . _is_primary_env @ property def is_debugging_simulation ( self ) -> bool : \"\"\"Whether this is an environment launched in debug mode\"\"\" return self . _is_debugging_env def set_arm_traj ( self , traj : ArmTrajectory ): # TODO IMPROVE THIS self . arm_traj_plan = traj def set_planning_duration ( self , duration ): # TODO improve this self . planning_duration = duration def set_flight_state ( self , state : Union [ str , FlightStates ]): \"\"\"Set the current flight state: for instance, whether we are in nominal operating mode, stopping, ... Args: state (Union[str, FlightStates]): A flight state or its string representation (i.e. \"nominal\", \"stopping\", ...) \"\"\" # TODO add check that it is valid # TODO should we store the state as the string or the Enum???? if isinstance ( state , str ): self . flight_state = self . FlightStates ( state ) elif isinstance ( state , self . FlightStates ): self . flight_state = state else : raise ValueError ( \"Flight state not recognized\" ) def set_target_state ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , vel : npt . ArrayLike , omega : npt . ArrayLike , accel : npt . ArrayLike , alpha : npt . ArrayLike , duration : float , ) -> None : \"\"\"Set the target dynamics state for planning/sampling trajectories and determining penalties Args: pos (npt.ArrayLike): Desired position, shape (3,) orn (npt.ArrayLike): Desired XYZW quaternion orientation, shape (4,) vel (npt.ArrayLike): Desired linear velocity, shape (3,) omega (npt.ArrayLike): Desired angular velocity, shape (3,) accel (npt.ArrayLike): Desired linear acceleration, shape (3,) alpha (npt.ArrayLike): Desired angular acceleration, shape (3,) duration (float): Amount of time to pass before achieving this desired state \"\"\" self . target_pos = pos self . target_orn = orn self . target_vel = vel self . target_omega = omega self . target_accel = accel self . target_alpha = alpha self . target_duration = duration def sample_trajectory ( self ) -> None : \"\"\"Samples a trajectory about the nominal target. - If the nominal_rollouts parameter is True for this environment, the final state of the trajectory will be exactly the nominal value (no noise added when sampling) - This should just be called in the vectorized rollout environments (not the main environment) since the main environment will use the best trajectory from the rollout envs \"\"\" if self . is_primary_simulation : raise ValueError ( \"Trajectory sampling should only occur in one of parallel environments for evaluation purposes\" ) pos , orn , vel , omega = self . robot . dynamics_state # Time sampling parameters (TODO refine these, move them somewhere else) time_stdev = 1 # Note: ensure that this is a positive value post-sampling min_time = 1 n_timesteps = round ( self . planning_duration / self . dt ) # Nominal if self . flight_state == self . FlightStates . NOMINAL : end_state = ( [ self . target_pos , self . target_orn , self . target_vel , self . target_omega , self . target_accel , self . target_alpha , ] if self . _nominal_rollouts else sample_state ( self . target_pos , self . target_orn , self . target_vel , self . target_omega , self . last_accel_cmd , self . last_alpha_cmd , self . pos_stdev , self . orn_stdev , self . vel_stdev , self . ang_vel_stdev , self . accel_stdev , self . alpha_stdev , ) ) duration = self . target_duration elif self . flight_state == self . FlightStates . SLOWING : end_state = ( [ self . target_pos , self . target_orn , self . target_vel , self . target_omega , self . target_accel , self . target_alpha , ] if self . _nominal_rollouts else sample_state ( self . target_pos , self . target_orn , self . target_vel , self . target_omega , self . last_accel_cmd , self . last_alpha_cmd , self . pos_stdev / 3 , self . orn_stdev / 3 , self . vel_stdev / 3 , self . ang_vel_stdev / 3 , self . accel_stdev / 3 , self . alpha_stdev / 3 , ) ) duration = ( self . target_duration if self . _nominal_rollouts else np . maximum ( np . random . normal ( self . target_duration , time_stdev ), min_time ) ) elif self . flight_state == self . FlightStates . STOPPING : end_state = [ self . target_pos , self . target_orn , self . target_vel , self . target_omega , self . target_accel , self . target_alpha , ] duration = ( self . planning_duration if self . _nominal_rollouts else np . maximum ( np . random . normal ( self . planning_duration , time_stdev ), min_time ) ) else : raise AttributeError ( \"Flight state not recognized\" ) traj = local_planner ( pos , orn , vel , omega , self . last_accel_cmd , self . last_alpha_cmd , * end_state , duration , self . dt , ) if traj . num_timesteps == n_timesteps : self . traj_plan = traj else : # Traj is either too long or too short, so adjust it if traj . num_timesteps > n_timesteps : self . traj_plan = traj . get_segment ( 0 , n_timesteps ) else : # Less than # Create a trajectory at the stopped position for the remaining timesteps remaining_timesteps = n_timesteps - traj . num_timesteps stop_traj = Trajectory ( traj . positions [ - 1 ] * np . ones (( remaining_timesteps , 1 )), traj . quaternions [ - 1 ] * np . ones (( remaining_timesteps , 1 )), np . zeros (( remaining_timesteps , 3 )), np . zeros (( remaining_timesteps , 3 )), np . zeros (( remaining_timesteps , 3 )), np . zeros (( remaining_timesteps , 3 )), np . arange ( remaining_timesteps ) * self . dt , ) self . traj_plan = concatenate_trajs ( traj , stop_traj ) self . sampled_end_state = ( self . traj_plan . positions [ - 1 ], self . traj_plan . quaternions [ - 1 ], self . traj_plan . linear_velocities [ - 1 ], self . traj_plan . angular_velocities [ - 1 ], ) def _get_obs ( self ) -> ObsType : if self . is_primary_simulation : return self . robot . full_state , self . bag . dynamics_state else : return None , None def step ( self , action : ActType ) -> tuple [ ObsType , float , bool , bool , dict [ str , Any ]]: # Note: For MPC, this is less so a \"step\" than a \"rollout\" function. The trajectory should be sampled # before calling this function # TODO use the action parameter to pass in a trajectory to follow? terminated = False # init (If at the terminal state) truncated = False # init (If stopping the sim before the terminal state) if self . traj_plan is None : raise ValueError ( \"Trajectory has not been planned\" ) # Follow the trajectory. NOTE: This is effectively the same as the follow_traj() function in the controller, # but accessing the loop directly allows us to do more with the data at each step # TODO decide how to handle the stopping criteria if not self . traj_plan . num_timesteps == self . arm_traj_plan . num_timesteps : raise ValueError ( \"Mismatched time info between base and arm trajs\" ) # If this is the primary simulation, we just follow the best trajectory we have # Rewrd for the primary simulation doesn't mean anything, so no computation needed inertia_update_freq = 5 steps_per_inertia_update = round ( 1 / ( self . traj_plan . timestep * inertia_update_freq ) ) if self . is_primary_simulation : for i in range ( self . traj_plan . num_timesteps ): pos , orn , lin_vel , ang_vel = self . controller . get_current_state () self . controller . step ( pos , lin_vel , orn , ang_vel , self . traj_plan . positions [ i , :], self . traj_plan . linear_velocities [ i , :], self . traj_plan . linear_accels [ i , :], self . traj_plan . quaternions [ i , :], self . traj_plan . angular_velocities [ i , :], self . traj_plan . angular_accels [ i , :], ) self . robot . set_joint_angles ( self . arm_traj_plan . angles [ i , :], self . arm_traj_plan . joint_ids ) # TODO THIS KINDA SUCKS if i % steps_per_inertia_update == 0 : T_R2W = self . robot . tmat T_B2W = self . bag . tmat T_B2R = invert_transform_mat ( T_R2W ) @ T_B2W p = T_B2R [: 3 , 3 ] self . controller . inertia = self . robot . inertia + self . bag . mass * ( np . dot ( p , p ) * np . eye ( 3 ) - np . outer ( p , p ) ) reward = 0 else : # We are in a rollout environment # So, follow the trajectory, but also keep track of a bunch of things so that we can compute the reward robot_safe_set_cost = 0 # init bag_safe_set_cost = 0 # init stabilization_cost = 0 tracking_cost = 0 bag_vel_cost = 0 steps_per_safe_set_eval = round ( 1 / ( self . traj_plan . timestep * self . safe_set_eval_freq ) ) # TODO IMPROVE THIS # the thought here was that if we're stopping (or slowing) we care more about the overall positioning # rather than just staying in the middle of the modules safe_set_weight = ( 1 if self . flight_state == self . FlightStates . NOMINAL else 0.1 ) for i in range ( self . traj_plan . num_timesteps ): # Note: the traj log gets updated whenever we access the current state pos , orn , lin_vel , ang_vel = self . controller . get_current_state () self . controller . step ( pos , lin_vel , orn , ang_vel , self . traj_plan . positions [ i , :], self . traj_plan . linear_velocities [ i , :], self . traj_plan . linear_accels [ i , :], self . traj_plan . quaternions [ i , :], self . traj_plan . angular_velocities [ i , :], self . traj_plan . angular_accels [ i , :], ) self . robot . set_joint_angles ( self . arm_traj_plan . angles [ i , :], self . arm_traj_plan . joint_ids ) # TODO THIS KINDA SUCKS if i % steps_per_inertia_update == 0 : T_R2W = self . robot . tmat T_B2W = self . bag . tmat T_B2R = invert_transform_mat ( T_R2W ) @ T_B2W p = T_B2R [: 3 , 3 ] self . controller . inertia = self . robot . inertia + self . bag . mass * ( np . dot ( p , p ) * np . eye ( 3 ) - np . outer ( p , p ) ) # *** COST FUNCTION *** # Perform collision checking on every timestep robot_bb = self . robot . bounding_box bag_bb = self . bag . bounding_box robot_is_safe = check_box_containment ( robot_bb , self . safe_set . values ()) bag_is_safe = check_box_containment ( bag_bb , self . safe_set . values ()) # If either the robot or bag collided, stop the simulation and return an effectively infinite cost # (Very large but not infinity to maintain sorting order in the edge case that all rollouts collide) if not robot_is_safe : robot_safe_set_cost += 10000 truncated = True # break if not bag_is_safe : bag_safe_set_cost += 10000 truncated = True # break # These \"stay away from the walls\" costs are somewhat expensive to compute and don't necessarily need # to be done every timestep. TODO just use the local description of the safe set, not the full thing if i % steps_per_safe_set_eval == 0 : robot_safe_set_cost += safe_set_weight * safe_set_cost ( robot_bb [ 0 ], self . safe_set . values () ) robot_safe_set_cost += safe_set_weight * safe_set_cost ( robot_bb [ 1 ], self . safe_set . values () ) bag_safe_set_cost += safe_set_weight * safe_set_cost ( bag_bb [ 0 ], self . safe_set . values () ) bag_safe_set_cost += safe_set_weight * safe_set_cost ( bag_bb [ 1 ], self . safe_set . values () ) bag_pos , bag_orn , bag_vel , bag_ang_vel = self . bag . dynamics_state # Penalizing bag velocities perpendicular to the robot's velocity at end of rollout if self . flight_state == self . FlightStates . NOMINAL : bag_vel_cost = 300 * ( np . linalg . norm ( bag_vel ) - np . dot ( lin_vel / np . linalg . norm ( lin_vel ), bag_vel ) ) # End-of-rollout additional cost function evaluations # 1) Stabilize the motion of the bag with respect to the robot # 2) Position the robot so it's stopped at the goal pose # Both of these are only relevant when we're at the end of the nominal trajectory # TODO tune all of the scaling factors on the costs if self . flight_state == self . FlightStates . STOPPING : angular_term = np . linalg . norm ( ang_vel - bag_ang_vel ) r_r2b = bag_pos - pos # Vector from robot to bag linear_term = np . linalg . norm ( lin_vel - bag_vel + np . cross ( ang_vel , r_r2b ) ) stabilization_cost += 500 * ( linear_term + angular_term ) # TODO make this a separate function? # Adding back in a tracking cost component # If we are stopping then we know that the target state is the goal pos_error = np . linalg . norm ( pos - self . target_pos ) orn_error = quaternion_dist ( orn , self . target_orn ) vel_error = np . linalg . norm ( lin_vel - self . target_vel ) ang_vel_error = np . linalg . norm ( ang_vel - self . target_omega ) if self . is_debugging_simulation : print ( \"Position error: \" , pos_error ) print ( \"Orn error: \" , orn_error ) print ( \"Vel error: \" , vel_error ) print ( \"Ang vel error: \" , ang_vel_error ) tracking_cost += ( 200 * pos_error + 100 * orn_error + 200 * vel_error + 100 * ang_vel_error ) else : stabilization_cost = 0 tracking_cost = 0 if self . is_debugging_simulation : print ( \"Robot safe set cost: \" , robot_safe_set_cost ) print ( \"Bag safe set cost: \" , bag_safe_set_cost ) print ( \"Stabilization cost: \" , stabilization_cost ) print ( \"Tracking cost: \" , tracking_cost ) print ( \"Bag velocity cost: \" , bag_vel_cost ) reward = - 1 * ( robot_safe_set_cost + bag_safe_set_cost + stabilization_cost + tracking_cost + bag_vel_cost ) # Observe the robot/bag state in the main env, dummy value if in rollout env observation = self . _get_obs () # Evaluate if we have stabilized the robot and the bag at the end of the trajectory # (main env only since that's what we care about and we don't want to waste compute) if ( self . flight_state == self . FlightStates . STOPPING and self . is_primary_simulation and robot_and_bag_termination_criteria ( observation [ 0 ], observation [ 1 ], self . goal_pose ) ): terminated = True # TODO: If we change the observation function to return the state of the robot and the bag, # we can determine the \"terminated\" parameter! # But note that we should only really do the observation in the main env info = self . _get_info () return observation , reward , terminated , truncated , info def close ( self ): self . client . disconnect () if self . is_primary_simulation and self . _cleanup : # Delete all of the previous saved states at the end of the simulation process # TODO: decide if each session should have its own directory? for path in Path ( AstrobeeMPCEnv . SAVE_STATE_DIR ) . glob ( \"*.bullet\" ): path . unlink () def save_state ( self ) -> str : # Ensure that any simulations strictly for evaluating rollouts cannot save their state if not self . is_primary_simulation : raise PermissionError ( \"Only the primary simulation can save the state\" ) return super () . save_state () def get_robot_state ( self ) -> tuple [ np . ndarray , ... ]: \"\"\"Returns the full state information for the Astrobee in the environment (Base pos/orn/vels, joint angles/vels) Returns: tuple[np.ndarray, ...]: np.ndarray: Position, shape (3,) np.ndarray: Orientation (XYZW quaternion), shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) np.ndarray: Joint positions, shape (NUM_JOINTS,) np.ndarray: Joint velocities, shape (NUM_JOINTS,) \"\"\" return self . robot . full_state def get_bag_state ( self ) -> tuple [ np . ndarray , ... ]: \"\"\"Returns the dynamics state information for the bag in the environment (pos/orn/vels) Returns: tuple[np.ndarray, ...]: np.ndarray: Position, shape (3,) np.ndarray: XYZW quaternion orientation, shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) \"\"\" return self . bag . dynamics_state def reset_robot_state ( self , state : tuple [ np . ndarray , ... ]) -> None : \"\"\"Fully resets the state of the Astrobee in the environment Args: state (tuple[np.ndarray, ...]): Full Astrobee state information containing: np.ndarray: Position, shape (3,) np.ndarray: Orientation (XYZW quaternion), shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) np.ndarray: Joint positions, shape (NUM_JOINTS,) np.ndarray: Joint velocities, shape (NUM_JOINTS,) \"\"\" assert len ( state ) == 6 assert len ( state [ 0 ]) == 3 assert len ( state [ 1 ]) == 4 assert len ( state [ 2 ]) == 3 assert len ( state [ 3 ]) == 3 assert len ( state [ 4 ]) == Astrobee . NUM_JOINTS assert len ( state [ 5 ]) == Astrobee . NUM_JOINTS self . robot . reset_full_state ( * state ) def reset_bag_state ( self , state : tuple [ np . ndarray , ... ]) -> None : \"\"\"Resets the dynamics of the bag in the environment Args: state (tuple[np.ndarray, ...]): Dynamics info of the bag, containing: np.ndarray: Position, shape (3,) np.ndarray: Orientation (XYZW quaternion), shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) \"\"\" assert len ( state ) == 4 assert len ( state [ 0 ]) == 3 assert len ( state [ 1 ]) == 4 assert len ( state [ 2 ]) == 3 assert len ( state [ 3 ]) == 3 self . bag . reset_dynamics ( * state ) def show_traj_plan ( self , n : Optional [ int ]) -> None : \"\"\"Displays the planned trajectory on the current pybullet client GUI (if enabled) Args: n (Optional[int]): Number of frames to plot, if plotting all of the frames is not desired. Defaults to None (plot all frames) \"\"\" if self . traj_plan is None : raise ValueError ( \"No trajectory available to visualize\" ) self . debug_viz_ids = self . traj_plan . visualize ( n , client = self . client ) def unshow_traj_plan ( self ) -> None : \"\"\"Removes a displayed trajectory from the pybullet client GUI\"\"\" if len ( self . debug_viz_ids ) == 0 : return remove_debug_objects ( self . debug_viz_ids , self . client ) self . debug_viz_ids = () Ancestors (in MRO) pyastrobee.core.environments.AstrobeeEnv gymnasium.core.Env typing.Generic Class variables FlightStates SAVE_STATE_DIR SAVE_STATE_PATHS metadata render_mode reward_range spec Instance variables is_debugging_simulation Whether this is an environment launched in debug mode is_primary_simulation Whether this environment is running the primary planning/control simulation or is a separate (likely vectorized) environment for evaluating rollouts np_random Returns the environment's internal :attr: _np_random that if not set will initialise with a random seed. unwrapped Returns the base non-wrapped environment. Methods close def close ( self ) After the user has finished using the environment, close contains the code necessary to \"clean up\" the environment. This is critical for closing rendering windows, database or HTTP connections. Calling close on an already closed environment has no effect and won't raise an error. View Source def close(self): self.client.disconnect() if self.is_primary_simulation and self._cleanup: # Delete all of the previous saved states at the end of the simulation process # TODO: decide if each session should have its own directory? for path in Path(AstrobeeMPCEnv.SAVE_STATE_DIR).glob(\"*.bullet\"): path.unlink() get_bag_state def get_bag_state ( self ) -> tuple [ numpy . ndarray , ... ] Returns the dynamics state information for the bag in the environment (pos/orn/vels) Returns: Type Description tuple[np.ndarray, ...] np.ndarray: Position, shape (3,) np.ndarray: XYZW quaternion orientation, shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) View Source def get_bag_state ( self ) -> tuple [ np . ndarray , ...] : \"\"\"Returns the dynamics state information for the bag in the environment (pos/orn/vels) Returns: tuple[np.ndarray, ...]: np.ndarray: Position, shape (3,) np.ndarray: XYZW quaternion orientation, shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) \"\"\" return self . bag . dynamics_state get_robot_state def get_robot_state ( self ) -> tuple [ numpy . ndarray , ... ] Returns the full state information for the Astrobee in the environment (Base pos/orn/vels, joint angles/vels) Returns: Type Description tuple[np.ndarray, ...] np.ndarray: Position, shape (3,) np.ndarray: Orientation (XYZW quaternion), shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) np.ndarray: Joint positions, shape (NUM_JOINTS,) np.ndarray: Joint velocities, shape (NUM_JOINTS,) View Source def get_robot_state ( self ) -> tuple [ np . ndarray , ...] : \"\"\"Returns the full state information for the Astrobee in the environment (Base pos/orn/vels, joint angles/vels) Returns: tuple[np.ndarray, ...]: np.ndarray: Position, shape (3,) np.ndarray: Orientation (XYZW quaternion), shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) np.ndarray: Joint positions, shape (NUM_JOINTS,) np.ndarray: Joint velocities, shape (NUM_JOINTS,) \"\"\" return self . robot . full_state get_wrapper_attr def get_wrapper_attr ( self , name : 'str' ) -> 'Any' Gets the attribute name from the environment. View Source def get_wrapper_attr ( self , name : str ) -> Any : \" \"\" Gets the attribute `name` from the environment. \"\" \" return getattr ( self , name ) render def render ( self ) -> 'RenderFrame | list[RenderFrame] | None' Compute the render frames as specified by :attr: render_mode during the initialization of the environment. The environment's :attr: metadata render modes ( env.metadata[\"render_modes\"] ) should contain the possible ways to implement the render modes. In addition, list versions for most render modes is achieved through gymnasium.make which automatically applies a wrapper to collect rendered frames. Note: As the :attr: render_mode is known during __init__ , the objects used to render the environment state should be initialised in __init__ . By convention, if the :attr: render_mode is: None (default): no render is computed. \"human\": The environment is continuously rendered in the current display or terminal, usually for human consumption. This rendering should occur during :meth: step and :meth: render doesn't need to be called. Returns None . \"rgb_array\": Return a single frame representing the current state of the environment. A frame is a np.ndarray with shape (x, y, 3) representing RGB values for an x-by-y pixel image. \"ansi\": Return a strings ( str ) or StringIO.StringIO containing a terminal-style text representation for each time step. The text can include newlines and ANSI escape sequences (e.g. for colors). \"rgb_array_list\" and \"ansi_list\": List based version of render modes are possible (except Human) through the wrapper, :py:class: gymnasium.wrappers.RenderCollection that is automatically applied during gymnasium.make(..., render_mode=\"rgb_array_list\") . The frames collected are popped after :meth: render is called or :meth: reset . Note: Make sure that your class's :attr: metadata \"render_modes\" key includes the list of supported modes. .. versionchanged:: 0.25.0 The render function was changed to no longer accept parameters, rather these parameters should be specified in the environment initialised, i.e., ``gymnasium.make(\"CartPole-v1\", render_mode=\"human\")`` View Source def render ( self ) -> RenderFrame | list [ RenderFrame ] | None : \" \"\" Compute the render frames as specified by :attr:`render_mode` during the initialization of the environment. The environment's :attr:`metadata` render modes (`env.metadata[\" render_modes \"]`) should contain the possible ways to implement the render modes. In addition, list versions for most render modes is achieved through `gymnasium.make` which automatically applies a wrapper to collect rendered frames. Note: As the :attr:`render_mode` is known during ``__init__``, the objects used to render the environment state should be initialised in ``__init__``. By convention, if the :attr:`render_mode` is: - None (default): no render is computed. - \" human \": The environment is continuously rendered in the current display or terminal, usually for human consumption. This rendering should occur during :meth:`step` and :meth:`render` doesn't need to be called. Returns ``None``. - \" rgb_array \": Return a single frame representing the current state of the environment. A frame is a ``np.ndarray`` with shape ``(x, y, 3)`` representing RGB values for an x-by-y pixel image. - \" ansi \": Return a strings (``str``) or ``StringIO.StringIO`` containing a terminal-style text representation for each time step. The text can include newlines and ANSI escape sequences (e.g. for colors). - \" rgb_array_list \" and \" ansi_list \": List based version of render modes are possible (except Human) through the wrapper, :py:class:`gymnasium.wrappers.RenderCollection` that is automatically applied during ``gymnasium.make(..., render_mode=\" rgb_array_list \")``. The frames collected are popped after :meth:`render` is called or :meth:`reset`. Note: Make sure that your class's :attr:`metadata` ``\" render_modes \"`` key includes the list of supported modes. .. versionchanged:: 0.25.0 The render function was changed to no longer accept parameters, rather these parameters should be specified in the environment initialised, i.e., ``gymnasium.make(\" CartPole - v1 \", render_mode=\" human \")`` \"\" \" raise NotImplementedError reset def reset ( self , seed : Optional [ int ] = None , options : Optional [ dict [ str , Any ]] = None ) -> tuple [ ~ ObsType , dict [ str , typing . Any ]] Resets the environment to an initial internal state, returning an initial observation and info. This method generates a new starting state often with some randomness to ensure that the agent explores the state space and learns a generalised policy about the environment. This randomness can be controlled with the seed parameter otherwise if the environment already has a random number generator and :meth: reset is called with seed=None , the RNG is not reset. Therefore, :meth: reset should (in the typical use case) be called with a seed right after initialization and then never again. For Custom environments, the first line of :meth: reset should be super().reset(seed=seed) which implements the seeding correctly. .. versionchanged:: v0.25 The `` return_info `` parameter was removed and now info is expected to be returned . Parameters: Name Type Description Default seed optional int The seed that is used to initialize the environment's PRNG ( np_random ). If the environment does not already have a PRNG and seed=None (the default option) is passed, a seed will be chosen from some source of entropy (e.g. timestamp or /dev/urandom). However, if the environment already has a PRNG and seed=None is passed, the PRNG will not be reset. If you pass an integer, the PRNG will be reset even if it already exists. Usually, you want to pass an integer right after the environment has been initialized and then never again . Please refer to the minimal example above to see this paradigm in action. None options optional dict Additional information to specify how the environment is reset (optional, depending on the specific environment) None Returns: Type Description None observation (ObsType): Observation of the initial state. This will be an element of :attr: observation_space (typically a numpy array) and is analogous to the observation returned by :meth: step . info (dictionary): This dictionary contains auxiliary information complementing observation . It should be analogous to the info returned by :meth: step . View Source def reset ( self , seed : Optional [ int ] = None , options : Optional [ dict[str, Any ] ] = None ) -> tuple [ ObsType, dict[str, Any ] ]: # Implementation of Gym template method reset () : See Gym for full method docstring # Gym states this must be the first line of the reset () method super (). reset ( seed = seed ) return self . _get_obs (), self . _get_info () # Initial state observation reset_bag_state def reset_bag_state ( self , state : tuple [ numpy . ndarray , ... ] ) -> None Resets the dynamics of the bag in the environment Parameters: Name Type Description Default state tuple[np.ndarray, ...] Dynamics info of the bag, containing: np.ndarray: Position, shape (3,) np.ndarray: Orientation (XYZW quaternion), shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) None View Source def reset_bag_state(self, state: tuple[np.ndarray, ...]) -> None: \"\"\"Resets the dynamics of the bag in the environment Args: state (tuple[np.ndarray, ...]): Dynamics info of the bag, containing: np.ndarray: Position, shape (3,) np.ndarray: Orientation (XYZW quaternion), shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) \"\"\" assert len(state) == 4 assert len(state[0]) == 3 assert len(state[1]) == 4 assert len(state[2]) == 3 assert len(state[3]) == 3 self.bag.reset_dynamics(*state) reset_robot_state def reset_robot_state ( self , state : tuple [ numpy . ndarray , ... ] ) -> None Fully resets the state of the Astrobee in the environment Parameters: Name Type Description Default state tuple[np.ndarray, ...] Full Astrobee state information containing: np.ndarray: Position, shape (3,) np.ndarray: Orientation (XYZW quaternion), shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) np.ndarray: Joint positions, shape (NUM_JOINTS,) np.ndarray: Joint velocities, shape (NUM_JOINTS,) None View Source def reset_robot_state(self, state: tuple[np.ndarray, ...]) -> None: \"\"\"Fully resets the state of the Astrobee in the environment Args: state (tuple[np.ndarray, ...]): Full Astrobee state information containing: np.ndarray: Position, shape (3,) np.ndarray: Orientation (XYZW quaternion), shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) np.ndarray: Joint positions, shape (NUM_JOINTS,) np.ndarray: Joint velocities, shape (NUM_JOINTS,) \"\"\" assert len(state) == 6 assert len(state[0]) == 3 assert len(state[1]) == 4 assert len(state[2]) == 3 assert len(state[3]) == 3 assert len(state[4]) == Astrobee.NUM_JOINTS assert len(state[5]) == Astrobee.NUM_JOINTS self.robot.reset_full_state(*state) restore_state def restore_state ( self , filename : str ) -> None Restores the simulation to a saved state file Parameters: Name Type Description Default filename str Path to a .bullet saved state within the saved state directory None View Source def restore_state ( self , filename : str ) -> None : \"\"\"Restores the simulation to a saved state file Args: filename (str): Path to a .bullet saved state within the saved state directory \"\"\" filename = self . _check_state_file ( filename ) self . client . restoreState ( fileName = filename ) sample_trajectory def sample_trajectory ( self ) -> None Samples a trajectory about the nominal target. If the nominal_rollouts parameter is True for this environment, the final state of the trajectory will be exactly the nominal value (no noise added when sampling) This should just be called in the vectorized rollout environments (not the main environment) since the main environment will use the best trajectory from the rollout envs View Source def sample_trajectory(self) -> None: \"\"\"Samples a trajectory about the nominal target. - If the nominal_rollouts parameter is True for this environment, the final state of the trajectory will be exactly the nominal value (no noise added when sampling) - This should just be called in the vectorized rollout environments (not the main environment) since the main environment will use the best trajectory from the rollout envs \"\"\" if self.is_primary_simulation: raise ValueError( \"Trajectory sampling should only occur in one of parallel environments for evaluation purposes\" ) pos, orn, vel, omega = self.robot.dynamics_state # Time sampling parameters (TODO refine these, move them somewhere else) time_stdev = 1 # Note: ensure that this is a positive value post-sampling min_time = 1 n_timesteps = round(self.planning_duration / self.dt) # Nominal if self.flight_state == self.FlightStates.NOMINAL: end_state = ( [ self.target_pos, self.target_orn, self.target_vel, self.target_omega, self.target_accel, self.target_alpha, ] if self._nominal_rollouts else sample_state( self.target_pos, self.target_orn, self.target_vel, self.target_omega, self.last_accel_cmd, self.last_alpha_cmd, self.pos_stdev, self.orn_stdev, self.vel_stdev, self.ang_vel_stdev, self.accel_stdev, self.alpha_stdev, ) ) duration = self.target_duration elif self.flight_state == self.FlightStates.SLOWING: end_state = ( [ self.target_pos, self.target_orn, self.target_vel, self.target_omega, self.target_accel, self.target_alpha, ] if self._nominal_rollouts else sample_state( self.target_pos, self.target_orn, self.target_vel, self.target_omega, self.last_accel_cmd, self.last_alpha_cmd, self.pos_stdev / 3, self.orn_stdev / 3, self.vel_stdev / 3, self.ang_vel_stdev / 3, self.accel_stdev / 3, self.alpha_stdev / 3, ) ) duration = ( self.target_duration if self._nominal_rollouts else np.maximum( np.random.normal(self.target_duration, time_stdev), min_time ) ) elif self.flight_state == self.FlightStates.STOPPING: end_state = [ self.target_pos, self.target_orn, self.target_vel, self.target_omega, self.target_accel, self.target_alpha, ] duration = ( self.planning_duration if self._nominal_rollouts else np.maximum( np.random.normal(self.planning_duration, time_stdev), min_time ) ) else: raise AttributeError(\"Flight state not recognized\") traj = local_planner( pos, orn, vel, omega, self.last_accel_cmd, self.last_alpha_cmd, *end_state, duration, self.dt, ) if traj.num_timesteps == n_timesteps: self.traj_plan = traj else: # Traj is either too long or too short, so adjust it if traj.num_timesteps > n_timesteps: self.traj_plan = traj.get_segment(0, n_timesteps) else: # Less than # Create a trajectory at the stopped position for the remaining timesteps remaining_timesteps = n_timesteps - traj.num_timesteps stop_traj = Trajectory( traj.positions[-1] * np.ones((remaining_timesteps, 1)), traj.quaternions[-1] * np.ones((remaining_timesteps, 1)), np.zeros((remaining_timesteps, 3)), np.zeros((remaining_timesteps, 3)), np.zeros((remaining_timesteps, 3)), np.zeros((remaining_timesteps, 3)), np.arange(remaining_timesteps) * self.dt, ) self.traj_plan = concatenate_trajs(traj, stop_traj) self.sampled_end_state = ( self.traj_plan.positions[-1], self.traj_plan.quaternions[-1], self.traj_plan.linear_velocities[-1], self.traj_plan.angular_velocities[-1], ) save_state def save_state ( self ) -> str Saves the current simulation state to disk Note: saved states are not currently overwritten (could lead to issues with parallel environments?). But, these can be cleared out at the end of the simulation period Returns: Type Description str Path to the saved state file View Source def save_state ( self ) -> str : # Ensure that any simulations strictly for evaluating rollouts cannot save their state if not self . is_primary_simulation : raise PermissionError ( \"Only the primary simulation can save the state\" ) return super (). save_state () send_client_command def send_client_command ( self , * args , ** kwargs ) -> Any Send a command to the environment's pybullet client For instance, we can use pybullet.getBasePositionAndOrientation with this as send_client_command(\"getBasePositionAndOrientation\", body_id) Returns: Type Description Any The return from the Pybullet command View Source def send_client_command(self, *args, * *kwargs) -> Any: \"\"\"Send a command to the environment's pybullet client For instance, we can use pybullet.getBasePositionAndOrientation with this as send_client_command(\"getBasePositionAndOrientation\", body_id) Returns: Any: The return from the Pybullet command \"\"\" attr = getattr(self.client, args[0]) if isinstance(attr, Callable): return attr(*args[1:], **kwargs) return attr set_arm_traj def set_arm_traj ( self , traj : pyastrobee . trajectories . trajectory . ArmTrajectory ) View Source def set_arm_traj(self, traj: ArmTrajectory): # TODO IMPROVE THIS self.arm_traj_plan = traj set_flight_state def set_flight_state ( self , state : Union [ str , pyastrobee . core . environments . AstrobeeMPCEnv . FlightStates ] ) Set the current flight state: for instance, whether we are in nominal operating mode, stopping, ... Parameters: Name Type Description Default state Union[str, FlightStates] A flight state or its string representation (i.e. \"nominal\", \"stopping\", ...) None View Source def set_flight_state(self, state: Union[str, FlightStates]): \"\"\"Set the current flight state: for instance, whether we are in nominal operating mode, stopping, ... Args: state (Union[str, FlightStates]): A flight state or its string representation (i.e. \"nominal\", \"stopping\", ...) \"\"\" # TODO add check that it is valid # TODO should we store the state as the string or the Enum???? if isinstance(state, str): self.flight_state = self.FlightStates(state) elif isinstance(state, self.FlightStates): self.flight_state = state else: raise ValueError(\"Flight state not recognized\") set_planning_duration def set_planning_duration ( self , duration ) View Source def set_planning_duration(self, duration): # TODO improve this self.planning_duration = duration set_target_state def set_target_state ( self , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], omega : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], accel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], alpha : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], duration : float ) -> None Set the target dynamics state for planning/sampling trajectories and determining penalties Parameters: Name Type Description Default pos npt.ArrayLike Desired position, shape (3,) None orn npt.ArrayLike Desired XYZW quaternion orientation, shape (4,) None vel npt.ArrayLike Desired linear velocity, shape (3,) None omega npt.ArrayLike Desired angular velocity, shape (3,) None accel npt.ArrayLike Desired linear acceleration, shape (3,) None alpha npt.ArrayLike Desired angular acceleration, shape (3,) None duration float Amount of time to pass before achieving this desired state None View Source def set_target_state ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , vel : npt . ArrayLike , omega : npt . ArrayLike , accel : npt . ArrayLike , alpha : npt . ArrayLike , duration : float , ) -> None : \"\"\"Set the target dynamics state for planning/sampling trajectories and determining penalties Args: pos (npt.ArrayLike): Desired position, shape (3,) orn (npt.ArrayLike): Desired XYZW quaternion orientation, shape (4,) vel (npt.ArrayLike): Desired linear velocity, shape (3,) omega (npt.ArrayLike): Desired angular velocity, shape (3,) accel (npt.ArrayLike): Desired linear acceleration, shape (3,) alpha (npt.ArrayLike): Desired angular acceleration, shape (3,) duration (float): Amount of time to pass before achieving this desired state \"\"\" self . target_pos = pos self . target_orn = orn self . target_vel = vel self . target_omega = omega self . target_accel = accel self . target_alpha = alpha self . target_duration = duration show_traj_plan def show_traj_plan ( self , n : Optional [ int ] ) -> None Displays the planned trajectory on the current pybullet client GUI (if enabled) Parameters: Name Type Description Default n Optional[int] Number of frames to plot, if plotting all of the frames is not desired. Defaults to None (plot all frames) None View Source def show_traj_plan ( self , n : Optional [ int ] ) -> None : \"\"\"Displays the planned trajectory on the current pybullet client GUI (if enabled) Args: n (Optional[int]): Number of frames to plot, if plotting all of the frames is not desired. Defaults to None (plot all frames) \"\"\" if self . traj_plan is None : raise ValueError ( \"No trajectory available to visualize\" ) self . debug_viz_ids = self . traj_plan . visualize ( n , client = self . client ) step def step ( self , action : ~ ActType ) -> tuple [ ~ ObsType , float , bool , bool , dict [ str , typing . Any ]] Run one timestep of the environment's dynamics using the agent actions. When the end of an episode is reached ( terminated or truncated ), it is necessary to call :meth: reset to reset this environment's state for the next episode. .. versionchanged:: 0.26 The Step API was changed removing `` done `` in favor of `` terminated `` and `` truncated `` to make it clearer to users when the environment had terminated or truncated which is critical for reinforcement learning bootstrapping algorithms . Parameters: Name Type Description Default action ActType an action provided by the agent to update the environment state. None Returns: Type Description None observation (ObsType): An element of the environment's :attr: observation_space as the next observation due to the agent actions. An example is a numpy array containing the positions and velocities of the pole in CartPole. reward (SupportsFloat): The reward as a result of taking the action. terminated (bool): Whether the agent reaches the terminal state (as defined under the MDP of the task) which can be positive or negative. An example is reaching the goal state or moving into the lava from the Sutton and Barton, Gridworld. If true, the user needs to call :meth: reset . truncated (bool): Whether the truncation condition outside the scope of the MDP is satisfied. Typically, this is a timelimit, but could also be used to indicate an agent physically going out of bounds. Can be used to end the episode prematurely before a terminal state is reached. If true, the user needs to call :meth: reset . info (dict): Contains auxiliary diagnostic information (helpful for debugging, learning, and logging). This might, for instance, contain: metrics that describe the agent's performance state, variables that are hidden from observations, or individual reward terms that are combined to produce the total reward. In OpenAI Gym <v26, it contains \"TimeLimit.truncated\" to distinguish truncation and termination, however this is deprecated in favour of returning terminated and truncated variables. done (bool): (Deprecated) A boolean value for if the episode has ended, in which case further :meth: step calls will return undefined results. This was removed in OpenAI Gym v26 in favor of terminated and truncated attributes. A done signal may be emitted for different reasons: Maybe the task underlying the environment was solved successfully, a certain timelimit was exceeded, or the physics simulation has entered an invalid state. View Source def step( self, action: ActType ) -> tuple[ObsType, float, bool, bool, dict[str, Any]]: # Note: For MPC, this is less so a \"step\" than a \"rollout\" function. The trajectory should be sampled # before calling this function # TODO use the action parameter to pass in a trajectory to follow? terminated = False # init (If at the terminal state) truncated = False # init (If stopping the sim before the terminal state) if self.traj_plan is None: raise ValueError(\"Trajectory has not been planned\") # Follow the trajectory. NOTE: This is effectively the same as the follow_traj() function in the controller, # but accessing the loop directly allows us to do more with the data at each step # TODO decide how to handle the stopping criteria if not self.traj_plan.num_timesteps == self.arm_traj_plan.num_timesteps: raise ValueError(\"Mismatched time info between base and arm trajs\") # If this is the primary simulation, we just follow the best trajectory we have # Rewrd for the primary simulation doesn't mean anything, so no computation needed inertia_update_freq = 5 steps_per_inertia_update = round( 1 / (self.traj_plan.timestep * inertia_update_freq) ) if self.is_primary_simulation: for i in range(self.traj_plan.num_timesteps): pos, orn, lin_vel, ang_vel = self.controller.get_current_state() self.controller.step( pos, lin_vel, orn, ang_vel, self.traj_plan.positions[i, :], self.traj_plan.linear_velocities[i, :], self.traj_plan.linear_accels[i, :], self.traj_plan.quaternions[i, :], self.traj_plan.angular_velocities[i, :], self.traj_plan.angular_accels[i, :], ) self.robot.set_joint_angles( self.arm_traj_plan.angles[i, :], self.arm_traj_plan.joint_ids ) # TODO THIS KINDA SUCKS if i % steps_per_inertia_update == 0: T_R2W = self.robot.tmat T_B2W = self.bag.tmat T_B2R = invert_transform_mat(T_R2W) @ T_B2W p = T_B2R[:3, 3] self.controller.inertia = self.robot.inertia + self.bag.mass * ( np.dot(p, p) * np.eye(3) - np.outer(p, p) ) reward = 0 else: # We are in a rollout environment # So, follow the trajectory, but also keep track of a bunch of things so that we can compute the reward robot_safe_set_cost = 0 # init bag_safe_set_cost = 0 # init stabilization_cost = 0 tracking_cost = 0 bag_vel_cost = 0 steps_per_safe_set_eval = round( 1 / (self.traj_plan.timestep * self.safe_set_eval_freq) ) # TODO IMPROVE THIS # the thought here was that if we're stopping (or slowing) we care more about the overall positioning # rather than just staying in the middle of the modules safe_set_weight = ( 1 if self.flight_state == self.FlightStates.NOMINAL else 0.1 ) for i in range(self.traj_plan.num_timesteps): # Note: the traj log gets updated whenever we access the current state pos, orn, lin_vel, ang_vel = self.controller.get_current_state() self.controller.step( pos, lin_vel, orn, ang_vel, self.traj_plan.positions[i, :], self.traj_plan.linear_velocities[i, :], self.traj_plan.linear_accels[i, :], self.traj_plan.quaternions[i, :], self.traj_plan.angular_velocities[i, :], self.traj_plan.angular_accels[i, :], ) self.robot.set_joint_angles( self.arm_traj_plan.angles[i, :], self.arm_traj_plan.joint_ids ) # TODO THIS KINDA SUCKS if i % steps_per_inertia_update == 0: T_R2W = self.robot.tmat T_B2W = self.bag.tmat T_B2R = invert_transform_mat(T_R2W) @ T_B2W p = T_B2R[:3, 3] self.controller.inertia = self.robot.inertia + self.bag.mass * ( np.dot(p, p) * np.eye(3) - np.outer(p, p) ) # *** COST FUNCTION *** # Perform collision checking on every timestep robot_bb = self.robot.bounding_box bag_bb = self.bag.bounding_box robot_is_safe = check_box_containment(robot_bb, self.safe_set.values()) bag_is_safe = check_box_containment(bag_bb, self.safe_set.values()) # If either the robot or bag collided, stop the simulation and return an effectively infinite cost # (Very large but not infinity to maintain sorting order in the edge case that all rollouts collide) if not robot_is_safe: robot_safe_set_cost += 10000 truncated = True # break if not bag_is_safe: bag_safe_set_cost += 10000 truncated = True # break # These \"stay away from the walls\" costs are somewhat expensive to compute and don't necessarily need # to be done every timestep. TODO just use the local description of the safe set, not the full thing if i % steps_per_safe_set_eval == 0: robot_safe_set_cost += safe_set_weight * safe_set_cost( robot_bb[0], self.safe_set.values() ) robot_safe_set_cost += safe_set_weight * safe_set_cost( robot_bb[1], self.safe_set.values() ) bag_safe_set_cost += safe_set_weight * safe_set_cost( bag_bb[0], self.safe_set.values() ) bag_safe_set_cost += safe_set_weight * safe_set_cost( bag_bb[1], self.safe_set.values() ) bag_pos, bag_orn, bag_vel, bag_ang_vel = self.bag.dynamics_state # Penalizing bag velocities perpendicular to the robot's velocity at end of rollout if self.flight_state == self.FlightStates.NOMINAL: bag_vel_cost = 300 * ( np.linalg.norm(bag_vel) - np.dot(lin_vel / np.linalg.norm(lin_vel), bag_vel) ) # End-of-rollout additional cost function evaluations # 1) Stabilize the motion of the bag with respect to the robot # 2) Position the robot so it's stopped at the goal pose # Both of these are only relevant when we're at the end of the nominal trajectory # TODO tune all of the scaling factors on the costs if self.flight_state == self.FlightStates.STOPPING: angular_term = np.linalg.norm(ang_vel - bag_ang_vel) r_r2b = bag_pos - pos # Vector from robot to bag linear_term = np.linalg.norm( lin_vel - bag_vel + np.cross(ang_vel, r_r2b) ) stabilization_cost += 500 * (linear_term + angular_term) # TODO make this a separate function? # Adding back in a tracking cost component # If we are stopping then we know that the target state is the goal pos_error = np.linalg.norm(pos - self.target_pos) orn_error = quaternion_dist(orn, self.target_orn) vel_error = np.linalg.norm(lin_vel - self.target_vel) ang_vel_error = np.linalg.norm(ang_vel - self.target_omega) if self.is_debugging_simulation: print(\"Position error: \", pos_error) print(\"Orn error: \", orn_error) print(\"Vel error: \", vel_error) print(\"Ang vel error: \", ang_vel_error) tracking_cost += ( 200 * pos_error + 100 * orn_error + 200 * vel_error + 100 * ang_vel_error ) else: stabilization_cost = 0 tracking_cost = 0 if self.is_debugging_simulation: print(\"Robot safe set cost: \", robot_safe_set_cost) print(\"Bag safe set cost: \", bag_safe_set_cost) print(\"Stabilization cost: \", stabilization_cost) print(\"Tracking cost: \", tracking_cost) print(\"Bag velocity cost: \", bag_vel_cost) reward = -1 * ( robot_safe_set_cost + bag_safe_set_cost + stabilization_cost + tracking_cost + bag_vel_cost ) # Observe the robot/bag state in the main env, dummy value if in rollout env observation = self._get_obs() # Evaluate if we have stabilized the robot and the bag at the end of the trajectory # (main env only since that's what we care about and we don't want to waste compute) if ( self.flight_state == self.FlightStates.STOPPING and self.is_primary_simulation and robot_and_bag_termination_criteria( observation[0], observation[1], self.goal_pose ) ): terminated = True # TODO: If we change the observation function to return the state of the robot and the bag, # we can determine the \"terminated\" parameter! # But note that we should only really do the observation in the main env info = self._get_info() return observation, reward, terminated, truncated, info step_simulation def step_simulation ( self ) Single pybullet simulation step View Source def step_simulation(self): \"\"\"Single pybullet simulation step\"\"\" self.client.stepSimulation() unshow_traj_plan def unshow_traj_plan ( self ) -> None Removes a displayed trajectory from the pybullet client GUI View Source def unshow_traj_plan ( self ) -> None : \"\"\"Removes a displayed trajectory from the pybullet client GUI\"\"\" if len ( self . debug_viz_ids ) == 0 : return remove_debug_objects ( self . debug_viz_ids , self . client ) self . debug_viz_ids = ()","title":"Environments"},{"location":"reference/pyastrobee/core/environments/#module-pyastrobeecoreenvironments","text":"Gym and vectorized environments for the Astrobee/ISS/Cargo setup NOTE: - Class variables DO NOT get updated in vectorized environments (for instance, modifying the value in a non-vectorized environment will be reflected in all non-vectorized environments, but not the vectorized ones. You'd have to explicitly call the set_attr method for that) View Source \"\"\"Gym and vectorized environments for the Astrobee/ISS/Cargo setup NOTE: - Class variables DO NOT get updated in vectorized environments (for instance, modifying the value in a non-vectorized environment will be reflected in all non-vectorized environments, but not the vectorized ones. You'd have to explicitly call the set_attr method for that) \"\"\" # TODO # - See if there is a faster way to save/restore state in the case that we're using the rigid bag # - Add ability to save/restore state from a state ID (saved in memory) -- ONLY if this is useful # - Use terminated/truncated as a stopping parameter # - Should the reset() function reset the simulation back to an initial saved state? # - Decide if the base AstrobeeEnv should have cleanup functionality import os from pathlib import Path from typing import Optional , Any , Callable , Dict , Type , Union from datetime import datetime from enum import Enum import numpy as np import numpy.typing as npt import gymnasium as gym from gymnasium.core import ObsType , ActType from stable_baselines3.common.monitor import Monitor from stable_baselines3.common.env_util import DummyVecEnv , SubprocVecEnv , VecEnv from stable_baselines3.common.vec_env.patch_gym import _patch_env from pyastrobee.control.force_torque_control import ForceTorqueController from pyastrobee.utils.bullet_utils import initialize_pybullet from pyastrobee.core.astrobee import Astrobee from pyastrobee.core.iss import ISS from pyastrobee.core.abstract_bag import CargoBag from pyastrobee.core.deformable_bag import DeformableCargoBag from pyastrobee.core.constraint_bag import ConstraintCargoBag from pyastrobee.control.metrics import safe_set_cost from pyastrobee.trajectories.sampling import generate_trajs , sample_state from pyastrobee.utils.debug_visualizer import remove_debug_objects from pyastrobee.utils.boxes import check_box_containment , visualize_3D_box from pyastrobee.config.iss_safe_boxes import FULL_SAFE_SET from pyastrobee.utils.quaternions import quaternion_dist from pyastrobee.control.metrics import robot_and_bag_termination_criteria from pyastrobee.config.astrobee_motion import MAX_FORCE_MAGNITUDE , MAX_TORQUE_MAGNITUDE from pyastrobee.trajectories.trajectory import Trajectory , ArmTrajectory from pyastrobee.utils.transformations import invert_transform_mat from pyastrobee.trajectories.planner import local_planner from pyastrobee.trajectories.trajectory import concatenate_trajs class AstrobeeEnv ( gym . Env ): \"\"\"Base Astrobee environment containing the Astrobee, ISS, and a cargo bag Args: use_gui (bool): Whether or not to use the GUI as opposed to headless. robot_pose (npt.ArrayLike, optional): Starting position + XYZW quaternion pose of the Astrobee, shape (7,) bag_name (str, optional): Type of cargo bag to load. Defaults to \"top_handle\". bag_mass (float): Mass of the cargo bag, in kg. Defaults to 10 bag_type (type[CargoBag]): Class of cargo bag to use in the environment. Defaults to DeformableCargoBag load_full_iss (bool, optional): Whether to load the ISS (expensive, not necessarily required for rollouts) or just work with the safe set information. Defaults to True (load the ISS) \"\"\" SAVE_STATE_DIR = \"artifacts/saved_states/\" SAVE_STATE_PATHS = [] def __init__ ( self , use_gui : bool , robot_pose : npt . ArrayLike = ( 0 , 0 , 0 , 0 , 0 , 0 , 1 ), bag_name : str = \"top_handle_symmetric\" , bag_mass : float = 10 , bag_type : type [ CargoBag ] = DeformableCargoBag , load_full_iss : bool = True , ): self . client = initialize_pybullet ( use_gui ) self . safe_set = FULL_SAFE_SET if load_full_iss : self . iss = ISS ( client = self . client ) elif use_gui : for box in self . safe_set . values (): visualize_3D_box ( box , rgba = ( 1 , 0 , 0 , 0.3 )) self . robot = Astrobee ( robot_pose , client = self . client ) self . bag = bag_type ( bag_name , bag_mass , client = self . client ) self . bag . reset_to_handle_pose ( self . robot . ee_pose ) self . bag . attach_to ( self . robot , object_to_move = \"bag\" ) self . dt = self . client . getPhysicsEngineParameters ()[ \"fixedTimeStep\" ] # Dummy parameters for gym/stable baselines compatibility # TODO make custom gym.spaces.space.Space subclasses for these? self . observation_space = gym . spaces . Discrete ( 3 ) # temporary, unused self . action_space = gym . spaces . Discrete ( 3 ) # temporary, unused # Step the simulation once to get the bag in the right place self . client . stepSimulation () def reset ( self , seed : Optional [ int ] = None , options : Optional [ dict [ str , Any ]] = None ) -> tuple [ ObsType , dict [ str , Any ]]: # Implementation of Gym template method reset(): See Gym for full method docstring # Gym states this must be the first line of the reset() method super () . reset ( seed = seed ) return self . _get_obs (), self . _get_info () # Initial state observation def _get_obs ( self ) -> ObsType : \"\"\"Translates the environment's state into an observation Returns: ObsType: Observation \"\"\" # This function setup was recommended in the gym documentation return None , None # Dummy value for now def _get_info ( self ) -> dict [ str , Any ]: \"\"\"Provide auxiliary information associated with an observation Returns: dict[str, Any]: Additional observation information \"\"\" # This function setup was recommended in the gym documentation return {} # Dummy value for now def step ( self , action : ActType ) -> tuple [ ObsType , float , bool , bool , dict [ str , Any ]]: # Implementation of Gym template method step(): See Gym for full method docstring # Note: The return parameters differ slightly from step() for a vectorized environment # In this base environment, we will just step the pybullet simulation and return a dummy value for reward # The MPC environment can add more specific MPC/control functionality here self . client . stepSimulation () reward = 0 observation = self . _get_obs () terminated = False # If at the terminal state truncated = False # If stopping the sim before the terminal state info = self . _get_info () return observation , reward , terminated , truncated , info def step_simulation ( self ): \"\"\"Single pybullet simulation step\"\"\" self . client . stepSimulation () def close ( self ): # Implementation of Gym template method close(): See Gym for full method docstring self . client . disconnect () def save_state ( self ) -> str : \"\"\"Saves the current simulation state to disk - Note: saved states are not currently overwritten (could lead to issues with parallel environments?). But, these can be cleared out at the end of the simulation period Returns: str: Path to the saved state file \"\"\" # Autogenerate a unique filename/path and save to it filename = \"state_\" + datetime . now () . strftime ( \"%Y%m %d _%H%M%S_ %f \" ) filepath = AstrobeeEnv . SAVE_STATE_DIR + filename + \".bullet\" self . client . saveBullet ( filepath ) AstrobeeEnv . SAVE_STATE_PATHS . append ( filepath ) return filepath def restore_state ( self , filename : str ) -> None : \"\"\"Restores the simulation to a saved state file Args: filename (str): Path to a .bullet saved state within the saved state directory \"\"\" filename = self . _check_state_file ( filename ) self . client . restoreState ( fileName = filename ) def _check_state_file ( self , filename : str ) -> str : \"\"\"Helper function: Validates that a saved state file exists Args: filename (str): Path to a .bullet saved state within the saved state directory Returns: str: Validated path \"\"\" path = Path ( filename ) if path . suffix != \".bullet\" : raise ValueError ( f \"Invalid filename: { filename } . \\n Not a .bullet saved state file\" ) if path . parent != Path ( AstrobeeEnv . SAVE_STATE_DIR ): raise ValueError ( f \"Invalid filename: { filename } . \\n Check that the filename points to within the saved state directory\" ) if path . is_file (): return str ( path ) raise FileNotFoundError ( f \"Could not find file: { filename } \" ) def send_client_command ( self , * args , ** kwargs ) -> Any : \"\"\"Send a command to the environment's pybullet client For instance, we can use pybullet.getBasePositionAndOrientation with this as send_client_command(\"getBasePositionAndOrientation\", body_id) Returns: Any: The return from the Pybullet command \"\"\" attr = getattr ( self . client , args [ 0 ]) if isinstance ( attr , Callable ): return attr ( * args [ 1 :], ** kwargs ) return attr class AstrobeeMPCEnv ( AstrobeeEnv ): \"\"\"Astrobee environment for MPC: Contains additional controller parameters and functions associated with MPC, on top of the base Astrobee environment capability Args: use_gui (bool): Whether or not to use the GUI as opposed to headless. is_primary (bool): Whether or not this environment is the main simulation (True) or if it is one of the vectorized environments for evaluating a rollout (False) robot_pose (npt.ArrayLike, optional): Starting position + XYZW quaternion pose of the Astrobee, shape (7,) bag_name (str, optional): Type of cargo bag to load. Defaults to \"top_handle\". bag_mass (float): Mass of the cargo bag, in kg. Defaults to 10 bag_type (type[CargoBag]): Class of cargo bag to use in the environment. Defaults to DeformableCargoBag load_full_iss (bool, optional): Whether to load the ISS (expensive, not necessarily required for rollouts) or just work with the safe set information. Defaults to True (load the ISS) nominal_rollouts (bool, optional): If True, will roll-out a trajectory based on the nominal target. If False, will sample a trajectory about the nominal target. Defaults to False. cleanup (bool, optional): Whether or not to delete all saved states when the simulation ends. Defaults to True. \"\"\" class FlightStates ( Enum ): # STARTING = \"starting\" NOMINAL = \"nominal\" SLOWING = \"slowing\" STOPPING = \"stopping\" def __init__ ( self , use_gui : bool , is_primary : bool , robot_pose : npt . ArrayLike = ( 0 , 0 , 0 , 0 , 0 , 0 , 1 ), bag_name : str = \"top_handle\" , bag_mass : float = 10 , bag_type : type [ CargoBag ] = DeformableCargoBag , load_full_iss : bool = True , nominal_rollouts : bool = False , cleanup : bool = True , ): super () . __init__ ( use_gui , robot_pose , bag_name , bag_mass , bag_type , load_full_iss ) # TODO figure out how to handle controller parameters # Just fixing the gains here for now # TODO should these be functions of the bag mass??? kp , kv , kq , kw = 20 , 5 , 5 , 0.1 # TODO make parameters p = self . bag . position - self . robot . position self . controller = ForceTorqueController ( self . robot . id , self . robot . mass + bag_mass , # self.robot.inertia, self . robot . inertia + bag_mass * ( np . dot ( p , p ) * np . eye ( 3 ) - np . outer ( p , p ) ), # TODO parallel axis theorem for bag?? test this kp , kv , kq , kw , self . dt , max_force = MAX_FORCE_MAGNITUDE * 10 , # TODO REMOVE THIS SCALING FACTOR max_torque = MAX_TORQUE_MAGNITUDE * 10 , client = self . client , ) # Sampling parameters (TODO these need refinement) self . pos_stdev = 0.1 self . orn_stdev = 0.1 self . vel_stdev = 0.1 self . ang_vel_stdev = 0.1 self . accel_stdev = 0.1 self . alpha_stdev = 0.1 # Store last acceleration commands # Update through set_attr self . last_accel_cmd = np . zeros ( 3 ) # init self . last_alpha_cmd = np . zeros ( 3 ) # init # Frequency at which we query our \"stay away from the walls\" cost function self . safe_set_eval_freq = 10 # Hz # Keep track of any temporary debug visualizer IDs self . debug_viz_ids = () # Keep track of whether we're stopping or in a nominal flight mode self . flight_state = self . FlightStates . NOMINAL # init # (effectively the rollout duration, should be a constant) - TODO IMPROVE THIS self . planning_duration = None # Store where we want the Astrobee to be at the end of the MPC run to determine if we are done self . goal_pose = None # init # HACK - improve how this is handled self . arm_traj_plan = None self . _is_primary_env = is_primary self . _is_debugging_env = not is_primary and use_gui self . _nominal_rollouts = nominal_rollouts self . _cleanup = cleanup self . traj_plan = None # Init self . target_pos = None # Init self . target_orn = None # Init self . target_vel = None # Init self . target_omega = None # Init self . target_duration = None # Init @property def is_primary_simulation ( self ) -> bool : \"\"\"Whether this environment is running the primary planning/control simulation or is a separate (likely vectorized) environment for evaluating rollouts\"\"\" return self . _is_primary_env @property def is_debugging_simulation ( self ) -> bool : \"\"\"Whether this is an environment launched in debug mode\"\"\" return self . _is_debugging_env def set_arm_traj ( self , traj : ArmTrajectory ): # TODO IMPROVE THIS self . arm_traj_plan = traj def set_planning_duration ( self , duration ): # TODO improve this self . planning_duration = duration def set_flight_state ( self , state : Union [ str , FlightStates ]): \"\"\"Set the current flight state: for instance, whether we are in nominal operating mode, stopping, ... Args: state (Union[str, FlightStates]): A flight state or its string representation (i.e. \"nominal\", \"stopping\", ...) \"\"\" # TODO add check that it is valid # TODO should we store the state as the string or the Enum???? if isinstance ( state , str ): self . flight_state = self . FlightStates ( state ) elif isinstance ( state , self . FlightStates ): self . flight_state = state else : raise ValueError ( \"Flight state not recognized\" ) def set_target_state ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , vel : npt . ArrayLike , omega : npt . ArrayLike , accel : npt . ArrayLike , alpha : npt . ArrayLike , duration : float , ) -> None : \"\"\"Set the target dynamics state for planning/sampling trajectories and determining penalties Args: pos (npt.ArrayLike): Desired position, shape (3,) orn (npt.ArrayLike): Desired XYZW quaternion orientation, shape (4,) vel (npt.ArrayLike): Desired linear velocity, shape (3,) omega (npt.ArrayLike): Desired angular velocity, shape (3,) accel (npt.ArrayLike): Desired linear acceleration, shape (3,) alpha (npt.ArrayLike): Desired angular acceleration, shape (3,) duration (float): Amount of time to pass before achieving this desired state \"\"\" self . target_pos = pos self . target_orn = orn self . target_vel = vel self . target_omega = omega self . target_accel = accel self . target_alpha = alpha self . target_duration = duration def sample_trajectory ( self ) -> None : \"\"\"Samples a trajectory about the nominal target. - If the nominal_rollouts parameter is True for this environment, the final state of the trajectory will be exactly the nominal value (no noise added when sampling) - This should just be called in the vectorized rollout environments (not the main environment) since the main environment will use the best trajectory from the rollout envs \"\"\" if self . is_primary_simulation : raise ValueError ( \"Trajectory sampling should only occur in one of parallel environments for evaluation purposes\" ) pos , orn , vel , omega = self . robot . dynamics_state # Time sampling parameters (TODO refine these, move them somewhere else) time_stdev = 1 # Note: ensure that this is a positive value post-sampling min_time = 1 n_timesteps = round ( self . planning_duration / self . dt ) # Nominal if self . flight_state == self . FlightStates . NOMINAL : end_state = ( [ self . target_pos , self . target_orn , self . target_vel , self . target_omega , self . target_accel , self . target_alpha , ] if self . _nominal_rollouts else sample_state ( self . target_pos , self . target_orn , self . target_vel , self . target_omega , self . last_accel_cmd , self . last_alpha_cmd , self . pos_stdev , self . orn_stdev , self . vel_stdev , self . ang_vel_stdev , self . accel_stdev , self . alpha_stdev , ) ) duration = self . target_duration elif self . flight_state == self . FlightStates . SLOWING : end_state = ( [ self . target_pos , self . target_orn , self . target_vel , self . target_omega , self . target_accel , self . target_alpha , ] if self . _nominal_rollouts else sample_state ( self . target_pos , self . target_orn , self . target_vel , self . target_omega , self . last_accel_cmd , self . last_alpha_cmd , self . pos_stdev / 3 , self . orn_stdev / 3 , self . vel_stdev / 3 , self . ang_vel_stdev / 3 , self . accel_stdev / 3 , self . alpha_stdev / 3 , ) ) duration = ( self . target_duration if self . _nominal_rollouts else np . maximum ( np . random . normal ( self . target_duration , time_stdev ), min_time ) ) elif self . flight_state == self . FlightStates . STOPPING : end_state = [ self . target_pos , self . target_orn , self . target_vel , self . target_omega , self . target_accel , self . target_alpha , ] duration = ( self . planning_duration if self . _nominal_rollouts else np . maximum ( np . random . normal ( self . planning_duration , time_stdev ), min_time ) ) else : raise AttributeError ( \"Flight state not recognized\" ) traj = local_planner ( pos , orn , vel , omega , self . last_accel_cmd , self . last_alpha_cmd , * end_state , duration , self . dt , ) if traj . num_timesteps == n_timesteps : self . traj_plan = traj else : # Traj is either too long or too short, so adjust it if traj . num_timesteps > n_timesteps : self . traj_plan = traj . get_segment ( 0 , n_timesteps ) else : # Less than # Create a trajectory at the stopped position for the remaining timesteps remaining_timesteps = n_timesteps - traj . num_timesteps stop_traj = Trajectory ( traj . positions [ - 1 ] * np . ones (( remaining_timesteps , 1 )), traj . quaternions [ - 1 ] * np . ones (( remaining_timesteps , 1 )), np . zeros (( remaining_timesteps , 3 )), np . zeros (( remaining_timesteps , 3 )), np . zeros (( remaining_timesteps , 3 )), np . zeros (( remaining_timesteps , 3 )), np . arange ( remaining_timesteps ) * self . dt , ) self . traj_plan = concatenate_trajs ( traj , stop_traj ) self . sampled_end_state = ( self . traj_plan . positions [ - 1 ], self . traj_plan . quaternions [ - 1 ], self . traj_plan . linear_velocities [ - 1 ], self . traj_plan . angular_velocities [ - 1 ], ) def _get_obs ( self ) -> ObsType : if self . is_primary_simulation : return self . robot . full_state , self . bag . dynamics_state else : return None , None def step ( self , action : ActType ) -> tuple [ ObsType , float , bool , bool , dict [ str , Any ]]: # Note: For MPC, this is less so a \"step\" than a \"rollout\" function. The trajectory should be sampled # before calling this function # TODO use the action parameter to pass in a trajectory to follow? terminated = False # init (If at the terminal state) truncated = False # init (If stopping the sim before the terminal state) if self . traj_plan is None : raise ValueError ( \"Trajectory has not been planned\" ) # Follow the trajectory. NOTE: This is effectively the same as the follow_traj() function in the controller, # but accessing the loop directly allows us to do more with the data at each step # TODO decide how to handle the stopping criteria if not self . traj_plan . num_timesteps == self . arm_traj_plan . num_timesteps : raise ValueError ( \"Mismatched time info between base and arm trajs\" ) # If this is the primary simulation, we just follow the best trajectory we have # Rewrd for the primary simulation doesn't mean anything, so no computation needed inertia_update_freq = 5 steps_per_inertia_update = round ( 1 / ( self . traj_plan . timestep * inertia_update_freq ) ) if self . is_primary_simulation : for i in range ( self . traj_plan . num_timesteps ): pos , orn , lin_vel , ang_vel = self . controller . get_current_state () self . controller . step ( pos , lin_vel , orn , ang_vel , self . traj_plan . positions [ i , :], self . traj_plan . linear_velocities [ i , :], self . traj_plan . linear_accels [ i , :], self . traj_plan . quaternions [ i , :], self . traj_plan . angular_velocities [ i , :], self . traj_plan . angular_accels [ i , :], ) self . robot . set_joint_angles ( self . arm_traj_plan . angles [ i , :], self . arm_traj_plan . joint_ids ) # TODO THIS KINDA SUCKS if i % steps_per_inertia_update == 0 : T_R2W = self . robot . tmat T_B2W = self . bag . tmat T_B2R = invert_transform_mat ( T_R2W ) @ T_B2W p = T_B2R [: 3 , 3 ] self . controller . inertia = self . robot . inertia + self . bag . mass * ( np . dot ( p , p ) * np . eye ( 3 ) - np . outer ( p , p ) ) reward = 0 else : # We are in a rollout environment # So, follow the trajectory, but also keep track of a bunch of things so that we can compute the reward robot_safe_set_cost = 0 # init bag_safe_set_cost = 0 # init stabilization_cost = 0 tracking_cost = 0 bag_vel_cost = 0 steps_per_safe_set_eval = round ( 1 / ( self . traj_plan . timestep * self . safe_set_eval_freq ) ) # TODO IMPROVE THIS # the thought here was that if we're stopping (or slowing) we care more about the overall positioning # rather than just staying in the middle of the modules safe_set_weight = ( 1 if self . flight_state == self . FlightStates . NOMINAL else 0.1 ) for i in range ( self . traj_plan . num_timesteps ): # Note: the traj log gets updated whenever we access the current state pos , orn , lin_vel , ang_vel = self . controller . get_current_state () self . controller . step ( pos , lin_vel , orn , ang_vel , self . traj_plan . positions [ i , :], self . traj_plan . linear_velocities [ i , :], self . traj_plan . linear_accels [ i , :], self . traj_plan . quaternions [ i , :], self . traj_plan . angular_velocities [ i , :], self . traj_plan . angular_accels [ i , :], ) self . robot . set_joint_angles ( self . arm_traj_plan . angles [ i , :], self . arm_traj_plan . joint_ids ) # TODO THIS KINDA SUCKS if i % steps_per_inertia_update == 0 : T_R2W = self . robot . tmat T_B2W = self . bag . tmat T_B2R = invert_transform_mat ( T_R2W ) @ T_B2W p = T_B2R [: 3 , 3 ] self . controller . inertia = self . robot . inertia + self . bag . mass * ( np . dot ( p , p ) * np . eye ( 3 ) - np . outer ( p , p ) ) # *** COST FUNCTION *** # Perform collision checking on every timestep robot_bb = self . robot . bounding_box bag_bb = self . bag . bounding_box robot_is_safe = check_box_containment ( robot_bb , self . safe_set . values ()) bag_is_safe = check_box_containment ( bag_bb , self . safe_set . values ()) # If either the robot or bag collided, stop the simulation and return an effectively infinite cost # (Very large but not infinity to maintain sorting order in the edge case that all rollouts collide) if not robot_is_safe : robot_safe_set_cost += 10000 truncated = True # break if not bag_is_safe : bag_safe_set_cost += 10000 truncated = True # break # These \"stay away from the walls\" costs are somewhat expensive to compute and don't necessarily need # to be done every timestep. TODO just use the local description of the safe set, not the full thing if i % steps_per_safe_set_eval == 0 : robot_safe_set_cost += safe_set_weight * safe_set_cost ( robot_bb [ 0 ], self . safe_set . values () ) robot_safe_set_cost += safe_set_weight * safe_set_cost ( robot_bb [ 1 ], self . safe_set . values () ) bag_safe_set_cost += safe_set_weight * safe_set_cost ( bag_bb [ 0 ], self . safe_set . values () ) bag_safe_set_cost += safe_set_weight * safe_set_cost ( bag_bb [ 1 ], self . safe_set . values () ) bag_pos , bag_orn , bag_vel , bag_ang_vel = self . bag . dynamics_state # Penalizing bag velocities perpendicular to the robot's velocity at end of rollout if self . flight_state == self . FlightStates . NOMINAL : bag_vel_cost = 300 * ( np . linalg . norm ( bag_vel ) - np . dot ( lin_vel / np . linalg . norm ( lin_vel ), bag_vel ) ) # End-of-rollout additional cost function evaluations # 1) Stabilize the motion of the bag with respect to the robot # 2) Position the robot so it's stopped at the goal pose # Both of these are only relevant when we're at the end of the nominal trajectory # TODO tune all of the scaling factors on the costs if self . flight_state == self . FlightStates . STOPPING : angular_term = np . linalg . norm ( ang_vel - bag_ang_vel ) r_r2b = bag_pos - pos # Vector from robot to bag linear_term = np . linalg . norm ( lin_vel - bag_vel + np . cross ( ang_vel , r_r2b ) ) stabilization_cost += 500 * ( linear_term + angular_term ) # TODO make this a separate function? # Adding back in a tracking cost component # If we are stopping then we know that the target state is the goal pos_error = np . linalg . norm ( pos - self . target_pos ) orn_error = quaternion_dist ( orn , self . target_orn ) vel_error = np . linalg . norm ( lin_vel - self . target_vel ) ang_vel_error = np . linalg . norm ( ang_vel - self . target_omega ) if self . is_debugging_simulation : print ( \"Position error: \" , pos_error ) print ( \"Orn error: \" , orn_error ) print ( \"Vel error: \" , vel_error ) print ( \"Ang vel error: \" , ang_vel_error ) tracking_cost += ( 200 * pos_error + 100 * orn_error + 200 * vel_error + 100 * ang_vel_error ) else : stabilization_cost = 0 tracking_cost = 0 if self . is_debugging_simulation : print ( \"Robot safe set cost: \" , robot_safe_set_cost ) print ( \"Bag safe set cost: \" , bag_safe_set_cost ) print ( \"Stabilization cost: \" , stabilization_cost ) print ( \"Tracking cost: \" , tracking_cost ) print ( \"Bag velocity cost: \" , bag_vel_cost ) reward = - 1 * ( robot_safe_set_cost + bag_safe_set_cost + stabilization_cost + tracking_cost + bag_vel_cost ) # Observe the robot/bag state in the main env, dummy value if in rollout env observation = self . _get_obs () # Evaluate if we have stabilized the robot and the bag at the end of the trajectory # (main env only since that's what we care about and we don't want to waste compute) if ( self . flight_state == self . FlightStates . STOPPING and self . is_primary_simulation and robot_and_bag_termination_criteria ( observation [ 0 ], observation [ 1 ], self . goal_pose ) ): terminated = True # TODO: If we change the observation function to return the state of the robot and the bag, # we can determine the \"terminated\" parameter! # But note that we should only really do the observation in the main env info = self . _get_info () return observation , reward , terminated , truncated , info def close ( self ): self . client . disconnect () if self . is_primary_simulation and self . _cleanup : # Delete all of the previous saved states at the end of the simulation process # TODO: decide if each session should have its own directory? for path in Path ( AstrobeeMPCEnv . SAVE_STATE_DIR ) . glob ( \"*.bullet\" ): path . unlink () def save_state ( self ) -> str : # Ensure that any simulations strictly for evaluating rollouts cannot save their state if not self . is_primary_simulation : raise PermissionError ( \"Only the primary simulation can save the state\" ) return super () . save_state () def get_robot_state ( self ) -> tuple [ np . ndarray , ... ]: \"\"\"Returns the full state information for the Astrobee in the environment (Base pos/orn/vels, joint angles/vels) Returns: tuple[np.ndarray, ...]: np.ndarray: Position, shape (3,) np.ndarray: Orientation (XYZW quaternion), shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) np.ndarray: Joint positions, shape (NUM_JOINTS,) np.ndarray: Joint velocities, shape (NUM_JOINTS,) \"\"\" return self . robot . full_state def get_bag_state ( self ) -> tuple [ np . ndarray , ... ]: \"\"\"Returns the dynamics state information for the bag in the environment (pos/orn/vels) Returns: tuple[np.ndarray, ...]: np.ndarray: Position, shape (3,) np.ndarray: XYZW quaternion orientation, shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) \"\"\" return self . bag . dynamics_state def reset_robot_state ( self , state : tuple [ np . ndarray , ... ]) -> None : \"\"\"Fully resets the state of the Astrobee in the environment Args: state (tuple[np.ndarray, ...]): Full Astrobee state information containing: np.ndarray: Position, shape (3,) np.ndarray: Orientation (XYZW quaternion), shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) np.ndarray: Joint positions, shape (NUM_JOINTS,) np.ndarray: Joint velocities, shape (NUM_JOINTS,) \"\"\" assert len ( state ) == 6 assert len ( state [ 0 ]) == 3 assert len ( state [ 1 ]) == 4 assert len ( state [ 2 ]) == 3 assert len ( state [ 3 ]) == 3 assert len ( state [ 4 ]) == Astrobee . NUM_JOINTS assert len ( state [ 5 ]) == Astrobee . NUM_JOINTS self . robot . reset_full_state ( * state ) def reset_bag_state ( self , state : tuple [ np . ndarray , ... ]) -> None : \"\"\"Resets the dynamics of the bag in the environment Args: state (tuple[np.ndarray, ...]): Dynamics info of the bag, containing: np.ndarray: Position, shape (3,) np.ndarray: Orientation (XYZW quaternion), shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) \"\"\" assert len ( state ) == 4 assert len ( state [ 0 ]) == 3 assert len ( state [ 1 ]) == 4 assert len ( state [ 2 ]) == 3 assert len ( state [ 3 ]) == 3 self . bag . reset_dynamics ( * state ) def show_traj_plan ( self , n : Optional [ int ]) -> None : \"\"\"Displays the planned trajectory on the current pybullet client GUI (if enabled) Args: n (Optional[int]): Number of frames to plot, if plotting all of the frames is not desired. Defaults to None (plot all frames) \"\"\" if self . traj_plan is None : raise ValueError ( \"No trajectory available to visualize\" ) self . debug_viz_ids = self . traj_plan . visualize ( n , client = self . client ) def unshow_traj_plan ( self ) -> None : \"\"\"Removes a displayed trajectory from the pybullet client GUI\"\"\" if len ( self . debug_viz_ids ) == 0 : return remove_debug_objects ( self . debug_viz_ids , self . client ) self . debug_viz_ids = () def make_vec_env ( env_id : Union [ str , Callable [ ... , gym . Env ]], n_envs : int = 1 , seed : Optional [ int ] = None , start_index : int = 0 , monitor_dir : Optional [ str ] = None , wrapper_class : Optional [ Callable [[ gym . Env ], gym . Env ]] = None , env_kwargs : Optional [ Dict [ str , Any ]] = None , vec_env_cls : Optional [ Type [ Union [ DummyVecEnv , SubprocVecEnv ]]] = None , vec_env_kwargs : Optional [ Dict [ str , Any ]] = None , monitor_kwargs : Optional [ Dict [ str , Any ]] = None , wrapper_kwargs : Optional [ Dict [ str , Any ]] = None , per_env_kwargs : Optional [ Dict [ int , Dict [ str , Any ]]] = None , # NEW ) -> VecEnv : \"\"\"Modified version of make_vec_env from Stable Baselines (SB3) to allow for specifying input parameters on a per-environment basis The main changes are any lines associated with the per_env_kwargs input. Updated SB3 docstring below: Create a wrapped, monitored ``VecEnv``. By default it uses a ``DummyVecEnv`` which is usually faster than a ``SubprocVecEnv``. :param env_id: either the env ID, the env class or a callable returning an env :param n_envs: the number of environments you wish to have in parallel :param seed: the initial seed for the random number generator :param start_index: start rank index :param monitor_dir: Path to a folder where the monitor files will be saved. If None, no file will be written, however, the env will still be wrapped in a Monitor wrapper to provide additional information about training. :param wrapper_class: Additional wrapper to use on the environment. This can also be a function with single argument that wraps the environment in many things. Note: the wrapper specified by this parameter will be applied after the ``Monitor`` wrapper. if some cases (e.g. with TimeLimit wrapper) this can lead to undesired behavior. See here for more details: https://github.com/DLR-RM/stable-baselines3/issues/894 :param env_kwargs: Optional keyword argument to pass to the env constructor :param vec_env_cls: A custom ``VecEnv`` class constructor. Default: None. :param vec_env_kwargs: Keyword arguments to pass to the ``VecEnv`` class constructor. :param monitor_kwargs: Keyword arguments to pass to the ``Monitor`` class constructor. :param wrapper_kwargs: Keyword arguments to pass to the ``Wrapper`` class constructor. :param per_env_kwargs: Like env-kwargs, keyword arguments fore the env constructor, but keyed to allow for different initialization on a per-env basis via the env's rank. These override any default values set via the env_kwargs input :return: The wrapped environment \"\"\" env_kwargs = env_kwargs or {} vec_env_kwargs = vec_env_kwargs or {} monitor_kwargs = monitor_kwargs or {} wrapper_kwargs = wrapper_kwargs or {} per_env_kwargs = per_env_kwargs or {} assert vec_env_kwargs is not None # for mypy def make_env ( rank : int ) -> Callable [[], gym . Env ]: def _init () -> gym . Env : # For type checker: assert monitor_kwargs is not None assert wrapper_kwargs is not None assert env_kwargs is not None this_env_kwargs = env_kwargs | per_env_kwargs . get ( rank , {}) if isinstance ( env_id , str ): # if the render mode was not specified, we set it to `rgb_array` as default. kwargs = { \"render_mode\" : \"rgb_array\" } kwargs . update ( this_env_kwargs ) try : env = gym . make ( env_id , ** kwargs ) # type: ignore[arg-type] except TypeError : env = gym . make ( env_id , ** this_env_kwargs ) else : env = env_id ( ** this_env_kwargs ) # Patch to support gym 0.21/0.26 and gymnasium env = _patch_env ( env ) if seed is not None : # Note: here we only seed the action space # We will seed the env at the next reset env . action_space . seed ( seed + rank ) # Wrap the env in a Monitor wrapper # to have additional training information monitor_path = ( os . path . join ( monitor_dir , str ( rank )) if monitor_dir is not None else None ) # Create the monitor folder if needed if monitor_path is not None and monitor_dir is not None : os . makedirs ( monitor_dir , exist_ok = True ) env = Monitor ( env , filename = monitor_path , ** monitor_kwargs ) # Optionally, wrap the environment with the provided wrapper if wrapper_class is not None : env = wrapper_class ( env , ** wrapper_kwargs ) return env return _init # No custom VecEnv is passed if vec_env_cls is None : # Default: use a DummyVecEnv vec_env_cls = DummyVecEnv vec_env = vec_env_cls ( [ make_env ( i + start_index ) for i in range ( n_envs )], ** vec_env_kwargs ) # Prepare the seeds for the first reset vec_env . seed ( seed ) return vec_env def _test_envs (): \"\"\"Run a quick test of the environment generation methods\"\"\" # Create one primary non-vectorized environment main_env = AstrobeeEnv ( use_gui = True ) # Create a few vectorized environments n_vec_envs = 4 env_kwargs = { \"use_gui\" : False } # Let one vectorized environment use the GUI for debugging per_env_kwargs = { 0 : { \"use_gui\" : True }} vec_envs = make_vec_env ( AstrobeeEnv , n_vec_envs , env_kwargs = env_kwargs , vec_env_cls = SubprocVecEnv if n_vec_envs > 1 else DummyVecEnv , per_env_kwargs = per_env_kwargs , ) try : # Reset has to be called first main_env . reset () vec_envs . reset () # Call step with dummy action values, note difference in return parameters observation , reward , terminated , truncated , info = main_env . step ( 0 ) observation , reward , done , info = vec_envs . step ( np . zeros ( n_vec_envs )) input ( \"Stepped. Press Enter to finish\" ) finally : # Terminate pybullet processes, delete any saved states main_env . close () vec_envs . close () if __name__ == \"__main__\" : _test_envs ()","title":"Module pyastrobee.core.environments"},{"location":"reference/pyastrobee/core/environments/#variables","text":"FULL_SAFE_SET MAX_FORCE_MAGNITUDE MAX_TORQUE_MAGNITUDE","title":"Variables"},{"location":"reference/pyastrobee/core/environments/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/core/environments/#make_vec_env","text":"def make_vec_env ( env_id : Union [ str , Callable [ ... , gymnasium . core . Env ]], n_envs : int = 1 , seed : Optional [ int ] = None , start_index : int = 0 , monitor_dir : Optional [ str ] = None , wrapper_class : Optional [ Callable [[ gymnasium . core . Env ], gymnasium . core . Env ]] = None , env_kwargs : Optional [ Dict [ str , Any ]] = None , vec_env_cls : Optional [ Type [ Union [ stable_baselines3 . common . vec_env . dummy_vec_env . DummyVecEnv , stable_baselines3 . common . vec_env . subproc_vec_env . SubprocVecEnv ]]] = None , vec_env_kwargs : Optional [ Dict [ str , Any ]] = None , monitor_kwargs : Optional [ Dict [ str , Any ]] = None , wrapper_kwargs : Optional [ Dict [ str , Any ]] = None , per_env_kwargs : Optional [ Dict [ int , Dict [ str , Any ]]] = None ) -> stable_baselines3 . common . vec_env . base_vec_env . VecEnv Modified version of make_vec_env from Stable Baselines (SB3) to allow for specifying input parameters on a per-environment basis The main changes are any lines associated with the per_env_kwargs input. Updated SB3 docstring below: Create a wrapped, monitored VecEnv . By default it uses a DummyVecEnv which is usually faster than a SubprocVecEnv . Parameters: Name Type Description Default env_id None either the env ID, the env class or a callable returning an env None n_envs None the number of environments you wish to have in parallel None seed None the initial seed for the random number generator None start_index None start rank index None monitor_dir None Path to a folder where the monitor files will be saved. If None, no file will be written, however, the env will still be wrapped in a Monitor wrapper to provide additional information about training. None wrapper_class None Additional wrapper to use on the environment. This can also be a function with single argument that wraps the environment in many things. Note: the wrapper specified by this parameter will be applied after the Monitor wrapper. if some cases (e.g. with TimeLimit wrapper) this can lead to undesired behavior. See here for more details: https://github.com/DLR-RM/stable-baselines3/issues/894 None env_kwargs None Optional keyword argument to pass to the env constructor None vec_env_cls None A custom VecEnv class constructor. Default: None. None vec_env_kwargs None Keyword arguments to pass to the VecEnv class constructor. None monitor_kwargs None Keyword arguments to pass to the Monitor class constructor. None wrapper_kwargs None Keyword arguments to pass to the Wrapper class constructor. None per_env_kwargs None Like env-kwargs, keyword arguments fore the env constructor, but keyed to allow for different initialization on a per-env basis via the env's rank. These override any default values set via the env_kwargs input None Returns: Type Description None The wrapped environment View Source def make_vec_env ( env_id : Union [ str , Callable [ ..., gym . Env ]] , n_envs : int = 1 , seed : Optional [ int ] = None , start_index : int = 0 , monitor_dir : Optional [ str ] = None , wrapper_class : Optional [ Callable [[ gym . Env ] , gym . Env ]] = None , env_kwargs : Optional [ Dict [ str , Any ]] = None , vec_env_cls : Optional [ Type [ Union [ DummyVecEnv , SubprocVecEnv ]]] = None , vec_env_kwargs : Optional [ Dict [ str , Any ]] = None , monitor_kwargs : Optional [ Dict [ str , Any ]] = None , wrapper_kwargs : Optional [ Dict [ str , Any ]] = None , per_env_kwargs : Optional [ Dict [ int , Dict [ str , Any ]]] = None , # NEW ) -> VecEnv : \" \"\" Modified version of make_vec_env from Stable Baselines (SB3) to allow for specifying input parameters on a per-environment basis The main changes are any lines associated with the per_env_kwargs input. Updated SB3 docstring below: Create a wrapped, monitored ``VecEnv``. By default it uses a ``DummyVecEnv`` which is usually faster than a ``SubprocVecEnv``. :param env_id: either the env ID, the env class or a callable returning an env :param n_envs: the number of environments you wish to have in parallel :param seed: the initial seed for the random number generator :param start_index: start rank index :param monitor_dir: Path to a folder where the monitor files will be saved. If None, no file will be written, however, the env will still be wrapped in a Monitor wrapper to provide additional information about training. :param wrapper_class: Additional wrapper to use on the environment. This can also be a function with single argument that wraps the environment in many things. Note: the wrapper specified by this parameter will be applied after the ``Monitor`` wrapper. if some cases (e.g. with TimeLimit wrapper) this can lead to undesired behavior. See here for more details: https://github.com/DLR-RM/stable-baselines3/issues/894 :param env_kwargs: Optional keyword argument to pass to the env constructor :param vec_env_cls: A custom ``VecEnv`` class constructor. Default: None. :param vec_env_kwargs: Keyword arguments to pass to the ``VecEnv`` class constructor. :param monitor_kwargs: Keyword arguments to pass to the ``Monitor`` class constructor. :param wrapper_kwargs: Keyword arguments to pass to the ``Wrapper`` class constructor. :param per_env_kwargs: Like env-kwargs, keyword arguments fore the env constructor, but keyed to allow for different initialization on a per-env basis via the env's rank. These override any default values set via the env_kwargs input :return: The wrapped environment \"\" \" env_kwargs = env_kwargs or {} vec_env_kwargs = vec_env_kwargs or {} monitor_kwargs = monitor_kwargs or {} wrapper_kwargs = wrapper_kwargs or {} per_env_kwargs = per_env_kwargs or {} assert vec_env_kwargs is not None # for mypy def make_env ( rank : int ) -> Callable [[] , gym . Env ] : def _init () -> gym . Env : # For type checker: assert monitor_kwargs is not None assert wrapper_kwargs is not None assert env_kwargs is not None this_env_kwargs = env_kwargs | per_env_kwargs . get ( rank , {} ) if isinstance ( env_id , str ) : # if the render mode was not specified, we set it to `rgb_array` as default. kwargs = { \"render_mode\" : \"rgb_array\" } kwargs . update ( this_env_kwargs ) try : env = gym . make ( env_id , ** kwargs ) # type: ignore[arg-type] except TypeError : env = gym . make ( env_id , ** this_env_kwargs ) else : env = env_id ( ** this_env_kwargs ) # Patch to support gym 0.21/0.26 and gymnasium env = _patch_env ( env ) if seed is not None : # Note: here we only seed the action space # We will seed the env at the next reset env . action_space . seed ( seed + rank ) # Wrap the env in a Monitor wrapper # to have additional training information monitor_path = ( os . path . join ( monitor_dir , str ( rank )) if monitor_dir is not None else None ) # Create the monitor folder if needed if monitor_path is not None and monitor_dir is not None : os . makedirs ( monitor_dir , exist_ok = True ) env = Monitor ( env , filename = monitor_path , ** monitor_kwargs ) # Optionally, wrap the environment with the provided wrapper if wrapper_class is not None : env = wrapper_class ( env , ** wrapper_kwargs ) return env return _init # No custom VecEnv is passed if vec_env_cls is None : # Default: use a DummyVecEnv vec_env_cls = DummyVecEnv vec_env = vec_env_cls ( [ make_env ( i + start_index ) for i in range ( n_envs ) ] , ** vec_env_kwargs ) # Prepare the seeds for the first reset vec_env . seed ( seed ) return vec_env","title":"make_vec_env"},{"location":"reference/pyastrobee/core/environments/#classes","text":"","title":"Classes"},{"location":"reference/pyastrobee/core/environments/#astrobeeenv","text":"class AstrobeeEnv ( use_gui : bool , robot_pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 0 , 0 , 0 , 0 , 0 , 0 , 1 ), bag_name : str = 'top_handle_symmetric' , bag_mass : float = 10 , bag_type : type [ pyastrobee . core . abstract_bag . CargoBag ] = < class ' pyastrobee . core . deformable_bag . DeformableCargoBag '>, load_full_iss : bool = True ) Base Astrobee environment containing the Astrobee, ISS, and a cargo bag","title":"AstrobeeEnv"},{"location":"reference/pyastrobee/core/environments/#attributes","text":"Name Type Description Default use_gui bool Whether or not to use the GUI as opposed to headless. None robot_pose npt.ArrayLike Starting position + XYZW quaternion pose of the Astrobee, shape (7,) None bag_name str Type of cargo bag to load. Defaults to \"top_handle\". \"top_handle\" bag_mass float Mass of the cargo bag, in kg. Defaults to 10 None bag_type type[CargoBag] Class of cargo bag to use in the environment. Defaults to DeformableCargoBag None load_full_iss bool Whether to load the ISS (expensive, not necessarily required for rollouts) or just work with the safe set information. Defaults to True (load the ISS) None View Source class AstrobeeEnv ( gym . Env ) : \"\"\"Base Astrobee environment containing the Astrobee, ISS, and a cargo bag Args: use_gui (bool): Whether or not to use the GUI as opposed to headless. robot_pose (npt.ArrayLike, optional): Starting position + XYZW quaternion pose of the Astrobee, shape (7,) bag_name (str, optional): Type of cargo bag to load. Defaults to \" top_handle \". bag_mass (float): Mass of the cargo bag, in kg. Defaults to 10 bag_type (type[CargoBag]): Class of cargo bag to use in the environment. Defaults to DeformableCargoBag load_full_iss (bool, optional): Whether to load the ISS (expensive, not necessarily required for rollouts) or just work with the safe set information. Defaults to True (load the ISS) \"\"\" SAVE_STATE_DIR = \"artifacts/saved_states/\" SAVE_STATE_PATHS = [] def __init__ ( self , use_gui : bool , robot_pose : npt . ArrayLike = ( 0 , 0 , 0 , 0 , 0 , 0 , 1 ), bag_name : str = \"top_handle_symmetric\" , bag_mass : float = 10 , bag_type : type [ CargoBag ] = DeformableCargoBag , load_full_iss : bool = True , ) : self . client = initialize_pybullet ( use_gui ) self . safe_set = FULL_SAFE_SET if load_full_iss : self . iss = ISS ( client = self . client ) elif use_gui : for box in self . safe_set . values () : visualize_3D_box ( box , rgba = ( 1 , 0 , 0 , 0.3 )) self . robot = Astrobee ( robot_pose , client = self . client ) self . bag = bag_type ( bag_name , bag_mass , client = self . client ) self . bag . reset_to_handle_pose ( self . robot . ee_pose ) self . bag . attach_to ( self . robot , object_to_move = \"bag\" ) self . dt = self . client . getPhysicsEngineParameters () [ \"fixedTimeStep\" ] # Dummy parameters for gym / stable baselines compatibility # TODO make custom gym . spaces . space . Space subclasses for these ? self . observation_space = gym . spaces . Discrete ( 3 ) # temporary , unused self . action_space = gym . spaces . Discrete ( 3 ) # temporary , unused # Step the simulation once to get the bag in the right place self . client . stepSimulation () def reset ( self , seed : Optional [ int ] = None , options : Optional [ dict[str, Any ] ] = None ) -> tuple [ ObsType, dict[str, Any ] ]: # Implementation of Gym template method reset () : See Gym for full method docstring # Gym states this must be the first line of the reset () method super (). reset ( seed = seed ) return self . _get_obs (), self . _get_info () # Initial state observation def _get_obs ( self ) -> ObsType : \"\"\"Translates the environment's state into an observation Returns: ObsType: Observation \"\"\" # This function setup was recommended in the gym documentation return None , None # Dummy value for now def _get_info ( self ) -> dict [ str, Any ] : \"\"\"Provide auxiliary information associated with an observation Returns: dict[str, Any]: Additional observation information \"\"\" # This function setup was recommended in the gym documentation return {} # Dummy value for now def step ( self , action : ActType ) -> tuple [ ObsType, float, bool, bool, dict[str, Any ] ]: # Implementation of Gym template method step () : See Gym for full method docstring # Note : The return parameters differ slightly from step () for a vectorized environment # In this base environment , we will just step the pybullet simulation and return a dummy value for reward # The MPC environment can add more specific MPC / control functionality here self . client . stepSimulation () reward = 0 observation = self . _get_obs () terminated = False # If at the terminal state truncated = False # If stopping the sim before the terminal state info = self . _get_info () return observation , reward , terminated , truncated , info def step_simulation ( self ) : \"\"\"Single pybullet simulation step\"\"\" self . client . stepSimulation () def close ( self ) : # Implementation of Gym template method close () : See Gym for full method docstring self . client . disconnect () def save_state ( self ) -> str : \"\"\"Saves the current simulation state to disk - Note: saved states are not currently overwritten (could lead to issues with parallel environments?). But, these can be cleared out at the end of the simulation period Returns: str: Path to the saved state file \"\"\" # Autogenerate a unique filename / path and save to it filename = \"state_\" + datetime . now (). strftime ( \"%Y%m%d_%H%M%S_%f\" ) filepath = AstrobeeEnv . SAVE_STATE_DIR + filename + \".bullet\" self . client . saveBullet ( filepath ) AstrobeeEnv . SAVE_STATE_PATHS . append ( filepath ) return filepath def restore_state ( self , filename : str ) -> None : \"\"\"Restores the simulation to a saved state file Args: filename (str): Path to a .bullet saved state within the saved state directory \"\"\" filename = self . _check_state_file ( filename ) self . client . restoreState ( fileName = filename ) def _check_state_file ( self , filename : str ) -> str : \"\"\"Helper function: Validates that a saved state file exists Args: filename (str): Path to a .bullet saved state within the saved state directory Returns: str: Validated path \"\"\" path = Path ( filename ) if path . suffix != \".bullet\" : raise ValueError ( f \"Invalid filename: {filename}.\\nNot a .bullet saved state file\" ) if path . parent != Path ( AstrobeeEnv . SAVE_STATE_DIR ) : raise ValueError ( f \"Invalid filename: {filename}.\\nCheck that the filename points to within the saved state directory\" ) if path . is_file () : return str ( path ) raise FileNotFoundError ( f \"Could not find file: {filename}\" ) def send_client_command ( self , * args , ** kwargs ) -> Any : \"\"\"Send a command to the environment's pybullet client For instance, we can use pybullet.getBasePositionAndOrientation with this as send_client_command(\" getBasePositionAndOrientation \", body_id) Returns: Any: The return from the Pybullet command \"\"\" attr = getattr ( self . client , args [ 0 ] ) if isinstance ( attr , Callable ) : return attr ( * args [ 1: ] , ** kwargs ) return attr","title":"Attributes"},{"location":"reference/pyastrobee/core/environments/#ancestors-in-mro","text":"gymnasium.core.Env typing.Generic","title":"Ancestors (in MRO)"},{"location":"reference/pyastrobee/core/environments/#descendants","text":"pyastrobee.core.environments.AstrobeeMPCEnv","title":"Descendants"},{"location":"reference/pyastrobee/core/environments/#class-variables","text":"SAVE_STATE_DIR SAVE_STATE_PATHS metadata render_mode reward_range spec","title":"Class variables"},{"location":"reference/pyastrobee/core/environments/#instance-variables","text":"np_random Returns the environment's internal :attr: _np_random that if not set will initialise with a random seed. unwrapped Returns the base non-wrapped environment.","title":"Instance variables"},{"location":"reference/pyastrobee/core/environments/#methods","text":"","title":"Methods"},{"location":"reference/pyastrobee/core/environments/#close","text":"def close ( self ) After the user has finished using the environment, close contains the code necessary to \"clean up\" the environment. This is critical for closing rendering windows, database or HTTP connections. Calling close on an already closed environment has no effect and won't raise an error. View Source def close ( self ) : # Implementation of Gym template method close () : See Gym for full method docstring self . client . disconnect ()","title":"close"},{"location":"reference/pyastrobee/core/environments/#get_wrapper_attr","text":"def get_wrapper_attr ( self , name : 'str' ) -> 'Any' Gets the attribute name from the environment. View Source def get_wrapper_attr ( self , name : str ) -> Any : \" \"\" Gets the attribute `name` from the environment. \"\" \" return getattr ( self , name )","title":"get_wrapper_attr"},{"location":"reference/pyastrobee/core/environments/#render","text":"def render ( self ) -> 'RenderFrame | list[RenderFrame] | None' Compute the render frames as specified by :attr: render_mode during the initialization of the environment. The environment's :attr: metadata render modes ( env.metadata[\"render_modes\"] ) should contain the possible ways to implement the render modes. In addition, list versions for most render modes is achieved through gymnasium.make which automatically applies a wrapper to collect rendered frames. Note: As the :attr: render_mode is known during __init__ , the objects used to render the environment state should be initialised in __init__ . By convention, if the :attr: render_mode is: None (default): no render is computed. \"human\": The environment is continuously rendered in the current display or terminal, usually for human consumption. This rendering should occur during :meth: step and :meth: render doesn't need to be called. Returns None . \"rgb_array\": Return a single frame representing the current state of the environment. A frame is a np.ndarray with shape (x, y, 3) representing RGB values for an x-by-y pixel image. \"ansi\": Return a strings ( str ) or StringIO.StringIO containing a terminal-style text representation for each time step. The text can include newlines and ANSI escape sequences (e.g. for colors). \"rgb_array_list\" and \"ansi_list\": List based version of render modes are possible (except Human) through the wrapper, :py:class: gymnasium.wrappers.RenderCollection that is automatically applied during gymnasium.make(..., render_mode=\"rgb_array_list\") . The frames collected are popped after :meth: render is called or :meth: reset . Note: Make sure that your class's :attr: metadata \"render_modes\" key includes the list of supported modes. .. versionchanged:: 0.25.0 The render function was changed to no longer accept parameters, rather these parameters should be specified in the environment initialised, i.e., ``gymnasium.make(\"CartPole-v1\", render_mode=\"human\")`` View Source def render ( self ) -> RenderFrame | list [ RenderFrame ] | None : \" \"\" Compute the render frames as specified by :attr:`render_mode` during the initialization of the environment. The environment's :attr:`metadata` render modes (`env.metadata[\" render_modes \"]`) should contain the possible ways to implement the render modes. In addition, list versions for most render modes is achieved through `gymnasium.make` which automatically applies a wrapper to collect rendered frames. Note: As the :attr:`render_mode` is known during ``__init__``, the objects used to render the environment state should be initialised in ``__init__``. By convention, if the :attr:`render_mode` is: - None (default): no render is computed. - \" human \": The environment is continuously rendered in the current display or terminal, usually for human consumption. This rendering should occur during :meth:`step` and :meth:`render` doesn't need to be called. Returns ``None``. - \" rgb_array \": Return a single frame representing the current state of the environment. A frame is a ``np.ndarray`` with shape ``(x, y, 3)`` representing RGB values for an x-by-y pixel image. - \" ansi \": Return a strings (``str``) or ``StringIO.StringIO`` containing a terminal-style text representation for each time step. The text can include newlines and ANSI escape sequences (e.g. for colors). - \" rgb_array_list \" and \" ansi_list \": List based version of render modes are possible (except Human) through the wrapper, :py:class:`gymnasium.wrappers.RenderCollection` that is automatically applied during ``gymnasium.make(..., render_mode=\" rgb_array_list \")``. The frames collected are popped after :meth:`render` is called or :meth:`reset`. Note: Make sure that your class's :attr:`metadata` ``\" render_modes \"`` key includes the list of supported modes. .. versionchanged:: 0.25.0 The render function was changed to no longer accept parameters, rather these parameters should be specified in the environment initialised, i.e., ``gymnasium.make(\" CartPole - v1 \", render_mode=\" human \")`` \"\" \" raise NotImplementedError","title":"render"},{"location":"reference/pyastrobee/core/environments/#reset","text":"def reset ( self , seed : Optional [ int ] = None , options : Optional [ dict [ str , Any ]] = None ) -> tuple [ ~ ObsType , dict [ str , typing . Any ]] Resets the environment to an initial internal state, returning an initial observation and info. This method generates a new starting state often with some randomness to ensure that the agent explores the state space and learns a generalised policy about the environment. This randomness can be controlled with the seed parameter otherwise if the environment already has a random number generator and :meth: reset is called with seed=None , the RNG is not reset. Therefore, :meth: reset should (in the typical use case) be called with a seed right after initialization and then never again. For Custom environments, the first line of :meth: reset should be super().reset(seed=seed) which implements the seeding correctly. .. versionchanged:: v0.25 The `` return_info `` parameter was removed and now info is expected to be returned . Parameters: Name Type Description Default seed optional int The seed that is used to initialize the environment's PRNG ( np_random ). If the environment does not already have a PRNG and seed=None (the default option) is passed, a seed will be chosen from some source of entropy (e.g. timestamp or /dev/urandom). However, if the environment already has a PRNG and seed=None is passed, the PRNG will not be reset. If you pass an integer, the PRNG will be reset even if it already exists. Usually, you want to pass an integer right after the environment has been initialized and then never again . Please refer to the minimal example above to see this paradigm in action. None options optional dict Additional information to specify how the environment is reset (optional, depending on the specific environment) None Returns: Type Description None observation (ObsType): Observation of the initial state. This will be an element of :attr: observation_space (typically a numpy array) and is analogous to the observation returned by :meth: step . info (dictionary): This dictionary contains auxiliary information complementing observation . It should be analogous to the info returned by :meth: step . View Source def reset ( self , seed : Optional [ int ] = None , options : Optional [ dict[str, Any ] ] = None ) -> tuple [ ObsType, dict[str, Any ] ]: # Implementation of Gym template method reset () : See Gym for full method docstring # Gym states this must be the first line of the reset () method super (). reset ( seed = seed ) return self . _get_obs (), self . _get_info () # Initial state observation","title":"reset"},{"location":"reference/pyastrobee/core/environments/#restore_state","text":"def restore_state ( self , filename : str ) -> None Restores the simulation to a saved state file Parameters: Name Type Description Default filename str Path to a .bullet saved state within the saved state directory None View Source def restore_state ( self , filename : str ) -> None : \"\"\"Restores the simulation to a saved state file Args: filename (str): Path to a .bullet saved state within the saved state directory \"\"\" filename = self . _check_state_file ( filename ) self . client . restoreState ( fileName = filename )","title":"restore_state"},{"location":"reference/pyastrobee/core/environments/#save_state","text":"def save_state ( self ) -> str Saves the current simulation state to disk Note: saved states are not currently overwritten (could lead to issues with parallel environments?). But, these can be cleared out at the end of the simulation period Returns: Type Description str Path to the saved state file View Source def save_state ( self ) -> str : \"\"\"Saves the current simulation state to disk - Note: saved states are not currently overwritten (could lead to issues with parallel environments?). But, these can be cleared out at the end of the simulation period Returns: str: Path to the saved state file \"\"\" # Autogenerate a unique filename / path and save to it filename = \"state_\" + datetime . now (). strftime ( \"%Y%m%d_%H%M%S_%f\" ) filepath = AstrobeeEnv . SAVE_STATE_DIR + filename + \".bullet\" self . client . saveBullet ( filepath ) AstrobeeEnv . SAVE_STATE_PATHS . append ( filepath ) return filepath","title":"save_state"},{"location":"reference/pyastrobee/core/environments/#send_client_command","text":"def send_client_command ( self , * args , ** kwargs ) -> Any Send a command to the environment's pybullet client For instance, we can use pybullet.getBasePositionAndOrientation with this as send_client_command(\"getBasePositionAndOrientation\", body_id) Returns: Type Description Any The return from the Pybullet command View Source def send_client_command(self, *args, * *kwargs) -> Any: \"\"\"Send a command to the environment's pybullet client For instance, we can use pybullet.getBasePositionAndOrientation with this as send_client_command(\"getBasePositionAndOrientation\", body_id) Returns: Any: The return from the Pybullet command \"\"\" attr = getattr(self.client, args[0]) if isinstance(attr, Callable): return attr(*args[1:], **kwargs) return attr","title":"send_client_command"},{"location":"reference/pyastrobee/core/environments/#step","text":"def step ( self , action : ~ ActType ) -> tuple [ ~ ObsType , float , bool , bool , dict [ str , typing . Any ]] Run one timestep of the environment's dynamics using the agent actions. When the end of an episode is reached ( terminated or truncated ), it is necessary to call :meth: reset to reset this environment's state for the next episode. .. versionchanged:: 0.26 The Step API was changed removing `` done `` in favor of `` terminated `` and `` truncated `` to make it clearer to users when the environment had terminated or truncated which is critical for reinforcement learning bootstrapping algorithms . Parameters: Name Type Description Default action ActType an action provided by the agent to update the environment state. None Returns: Type Description None observation (ObsType): An element of the environment's :attr: observation_space as the next observation due to the agent actions. An example is a numpy array containing the positions and velocities of the pole in CartPole. reward (SupportsFloat): The reward as a result of taking the action. terminated (bool): Whether the agent reaches the terminal state (as defined under the MDP of the task) which can be positive or negative. An example is reaching the goal state or moving into the lava from the Sutton and Barton, Gridworld. If true, the user needs to call :meth: reset . truncated (bool): Whether the truncation condition outside the scope of the MDP is satisfied. Typically, this is a timelimit, but could also be used to indicate an agent physically going out of bounds. Can be used to end the episode prematurely before a terminal state is reached. If true, the user needs to call :meth: reset . info (dict): Contains auxiliary diagnostic information (helpful for debugging, learning, and logging). This might, for instance, contain: metrics that describe the agent's performance state, variables that are hidden from observations, or individual reward terms that are combined to produce the total reward. In OpenAI Gym <v26, it contains \"TimeLimit.truncated\" to distinguish truncation and termination, however this is deprecated in favour of returning terminated and truncated variables. done (bool): (Deprecated) A boolean value for if the episode has ended, in which case further :meth: step calls will return undefined results. This was removed in OpenAI Gym v26 in favor of terminated and truncated attributes. A done signal may be emitted for different reasons: Maybe the task underlying the environment was solved successfully, a certain timelimit was exceeded, or the physics simulation has entered an invalid state. View Source def step ( self , action : ActType ) -> tuple [ ObsType , float , bool , bool , dict [ str , Any ]] : # Implementation of Gym template method step () : See Gym for full method docstring # Note : The return parameters differ slightly from step () for a vectorized environment # In this base environment , we will just step the pybullet simulation and return a dummy value for reward # The MPC environment can add more specific MPC / control functionality here self . client . stepSimulation () reward = 0 observation = self . _get_obs () terminated = False # If at the terminal state truncated = False # If stopping the sim before the terminal state info = self . _get_info () return observation , reward , terminated , truncated , info","title":"step"},{"location":"reference/pyastrobee/core/environments/#step_simulation","text":"def step_simulation ( self ) Single pybullet simulation step View Source def step_simulation(self): \"\"\"Single pybullet simulation step\"\"\" self.client.stepSimulation()","title":"step_simulation"},{"location":"reference/pyastrobee/core/environments/#astrobeempcenv","text":"class AstrobeeMPCEnv ( use_gui : bool , is_primary : bool , robot_pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 0 , 0 , 0 , 0 , 0 , 0 , 1 ), bag_name : str = 'top_handle' , bag_mass : float = 10 , bag_type : type [ pyastrobee . core . abstract_bag . CargoBag ] = < class ' pyastrobee . core . deformable_bag . DeformableCargoBag '>, load_full_iss : bool = True , nominal_rollouts : bool = False , cleanup : bool = True ) Astrobee environment for MPC: Contains additional controller parameters and functions associated with MPC, on top of the base Astrobee environment capability","title":"AstrobeeMPCEnv"},{"location":"reference/pyastrobee/core/environments/#attributes_1","text":"Name Type Description Default use_gui bool Whether or not to use the GUI as opposed to headless. None is_primary bool Whether or not this environment is the main simulation (True) or if it is one of the vectorized environments for evaluating a rollout (False) None robot_pose npt.ArrayLike Starting position + XYZW quaternion pose of the Astrobee, shape (7,) None bag_name str Type of cargo bag to load. Defaults to \"top_handle\". \"top_handle\" bag_mass float Mass of the cargo bag, in kg. Defaults to 10 None bag_type type[CargoBag] Class of cargo bag to use in the environment. Defaults to DeformableCargoBag None load_full_iss bool Whether to load the ISS (expensive, not necessarily required for rollouts) or just work with the safe set information. Defaults to True (load the ISS) None nominal_rollouts bool If True, will roll-out a trajectory based on the nominal target. If False, will sample a trajectory about the nominal target. Defaults to False. None cleanup bool Whether or not to delete all saved states when the simulation ends. Defaults to True. True View Source class AstrobeeMPCEnv ( AstrobeeEnv ): \"\"\"Astrobee environment for MPC: Contains additional controller parameters and functions associated with MPC, on top of the base Astrobee environment capability Args: use_gui (bool): Whether or not to use the GUI as opposed to headless. is_primary (bool): Whether or not this environment is the main simulation (True) or if it is one of the vectorized environments for evaluating a rollout (False) robot_pose (npt.ArrayLike, optional): Starting position + XYZW quaternion pose of the Astrobee, shape (7,) bag_name (str, optional): Type of cargo bag to load. Defaults to \"top_handle\". bag_mass (float): Mass of the cargo bag, in kg. Defaults to 10 bag_type (type[CargoBag]): Class of cargo bag to use in the environment. Defaults to DeformableCargoBag load_full_iss (bool, optional): Whether to load the ISS (expensive, not necessarily required for rollouts) or just work with the safe set information. Defaults to True (load the ISS) nominal_rollouts (bool, optional): If True, will roll-out a trajectory based on the nominal target. If False, will sample a trajectory about the nominal target. Defaults to False. cleanup (bool, optional): Whether or not to delete all saved states when the simulation ends. Defaults to True. \"\"\" class FlightStates ( Enum ): # STARTING = \"starting\" NOMINAL = \"nominal\" SLOWING = \"slowing\" STOPPING = \"stopping\" def __init__ ( self , use_gui : bool , is_primary : bool , robot_pose : npt . ArrayLike = ( 0 , 0 , 0 , 0 , 0 , 0 , 1 ), bag_name : str = \"top_handle\" , bag_mass : float = 10 , bag_type : type [ CargoBag ] = DeformableCargoBag , load_full_iss : bool = True , nominal_rollouts : bool = False , cleanup : bool = True , ): super () . __init__ ( use_gui , robot_pose , bag_name , bag_mass , bag_type , load_full_iss ) # TODO figure out how to handle controller parameters # Just fixing the gains here for now # TODO should these be functions of the bag mass??? kp , kv , kq , kw = 20 , 5 , 5 , 0.1 # TODO make parameters p = self . bag . position - self . robot . position self . controller = ForceTorqueController ( self . robot . id , self . robot . mass + bag_mass , # self.robot.inertia, self . robot . inertia + bag_mass * ( np . dot ( p , p ) * np . eye ( 3 ) - np . outer ( p , p ) ), # TODO parallel axis theorem for bag?? test this kp , kv , kq , kw , self . dt , max_force = MAX_FORCE_MAGNITUDE * 10 , # TODO REMOVE THIS SCALING FACTOR max_torque = MAX_TORQUE_MAGNITUDE * 10 , client = self . client , ) # Sampling parameters (TODO these need refinement) self . pos_stdev = 0.1 self . orn_stdev = 0.1 self . vel_stdev = 0.1 self . ang_vel_stdev = 0.1 self . accel_stdev = 0.1 self . alpha_stdev = 0.1 # Store last acceleration commands # Update through set_attr self . last_accel_cmd = np . zeros ( 3 ) # init self . last_alpha_cmd = np . zeros ( 3 ) # init # Frequency at which we query our \"stay away from the walls\" cost function self . safe_set_eval_freq = 10 # Hz # Keep track of any temporary debug visualizer IDs self . debug_viz_ids = () # Keep track of whether we're stopping or in a nominal flight mode self . flight_state = self . FlightStates . NOMINAL # init # (effectively the rollout duration, should be a constant) - TODO IMPROVE THIS self . planning_duration = None # Store where we want the Astrobee to be at the end of the MPC run to determine if we are done self . goal_pose = None # init # HACK - improve how this is handled self . arm_traj_plan = None self . _is_primary_env = is_primary self . _is_debugging_env = not is_primary and use_gui self . _nominal_rollouts = nominal_rollouts self . _cleanup = cleanup self . traj_plan = None # Init self . target_pos = None # Init self . target_orn = None # Init self . target_vel = None # Init self . target_omega = None # Init self . target_duration = None # Init @ property def is_primary_simulation ( self ) -> bool : \"\"\"Whether this environment is running the primary planning/control simulation or is a separate (likely vectorized) environment for evaluating rollouts\"\"\" return self . _is_primary_env @ property def is_debugging_simulation ( self ) -> bool : \"\"\"Whether this is an environment launched in debug mode\"\"\" return self . _is_debugging_env def set_arm_traj ( self , traj : ArmTrajectory ): # TODO IMPROVE THIS self . arm_traj_plan = traj def set_planning_duration ( self , duration ): # TODO improve this self . planning_duration = duration def set_flight_state ( self , state : Union [ str , FlightStates ]): \"\"\"Set the current flight state: for instance, whether we are in nominal operating mode, stopping, ... Args: state (Union[str, FlightStates]): A flight state or its string representation (i.e. \"nominal\", \"stopping\", ...) \"\"\" # TODO add check that it is valid # TODO should we store the state as the string or the Enum???? if isinstance ( state , str ): self . flight_state = self . FlightStates ( state ) elif isinstance ( state , self . FlightStates ): self . flight_state = state else : raise ValueError ( \"Flight state not recognized\" ) def set_target_state ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , vel : npt . ArrayLike , omega : npt . ArrayLike , accel : npt . ArrayLike , alpha : npt . ArrayLike , duration : float , ) -> None : \"\"\"Set the target dynamics state for planning/sampling trajectories and determining penalties Args: pos (npt.ArrayLike): Desired position, shape (3,) orn (npt.ArrayLike): Desired XYZW quaternion orientation, shape (4,) vel (npt.ArrayLike): Desired linear velocity, shape (3,) omega (npt.ArrayLike): Desired angular velocity, shape (3,) accel (npt.ArrayLike): Desired linear acceleration, shape (3,) alpha (npt.ArrayLike): Desired angular acceleration, shape (3,) duration (float): Amount of time to pass before achieving this desired state \"\"\" self . target_pos = pos self . target_orn = orn self . target_vel = vel self . target_omega = omega self . target_accel = accel self . target_alpha = alpha self . target_duration = duration def sample_trajectory ( self ) -> None : \"\"\"Samples a trajectory about the nominal target. - If the nominal_rollouts parameter is True for this environment, the final state of the trajectory will be exactly the nominal value (no noise added when sampling) - This should just be called in the vectorized rollout environments (not the main environment) since the main environment will use the best trajectory from the rollout envs \"\"\" if self . is_primary_simulation : raise ValueError ( \"Trajectory sampling should only occur in one of parallel environments for evaluation purposes\" ) pos , orn , vel , omega = self . robot . dynamics_state # Time sampling parameters (TODO refine these, move them somewhere else) time_stdev = 1 # Note: ensure that this is a positive value post-sampling min_time = 1 n_timesteps = round ( self . planning_duration / self . dt ) # Nominal if self . flight_state == self . FlightStates . NOMINAL : end_state = ( [ self . target_pos , self . target_orn , self . target_vel , self . target_omega , self . target_accel , self . target_alpha , ] if self . _nominal_rollouts else sample_state ( self . target_pos , self . target_orn , self . target_vel , self . target_omega , self . last_accel_cmd , self . last_alpha_cmd , self . pos_stdev , self . orn_stdev , self . vel_stdev , self . ang_vel_stdev , self . accel_stdev , self . alpha_stdev , ) ) duration = self . target_duration elif self . flight_state == self . FlightStates . SLOWING : end_state = ( [ self . target_pos , self . target_orn , self . target_vel , self . target_omega , self . target_accel , self . target_alpha , ] if self . _nominal_rollouts else sample_state ( self . target_pos , self . target_orn , self . target_vel , self . target_omega , self . last_accel_cmd , self . last_alpha_cmd , self . pos_stdev / 3 , self . orn_stdev / 3 , self . vel_stdev / 3 , self . ang_vel_stdev / 3 , self . accel_stdev / 3 , self . alpha_stdev / 3 , ) ) duration = ( self . target_duration if self . _nominal_rollouts else np . maximum ( np . random . normal ( self . target_duration , time_stdev ), min_time ) ) elif self . flight_state == self . FlightStates . STOPPING : end_state = [ self . target_pos , self . target_orn , self . target_vel , self . target_omega , self . target_accel , self . target_alpha , ] duration = ( self . planning_duration if self . _nominal_rollouts else np . maximum ( np . random . normal ( self . planning_duration , time_stdev ), min_time ) ) else : raise AttributeError ( \"Flight state not recognized\" ) traj = local_planner ( pos , orn , vel , omega , self . last_accel_cmd , self . last_alpha_cmd , * end_state , duration , self . dt , ) if traj . num_timesteps == n_timesteps : self . traj_plan = traj else : # Traj is either too long or too short, so adjust it if traj . num_timesteps > n_timesteps : self . traj_plan = traj . get_segment ( 0 , n_timesteps ) else : # Less than # Create a trajectory at the stopped position for the remaining timesteps remaining_timesteps = n_timesteps - traj . num_timesteps stop_traj = Trajectory ( traj . positions [ - 1 ] * np . ones (( remaining_timesteps , 1 )), traj . quaternions [ - 1 ] * np . ones (( remaining_timesteps , 1 )), np . zeros (( remaining_timesteps , 3 )), np . zeros (( remaining_timesteps , 3 )), np . zeros (( remaining_timesteps , 3 )), np . zeros (( remaining_timesteps , 3 )), np . arange ( remaining_timesteps ) * self . dt , ) self . traj_plan = concatenate_trajs ( traj , stop_traj ) self . sampled_end_state = ( self . traj_plan . positions [ - 1 ], self . traj_plan . quaternions [ - 1 ], self . traj_plan . linear_velocities [ - 1 ], self . traj_plan . angular_velocities [ - 1 ], ) def _get_obs ( self ) -> ObsType : if self . is_primary_simulation : return self . robot . full_state , self . bag . dynamics_state else : return None , None def step ( self , action : ActType ) -> tuple [ ObsType , float , bool , bool , dict [ str , Any ]]: # Note: For MPC, this is less so a \"step\" than a \"rollout\" function. The trajectory should be sampled # before calling this function # TODO use the action parameter to pass in a trajectory to follow? terminated = False # init (If at the terminal state) truncated = False # init (If stopping the sim before the terminal state) if self . traj_plan is None : raise ValueError ( \"Trajectory has not been planned\" ) # Follow the trajectory. NOTE: This is effectively the same as the follow_traj() function in the controller, # but accessing the loop directly allows us to do more with the data at each step # TODO decide how to handle the stopping criteria if not self . traj_plan . num_timesteps == self . arm_traj_plan . num_timesteps : raise ValueError ( \"Mismatched time info between base and arm trajs\" ) # If this is the primary simulation, we just follow the best trajectory we have # Rewrd for the primary simulation doesn't mean anything, so no computation needed inertia_update_freq = 5 steps_per_inertia_update = round ( 1 / ( self . traj_plan . timestep * inertia_update_freq ) ) if self . is_primary_simulation : for i in range ( self . traj_plan . num_timesteps ): pos , orn , lin_vel , ang_vel = self . controller . get_current_state () self . controller . step ( pos , lin_vel , orn , ang_vel , self . traj_plan . positions [ i , :], self . traj_plan . linear_velocities [ i , :], self . traj_plan . linear_accels [ i , :], self . traj_plan . quaternions [ i , :], self . traj_plan . angular_velocities [ i , :], self . traj_plan . angular_accels [ i , :], ) self . robot . set_joint_angles ( self . arm_traj_plan . angles [ i , :], self . arm_traj_plan . joint_ids ) # TODO THIS KINDA SUCKS if i % steps_per_inertia_update == 0 : T_R2W = self . robot . tmat T_B2W = self . bag . tmat T_B2R = invert_transform_mat ( T_R2W ) @ T_B2W p = T_B2R [: 3 , 3 ] self . controller . inertia = self . robot . inertia + self . bag . mass * ( np . dot ( p , p ) * np . eye ( 3 ) - np . outer ( p , p ) ) reward = 0 else : # We are in a rollout environment # So, follow the trajectory, but also keep track of a bunch of things so that we can compute the reward robot_safe_set_cost = 0 # init bag_safe_set_cost = 0 # init stabilization_cost = 0 tracking_cost = 0 bag_vel_cost = 0 steps_per_safe_set_eval = round ( 1 / ( self . traj_plan . timestep * self . safe_set_eval_freq ) ) # TODO IMPROVE THIS # the thought here was that if we're stopping (or slowing) we care more about the overall positioning # rather than just staying in the middle of the modules safe_set_weight = ( 1 if self . flight_state == self . FlightStates . NOMINAL else 0.1 ) for i in range ( self . traj_plan . num_timesteps ): # Note: the traj log gets updated whenever we access the current state pos , orn , lin_vel , ang_vel = self . controller . get_current_state () self . controller . step ( pos , lin_vel , orn , ang_vel , self . traj_plan . positions [ i , :], self . traj_plan . linear_velocities [ i , :], self . traj_plan . linear_accels [ i , :], self . traj_plan . quaternions [ i , :], self . traj_plan . angular_velocities [ i , :], self . traj_plan . angular_accels [ i , :], ) self . robot . set_joint_angles ( self . arm_traj_plan . angles [ i , :], self . arm_traj_plan . joint_ids ) # TODO THIS KINDA SUCKS if i % steps_per_inertia_update == 0 : T_R2W = self . robot . tmat T_B2W = self . bag . tmat T_B2R = invert_transform_mat ( T_R2W ) @ T_B2W p = T_B2R [: 3 , 3 ] self . controller . inertia = self . robot . inertia + self . bag . mass * ( np . dot ( p , p ) * np . eye ( 3 ) - np . outer ( p , p ) ) # *** COST FUNCTION *** # Perform collision checking on every timestep robot_bb = self . robot . bounding_box bag_bb = self . bag . bounding_box robot_is_safe = check_box_containment ( robot_bb , self . safe_set . values ()) bag_is_safe = check_box_containment ( bag_bb , self . safe_set . values ()) # If either the robot or bag collided, stop the simulation and return an effectively infinite cost # (Very large but not infinity to maintain sorting order in the edge case that all rollouts collide) if not robot_is_safe : robot_safe_set_cost += 10000 truncated = True # break if not bag_is_safe : bag_safe_set_cost += 10000 truncated = True # break # These \"stay away from the walls\" costs are somewhat expensive to compute and don't necessarily need # to be done every timestep. TODO just use the local description of the safe set, not the full thing if i % steps_per_safe_set_eval == 0 : robot_safe_set_cost += safe_set_weight * safe_set_cost ( robot_bb [ 0 ], self . safe_set . values () ) robot_safe_set_cost += safe_set_weight * safe_set_cost ( robot_bb [ 1 ], self . safe_set . values () ) bag_safe_set_cost += safe_set_weight * safe_set_cost ( bag_bb [ 0 ], self . safe_set . values () ) bag_safe_set_cost += safe_set_weight * safe_set_cost ( bag_bb [ 1 ], self . safe_set . values () ) bag_pos , bag_orn , bag_vel , bag_ang_vel = self . bag . dynamics_state # Penalizing bag velocities perpendicular to the robot's velocity at end of rollout if self . flight_state == self . FlightStates . NOMINAL : bag_vel_cost = 300 * ( np . linalg . norm ( bag_vel ) - np . dot ( lin_vel / np . linalg . norm ( lin_vel ), bag_vel ) ) # End-of-rollout additional cost function evaluations # 1) Stabilize the motion of the bag with respect to the robot # 2) Position the robot so it's stopped at the goal pose # Both of these are only relevant when we're at the end of the nominal trajectory # TODO tune all of the scaling factors on the costs if self . flight_state == self . FlightStates . STOPPING : angular_term = np . linalg . norm ( ang_vel - bag_ang_vel ) r_r2b = bag_pos - pos # Vector from robot to bag linear_term = np . linalg . norm ( lin_vel - bag_vel + np . cross ( ang_vel , r_r2b ) ) stabilization_cost += 500 * ( linear_term + angular_term ) # TODO make this a separate function? # Adding back in a tracking cost component # If we are stopping then we know that the target state is the goal pos_error = np . linalg . norm ( pos - self . target_pos ) orn_error = quaternion_dist ( orn , self . target_orn ) vel_error = np . linalg . norm ( lin_vel - self . target_vel ) ang_vel_error = np . linalg . norm ( ang_vel - self . target_omega ) if self . is_debugging_simulation : print ( \"Position error: \" , pos_error ) print ( \"Orn error: \" , orn_error ) print ( \"Vel error: \" , vel_error ) print ( \"Ang vel error: \" , ang_vel_error ) tracking_cost += ( 200 * pos_error + 100 * orn_error + 200 * vel_error + 100 * ang_vel_error ) else : stabilization_cost = 0 tracking_cost = 0 if self . is_debugging_simulation : print ( \"Robot safe set cost: \" , robot_safe_set_cost ) print ( \"Bag safe set cost: \" , bag_safe_set_cost ) print ( \"Stabilization cost: \" , stabilization_cost ) print ( \"Tracking cost: \" , tracking_cost ) print ( \"Bag velocity cost: \" , bag_vel_cost ) reward = - 1 * ( robot_safe_set_cost + bag_safe_set_cost + stabilization_cost + tracking_cost + bag_vel_cost ) # Observe the robot/bag state in the main env, dummy value if in rollout env observation = self . _get_obs () # Evaluate if we have stabilized the robot and the bag at the end of the trajectory # (main env only since that's what we care about and we don't want to waste compute) if ( self . flight_state == self . FlightStates . STOPPING and self . is_primary_simulation and robot_and_bag_termination_criteria ( observation [ 0 ], observation [ 1 ], self . goal_pose ) ): terminated = True # TODO: If we change the observation function to return the state of the robot and the bag, # we can determine the \"terminated\" parameter! # But note that we should only really do the observation in the main env info = self . _get_info () return observation , reward , terminated , truncated , info def close ( self ): self . client . disconnect () if self . is_primary_simulation and self . _cleanup : # Delete all of the previous saved states at the end of the simulation process # TODO: decide if each session should have its own directory? for path in Path ( AstrobeeMPCEnv . SAVE_STATE_DIR ) . glob ( \"*.bullet\" ): path . unlink () def save_state ( self ) -> str : # Ensure that any simulations strictly for evaluating rollouts cannot save their state if not self . is_primary_simulation : raise PermissionError ( \"Only the primary simulation can save the state\" ) return super () . save_state () def get_robot_state ( self ) -> tuple [ np . ndarray , ... ]: \"\"\"Returns the full state information for the Astrobee in the environment (Base pos/orn/vels, joint angles/vels) Returns: tuple[np.ndarray, ...]: np.ndarray: Position, shape (3,) np.ndarray: Orientation (XYZW quaternion), shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) np.ndarray: Joint positions, shape (NUM_JOINTS,) np.ndarray: Joint velocities, shape (NUM_JOINTS,) \"\"\" return self . robot . full_state def get_bag_state ( self ) -> tuple [ np . ndarray , ... ]: \"\"\"Returns the dynamics state information for the bag in the environment (pos/orn/vels) Returns: tuple[np.ndarray, ...]: np.ndarray: Position, shape (3,) np.ndarray: XYZW quaternion orientation, shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) \"\"\" return self . bag . dynamics_state def reset_robot_state ( self , state : tuple [ np . ndarray , ... ]) -> None : \"\"\"Fully resets the state of the Astrobee in the environment Args: state (tuple[np.ndarray, ...]): Full Astrobee state information containing: np.ndarray: Position, shape (3,) np.ndarray: Orientation (XYZW quaternion), shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) np.ndarray: Joint positions, shape (NUM_JOINTS,) np.ndarray: Joint velocities, shape (NUM_JOINTS,) \"\"\" assert len ( state ) == 6 assert len ( state [ 0 ]) == 3 assert len ( state [ 1 ]) == 4 assert len ( state [ 2 ]) == 3 assert len ( state [ 3 ]) == 3 assert len ( state [ 4 ]) == Astrobee . NUM_JOINTS assert len ( state [ 5 ]) == Astrobee . NUM_JOINTS self . robot . reset_full_state ( * state ) def reset_bag_state ( self , state : tuple [ np . ndarray , ... ]) -> None : \"\"\"Resets the dynamics of the bag in the environment Args: state (tuple[np.ndarray, ...]): Dynamics info of the bag, containing: np.ndarray: Position, shape (3,) np.ndarray: Orientation (XYZW quaternion), shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) \"\"\" assert len ( state ) == 4 assert len ( state [ 0 ]) == 3 assert len ( state [ 1 ]) == 4 assert len ( state [ 2 ]) == 3 assert len ( state [ 3 ]) == 3 self . bag . reset_dynamics ( * state ) def show_traj_plan ( self , n : Optional [ int ]) -> None : \"\"\"Displays the planned trajectory on the current pybullet client GUI (if enabled) Args: n (Optional[int]): Number of frames to plot, if plotting all of the frames is not desired. Defaults to None (plot all frames) \"\"\" if self . traj_plan is None : raise ValueError ( \"No trajectory available to visualize\" ) self . debug_viz_ids = self . traj_plan . visualize ( n , client = self . client ) def unshow_traj_plan ( self ) -> None : \"\"\"Removes a displayed trajectory from the pybullet client GUI\"\"\" if len ( self . debug_viz_ids ) == 0 : return remove_debug_objects ( self . debug_viz_ids , self . client ) self . debug_viz_ids = ()","title":"Attributes"},{"location":"reference/pyastrobee/core/environments/#ancestors-in-mro_1","text":"pyastrobee.core.environments.AstrobeeEnv gymnasium.core.Env typing.Generic","title":"Ancestors (in MRO)"},{"location":"reference/pyastrobee/core/environments/#class-variables_1","text":"FlightStates SAVE_STATE_DIR SAVE_STATE_PATHS metadata render_mode reward_range spec","title":"Class variables"},{"location":"reference/pyastrobee/core/environments/#instance-variables_1","text":"is_debugging_simulation Whether this is an environment launched in debug mode is_primary_simulation Whether this environment is running the primary planning/control simulation or is a separate (likely vectorized) environment for evaluating rollouts np_random Returns the environment's internal :attr: _np_random that if not set will initialise with a random seed. unwrapped Returns the base non-wrapped environment.","title":"Instance variables"},{"location":"reference/pyastrobee/core/environments/#methods_1","text":"","title":"Methods"},{"location":"reference/pyastrobee/core/environments/#close_1","text":"def close ( self ) After the user has finished using the environment, close contains the code necessary to \"clean up\" the environment. This is critical for closing rendering windows, database or HTTP connections. Calling close on an already closed environment has no effect and won't raise an error. View Source def close(self): self.client.disconnect() if self.is_primary_simulation and self._cleanup: # Delete all of the previous saved states at the end of the simulation process # TODO: decide if each session should have its own directory? for path in Path(AstrobeeMPCEnv.SAVE_STATE_DIR).glob(\"*.bullet\"): path.unlink()","title":"close"},{"location":"reference/pyastrobee/core/environments/#get_bag_state","text":"def get_bag_state ( self ) -> tuple [ numpy . ndarray , ... ] Returns the dynamics state information for the bag in the environment (pos/orn/vels) Returns: Type Description tuple[np.ndarray, ...] np.ndarray: Position, shape (3,) np.ndarray: XYZW quaternion orientation, shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) View Source def get_bag_state ( self ) -> tuple [ np . ndarray , ...] : \"\"\"Returns the dynamics state information for the bag in the environment (pos/orn/vels) Returns: tuple[np.ndarray, ...]: np.ndarray: Position, shape (3,) np.ndarray: XYZW quaternion orientation, shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) \"\"\" return self . bag . dynamics_state","title":"get_bag_state"},{"location":"reference/pyastrobee/core/environments/#get_robot_state","text":"def get_robot_state ( self ) -> tuple [ numpy . ndarray , ... ] Returns the full state information for the Astrobee in the environment (Base pos/orn/vels, joint angles/vels) Returns: Type Description tuple[np.ndarray, ...] np.ndarray: Position, shape (3,) np.ndarray: Orientation (XYZW quaternion), shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) np.ndarray: Joint positions, shape (NUM_JOINTS,) np.ndarray: Joint velocities, shape (NUM_JOINTS,) View Source def get_robot_state ( self ) -> tuple [ np . ndarray , ...] : \"\"\"Returns the full state information for the Astrobee in the environment (Base pos/orn/vels, joint angles/vels) Returns: tuple[np.ndarray, ...]: np.ndarray: Position, shape (3,) np.ndarray: Orientation (XYZW quaternion), shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) np.ndarray: Joint positions, shape (NUM_JOINTS,) np.ndarray: Joint velocities, shape (NUM_JOINTS,) \"\"\" return self . robot . full_state","title":"get_robot_state"},{"location":"reference/pyastrobee/core/environments/#get_wrapper_attr_1","text":"def get_wrapper_attr ( self , name : 'str' ) -> 'Any' Gets the attribute name from the environment. View Source def get_wrapper_attr ( self , name : str ) -> Any : \" \"\" Gets the attribute `name` from the environment. \"\" \" return getattr ( self , name )","title":"get_wrapper_attr"},{"location":"reference/pyastrobee/core/environments/#render_1","text":"def render ( self ) -> 'RenderFrame | list[RenderFrame] | None' Compute the render frames as specified by :attr: render_mode during the initialization of the environment. The environment's :attr: metadata render modes ( env.metadata[\"render_modes\"] ) should contain the possible ways to implement the render modes. In addition, list versions for most render modes is achieved through gymnasium.make which automatically applies a wrapper to collect rendered frames. Note: As the :attr: render_mode is known during __init__ , the objects used to render the environment state should be initialised in __init__ . By convention, if the :attr: render_mode is: None (default): no render is computed. \"human\": The environment is continuously rendered in the current display or terminal, usually for human consumption. This rendering should occur during :meth: step and :meth: render doesn't need to be called. Returns None . \"rgb_array\": Return a single frame representing the current state of the environment. A frame is a np.ndarray with shape (x, y, 3) representing RGB values for an x-by-y pixel image. \"ansi\": Return a strings ( str ) or StringIO.StringIO containing a terminal-style text representation for each time step. The text can include newlines and ANSI escape sequences (e.g. for colors). \"rgb_array_list\" and \"ansi_list\": List based version of render modes are possible (except Human) through the wrapper, :py:class: gymnasium.wrappers.RenderCollection that is automatically applied during gymnasium.make(..., render_mode=\"rgb_array_list\") . The frames collected are popped after :meth: render is called or :meth: reset . Note: Make sure that your class's :attr: metadata \"render_modes\" key includes the list of supported modes. .. versionchanged:: 0.25.0 The render function was changed to no longer accept parameters, rather these parameters should be specified in the environment initialised, i.e., ``gymnasium.make(\"CartPole-v1\", render_mode=\"human\")`` View Source def render ( self ) -> RenderFrame | list [ RenderFrame ] | None : \" \"\" Compute the render frames as specified by :attr:`render_mode` during the initialization of the environment. The environment's :attr:`metadata` render modes (`env.metadata[\" render_modes \"]`) should contain the possible ways to implement the render modes. In addition, list versions for most render modes is achieved through `gymnasium.make` which automatically applies a wrapper to collect rendered frames. Note: As the :attr:`render_mode` is known during ``__init__``, the objects used to render the environment state should be initialised in ``__init__``. By convention, if the :attr:`render_mode` is: - None (default): no render is computed. - \" human \": The environment is continuously rendered in the current display or terminal, usually for human consumption. This rendering should occur during :meth:`step` and :meth:`render` doesn't need to be called. Returns ``None``. - \" rgb_array \": Return a single frame representing the current state of the environment. A frame is a ``np.ndarray`` with shape ``(x, y, 3)`` representing RGB values for an x-by-y pixel image. - \" ansi \": Return a strings (``str``) or ``StringIO.StringIO`` containing a terminal-style text representation for each time step. The text can include newlines and ANSI escape sequences (e.g. for colors). - \" rgb_array_list \" and \" ansi_list \": List based version of render modes are possible (except Human) through the wrapper, :py:class:`gymnasium.wrappers.RenderCollection` that is automatically applied during ``gymnasium.make(..., render_mode=\" rgb_array_list \")``. The frames collected are popped after :meth:`render` is called or :meth:`reset`. Note: Make sure that your class's :attr:`metadata` ``\" render_modes \"`` key includes the list of supported modes. .. versionchanged:: 0.25.0 The render function was changed to no longer accept parameters, rather these parameters should be specified in the environment initialised, i.e., ``gymnasium.make(\" CartPole - v1 \", render_mode=\" human \")`` \"\" \" raise NotImplementedError","title":"render"},{"location":"reference/pyastrobee/core/environments/#reset_1","text":"def reset ( self , seed : Optional [ int ] = None , options : Optional [ dict [ str , Any ]] = None ) -> tuple [ ~ ObsType , dict [ str , typing . Any ]] Resets the environment to an initial internal state, returning an initial observation and info. This method generates a new starting state often with some randomness to ensure that the agent explores the state space and learns a generalised policy about the environment. This randomness can be controlled with the seed parameter otherwise if the environment already has a random number generator and :meth: reset is called with seed=None , the RNG is not reset. Therefore, :meth: reset should (in the typical use case) be called with a seed right after initialization and then never again. For Custom environments, the first line of :meth: reset should be super().reset(seed=seed) which implements the seeding correctly. .. versionchanged:: v0.25 The `` return_info `` parameter was removed and now info is expected to be returned . Parameters: Name Type Description Default seed optional int The seed that is used to initialize the environment's PRNG ( np_random ). If the environment does not already have a PRNG and seed=None (the default option) is passed, a seed will be chosen from some source of entropy (e.g. timestamp or /dev/urandom). However, if the environment already has a PRNG and seed=None is passed, the PRNG will not be reset. If you pass an integer, the PRNG will be reset even if it already exists. Usually, you want to pass an integer right after the environment has been initialized and then never again . Please refer to the minimal example above to see this paradigm in action. None options optional dict Additional information to specify how the environment is reset (optional, depending on the specific environment) None Returns: Type Description None observation (ObsType): Observation of the initial state. This will be an element of :attr: observation_space (typically a numpy array) and is analogous to the observation returned by :meth: step . info (dictionary): This dictionary contains auxiliary information complementing observation . It should be analogous to the info returned by :meth: step . View Source def reset ( self , seed : Optional [ int ] = None , options : Optional [ dict[str, Any ] ] = None ) -> tuple [ ObsType, dict[str, Any ] ]: # Implementation of Gym template method reset () : See Gym for full method docstring # Gym states this must be the first line of the reset () method super (). reset ( seed = seed ) return self . _get_obs (), self . _get_info () # Initial state observation","title":"reset"},{"location":"reference/pyastrobee/core/environments/#reset_bag_state","text":"def reset_bag_state ( self , state : tuple [ numpy . ndarray , ... ] ) -> None Resets the dynamics of the bag in the environment Parameters: Name Type Description Default state tuple[np.ndarray, ...] Dynamics info of the bag, containing: np.ndarray: Position, shape (3,) np.ndarray: Orientation (XYZW quaternion), shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) None View Source def reset_bag_state(self, state: tuple[np.ndarray, ...]) -> None: \"\"\"Resets the dynamics of the bag in the environment Args: state (tuple[np.ndarray, ...]): Dynamics info of the bag, containing: np.ndarray: Position, shape (3,) np.ndarray: Orientation (XYZW quaternion), shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) \"\"\" assert len(state) == 4 assert len(state[0]) == 3 assert len(state[1]) == 4 assert len(state[2]) == 3 assert len(state[3]) == 3 self.bag.reset_dynamics(*state)","title":"reset_bag_state"},{"location":"reference/pyastrobee/core/environments/#reset_robot_state","text":"def reset_robot_state ( self , state : tuple [ numpy . ndarray , ... ] ) -> None Fully resets the state of the Astrobee in the environment Parameters: Name Type Description Default state tuple[np.ndarray, ...] Full Astrobee state information containing: np.ndarray: Position, shape (3,) np.ndarray: Orientation (XYZW quaternion), shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) np.ndarray: Joint positions, shape (NUM_JOINTS,) np.ndarray: Joint velocities, shape (NUM_JOINTS,) None View Source def reset_robot_state(self, state: tuple[np.ndarray, ...]) -> None: \"\"\"Fully resets the state of the Astrobee in the environment Args: state (tuple[np.ndarray, ...]): Full Astrobee state information containing: np.ndarray: Position, shape (3,) np.ndarray: Orientation (XYZW quaternion), shape (4,) np.ndarray: Linear velocity, shape (3,) np.ndarray: Angular velocity, shape (3,) np.ndarray: Joint positions, shape (NUM_JOINTS,) np.ndarray: Joint velocities, shape (NUM_JOINTS,) \"\"\" assert len(state) == 6 assert len(state[0]) == 3 assert len(state[1]) == 4 assert len(state[2]) == 3 assert len(state[3]) == 3 assert len(state[4]) == Astrobee.NUM_JOINTS assert len(state[5]) == Astrobee.NUM_JOINTS self.robot.reset_full_state(*state)","title":"reset_robot_state"},{"location":"reference/pyastrobee/core/environments/#restore_state_1","text":"def restore_state ( self , filename : str ) -> None Restores the simulation to a saved state file Parameters: Name Type Description Default filename str Path to a .bullet saved state within the saved state directory None View Source def restore_state ( self , filename : str ) -> None : \"\"\"Restores the simulation to a saved state file Args: filename (str): Path to a .bullet saved state within the saved state directory \"\"\" filename = self . _check_state_file ( filename ) self . client . restoreState ( fileName = filename )","title":"restore_state"},{"location":"reference/pyastrobee/core/environments/#sample_trajectory","text":"def sample_trajectory ( self ) -> None Samples a trajectory about the nominal target. If the nominal_rollouts parameter is True for this environment, the final state of the trajectory will be exactly the nominal value (no noise added when sampling) This should just be called in the vectorized rollout environments (not the main environment) since the main environment will use the best trajectory from the rollout envs View Source def sample_trajectory(self) -> None: \"\"\"Samples a trajectory about the nominal target. - If the nominal_rollouts parameter is True for this environment, the final state of the trajectory will be exactly the nominal value (no noise added when sampling) - This should just be called in the vectorized rollout environments (not the main environment) since the main environment will use the best trajectory from the rollout envs \"\"\" if self.is_primary_simulation: raise ValueError( \"Trajectory sampling should only occur in one of parallel environments for evaluation purposes\" ) pos, orn, vel, omega = self.robot.dynamics_state # Time sampling parameters (TODO refine these, move them somewhere else) time_stdev = 1 # Note: ensure that this is a positive value post-sampling min_time = 1 n_timesteps = round(self.planning_duration / self.dt) # Nominal if self.flight_state == self.FlightStates.NOMINAL: end_state = ( [ self.target_pos, self.target_orn, self.target_vel, self.target_omega, self.target_accel, self.target_alpha, ] if self._nominal_rollouts else sample_state( self.target_pos, self.target_orn, self.target_vel, self.target_omega, self.last_accel_cmd, self.last_alpha_cmd, self.pos_stdev, self.orn_stdev, self.vel_stdev, self.ang_vel_stdev, self.accel_stdev, self.alpha_stdev, ) ) duration = self.target_duration elif self.flight_state == self.FlightStates.SLOWING: end_state = ( [ self.target_pos, self.target_orn, self.target_vel, self.target_omega, self.target_accel, self.target_alpha, ] if self._nominal_rollouts else sample_state( self.target_pos, self.target_orn, self.target_vel, self.target_omega, self.last_accel_cmd, self.last_alpha_cmd, self.pos_stdev / 3, self.orn_stdev / 3, self.vel_stdev / 3, self.ang_vel_stdev / 3, self.accel_stdev / 3, self.alpha_stdev / 3, ) ) duration = ( self.target_duration if self._nominal_rollouts else np.maximum( np.random.normal(self.target_duration, time_stdev), min_time ) ) elif self.flight_state == self.FlightStates.STOPPING: end_state = [ self.target_pos, self.target_orn, self.target_vel, self.target_omega, self.target_accel, self.target_alpha, ] duration = ( self.planning_duration if self._nominal_rollouts else np.maximum( np.random.normal(self.planning_duration, time_stdev), min_time ) ) else: raise AttributeError(\"Flight state not recognized\") traj = local_planner( pos, orn, vel, omega, self.last_accel_cmd, self.last_alpha_cmd, *end_state, duration, self.dt, ) if traj.num_timesteps == n_timesteps: self.traj_plan = traj else: # Traj is either too long or too short, so adjust it if traj.num_timesteps > n_timesteps: self.traj_plan = traj.get_segment(0, n_timesteps) else: # Less than # Create a trajectory at the stopped position for the remaining timesteps remaining_timesteps = n_timesteps - traj.num_timesteps stop_traj = Trajectory( traj.positions[-1] * np.ones((remaining_timesteps, 1)), traj.quaternions[-1] * np.ones((remaining_timesteps, 1)), np.zeros((remaining_timesteps, 3)), np.zeros((remaining_timesteps, 3)), np.zeros((remaining_timesteps, 3)), np.zeros((remaining_timesteps, 3)), np.arange(remaining_timesteps) * self.dt, ) self.traj_plan = concatenate_trajs(traj, stop_traj) self.sampled_end_state = ( self.traj_plan.positions[-1], self.traj_plan.quaternions[-1], self.traj_plan.linear_velocities[-1], self.traj_plan.angular_velocities[-1], )","title":"sample_trajectory"},{"location":"reference/pyastrobee/core/environments/#save_state_1","text":"def save_state ( self ) -> str Saves the current simulation state to disk Note: saved states are not currently overwritten (could lead to issues with parallel environments?). But, these can be cleared out at the end of the simulation period Returns: Type Description str Path to the saved state file View Source def save_state ( self ) -> str : # Ensure that any simulations strictly for evaluating rollouts cannot save their state if not self . is_primary_simulation : raise PermissionError ( \"Only the primary simulation can save the state\" ) return super (). save_state ()","title":"save_state"},{"location":"reference/pyastrobee/core/environments/#send_client_command_1","text":"def send_client_command ( self , * args , ** kwargs ) -> Any Send a command to the environment's pybullet client For instance, we can use pybullet.getBasePositionAndOrientation with this as send_client_command(\"getBasePositionAndOrientation\", body_id) Returns: Type Description Any The return from the Pybullet command View Source def send_client_command(self, *args, * *kwargs) -> Any: \"\"\"Send a command to the environment's pybullet client For instance, we can use pybullet.getBasePositionAndOrientation with this as send_client_command(\"getBasePositionAndOrientation\", body_id) Returns: Any: The return from the Pybullet command \"\"\" attr = getattr(self.client, args[0]) if isinstance(attr, Callable): return attr(*args[1:], **kwargs) return attr","title":"send_client_command"},{"location":"reference/pyastrobee/core/environments/#set_arm_traj","text":"def set_arm_traj ( self , traj : pyastrobee . trajectories . trajectory . ArmTrajectory ) View Source def set_arm_traj(self, traj: ArmTrajectory): # TODO IMPROVE THIS self.arm_traj_plan = traj","title":"set_arm_traj"},{"location":"reference/pyastrobee/core/environments/#set_flight_state","text":"def set_flight_state ( self , state : Union [ str , pyastrobee . core . environments . AstrobeeMPCEnv . FlightStates ] ) Set the current flight state: for instance, whether we are in nominal operating mode, stopping, ... Parameters: Name Type Description Default state Union[str, FlightStates] A flight state or its string representation (i.e. \"nominal\", \"stopping\", ...) None View Source def set_flight_state(self, state: Union[str, FlightStates]): \"\"\"Set the current flight state: for instance, whether we are in nominal operating mode, stopping, ... Args: state (Union[str, FlightStates]): A flight state or its string representation (i.e. \"nominal\", \"stopping\", ...) \"\"\" # TODO add check that it is valid # TODO should we store the state as the string or the Enum???? if isinstance(state, str): self.flight_state = self.FlightStates(state) elif isinstance(state, self.FlightStates): self.flight_state = state else: raise ValueError(\"Flight state not recognized\")","title":"set_flight_state"},{"location":"reference/pyastrobee/core/environments/#set_planning_duration","text":"def set_planning_duration ( self , duration ) View Source def set_planning_duration(self, duration): # TODO improve this self.planning_duration = duration","title":"set_planning_duration"},{"location":"reference/pyastrobee/core/environments/#set_target_state","text":"def set_target_state ( self , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], omega : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], accel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], alpha : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], duration : float ) -> None Set the target dynamics state for planning/sampling trajectories and determining penalties Parameters: Name Type Description Default pos npt.ArrayLike Desired position, shape (3,) None orn npt.ArrayLike Desired XYZW quaternion orientation, shape (4,) None vel npt.ArrayLike Desired linear velocity, shape (3,) None omega npt.ArrayLike Desired angular velocity, shape (3,) None accel npt.ArrayLike Desired linear acceleration, shape (3,) None alpha npt.ArrayLike Desired angular acceleration, shape (3,) None duration float Amount of time to pass before achieving this desired state None View Source def set_target_state ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , vel : npt . ArrayLike , omega : npt . ArrayLike , accel : npt . ArrayLike , alpha : npt . ArrayLike , duration : float , ) -> None : \"\"\"Set the target dynamics state for planning/sampling trajectories and determining penalties Args: pos (npt.ArrayLike): Desired position, shape (3,) orn (npt.ArrayLike): Desired XYZW quaternion orientation, shape (4,) vel (npt.ArrayLike): Desired linear velocity, shape (3,) omega (npt.ArrayLike): Desired angular velocity, shape (3,) accel (npt.ArrayLike): Desired linear acceleration, shape (3,) alpha (npt.ArrayLike): Desired angular acceleration, shape (3,) duration (float): Amount of time to pass before achieving this desired state \"\"\" self . target_pos = pos self . target_orn = orn self . target_vel = vel self . target_omega = omega self . target_accel = accel self . target_alpha = alpha self . target_duration = duration","title":"set_target_state"},{"location":"reference/pyastrobee/core/environments/#show_traj_plan","text":"def show_traj_plan ( self , n : Optional [ int ] ) -> None Displays the planned trajectory on the current pybullet client GUI (if enabled) Parameters: Name Type Description Default n Optional[int] Number of frames to plot, if plotting all of the frames is not desired. Defaults to None (plot all frames) None View Source def show_traj_plan ( self , n : Optional [ int ] ) -> None : \"\"\"Displays the planned trajectory on the current pybullet client GUI (if enabled) Args: n (Optional[int]): Number of frames to plot, if plotting all of the frames is not desired. Defaults to None (plot all frames) \"\"\" if self . traj_plan is None : raise ValueError ( \"No trajectory available to visualize\" ) self . debug_viz_ids = self . traj_plan . visualize ( n , client = self . client )","title":"show_traj_plan"},{"location":"reference/pyastrobee/core/environments/#step_1","text":"def step ( self , action : ~ ActType ) -> tuple [ ~ ObsType , float , bool , bool , dict [ str , typing . Any ]] Run one timestep of the environment's dynamics using the agent actions. When the end of an episode is reached ( terminated or truncated ), it is necessary to call :meth: reset to reset this environment's state for the next episode. .. versionchanged:: 0.26 The Step API was changed removing `` done `` in favor of `` terminated `` and `` truncated `` to make it clearer to users when the environment had terminated or truncated which is critical for reinforcement learning bootstrapping algorithms . Parameters: Name Type Description Default action ActType an action provided by the agent to update the environment state. None Returns: Type Description None observation (ObsType): An element of the environment's :attr: observation_space as the next observation due to the agent actions. An example is a numpy array containing the positions and velocities of the pole in CartPole. reward (SupportsFloat): The reward as a result of taking the action. terminated (bool): Whether the agent reaches the terminal state (as defined under the MDP of the task) which can be positive or negative. An example is reaching the goal state or moving into the lava from the Sutton and Barton, Gridworld. If true, the user needs to call :meth: reset . truncated (bool): Whether the truncation condition outside the scope of the MDP is satisfied. Typically, this is a timelimit, but could also be used to indicate an agent physically going out of bounds. Can be used to end the episode prematurely before a terminal state is reached. If true, the user needs to call :meth: reset . info (dict): Contains auxiliary diagnostic information (helpful for debugging, learning, and logging). This might, for instance, contain: metrics that describe the agent's performance state, variables that are hidden from observations, or individual reward terms that are combined to produce the total reward. In OpenAI Gym <v26, it contains \"TimeLimit.truncated\" to distinguish truncation and termination, however this is deprecated in favour of returning terminated and truncated variables. done (bool): (Deprecated) A boolean value for if the episode has ended, in which case further :meth: step calls will return undefined results. This was removed in OpenAI Gym v26 in favor of terminated and truncated attributes. A done signal may be emitted for different reasons: Maybe the task underlying the environment was solved successfully, a certain timelimit was exceeded, or the physics simulation has entered an invalid state. View Source def step( self, action: ActType ) -> tuple[ObsType, float, bool, bool, dict[str, Any]]: # Note: For MPC, this is less so a \"step\" than a \"rollout\" function. The trajectory should be sampled # before calling this function # TODO use the action parameter to pass in a trajectory to follow? terminated = False # init (If at the terminal state) truncated = False # init (If stopping the sim before the terminal state) if self.traj_plan is None: raise ValueError(\"Trajectory has not been planned\") # Follow the trajectory. NOTE: This is effectively the same as the follow_traj() function in the controller, # but accessing the loop directly allows us to do more with the data at each step # TODO decide how to handle the stopping criteria if not self.traj_plan.num_timesteps == self.arm_traj_plan.num_timesteps: raise ValueError(\"Mismatched time info between base and arm trajs\") # If this is the primary simulation, we just follow the best trajectory we have # Rewrd for the primary simulation doesn't mean anything, so no computation needed inertia_update_freq = 5 steps_per_inertia_update = round( 1 / (self.traj_plan.timestep * inertia_update_freq) ) if self.is_primary_simulation: for i in range(self.traj_plan.num_timesteps): pos, orn, lin_vel, ang_vel = self.controller.get_current_state() self.controller.step( pos, lin_vel, orn, ang_vel, self.traj_plan.positions[i, :], self.traj_plan.linear_velocities[i, :], self.traj_plan.linear_accels[i, :], self.traj_plan.quaternions[i, :], self.traj_plan.angular_velocities[i, :], self.traj_plan.angular_accels[i, :], ) self.robot.set_joint_angles( self.arm_traj_plan.angles[i, :], self.arm_traj_plan.joint_ids ) # TODO THIS KINDA SUCKS if i % steps_per_inertia_update == 0: T_R2W = self.robot.tmat T_B2W = self.bag.tmat T_B2R = invert_transform_mat(T_R2W) @ T_B2W p = T_B2R[:3, 3] self.controller.inertia = self.robot.inertia + self.bag.mass * ( np.dot(p, p) * np.eye(3) - np.outer(p, p) ) reward = 0 else: # We are in a rollout environment # So, follow the trajectory, but also keep track of a bunch of things so that we can compute the reward robot_safe_set_cost = 0 # init bag_safe_set_cost = 0 # init stabilization_cost = 0 tracking_cost = 0 bag_vel_cost = 0 steps_per_safe_set_eval = round( 1 / (self.traj_plan.timestep * self.safe_set_eval_freq) ) # TODO IMPROVE THIS # the thought here was that if we're stopping (or slowing) we care more about the overall positioning # rather than just staying in the middle of the modules safe_set_weight = ( 1 if self.flight_state == self.FlightStates.NOMINAL else 0.1 ) for i in range(self.traj_plan.num_timesteps): # Note: the traj log gets updated whenever we access the current state pos, orn, lin_vel, ang_vel = self.controller.get_current_state() self.controller.step( pos, lin_vel, orn, ang_vel, self.traj_plan.positions[i, :], self.traj_plan.linear_velocities[i, :], self.traj_plan.linear_accels[i, :], self.traj_plan.quaternions[i, :], self.traj_plan.angular_velocities[i, :], self.traj_plan.angular_accels[i, :], ) self.robot.set_joint_angles( self.arm_traj_plan.angles[i, :], self.arm_traj_plan.joint_ids ) # TODO THIS KINDA SUCKS if i % steps_per_inertia_update == 0: T_R2W = self.robot.tmat T_B2W = self.bag.tmat T_B2R = invert_transform_mat(T_R2W) @ T_B2W p = T_B2R[:3, 3] self.controller.inertia = self.robot.inertia + self.bag.mass * ( np.dot(p, p) * np.eye(3) - np.outer(p, p) ) # *** COST FUNCTION *** # Perform collision checking on every timestep robot_bb = self.robot.bounding_box bag_bb = self.bag.bounding_box robot_is_safe = check_box_containment(robot_bb, self.safe_set.values()) bag_is_safe = check_box_containment(bag_bb, self.safe_set.values()) # If either the robot or bag collided, stop the simulation and return an effectively infinite cost # (Very large but not infinity to maintain sorting order in the edge case that all rollouts collide) if not robot_is_safe: robot_safe_set_cost += 10000 truncated = True # break if not bag_is_safe: bag_safe_set_cost += 10000 truncated = True # break # These \"stay away from the walls\" costs are somewhat expensive to compute and don't necessarily need # to be done every timestep. TODO just use the local description of the safe set, not the full thing if i % steps_per_safe_set_eval == 0: robot_safe_set_cost += safe_set_weight * safe_set_cost( robot_bb[0], self.safe_set.values() ) robot_safe_set_cost += safe_set_weight * safe_set_cost( robot_bb[1], self.safe_set.values() ) bag_safe_set_cost += safe_set_weight * safe_set_cost( bag_bb[0], self.safe_set.values() ) bag_safe_set_cost += safe_set_weight * safe_set_cost( bag_bb[1], self.safe_set.values() ) bag_pos, bag_orn, bag_vel, bag_ang_vel = self.bag.dynamics_state # Penalizing bag velocities perpendicular to the robot's velocity at end of rollout if self.flight_state == self.FlightStates.NOMINAL: bag_vel_cost = 300 * ( np.linalg.norm(bag_vel) - np.dot(lin_vel / np.linalg.norm(lin_vel), bag_vel) ) # End-of-rollout additional cost function evaluations # 1) Stabilize the motion of the bag with respect to the robot # 2) Position the robot so it's stopped at the goal pose # Both of these are only relevant when we're at the end of the nominal trajectory # TODO tune all of the scaling factors on the costs if self.flight_state == self.FlightStates.STOPPING: angular_term = np.linalg.norm(ang_vel - bag_ang_vel) r_r2b = bag_pos - pos # Vector from robot to bag linear_term = np.linalg.norm( lin_vel - bag_vel + np.cross(ang_vel, r_r2b) ) stabilization_cost += 500 * (linear_term + angular_term) # TODO make this a separate function? # Adding back in a tracking cost component # If we are stopping then we know that the target state is the goal pos_error = np.linalg.norm(pos - self.target_pos) orn_error = quaternion_dist(orn, self.target_orn) vel_error = np.linalg.norm(lin_vel - self.target_vel) ang_vel_error = np.linalg.norm(ang_vel - self.target_omega) if self.is_debugging_simulation: print(\"Position error: \", pos_error) print(\"Orn error: \", orn_error) print(\"Vel error: \", vel_error) print(\"Ang vel error: \", ang_vel_error) tracking_cost += ( 200 * pos_error + 100 * orn_error + 200 * vel_error + 100 * ang_vel_error ) else: stabilization_cost = 0 tracking_cost = 0 if self.is_debugging_simulation: print(\"Robot safe set cost: \", robot_safe_set_cost) print(\"Bag safe set cost: \", bag_safe_set_cost) print(\"Stabilization cost: \", stabilization_cost) print(\"Tracking cost: \", tracking_cost) print(\"Bag velocity cost: \", bag_vel_cost) reward = -1 * ( robot_safe_set_cost + bag_safe_set_cost + stabilization_cost + tracking_cost + bag_vel_cost ) # Observe the robot/bag state in the main env, dummy value if in rollout env observation = self._get_obs() # Evaluate if we have stabilized the robot and the bag at the end of the trajectory # (main env only since that's what we care about and we don't want to waste compute) if ( self.flight_state == self.FlightStates.STOPPING and self.is_primary_simulation and robot_and_bag_termination_criteria( observation[0], observation[1], self.goal_pose ) ): terminated = True # TODO: If we change the observation function to return the state of the robot and the bag, # we can determine the \"terminated\" parameter! # But note that we should only really do the observation in the main env info = self._get_info() return observation, reward, terminated, truncated, info","title":"step"},{"location":"reference/pyastrobee/core/environments/#step_simulation_1","text":"def step_simulation ( self ) Single pybullet simulation step View Source def step_simulation(self): \"\"\"Single pybullet simulation step\"\"\" self.client.stepSimulation()","title":"step_simulation"},{"location":"reference/pyastrobee/core/environments/#unshow_traj_plan","text":"def unshow_traj_plan ( self ) -> None Removes a displayed trajectory from the pybullet client GUI View Source def unshow_traj_plan ( self ) -> None : \"\"\"Removes a displayed trajectory from the pybullet client GUI\"\"\" if len ( self . debug_viz_ids ) == 0 : return remove_debug_objects ( self . debug_viz_ids , self . client ) self . debug_viz_ids = ()","title":"unshow_traj_plan"},{"location":"reference/pyastrobee/core/hybrid_bag/","text":"Module pyastrobee.core.hybrid_bag Testing to see if we can attach a deformable handle to a rigid bag (work in progress) View Source \"\"\"Testing to see if we can attach a deformable handle to a rigid bag (work in progress) \"\"\" import time from typing import Optional import numpy as np import numpy.typing as npt from pybullet_utils.bullet_client import BulletClient from pyastrobee.utils.bullet_utils import ( initialize_pybullet , load_deformable_object , create_box , create_anchor , ) from pyastrobee.utils.mesh_utils import get_closest_mesh_vertex , get_mesh_data from pyastrobee.config.bag_properties import BOX_LENGTH , BOX_WIDTH , BOX_HEIGHT from pyastrobee.core.abstract_bag import CargoBag from pyastrobee.core.astrobee import Astrobee def main (): handle_corner_pos_local = [ # Outer corners ( 0.075 , 0.025 , 0 ), # ID 32 ( 0.075 , - 0.025 , 0 ), # ID 1 ( - 0.075 , 0.025 , 0 ), # ID 21 ( - 0.075 , - 0.025 , 0 ), # ID 19 # Inner corners ( 0.06138287 , 0.025 , 0 ), # ID 31 ( 0.06138287 , - 0.025 , 0 ), # ID 0 ( - 0.06138287 , 0.025 , 0 ), # ID 22 ( - 0.06138287 , - 0.025 , 0 ), # ID 20 ] client = initialize_pybullet () box = create_box ( ( 0 , 0 , - BOX_HEIGHT / 2 ), ( 0 , 0 , 0 , 1 ), 5 , ( BOX_LENGTH , BOX_WIDTH , BOX_HEIGHT ), True , client = client , ) handle = load_deformable_object ( \"pyastrobee/assets/meshes/handle_only.vtk\" , pos = ( 0 , 0 , 0 ), mass = 0.2 , client = client , ) n_verts , vert_positions = get_mesh_data ( handle , client = client ) ids = [] for i , pos in enumerate ( handle_corner_pos_local ): actual_pos , vert_id = get_closest_mesh_vertex ( pos , vert_positions ) print ( f \"Corner # { i } : ID = { vert_id } . Distance: { np . linalg . norm ( pos - actual_pos ) } \" ) ids . append ( vert_id ) anchor_ids = [] for id in ids : aid , _ = create_anchor ( handle , id , box , - 1 ) anchor_ids . append ( aid ) while True : client . stepSimulation () time . sleep ( 1 / 120 ) class HybridCargoBag ( CargoBag ): def __init__ ( self , bag_name : str , mass : float , pos : npt . ArrayLike , orn : npt . ArrayLike , client : Optional [ BulletClient ] = None , ): super () . __init__ ( bag_name , mass , pos , orn , client ) @property def pose ( self ) -> np . ndarray : # return super().pose pass @property def position ( self ) -> np . ndarray : # return super().position pass @property def orientation ( self ) -> np . ndarray : # return super().orientation pass @property def velocity ( self ) -> np . ndarray : # return super().velocity pass @property def angular_velocity ( self ) -> np . ndarray : # return super().angular_velocity pass @property def dynamics_state ( self ) -> tuple [ np . ndarray , np . ndarray , np . ndarray , np . ndarray ]: # return super().dynamics_state pass @property def corner_positions ( self ) -> list [ np . ndarray ]: # return super().corner_positions pass def _load ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , ) -> int : # return super()._load(pos, orn) pass def unload ( self ) -> None : # return super().unload() pass def _attach ( self , robot : Astrobee , handle_index : int ) -> None : # return super()._attach(robot, handle_index) pass def detach ( self ) -> None : # return super().detach() pass def detach_robot ( self , robot_id : int ) -> None : # return super().detach_robot(robot_id) pass def reset_dynamics ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , lin_vel : npt . ArrayLike , ang_vel : npt . ArrayLike , ) -> None : # return super().reset_dynamics(pos, orn, lin_vel, ang_vel) pass if __name__ == \"__main__\" : main () Variables BOX_HEIGHT BOX_LENGTH BOX_WIDTH Functions main def main ( ) View Source def main (): handle_corner_pos_local = [ # Outer corners ( 0.075 , 0.025 , 0 ), # ID 32 ( 0.075 , - 0.025 , 0 ), # ID 1 ( - 0.075 , 0.025 , 0 ), # ID 21 ( - 0.075 , - 0.025 , 0 ), # ID 19 # Inner corners ( 0.06138287 , 0.025 , 0 ), # ID 31 ( 0.06138287 , - 0.025 , 0 ), # ID 0 ( - 0.06138287 , 0.025 , 0 ), # ID 22 ( - 0.06138287 , - 0.025 , 0 ), # ID 20 ] client = initialize_pybullet () box = create_box ( ( 0 , 0 , - BOX_HEIGHT / 2 ), ( 0 , 0 , 0 , 1 ), 5 , ( BOX_LENGTH , BOX_WIDTH , BOX_HEIGHT ), True , client = client , ) handle = load_deformable_object ( \"pyastrobee/assets/meshes/handle_only.vtk\" , pos = ( 0 , 0 , 0 ), mass = 0.2 , client = client , ) n_verts , vert_positions = get_mesh_data ( handle , client = client ) ids = [] for i , pos in enumerate ( handle_corner_pos_local ): actual_pos , vert_id = get_closest_mesh_vertex ( pos , vert_positions ) print ( f \"Corner #{i}: ID = {vert_id}. Distance: {np.linalg.norm(pos - actual_pos)}\" ) ids . append ( vert_id ) anchor_ids = [] for id in ids : aid , _ = create_anchor ( handle , id , box , - 1 ) anchor_ids . append ( aid ) while True : client . stepSimulation () time . sleep ( 1 / 120 ) Classes HybridCargoBag class HybridCargoBag ( bag_name : str , mass : float , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) Base (abstract) cargo bag class See inherited cargo bags for full implementations (deformable bag, rigid bag, constraint bag, ...) Attributes Name Type Description Default bag_name str Type of cargo bag to load. Single handle: \"front_handle\", \"right_handle\", \"top_handle\". Dual handle: \"front_back_handle\", \"right_left_handle\", \"top_bottom_handle\" None mass float Mass of the cargo bag, in kg None pos npt.ArrayLike Initial XYZ position to load the bag None orn npt.ArrayLike Initial XYZW quaternion to load the bag None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None View Source class HybridCargoBag ( CargoBag ) : def __init__ ( self , bag_name : str , mass : float , pos : npt . ArrayLike , orn : npt . ArrayLike , client : Optional [ BulletClient ] = None , ) : super (). __init__ ( bag_name , mass , pos , orn , client ) @property def pose ( self ) -> np . ndarray : # return super (). pose pass @property def position ( self ) -> np . ndarray : # return super (). position pass @property def orientation ( self ) -> np . ndarray : # return super (). orientation pass @property def velocity ( self ) -> np . ndarray : # return super (). velocity pass @property def angular_velocity ( self ) -> np . ndarray : # return super (). angular_velocity pass @property def dynamics_state ( self ) -> tuple [ np.ndarray, np.ndarray, np.ndarray, np.ndarray ] : # return super (). dynamics_state pass @property def corner_positions ( self ) -> list [ np.ndarray ] : # return super (). corner_positions pass def _load ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , ) -> int : # return super (). _load ( pos , orn ) pass def unload ( self ) -> None : # return super (). unload () pass def _attach ( self , robot : Astrobee , handle_index : int ) -> None : # return super (). _attach ( robot , handle_index ) pass def detach ( self ) -> None : # return super (). detach () pass def detach_robot ( self , robot_id : int ) -> None : # return super (). detach_robot ( robot_id ) pass def reset_dynamics ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , lin_vel : npt . ArrayLike , ang_vel : npt . ArrayLike , ) -> None : # return super (). reset_dynamics ( pos , orn , lin_vel , ang_vel ) pass Ancestors (in MRO) pyastrobee.core.abstract_bag.CargoBag abc.ABC Class variables BAG_NAMES DUAL_HANDLE_BAGS HANDLE_TRANSFORMS HEIGHT LENGTH MESH_DIR SINGLE_HANDLE_BAGS URDF_DIR WIDTH Instance variables angular_velocity attached ID(s) of the robot (or robots) grasping the bag. Empty if no robots are attached bounding_box Current axis-aligned bounding box of the bag (or just the main compartment), shape (2, 3) corner_positions dynamics_state grasp_transforms Transformation matrices \"handle to bag\" representing the grasp locations on the handles to the bag COM In the case of a single-handled bag, this list will only have one entry mass Mass of the cargo bag name Type of cargo bag num_handles Number of handles on the cargo bag orientation pose position tmat Current transformation matrix for the cargo bag: (Bag to world) velocity Methods attach_to def attach_to ( self , robot_or_robots : Union [ pyastrobee . core . astrobee . Astrobee , list [ pyastrobee . core . astrobee . Astrobee ], tuple [ pyastrobee . core . astrobee . Astrobee ]], object_to_move : str = 'robot' ) -> None Attaches a robot (or multiple robots) to the handle(s) of the bag Parameters: Name Type Description Default robot_or_robots Union[Astrobee, list[Astrobee], tuple[Astrobee]] Robot(s) to attach to the bag None object_to_move str Either \"robot\" or \"bag\". This dictates what object will get its position reset in order to make the grasp connection. In general, it makes more sense to move the robot to the bag (default behavior) None Raises: Type Description ValueError For invalid inputs, or if the bag does not have enough handles for each robot NotImplementedError Multi-robot case with >2 robots View Source def attach_to ( self , robot_or_robots : Union [ Astrobee, list[Astrobee ] , tuple [ Astrobee ] ] , object_to_move : str = \"robot\" , ) -> None : \"\"\"Attaches a robot (or multiple robots) to the handle(s) of the bag Args: robot_or_robots (Union[Astrobee, list[Astrobee], tuple[Astrobee]]): Robot(s) to attach to the bag object_to_move (str, optional): Either \" robot \" or \" bag \". This dictates what object will get its position reset in order to make the grasp connection. In general, it makes more sense to move the robot to the bag (default behavior) Raises: ValueError: For invalid inputs, or if the bag does not have enough handles for each robot NotImplementedError: Multi-robot case with >2 robots \"\"\" # Handle inputs if isinstance ( robot_or_robots , Astrobee ) : # Single robot num_robots = 1 elif isinstance ( robot_or_robots , ( list , tuple )) : # Multi - robot if not all ( isinstance ( r , Astrobee ) for r in robot_or_robots ) : raise ValueError ( \"Non-Astrobee input detected\" ) num_robots = len ( robot_or_robots ) if self . num_handles < num_robots : raise ValueError ( f \"Bag does not have enough handles to support {num_robots} robots\" ) if num_robots == 1 : # Edge case : Unpack the list if only one robot robot_or_robots = robot_or_robots [ 0 ] else : raise ValueError ( \"Invalid input: Must provide either an Astrobee or a list of multiple Astrobees\" ) if object_to_move not in { \"robot\" , \"bag\" }: raise ValueError ( \"Invalid object to move: Must be either 'robot' or 'bag'.\" ) bag_to_world = pos_quat_to_tmat ( self . pose ) if num_robots == 1 : robot = robot_or_robots # Unpack list if object_to_move == \"robot\" : # Reset the position of the robot to interface with the handle handle_to_bag = self . grasp_transforms [ 0 ] handle_to_world = bag_to_world @ handle_to_bag handle_pose = tmat_to_pos_quat ( handle_to_world ) robot . reset_to_ee_pose ( handle_pose ) else : # Move the bag to the robot self . reset_to_handle_pose ( robot . ee_pose ) self . _attach ( robot , 0 ) elif num_robots == 2 : robot_1 , robot_2 = robot_or_robots # Unpack list if object_to_move == \"robot\" : # Reset the position of each robot to interface with the two handles handle_1_to_bag = self . grasp_transforms [ 0 ] handle_2_to_bag = self . grasp_transforms [ 1 ] handle_1_to_world = bag_to_world @ handle_1_to_bag handle_2_to_world = bag_to_world @ handle_2_to_bag robot_1 . reset_to_ee_pose ( tmat_to_pos_quat ( handle_1_to_world )) robot_2 . reset_to_ee_pose ( tmat_to_pos_quat ( handle_2_to_world )) self . _attach ( robot_1 , 0 ) self . _attach ( robot_2 , 1 ) else : # Move the bag while leaving the robots static raise NotImplementedError ( \"Attaching the bag to multiple robots requires moving at least 1 robot\" ) else : raise NotImplementedError ( \"The multi-robot case is only implemented for 2 Astrobees\" ) detach def detach ( self ) -> None Detach all connections to the bag View Source def detach ( self ) -> None : # return super (). detach () pass detach_robot def detach_robot ( self , robot_id : int ) -> None Detaches a specific robot from the bag Parameters: Name Type Description Default robot_id int Pybullet ID of the robot to detach None View Source def detach_robot ( self , robot_id : int ) -> None : # return super (). detach_robot ( robot_id ) pass reset_dynamics def reset_dynamics ( self , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], lin_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], ang_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> None Resets the pose and velocities of the bag Parameters: Name Type Description Default pos npt.ArrayLike Position, shape (3,) None orn npt.ArrayLike XYZW quaternion orientation, shape (4,) None lin_vel npt.ArrayLike Linear velocity, shape (3,) None ang_vel npt.ArrayLike Angular velocity, shape (3,) None View Source def reset_dynamics ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , lin_vel : npt . ArrayLike , ang_vel : npt . ArrayLike , ) -> None : # return super (). reset_dynamics ( pos , orn , lin_vel , ang_vel ) pass reset_to_handle_pose def reset_to_handle_pose ( self , handle_pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], handle_index : int = 0 ) -> None Resets the position of the bag so that the handle is positioned at a desired pose Parameters: Name Type Description Default handle_pose npt.ArrayLike Desired pose of the handle (\"handle-to-world\"), shape (7,) None handle_index int Index of the handle to align to the desired pose. Defaults to 0. 0 View Source def reset_to_handle_pose ( self , handle_pose : npt . ArrayLike , handle_index : int = 0 ) -> None : \"\"\"Resets the position of the bag so that the handle is positioned at a desired pose Args: handle_pose (npt.ArrayLike): Desired pose of the handle (\" handle - to - world \"), shape (7,) handle_index (int, optional): Index of the handle to align to the desired pose. Defaults to 0. \"\"\" handle_to_world = pos_quat_to_tmat ( handle_pose ) bag_to_handle = invert_transform_mat ( self . grasp_transforms [ handle_index ] ) bag_to_world = handle_to_world @ bag_to_handle bag_pose = tmat_to_pos_quat ( bag_to_world ) # This assumes that we want the bag to be stationary self . reset_dynamics ( bag_pose [ :3 ] , bag_pose [ 3: ] , np . zeros ( 3 ), np . zeros ( 3 )) unload def unload ( self ) -> None Removes the cargo bag from the simulation View Source def unload ( self ) -> None : # return super().unload() pass","title":"Hybrid Bag"},{"location":"reference/pyastrobee/core/hybrid_bag/#module-pyastrobeecorehybrid_bag","text":"Testing to see if we can attach a deformable handle to a rigid bag (work in progress) View Source \"\"\"Testing to see if we can attach a deformable handle to a rigid bag (work in progress) \"\"\" import time from typing import Optional import numpy as np import numpy.typing as npt from pybullet_utils.bullet_client import BulletClient from pyastrobee.utils.bullet_utils import ( initialize_pybullet , load_deformable_object , create_box , create_anchor , ) from pyastrobee.utils.mesh_utils import get_closest_mesh_vertex , get_mesh_data from pyastrobee.config.bag_properties import BOX_LENGTH , BOX_WIDTH , BOX_HEIGHT from pyastrobee.core.abstract_bag import CargoBag from pyastrobee.core.astrobee import Astrobee def main (): handle_corner_pos_local = [ # Outer corners ( 0.075 , 0.025 , 0 ), # ID 32 ( 0.075 , - 0.025 , 0 ), # ID 1 ( - 0.075 , 0.025 , 0 ), # ID 21 ( - 0.075 , - 0.025 , 0 ), # ID 19 # Inner corners ( 0.06138287 , 0.025 , 0 ), # ID 31 ( 0.06138287 , - 0.025 , 0 ), # ID 0 ( - 0.06138287 , 0.025 , 0 ), # ID 22 ( - 0.06138287 , - 0.025 , 0 ), # ID 20 ] client = initialize_pybullet () box = create_box ( ( 0 , 0 , - BOX_HEIGHT / 2 ), ( 0 , 0 , 0 , 1 ), 5 , ( BOX_LENGTH , BOX_WIDTH , BOX_HEIGHT ), True , client = client , ) handle = load_deformable_object ( \"pyastrobee/assets/meshes/handle_only.vtk\" , pos = ( 0 , 0 , 0 ), mass = 0.2 , client = client , ) n_verts , vert_positions = get_mesh_data ( handle , client = client ) ids = [] for i , pos in enumerate ( handle_corner_pos_local ): actual_pos , vert_id = get_closest_mesh_vertex ( pos , vert_positions ) print ( f \"Corner # { i } : ID = { vert_id } . Distance: { np . linalg . norm ( pos - actual_pos ) } \" ) ids . append ( vert_id ) anchor_ids = [] for id in ids : aid , _ = create_anchor ( handle , id , box , - 1 ) anchor_ids . append ( aid ) while True : client . stepSimulation () time . sleep ( 1 / 120 ) class HybridCargoBag ( CargoBag ): def __init__ ( self , bag_name : str , mass : float , pos : npt . ArrayLike , orn : npt . ArrayLike , client : Optional [ BulletClient ] = None , ): super () . __init__ ( bag_name , mass , pos , orn , client ) @property def pose ( self ) -> np . ndarray : # return super().pose pass @property def position ( self ) -> np . ndarray : # return super().position pass @property def orientation ( self ) -> np . ndarray : # return super().orientation pass @property def velocity ( self ) -> np . ndarray : # return super().velocity pass @property def angular_velocity ( self ) -> np . ndarray : # return super().angular_velocity pass @property def dynamics_state ( self ) -> tuple [ np . ndarray , np . ndarray , np . ndarray , np . ndarray ]: # return super().dynamics_state pass @property def corner_positions ( self ) -> list [ np . ndarray ]: # return super().corner_positions pass def _load ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , ) -> int : # return super()._load(pos, orn) pass def unload ( self ) -> None : # return super().unload() pass def _attach ( self , robot : Astrobee , handle_index : int ) -> None : # return super()._attach(robot, handle_index) pass def detach ( self ) -> None : # return super().detach() pass def detach_robot ( self , robot_id : int ) -> None : # return super().detach_robot(robot_id) pass def reset_dynamics ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , lin_vel : npt . ArrayLike , ang_vel : npt . ArrayLike , ) -> None : # return super().reset_dynamics(pos, orn, lin_vel, ang_vel) pass if __name__ == \"__main__\" : main ()","title":"Module pyastrobee.core.hybrid_bag"},{"location":"reference/pyastrobee/core/hybrid_bag/#variables","text":"BOX_HEIGHT BOX_LENGTH BOX_WIDTH","title":"Variables"},{"location":"reference/pyastrobee/core/hybrid_bag/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/core/hybrid_bag/#main","text":"def main ( ) View Source def main (): handle_corner_pos_local = [ # Outer corners ( 0.075 , 0.025 , 0 ), # ID 32 ( 0.075 , - 0.025 , 0 ), # ID 1 ( - 0.075 , 0.025 , 0 ), # ID 21 ( - 0.075 , - 0.025 , 0 ), # ID 19 # Inner corners ( 0.06138287 , 0.025 , 0 ), # ID 31 ( 0.06138287 , - 0.025 , 0 ), # ID 0 ( - 0.06138287 , 0.025 , 0 ), # ID 22 ( - 0.06138287 , - 0.025 , 0 ), # ID 20 ] client = initialize_pybullet () box = create_box ( ( 0 , 0 , - BOX_HEIGHT / 2 ), ( 0 , 0 , 0 , 1 ), 5 , ( BOX_LENGTH , BOX_WIDTH , BOX_HEIGHT ), True , client = client , ) handle = load_deformable_object ( \"pyastrobee/assets/meshes/handle_only.vtk\" , pos = ( 0 , 0 , 0 ), mass = 0.2 , client = client , ) n_verts , vert_positions = get_mesh_data ( handle , client = client ) ids = [] for i , pos in enumerate ( handle_corner_pos_local ): actual_pos , vert_id = get_closest_mesh_vertex ( pos , vert_positions ) print ( f \"Corner #{i}: ID = {vert_id}. Distance: {np.linalg.norm(pos - actual_pos)}\" ) ids . append ( vert_id ) anchor_ids = [] for id in ids : aid , _ = create_anchor ( handle , id , box , - 1 ) anchor_ids . append ( aid ) while True : client . stepSimulation () time . sleep ( 1 / 120 )","title":"main"},{"location":"reference/pyastrobee/core/hybrid_bag/#classes","text":"","title":"Classes"},{"location":"reference/pyastrobee/core/hybrid_bag/#hybridcargobag","text":"class HybridCargoBag ( bag_name : str , mass : float , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) Base (abstract) cargo bag class See inherited cargo bags for full implementations (deformable bag, rigid bag, constraint bag, ...)","title":"HybridCargoBag"},{"location":"reference/pyastrobee/core/hybrid_bag/#attributes","text":"Name Type Description Default bag_name str Type of cargo bag to load. Single handle: \"front_handle\", \"right_handle\", \"top_handle\". Dual handle: \"front_back_handle\", \"right_left_handle\", \"top_bottom_handle\" None mass float Mass of the cargo bag, in kg None pos npt.ArrayLike Initial XYZ position to load the bag None orn npt.ArrayLike Initial XYZW quaternion to load the bag None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None View Source class HybridCargoBag ( CargoBag ) : def __init__ ( self , bag_name : str , mass : float , pos : npt . ArrayLike , orn : npt . ArrayLike , client : Optional [ BulletClient ] = None , ) : super (). __init__ ( bag_name , mass , pos , orn , client ) @property def pose ( self ) -> np . ndarray : # return super (). pose pass @property def position ( self ) -> np . ndarray : # return super (). position pass @property def orientation ( self ) -> np . ndarray : # return super (). orientation pass @property def velocity ( self ) -> np . ndarray : # return super (). velocity pass @property def angular_velocity ( self ) -> np . ndarray : # return super (). angular_velocity pass @property def dynamics_state ( self ) -> tuple [ np.ndarray, np.ndarray, np.ndarray, np.ndarray ] : # return super (). dynamics_state pass @property def corner_positions ( self ) -> list [ np.ndarray ] : # return super (). corner_positions pass def _load ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , ) -> int : # return super (). _load ( pos , orn ) pass def unload ( self ) -> None : # return super (). unload () pass def _attach ( self , robot : Astrobee , handle_index : int ) -> None : # return super (). _attach ( robot , handle_index ) pass def detach ( self ) -> None : # return super (). detach () pass def detach_robot ( self , robot_id : int ) -> None : # return super (). detach_robot ( robot_id ) pass def reset_dynamics ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , lin_vel : npt . ArrayLike , ang_vel : npt . ArrayLike , ) -> None : # return super (). reset_dynamics ( pos , orn , lin_vel , ang_vel ) pass","title":"Attributes"},{"location":"reference/pyastrobee/core/hybrid_bag/#ancestors-in-mro","text":"pyastrobee.core.abstract_bag.CargoBag abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/pyastrobee/core/hybrid_bag/#class-variables","text":"BAG_NAMES DUAL_HANDLE_BAGS HANDLE_TRANSFORMS HEIGHT LENGTH MESH_DIR SINGLE_HANDLE_BAGS URDF_DIR WIDTH","title":"Class variables"},{"location":"reference/pyastrobee/core/hybrid_bag/#instance-variables","text":"angular_velocity attached ID(s) of the robot (or robots) grasping the bag. Empty if no robots are attached bounding_box Current axis-aligned bounding box of the bag (or just the main compartment), shape (2, 3) corner_positions dynamics_state grasp_transforms Transformation matrices \"handle to bag\" representing the grasp locations on the handles to the bag COM In the case of a single-handled bag, this list will only have one entry mass Mass of the cargo bag name Type of cargo bag num_handles Number of handles on the cargo bag orientation pose position tmat Current transformation matrix for the cargo bag: (Bag to world) velocity","title":"Instance variables"},{"location":"reference/pyastrobee/core/hybrid_bag/#methods","text":"","title":"Methods"},{"location":"reference/pyastrobee/core/hybrid_bag/#attach_to","text":"def attach_to ( self , robot_or_robots : Union [ pyastrobee . core . astrobee . Astrobee , list [ pyastrobee . core . astrobee . Astrobee ], tuple [ pyastrobee . core . astrobee . Astrobee ]], object_to_move : str = 'robot' ) -> None Attaches a robot (or multiple robots) to the handle(s) of the bag Parameters: Name Type Description Default robot_or_robots Union[Astrobee, list[Astrobee], tuple[Astrobee]] Robot(s) to attach to the bag None object_to_move str Either \"robot\" or \"bag\". This dictates what object will get its position reset in order to make the grasp connection. In general, it makes more sense to move the robot to the bag (default behavior) None Raises: Type Description ValueError For invalid inputs, or if the bag does not have enough handles for each robot NotImplementedError Multi-robot case with >2 robots View Source def attach_to ( self , robot_or_robots : Union [ Astrobee, list[Astrobee ] , tuple [ Astrobee ] ] , object_to_move : str = \"robot\" , ) -> None : \"\"\"Attaches a robot (or multiple robots) to the handle(s) of the bag Args: robot_or_robots (Union[Astrobee, list[Astrobee], tuple[Astrobee]]): Robot(s) to attach to the bag object_to_move (str, optional): Either \" robot \" or \" bag \". This dictates what object will get its position reset in order to make the grasp connection. In general, it makes more sense to move the robot to the bag (default behavior) Raises: ValueError: For invalid inputs, or if the bag does not have enough handles for each robot NotImplementedError: Multi-robot case with >2 robots \"\"\" # Handle inputs if isinstance ( robot_or_robots , Astrobee ) : # Single robot num_robots = 1 elif isinstance ( robot_or_robots , ( list , tuple )) : # Multi - robot if not all ( isinstance ( r , Astrobee ) for r in robot_or_robots ) : raise ValueError ( \"Non-Astrobee input detected\" ) num_robots = len ( robot_or_robots ) if self . num_handles < num_robots : raise ValueError ( f \"Bag does not have enough handles to support {num_robots} robots\" ) if num_robots == 1 : # Edge case : Unpack the list if only one robot robot_or_robots = robot_or_robots [ 0 ] else : raise ValueError ( \"Invalid input: Must provide either an Astrobee or a list of multiple Astrobees\" ) if object_to_move not in { \"robot\" , \"bag\" }: raise ValueError ( \"Invalid object to move: Must be either 'robot' or 'bag'.\" ) bag_to_world = pos_quat_to_tmat ( self . pose ) if num_robots == 1 : robot = robot_or_robots # Unpack list if object_to_move == \"robot\" : # Reset the position of the robot to interface with the handle handle_to_bag = self . grasp_transforms [ 0 ] handle_to_world = bag_to_world @ handle_to_bag handle_pose = tmat_to_pos_quat ( handle_to_world ) robot . reset_to_ee_pose ( handle_pose ) else : # Move the bag to the robot self . reset_to_handle_pose ( robot . ee_pose ) self . _attach ( robot , 0 ) elif num_robots == 2 : robot_1 , robot_2 = robot_or_robots # Unpack list if object_to_move == \"robot\" : # Reset the position of each robot to interface with the two handles handle_1_to_bag = self . grasp_transforms [ 0 ] handle_2_to_bag = self . grasp_transforms [ 1 ] handle_1_to_world = bag_to_world @ handle_1_to_bag handle_2_to_world = bag_to_world @ handle_2_to_bag robot_1 . reset_to_ee_pose ( tmat_to_pos_quat ( handle_1_to_world )) robot_2 . reset_to_ee_pose ( tmat_to_pos_quat ( handle_2_to_world )) self . _attach ( robot_1 , 0 ) self . _attach ( robot_2 , 1 ) else : # Move the bag while leaving the robots static raise NotImplementedError ( \"Attaching the bag to multiple robots requires moving at least 1 robot\" ) else : raise NotImplementedError ( \"The multi-robot case is only implemented for 2 Astrobees\" )","title":"attach_to"},{"location":"reference/pyastrobee/core/hybrid_bag/#detach","text":"def detach ( self ) -> None Detach all connections to the bag View Source def detach ( self ) -> None : # return super (). detach () pass","title":"detach"},{"location":"reference/pyastrobee/core/hybrid_bag/#detach_robot","text":"def detach_robot ( self , robot_id : int ) -> None Detaches a specific robot from the bag Parameters: Name Type Description Default robot_id int Pybullet ID of the robot to detach None View Source def detach_robot ( self , robot_id : int ) -> None : # return super (). detach_robot ( robot_id ) pass","title":"detach_robot"},{"location":"reference/pyastrobee/core/hybrid_bag/#reset_dynamics","text":"def reset_dynamics ( self , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], lin_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], ang_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> None Resets the pose and velocities of the bag Parameters: Name Type Description Default pos npt.ArrayLike Position, shape (3,) None orn npt.ArrayLike XYZW quaternion orientation, shape (4,) None lin_vel npt.ArrayLike Linear velocity, shape (3,) None ang_vel npt.ArrayLike Angular velocity, shape (3,) None View Source def reset_dynamics ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , lin_vel : npt . ArrayLike , ang_vel : npt . ArrayLike , ) -> None : # return super (). reset_dynamics ( pos , orn , lin_vel , ang_vel ) pass","title":"reset_dynamics"},{"location":"reference/pyastrobee/core/hybrid_bag/#reset_to_handle_pose","text":"def reset_to_handle_pose ( self , handle_pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], handle_index : int = 0 ) -> None Resets the position of the bag so that the handle is positioned at a desired pose Parameters: Name Type Description Default handle_pose npt.ArrayLike Desired pose of the handle (\"handle-to-world\"), shape (7,) None handle_index int Index of the handle to align to the desired pose. Defaults to 0. 0 View Source def reset_to_handle_pose ( self , handle_pose : npt . ArrayLike , handle_index : int = 0 ) -> None : \"\"\"Resets the position of the bag so that the handle is positioned at a desired pose Args: handle_pose (npt.ArrayLike): Desired pose of the handle (\" handle - to - world \"), shape (7,) handle_index (int, optional): Index of the handle to align to the desired pose. Defaults to 0. \"\"\" handle_to_world = pos_quat_to_tmat ( handle_pose ) bag_to_handle = invert_transform_mat ( self . grasp_transforms [ handle_index ] ) bag_to_world = handle_to_world @ bag_to_handle bag_pose = tmat_to_pos_quat ( bag_to_world ) # This assumes that we want the bag to be stationary self . reset_dynamics ( bag_pose [ :3 ] , bag_pose [ 3: ] , np . zeros ( 3 ), np . zeros ( 3 ))","title":"reset_to_handle_pose"},{"location":"reference/pyastrobee/core/hybrid_bag/#unload","text":"def unload ( self ) -> None Removes the cargo bag from the simulation View Source def unload ( self ) -> None : # return super().unload() pass","title":"unload"},{"location":"reference/pyastrobee/core/iss/","text":"Module pyastrobee.core.iss Functions related to loading the ISS modules into pybullet Notes: - If any of the ISS meshes are updated (such as a reorientation or repositioning in Blender), the default orientation should be changed in the loading functions - If the mesh directory gets changed, the hardcoded relative paths need to be updated View Source \"\"\"Functions related to loading the ISS modules into pybullet Notes: - If any of the ISS meshes are updated (such as a reorientation or repositioning in Blender), the default orientation should be changed in the loading functions - If the mesh directory gets changed, the hardcoded relative paths need to be updated \"\"\" import os from enum import Enum from typing import Optional import pybullet from pybullet_utils.bullet_client import BulletClient import numpy as np from pyastrobee.utils.bullet_utils import initialize_pybullet from pyastrobee.utils.errors import PybulletError from pyastrobee.utils.python_utils import print_green from pyastrobee.config.iss_safe_boxes import FULL_SAFE_SET , ROBOT_SAFE_SET from pyastrobee.config.iss_paths import GRAPH from pyastrobee.utils.boxes import visualize_3D_box class ISS : \"\"\"The ISS, as represented in the original NASA/astrobee repo Args: debug (bool, optional): Whether or not to visualize just the collision bodies. Defaults to False client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" class Modules ( Enum ): \"\"\"Enumerates the different ISS modules - The naming of these corresponds with NASA code and mesh filenames (typically lowercase) \"\"\" CUPOLA = 0 EU_LAB = 1 JPM = 2 NODE_1 = 3 NODE_2 = 4 NODE_3 = 5 US_LAB = 6 def __init__ ( self , debug : bool = False , client : Optional [ BulletClient ] = None ): self . debug = debug self . client : pybullet = pybullet if client is None else client # The meshes have a weird orientation so we need to use this orientation to rotate them to lay flat self . mesh_orn = ( np . sqrt ( 2 ) / 2 , 0 , 0 , np . sqrt ( 2 ) / 2 ) self . full_safe_set = FULL_SAFE_SET self . robot_safe_set = ROBOT_SAFE_SET self . graph = GRAPH # Precomputed self . _debug_box_ids = [] self . ids = [] for module in ISS . Modules : self . ids . append ( self . _load_module ( module )) print_green ( \"ISS is ready\" ) def show_safe_set ( self , for_robot : bool = False ) -> None : \"\"\"Visualizes the collision-free regions inside the ISS Args: for_robot (bool, optional): Whether to shrink the safe set to account for the collision radius of the Astrobee's body. Defaults to False (Show the full safe set) \"\"\" boxes = self . robot_safe_set if for_robot else self . full_safe_set for box in boxes . values (): self . _debug_box_ids . append ( visualize_3D_box ( box )) def hide_safe_set ( self ) -> None : \"\"\"Removes the visualization of the collision-free regions\"\"\" for box_id in self . _debug_box_ids : self . client . removeBody ( box_id ) self . _debug_box_ids = [] def _load_module ( self , module : Modules ) -> int : \"\"\"Loads a single ISS module. For example, US_LAB Args: module (Modules): The module to load. For example, Modules.CUPOLA / .EU_LAB / .JPM / ... Returns: int: The Pybullet ID for the multibody associated with the VHACD collision object \"\"\" # Locate the paths to all of the meshes for the module vhacd_path , part_paths = self . _find_mesh_files ( module ) # If we're debugging the collision info, just load the VHACD results as both the collision and visual if self . debug : visual_id = self . client . createVisualShape ( shapeType = pybullet . GEOM_MESH , fileName = vhacd_path , visualFrameOrientation = self . mesh_orn , ) collision_id = self . client . createCollisionShape ( shapeType = pybullet . GEOM_MESH , fileName = vhacd_path , collisionFrameOrientation = self . mesh_orn , ) rigid_id = self . client . createMultiBody ( baseMass = 0 , # Fixed position baseCollisionShapeIndex = collision_id , baseVisualShapeIndex = visual_id , baseInertialFrameOrientation = self . mesh_orn , ) return rigid_id # Load the module: # Each part of the module will load the visual for the associated body # If we're dealing with the first part, load the VHACD file as the collision body. # For the remaining parts, we won't provide any collision information ids = [] for i , path in enumerate ( part_paths ): # Every part will have an associated visual shape # When the path points to an OBJ, it will load colors via the associated MTL file in the same directory visual_id = self . client . createVisualShape ( shapeType = pybullet . GEOM_MESH , fileName = path , visualFrameOrientation = self . mesh_orn , ) if visual_id < 0 : raise PybulletError ( f \"Could not load the visual shape for { path } \" , visual_id ) if i == 0 : # Load the VHACD results as the collision info collision_id = self . client . createCollisionShape ( shapeType = pybullet . GEOM_MESH , fileName = vhacd_path , collisionFrameOrientation = self . mesh_orn , ) if collision_id < 0 : raise PybulletError ( f \"Could not load the collision shape for { path } \" , collision_id ) else : collision_id = - 1 # -1 means no collision bodies will be generated rigid_id = self . client . createMultiBody ( baseMass = 0 , # Fixed position baseCollisionShapeIndex = collision_id , baseVisualShapeIndex = visual_id , baseInertialFrameOrientation = self . mesh_orn , ) ids . append ( rigid_id ) return ids [ 0 ] # Just the ID for the VHACD object def _find_mesh_files ( self , module : Modules ) -> tuple [ str , list [ str ]]: \"\"\"Helper function to locate the paths to the ISS module meshes Args: module (ISSModule): The module to load. For example, ISSModule.CUPOLA / .EU_LAB / .JPM / ... Raises: ValueError: If an invalid ISS module name is provided NotADirectoryError: If the module's mesh directory cannot be found FileNotFoundError: If either the vhacd obj file or the obj2sdf objs cannot be found in the mesh directory Returns: tuple[str, list[str]]: str: The path to the VHACD collision mesh for the module list[str]: Paths to all of the decomposed visual meshes for the module \"\"\" # Extract the name from the enum module_name = module . name . lower () # Get the paths for all files in the directory (visual and collision) cwd = os . getcwd () directory = f \" { cwd } /pyastrobee/assets/meshes/iss/obj/ { module_name } \" if not os . path . exists ( directory ): raise NotADirectoryError ( f \" { directory } is not valid. \\n Check on the input, { module } , or current working directory, { cwd } \" ) part_paths = [] vhacd_path = \"\" for filename in os . listdir ( directory ): if filename == \"decomp.obj\" : vhacd_path = os . path . join ( directory , filename ) elif filename . startswith ( \"part\" ): part_paths . append ( os . path . join ( directory , filename )) else : continue if not vhacd_path : raise FileNotFoundError ( \"Could not find the VHACD OBJ file for collision info\" ) if not part_paths : raise FileNotFoundError ( \"Could not find the OBJ files for the ISS visual info\" ) return vhacd_path , part_paths def _main (): client = initialize_pybullet () iss = ISS ( debug = False , client = client ) iss . show_safe_set () input ( \"Press Enter to hide the safe set visualization\" ) iss . hide_safe_set () input ( \"Press Enter to exit\" ) client . disconnect () if __name__ == \"__main__\" : _main () Variables FULL_SAFE_SET GRAPH ROBOT_SAFE_SET Classes ISS class ISS ( debug : bool = False , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) The ISS, as represented in the original NASA/astrobee repo Attributes Name Type Description Default debug bool Whether or not to visualize just the collision bodies. Defaults to False None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None View Source class ISS : \"\"\"The ISS, as represented in the original NASA/astrobee repo Args: debug (bool, optional): Whether or not to visualize just the collision bodies. Defaults to False client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" class Modules ( Enum ): \"\"\"Enumerates the different ISS modules - The naming of these corresponds with NASA code and mesh filenames (typically lowercase) \"\"\" CUPOLA = 0 EU_LAB = 1 JPM = 2 NODE_1 = 3 NODE_2 = 4 NODE_3 = 5 US_LAB = 6 def __init__ ( self , debug : bool = False , client : Optional [ BulletClient ] = None ): self . debug = debug self . client : pybullet = pybullet if client is None else client # The meshes have a weird orientation so we need to use this orientation to rotate them to lay flat self . mesh_orn = ( np . sqrt ( 2 ) / 2 , 0 , 0 , np . sqrt ( 2 ) / 2 ) self . full_safe_set = FULL_SAFE_SET self . robot_safe_set = ROBOT_SAFE_SET self . graph = GRAPH # Precomputed self . _debug_box_ids = [] self . ids = [] for module in ISS . Modules : self . ids . append ( self . _load_module ( module )) print_green ( \"ISS is ready\" ) def show_safe_set ( self , for_robot : bool = False ) -> None : \"\"\"Visualizes the collision-free regions inside the ISS Args: for_robot (bool, optional): Whether to shrink the safe set to account for the collision radius of the Astrobee's body. Defaults to False (Show the full safe set) \"\"\" boxes = self . robot_safe_set if for_robot else self . full_safe_set for box in boxes . values (): self . _debug_box_ids . append ( visualize_3D_box ( box )) def hide_safe_set ( self ) -> None : \"\"\"Removes the visualization of the collision-free regions\"\"\" for box_id in self . _debug_box_ids : self . client . removeBody ( box_id ) self . _debug_box_ids = [] def _load_module ( self , module : Modules ) -> int : \"\"\"Loads a single ISS module. For example, US_LAB Args: module (Modules): The module to load. For example, Modules.CUPOLA / .EU_LAB / .JPM / ... Returns: int: The Pybullet ID for the multibody associated with the VHACD collision object \"\"\" # Locate the paths to all of the meshes for the module vhacd_path , part_paths = self . _find_mesh_files ( module ) # If we're debugging the collision info, just load the VHACD results as both the collision and visual if self . debug : visual_id = self . client . createVisualShape ( shapeType = pybullet . GEOM_MESH , fileName = vhacd_path , visualFrameOrientation = self . mesh_orn , ) collision_id = self . client . createCollisionShape ( shapeType = pybullet . GEOM_MESH , fileName = vhacd_path , collisionFrameOrientation = self . mesh_orn , ) rigid_id = self . client . createMultiBody ( baseMass = 0 , # Fixed position baseCollisionShapeIndex = collision_id , baseVisualShapeIndex = visual_id , baseInertialFrameOrientation = self . mesh_orn , ) return rigid_id # Load the module: # Each part of the module will load the visual for the associated body # If we're dealing with the first part, load the VHACD file as the collision body. # For the remaining parts, we won't provide any collision information ids = [] for i , path in enumerate ( part_paths ): # Every part will have an associated visual shape # When the path points to an OBJ, it will load colors via the associated MTL file in the same directory visual_id = self . client . createVisualShape ( shapeType = pybullet . GEOM_MESH , fileName = path , visualFrameOrientation = self . mesh_orn , ) if visual_id < 0 : raise PybulletError ( f \"Could not load the visual shape for {path}\" , visual_id ) if i == 0 : # Load the VHACD results as the collision info collision_id = self . client . createCollisionShape ( shapeType = pybullet . GEOM_MESH , fileName = vhacd_path , collisionFrameOrientation = self . mesh_orn , ) if collision_id < 0 : raise PybulletError ( f \"Could not load the collision shape for {path}\" , collision_id ) else : collision_id = - 1 # -1 means no collision bodies will be generated rigid_id = self . client . createMultiBody ( baseMass = 0 , # Fixed position baseCollisionShapeIndex = collision_id , baseVisualShapeIndex = visual_id , baseInertialFrameOrientation = self . mesh_orn , ) ids . append ( rigid_id ) return ids [ 0 ] # Just the ID for the VHACD object def _find_mesh_files ( self , module : Modules ) -> tuple [ str , list [ str ]]: \"\"\"Helper function to locate the paths to the ISS module meshes Args: module (ISSModule): The module to load. For example, ISSModule.CUPOLA / .EU_LAB / .JPM / ... Raises: ValueError: If an invalid ISS module name is provided NotADirectoryError: If the module's mesh directory cannot be found FileNotFoundError: If either the vhacd obj file or the obj2sdf objs cannot be found in the mesh directory Returns: tuple[str, list[str]]: str: The path to the VHACD collision mesh for the module list[str]: Paths to all of the decomposed visual meshes for the module \"\"\" # Extract the name from the enum module_name = module . name . lower () # Get the paths for all files in the directory (visual and collision) cwd = os . getcwd () directory = f \"{cwd}/pyastrobee/assets/meshes/iss/obj/{module_name}\" if not os . path . exists ( directory ): raise NotADirectoryError ( f \"{directory} is not valid. \\n Check on the input, {module}, or current working directory, {cwd}\" ) part_paths = [] vhacd_path = \"\" for filename in os . listdir ( directory ): if filename == \"decomp.obj\" : vhacd_path = os . path . join ( directory , filename ) elif filename . startswith ( \"part\" ): part_paths . append ( os . path . join ( directory , filename )) else : continue if not vhacd_path : raise FileNotFoundError ( \"Could not find the VHACD OBJ file for collision info\" ) if not part_paths : raise FileNotFoundError ( \"Could not find the OBJ files for the ISS visual info\" ) return vhacd_path , part_paths Class variables Modules Methods hide_safe_set def hide_safe_set ( self ) -> None Removes the visualization of the collision-free regions View Source def hide_safe_set ( self ) -> None: \"\"\"Removes the visualization of the collision-free regions\"\"\" for box_id in self . _debug_box_ids: self . client . removeBody ( box_id ) self . _debug_box_ids = [] show_safe_set def show_safe_set ( self , for_robot : bool = False ) -> None Visualizes the collision-free regions inside the ISS Parameters: Name Type Description Default for_robot bool Whether to shrink the safe set to account for the collision radius of the Astrobee's body. Defaults to False (Show the full safe set) None View Source def show_safe_set ( self , for_robot: bool = False ) -> None: \"\"\"Visualizes the collision-free regions inside the ISS Args: for_robot ( bool , optional ) : Whether to shrink the safe set to account for the collision radius of the Astrobee ' s body . Defaults to False ( Show the full safe set ) \"\"\" boxes = self . robot_safe_set if for_robot else self . full_safe_set for box in boxes . values () : self . _debug_box_ids . append ( visualize_3D_box ( box ))","title":"Iss"},{"location":"reference/pyastrobee/core/iss/#module-pyastrobeecoreiss","text":"Functions related to loading the ISS modules into pybullet Notes: - If any of the ISS meshes are updated (such as a reorientation or repositioning in Blender), the default orientation should be changed in the loading functions - If the mesh directory gets changed, the hardcoded relative paths need to be updated View Source \"\"\"Functions related to loading the ISS modules into pybullet Notes: - If any of the ISS meshes are updated (such as a reorientation or repositioning in Blender), the default orientation should be changed in the loading functions - If the mesh directory gets changed, the hardcoded relative paths need to be updated \"\"\" import os from enum import Enum from typing import Optional import pybullet from pybullet_utils.bullet_client import BulletClient import numpy as np from pyastrobee.utils.bullet_utils import initialize_pybullet from pyastrobee.utils.errors import PybulletError from pyastrobee.utils.python_utils import print_green from pyastrobee.config.iss_safe_boxes import FULL_SAFE_SET , ROBOT_SAFE_SET from pyastrobee.config.iss_paths import GRAPH from pyastrobee.utils.boxes import visualize_3D_box class ISS : \"\"\"The ISS, as represented in the original NASA/astrobee repo Args: debug (bool, optional): Whether or not to visualize just the collision bodies. Defaults to False client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" class Modules ( Enum ): \"\"\"Enumerates the different ISS modules - The naming of these corresponds with NASA code and mesh filenames (typically lowercase) \"\"\" CUPOLA = 0 EU_LAB = 1 JPM = 2 NODE_1 = 3 NODE_2 = 4 NODE_3 = 5 US_LAB = 6 def __init__ ( self , debug : bool = False , client : Optional [ BulletClient ] = None ): self . debug = debug self . client : pybullet = pybullet if client is None else client # The meshes have a weird orientation so we need to use this orientation to rotate them to lay flat self . mesh_orn = ( np . sqrt ( 2 ) / 2 , 0 , 0 , np . sqrt ( 2 ) / 2 ) self . full_safe_set = FULL_SAFE_SET self . robot_safe_set = ROBOT_SAFE_SET self . graph = GRAPH # Precomputed self . _debug_box_ids = [] self . ids = [] for module in ISS . Modules : self . ids . append ( self . _load_module ( module )) print_green ( \"ISS is ready\" ) def show_safe_set ( self , for_robot : bool = False ) -> None : \"\"\"Visualizes the collision-free regions inside the ISS Args: for_robot (bool, optional): Whether to shrink the safe set to account for the collision radius of the Astrobee's body. Defaults to False (Show the full safe set) \"\"\" boxes = self . robot_safe_set if for_robot else self . full_safe_set for box in boxes . values (): self . _debug_box_ids . append ( visualize_3D_box ( box )) def hide_safe_set ( self ) -> None : \"\"\"Removes the visualization of the collision-free regions\"\"\" for box_id in self . _debug_box_ids : self . client . removeBody ( box_id ) self . _debug_box_ids = [] def _load_module ( self , module : Modules ) -> int : \"\"\"Loads a single ISS module. For example, US_LAB Args: module (Modules): The module to load. For example, Modules.CUPOLA / .EU_LAB / .JPM / ... Returns: int: The Pybullet ID for the multibody associated with the VHACD collision object \"\"\" # Locate the paths to all of the meshes for the module vhacd_path , part_paths = self . _find_mesh_files ( module ) # If we're debugging the collision info, just load the VHACD results as both the collision and visual if self . debug : visual_id = self . client . createVisualShape ( shapeType = pybullet . GEOM_MESH , fileName = vhacd_path , visualFrameOrientation = self . mesh_orn , ) collision_id = self . client . createCollisionShape ( shapeType = pybullet . GEOM_MESH , fileName = vhacd_path , collisionFrameOrientation = self . mesh_orn , ) rigid_id = self . client . createMultiBody ( baseMass = 0 , # Fixed position baseCollisionShapeIndex = collision_id , baseVisualShapeIndex = visual_id , baseInertialFrameOrientation = self . mesh_orn , ) return rigid_id # Load the module: # Each part of the module will load the visual for the associated body # If we're dealing with the first part, load the VHACD file as the collision body. # For the remaining parts, we won't provide any collision information ids = [] for i , path in enumerate ( part_paths ): # Every part will have an associated visual shape # When the path points to an OBJ, it will load colors via the associated MTL file in the same directory visual_id = self . client . createVisualShape ( shapeType = pybullet . GEOM_MESH , fileName = path , visualFrameOrientation = self . mesh_orn , ) if visual_id < 0 : raise PybulletError ( f \"Could not load the visual shape for { path } \" , visual_id ) if i == 0 : # Load the VHACD results as the collision info collision_id = self . client . createCollisionShape ( shapeType = pybullet . GEOM_MESH , fileName = vhacd_path , collisionFrameOrientation = self . mesh_orn , ) if collision_id < 0 : raise PybulletError ( f \"Could not load the collision shape for { path } \" , collision_id ) else : collision_id = - 1 # -1 means no collision bodies will be generated rigid_id = self . client . createMultiBody ( baseMass = 0 , # Fixed position baseCollisionShapeIndex = collision_id , baseVisualShapeIndex = visual_id , baseInertialFrameOrientation = self . mesh_orn , ) ids . append ( rigid_id ) return ids [ 0 ] # Just the ID for the VHACD object def _find_mesh_files ( self , module : Modules ) -> tuple [ str , list [ str ]]: \"\"\"Helper function to locate the paths to the ISS module meshes Args: module (ISSModule): The module to load. For example, ISSModule.CUPOLA / .EU_LAB / .JPM / ... Raises: ValueError: If an invalid ISS module name is provided NotADirectoryError: If the module's mesh directory cannot be found FileNotFoundError: If either the vhacd obj file or the obj2sdf objs cannot be found in the mesh directory Returns: tuple[str, list[str]]: str: The path to the VHACD collision mesh for the module list[str]: Paths to all of the decomposed visual meshes for the module \"\"\" # Extract the name from the enum module_name = module . name . lower () # Get the paths for all files in the directory (visual and collision) cwd = os . getcwd () directory = f \" { cwd } /pyastrobee/assets/meshes/iss/obj/ { module_name } \" if not os . path . exists ( directory ): raise NotADirectoryError ( f \" { directory } is not valid. \\n Check on the input, { module } , or current working directory, { cwd } \" ) part_paths = [] vhacd_path = \"\" for filename in os . listdir ( directory ): if filename == \"decomp.obj\" : vhacd_path = os . path . join ( directory , filename ) elif filename . startswith ( \"part\" ): part_paths . append ( os . path . join ( directory , filename )) else : continue if not vhacd_path : raise FileNotFoundError ( \"Could not find the VHACD OBJ file for collision info\" ) if not part_paths : raise FileNotFoundError ( \"Could not find the OBJ files for the ISS visual info\" ) return vhacd_path , part_paths def _main (): client = initialize_pybullet () iss = ISS ( debug = False , client = client ) iss . show_safe_set () input ( \"Press Enter to hide the safe set visualization\" ) iss . hide_safe_set () input ( \"Press Enter to exit\" ) client . disconnect () if __name__ == \"__main__\" : _main ()","title":"Module pyastrobee.core.iss"},{"location":"reference/pyastrobee/core/iss/#variables","text":"FULL_SAFE_SET GRAPH ROBOT_SAFE_SET","title":"Variables"},{"location":"reference/pyastrobee/core/iss/#classes","text":"","title":"Classes"},{"location":"reference/pyastrobee/core/iss/#iss","text":"class ISS ( debug : bool = False , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) The ISS, as represented in the original NASA/astrobee repo","title":"ISS"},{"location":"reference/pyastrobee/core/iss/#attributes","text":"Name Type Description Default debug bool Whether or not to visualize just the collision bodies. Defaults to False None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None View Source class ISS : \"\"\"The ISS, as represented in the original NASA/astrobee repo Args: debug (bool, optional): Whether or not to visualize just the collision bodies. Defaults to False client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" class Modules ( Enum ): \"\"\"Enumerates the different ISS modules - The naming of these corresponds with NASA code and mesh filenames (typically lowercase) \"\"\" CUPOLA = 0 EU_LAB = 1 JPM = 2 NODE_1 = 3 NODE_2 = 4 NODE_3 = 5 US_LAB = 6 def __init__ ( self , debug : bool = False , client : Optional [ BulletClient ] = None ): self . debug = debug self . client : pybullet = pybullet if client is None else client # The meshes have a weird orientation so we need to use this orientation to rotate them to lay flat self . mesh_orn = ( np . sqrt ( 2 ) / 2 , 0 , 0 , np . sqrt ( 2 ) / 2 ) self . full_safe_set = FULL_SAFE_SET self . robot_safe_set = ROBOT_SAFE_SET self . graph = GRAPH # Precomputed self . _debug_box_ids = [] self . ids = [] for module in ISS . Modules : self . ids . append ( self . _load_module ( module )) print_green ( \"ISS is ready\" ) def show_safe_set ( self , for_robot : bool = False ) -> None : \"\"\"Visualizes the collision-free regions inside the ISS Args: for_robot (bool, optional): Whether to shrink the safe set to account for the collision radius of the Astrobee's body. Defaults to False (Show the full safe set) \"\"\" boxes = self . robot_safe_set if for_robot else self . full_safe_set for box in boxes . values (): self . _debug_box_ids . append ( visualize_3D_box ( box )) def hide_safe_set ( self ) -> None : \"\"\"Removes the visualization of the collision-free regions\"\"\" for box_id in self . _debug_box_ids : self . client . removeBody ( box_id ) self . _debug_box_ids = [] def _load_module ( self , module : Modules ) -> int : \"\"\"Loads a single ISS module. For example, US_LAB Args: module (Modules): The module to load. For example, Modules.CUPOLA / .EU_LAB / .JPM / ... Returns: int: The Pybullet ID for the multibody associated with the VHACD collision object \"\"\" # Locate the paths to all of the meshes for the module vhacd_path , part_paths = self . _find_mesh_files ( module ) # If we're debugging the collision info, just load the VHACD results as both the collision and visual if self . debug : visual_id = self . client . createVisualShape ( shapeType = pybullet . GEOM_MESH , fileName = vhacd_path , visualFrameOrientation = self . mesh_orn , ) collision_id = self . client . createCollisionShape ( shapeType = pybullet . GEOM_MESH , fileName = vhacd_path , collisionFrameOrientation = self . mesh_orn , ) rigid_id = self . client . createMultiBody ( baseMass = 0 , # Fixed position baseCollisionShapeIndex = collision_id , baseVisualShapeIndex = visual_id , baseInertialFrameOrientation = self . mesh_orn , ) return rigid_id # Load the module: # Each part of the module will load the visual for the associated body # If we're dealing with the first part, load the VHACD file as the collision body. # For the remaining parts, we won't provide any collision information ids = [] for i , path in enumerate ( part_paths ): # Every part will have an associated visual shape # When the path points to an OBJ, it will load colors via the associated MTL file in the same directory visual_id = self . client . createVisualShape ( shapeType = pybullet . GEOM_MESH , fileName = path , visualFrameOrientation = self . mesh_orn , ) if visual_id < 0 : raise PybulletError ( f \"Could not load the visual shape for {path}\" , visual_id ) if i == 0 : # Load the VHACD results as the collision info collision_id = self . client . createCollisionShape ( shapeType = pybullet . GEOM_MESH , fileName = vhacd_path , collisionFrameOrientation = self . mesh_orn , ) if collision_id < 0 : raise PybulletError ( f \"Could not load the collision shape for {path}\" , collision_id ) else : collision_id = - 1 # -1 means no collision bodies will be generated rigid_id = self . client . createMultiBody ( baseMass = 0 , # Fixed position baseCollisionShapeIndex = collision_id , baseVisualShapeIndex = visual_id , baseInertialFrameOrientation = self . mesh_orn , ) ids . append ( rigid_id ) return ids [ 0 ] # Just the ID for the VHACD object def _find_mesh_files ( self , module : Modules ) -> tuple [ str , list [ str ]]: \"\"\"Helper function to locate the paths to the ISS module meshes Args: module (ISSModule): The module to load. For example, ISSModule.CUPOLA / .EU_LAB / .JPM / ... Raises: ValueError: If an invalid ISS module name is provided NotADirectoryError: If the module's mesh directory cannot be found FileNotFoundError: If either the vhacd obj file or the obj2sdf objs cannot be found in the mesh directory Returns: tuple[str, list[str]]: str: The path to the VHACD collision mesh for the module list[str]: Paths to all of the decomposed visual meshes for the module \"\"\" # Extract the name from the enum module_name = module . name . lower () # Get the paths for all files in the directory (visual and collision) cwd = os . getcwd () directory = f \"{cwd}/pyastrobee/assets/meshes/iss/obj/{module_name}\" if not os . path . exists ( directory ): raise NotADirectoryError ( f \"{directory} is not valid. \\n Check on the input, {module}, or current working directory, {cwd}\" ) part_paths = [] vhacd_path = \"\" for filename in os . listdir ( directory ): if filename == \"decomp.obj\" : vhacd_path = os . path . join ( directory , filename ) elif filename . startswith ( \"part\" ): part_paths . append ( os . path . join ( directory , filename )) else : continue if not vhacd_path : raise FileNotFoundError ( \"Could not find the VHACD OBJ file for collision info\" ) if not part_paths : raise FileNotFoundError ( \"Could not find the OBJ files for the ISS visual info\" ) return vhacd_path , part_paths","title":"Attributes"},{"location":"reference/pyastrobee/core/iss/#class-variables","text":"Modules","title":"Class variables"},{"location":"reference/pyastrobee/core/iss/#methods","text":"","title":"Methods"},{"location":"reference/pyastrobee/core/iss/#hide_safe_set","text":"def hide_safe_set ( self ) -> None Removes the visualization of the collision-free regions View Source def hide_safe_set ( self ) -> None: \"\"\"Removes the visualization of the collision-free regions\"\"\" for box_id in self . _debug_box_ids: self . client . removeBody ( box_id ) self . _debug_box_ids = []","title":"hide_safe_set"},{"location":"reference/pyastrobee/core/iss/#show_safe_set","text":"def show_safe_set ( self , for_robot : bool = False ) -> None Visualizes the collision-free regions inside the ISS Parameters: Name Type Description Default for_robot bool Whether to shrink the safe set to account for the collision radius of the Astrobee's body. Defaults to False (Show the full safe set) None View Source def show_safe_set ( self , for_robot: bool = False ) -> None: \"\"\"Visualizes the collision-free regions inside the ISS Args: for_robot ( bool , optional ) : Whether to shrink the safe set to account for the collision radius of the Astrobee ' s body . Defaults to False ( Show the full safe set ) \"\"\" boxes = self . robot_safe_set if for_robot else self . full_safe_set for box in boxes . values () : self . _debug_box_ids . append ( visualize_3D_box ( box ))","title":"show_safe_set"},{"location":"reference/pyastrobee/core/rigid_bag/","text":"Module pyastrobee.core.rigid_bag Rigid version of the cargo bag, using joints in the URDF to mimic what we would see from a deformable Documentation for inherited methods can be found in the base class View Source \"\"\"Rigid version of the cargo bag, using joints in the URDF to mimic what we would see from a deformable Documentation for inherited methods can be found in the base class \"\"\" # TODO tune the position control force on the handle import time from typing import Optional import pybullet from pybullet_utils.bullet_client import BulletClient import numpy as np import numpy.typing as npt from pyastrobee.core.astrobee import Astrobee from pyastrobee.core.abstract_bag import CargoBag from pyastrobee.utils.bullet_utils import initialize_pybullet from pyastrobee.utils.python_utils import print_green from pyastrobee.utils.transformations import make_transform_mat from pyastrobee.utils.rotations import quat_to_rmat from pyastrobee.utils.dynamics import box_inertia class RigidCargoBag ( CargoBag ): \"\"\"Class for loading and managing properties associated with the rigid URDF-based cargo bags Args: bag_name (str): Type of cargo bag to load. Single handle: \"front_handle\", \"right_handle\", \"top_handle\". Dual handle: \"front_back_handle\", \"right_left_handle\", \"top_bottom_handle\" mass (float): Mass of the cargo bag, in kg pos (npt.ArrayLike, optional): Initial XYZ position to load the bag. Defaults to (0, 0, 0) orn (npt.ArrayLike, optional): Initial XYZW quaternion to load the bag. Defaults to (0, 0, 0, 1) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" LINKS_PER_HANDLE = 4 # 3 dummy links for roll/pitch/yaw, plus the handle itself _urdfs = [ CargoBag . URDF_DIR + name + \"_rigid_bag.urdf\" for name in CargoBag . BAG_NAMES ] URDFS = dict ( zip ( CargoBag . BAG_NAMES , _urdfs )) def __init__ ( self , bag_name : str , mass : float , pos : npt . ArrayLike = ( 0 , 0 , 0 ), orn : npt . ArrayLike = ( 0 , 0 , 0 , 1 ), client : Optional [ BulletClient ] = None , ): # This inertia is slightly approximate because some mass is in the handle and dummy links self . inertia = box_inertia ( mass , self . LENGTH , self . WIDTH , self . HEIGHT ) # Initializations self . _name = bag_name # HACK (this gets set in super.init but we need to know it before calling that) self . _constraints = {} # Add position control to the handle(s) so its springs back into its natural position # to provide some resistance to motion like we would see in a deformable # The dummy joints are the joints associated with the motion of the handle if self . num_handles == 1 : self . num_joints = 4 # 3 for rpy, 1 for handle self . num_links = 5 # Base, 3 dummies for rpy, handle dummy_joint_ids = [ 0 , 1 , 2 ] elif self . num_handles == 2 : self . num_joints = 8 self . num_links = 9 dummy_joint_ids = [ 0 , 1 , 2 , 4 , 5 , 6 ] super () . __init__ ( bag_name , mass , pos , orn , client ) self . client . setJointMotorControlArray ( self . id , dummy_joint_ids , pybullet . POSITION_CONTROL , [ 0 ] * len ( dummy_joint_ids ), forces = [ 0.1 ] * len ( dummy_joint_ids ), # TODO tune force ) print_green ( \"Bag is ready\" ) # TODO make this structure consistent with the constraint bag @property def constraints ( self ) -> list [ int ]: \"\"\"Active IDs of constraints on the bag\"\"\" return list ( self . _constraints . values ()) def _load ( self , pos : npt . ArrayLike , orn : npt . ArrayLike ) -> int : bag_id = self . client . loadURDF ( self . URDFS [ self . name ], pos , orn ) # Update the mass of the bag based on the value provided at initialization # The other links in the URDF (e.g. the handle(s)) have some mass so we need to account for this link_mass = 0 for i in range ( self . num_links - 1 ): link_mass += self . client . getDynamicsInfo ( bag_id , i )[ 0 ] self . client . changeDynamics ( bag_id , - 1 , self . mass - link_mass ) return bag_id def _attach ( self , robot : Astrobee , handle_index : int ) -> None : handle_link_index = ( handle_index + 1 ) * self . LINKS_PER_HANDLE - 1 cid = self . client . createConstraint ( robot . id , robot . Links . ARM_DISTAL . value , self . id , handle_link_index , pybullet . JOINT_FIXED , [ 0 , 0 , 1 ], robot . TRANSFORMS . GRIPPER_TO_ARM_DISTAL [: 3 , 3 ], [ 0 , 0 , 0 ], ) self . _constraints . update ({ robot . id : cid }) self . _attached . append ( robot . id ) def detach ( self ) -> None : for cid in self . constraints : self . client . removeConstraint ( cid ) self . _constraints = {} self . _attached = [] def detach_robot ( self , robot_id : int ) -> None : if robot_id not in self . attached : raise ValueError ( \"Cannot detach robot: ID unknown\" ) self . client . removeConstraint ( self . _constraints [ robot_id ]) self . _constraints . pop ( robot_id ) self . _attached . remove ( robot_id ) def get_handle_transform ( self , handle_index : int = 0 ) -> np . ndarray : \"\"\"Calculates the transformation matrix (w.r.t the world) for a specified handle Args: handle_index (int): Index of the handle on the bag Returns: np.ndarray: Transformation matrix (handle to world). Shape = (4,4) \"\"\" if ( handle_index + 1 ) > self . num_handles : raise ValueError ( f \"Invalid handle index: { handle_index } . Bag only has { self . num_handles } handles\" ) handle_link_index = ( handle_index + 1 ) * self . LINKS_PER_HANDLE - 1 link_state = self . client . getLinkState ( self . id , handle_link_index , computeForwardKinematics = True ) pos , quat = link_state [: 2 ] return make_transform_mat ( quat_to_rmat ( quat ), pos ) def _single_handle_test ( bag_name : str ): # Very simple example of loading the bag and attaching a robot client = initialize_pybullet ( bg_color = ( 0.8 , 0.8 , 1 )) robot = Astrobee () bag = RigidCargoBag ( bag_name , 10 ) bag . attach_to ( robot ) while True : client . stepSimulation () time . sleep ( 1 / 120 ) def _two_handle_test ( bag_name : str ): # Load the bag and attach to two robots client = initialize_pybullet ( bg_color = ( 0.8 , 0.8 , 1 )) robot_1 = Astrobee () robot_2 = Astrobee () bag = RigidCargoBag ( bag_name , 10 ) bag . attach_to ([ robot_1 , robot_2 ]) while True : client . stepSimulation () time . sleep ( 1 / 120 ) if __name__ == \"__main__\" : # _single_handle_test(\"top_handle\") _two_handle_test ( \"top_bottom_handle\" ) Classes RigidCargoBag class RigidCargoBag ( bag_name : str , mass : float , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 0 , 0 , 0 ), orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 0 , 0 , 0 , 1 ), client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) Class for loading and managing properties associated with the rigid URDF-based cargo bags Attributes Name Type Description Default bag_name str Type of cargo bag to load. Single handle: \"front_handle\", \"right_handle\", \"top_handle\". Dual handle: \"front_back_handle\", \"right_left_handle\", \"top_bottom_handle\" None mass float Mass of the cargo bag, in kg None pos npt.ArrayLike Initial XYZ position to load the bag. Defaults to (0, 0, 0) None orn npt.ArrayLike Initial XYZW quaternion to load the bag. Defaults to (0, 0, 0, 1) None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None View Source class RigidCargoBag ( CargoBag ): \"\"\"Class for loading and managing properties associated with the rigid URDF-based cargo bags Args: bag_name (str): Type of cargo bag to load. Single handle: \"front_handle\", \"right_handle\", \"top_handle\". Dual handle: \"front_back_handle\", \"right_left_handle\", \"top_bottom_handle\" mass (float): Mass of the cargo bag, in kg pos (npt.ArrayLike, optional): Initial XYZ position to load the bag. Defaults to (0, 0, 0) orn (npt.ArrayLike, optional): Initial XYZW quaternion to load the bag. Defaults to (0, 0, 0, 1) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" LINKS_PER_HANDLE = 4 # 3 dummy links for roll/pitch/yaw, plus the handle itself _urdfs = [ CargoBag . URDF_DIR + name + \"_rigid_bag.urdf\" for name in CargoBag . BAG_NAMES ] URDFS = dict ( zip ( CargoBag . BAG_NAMES , _urdfs )) def __init__ ( self , bag_name : str , mass : float , pos : npt . ArrayLike = ( 0 , 0 , 0 ), orn : npt . ArrayLike = ( 0 , 0 , 0 , 1 ), client : Optional [ BulletClient ] = None , ): # This inertia is slightly approximate because some mass is in the handle and dummy links self . inertia = box_inertia ( mass , self . LENGTH , self . WIDTH , self . HEIGHT ) # Initializations self . _name = bag_name # HACK (this gets set in super.init but we need to know it before calling that) self . _constraints = {} # Add position control to the handle(s) so its springs back into its natural position # to provide some resistance to motion like we would see in a deformable # The dummy joints are the joints associated with the motion of the handle if self . num_handles == 1 : self . num_joints = 4 # 3 for rpy, 1 for handle self . num_links = 5 # Base, 3 dummies for rpy, handle dummy_joint_ids = [ 0 , 1 , 2 ] elif self . num_handles == 2 : self . num_joints = 8 self . num_links = 9 dummy_joint_ids = [ 0 , 1 , 2 , 4 , 5 , 6 ] super () . __init__ ( bag_name , mass , pos , orn , client ) self . client . setJointMotorControlArray ( self . id , dummy_joint_ids , pybullet . POSITION_CONTROL , [ 0 ] * len ( dummy_joint_ids ), forces = [ 0.1 ] * len ( dummy_joint_ids ), # TODO tune force ) print_green ( \"Bag is ready\" ) # TODO make this structure consistent with the constraint bag @ property def constraints ( self ) -> list [ int ]: \"\"\"Active IDs of constraints on the bag\"\"\" return list ( self . _constraints . values ()) def _load ( self , pos : npt . ArrayLike , orn : npt . ArrayLike ) -> int : bag_id = self . client . loadURDF ( self . URDFS [ self . name ], pos , orn ) # Update the mass of the bag based on the value provided at initialization # The other links in the URDF (e.g. the handle(s)) have some mass so we need to account for this link_mass = 0 for i in range ( self . num_links - 1 ): link_mass += self . client . getDynamicsInfo ( bag_id , i )[ 0 ] self . client . changeDynamics ( bag_id , - 1 , self . mass - link_mass ) return bag_id def _attach ( self , robot : Astrobee , handle_index : int ) -> None : handle_link_index = ( handle_index + 1 ) * self . LINKS_PER_HANDLE - 1 cid = self . client . createConstraint ( robot . id , robot . Links . ARM_DISTAL . value , self . id , handle_link_index , pybullet . JOINT_FIXED , [ 0 , 0 , 1 ], robot . TRANSFORMS . GRIPPER_TO_ARM_DISTAL [: 3 , 3 ], [ 0 , 0 , 0 ], ) self . _constraints . update ({ robot . id : cid }) self . _attached . append ( robot . id ) def detach ( self ) -> None : for cid in self . constraints : self . client . removeConstraint ( cid ) self . _constraints = {} self . _attached = [] def detach_robot ( self , robot_id : int ) -> None : if robot_id not in self . attached : raise ValueError ( \"Cannot detach robot: ID unknown\" ) self . client . removeConstraint ( self . _constraints [ robot_id ]) self . _constraints . pop ( robot_id ) self . _attached . remove ( robot_id ) def get_handle_transform ( self , handle_index : int = 0 ) -> np . ndarray : \"\"\"Calculates the transformation matrix (w.r.t the world) for a specified handle Args: handle_index (int): Index of the handle on the bag Returns: np.ndarray: Transformation matrix (handle to world). Shape = (4,4) \"\"\" if ( handle_index + 1 ) > self . num_handles : raise ValueError ( f \"Invalid handle index: {handle_index}. Bag only has {self.num_handles} handles\" ) handle_link_index = ( handle_index + 1 ) * self . LINKS_PER_HANDLE - 1 link_state = self . client . getLinkState ( self . id , handle_link_index , computeForwardKinematics = True ) pos , quat = link_state [: 2 ] return make_transform_mat ( quat_to_rmat ( quat ), pos ) Ancestors (in MRO) pyastrobee.core.abstract_bag.CargoBag abc.ABC Class variables BAG_NAMES DUAL_HANDLE_BAGS HANDLE_TRANSFORMS HEIGHT LENGTH LINKS_PER_HANDLE MESH_DIR SINGLE_HANDLE_BAGS URDFS URDF_DIR WIDTH Instance variables angular_velocity Current [wx, wy, wz] angular velocity of the cargo bag's COM frame If both velocity and angular velocity are desired, use the dynamics_state property instead attached ID(s) of the robot (or robots) grasping the bag. Empty if no robots are attached bounding_box Current axis-aligned bounding box of the bag (or just the main compartment), shape (2, 3) constraints Active IDs of constraints on the bag corner_positions Positions of the 8 corners of the main compartment of the bag, shape (8, 3) dynamics_state Current state of the bag dynamics: Position, orientation, linear vel, and angular vel grasp_transforms Transformation matrices \"handle to bag\" representing the grasp locations on the handles to the bag COM In the case of a single-handled bag, this list will only have one entry mass Mass of the cargo bag name Type of cargo bag num_handles Number of handles on the cargo bag orientation Current XYZW quaternion orientation of the cargo bag's COM frame pose Current position + XYZW quaternion pose of the bag position Current XYZ position of the origin (COM frame) of the cargo bag tmat Current transformation matrix for the cargo bag: (Bag to world) velocity Current [vx, vy, vz] velocity of the cargo bag's COM frame If both velocity and angular velocity are desired, use the dynamics_state property instead Methods attach_to def attach_to ( self , robot_or_robots : Union [ pyastrobee . core . astrobee . Astrobee , list [ pyastrobee . core . astrobee . Astrobee ], tuple [ pyastrobee . core . astrobee . Astrobee ]], object_to_move : str = 'robot' ) -> None Attaches a robot (or multiple robots) to the handle(s) of the bag Parameters: Name Type Description Default robot_or_robots Union[Astrobee, list[Astrobee], tuple[Astrobee]] Robot(s) to attach to the bag None object_to_move str Either \"robot\" or \"bag\". This dictates what object will get its position reset in order to make the grasp connection. In general, it makes more sense to move the robot to the bag (default behavior) None Raises: Type Description ValueError For invalid inputs, or if the bag does not have enough handles for each robot NotImplementedError Multi-robot case with >2 robots View Source def attach_to ( self , robot_or_robots : Union [ Astrobee, list[Astrobee ] , tuple [ Astrobee ] ] , object_to_move : str = \"robot\" , ) -> None : \"\"\"Attaches a robot (or multiple robots) to the handle(s) of the bag Args: robot_or_robots (Union[Astrobee, list[Astrobee], tuple[Astrobee]]): Robot(s) to attach to the bag object_to_move (str, optional): Either \" robot \" or \" bag \". This dictates what object will get its position reset in order to make the grasp connection. In general, it makes more sense to move the robot to the bag (default behavior) Raises: ValueError: For invalid inputs, or if the bag does not have enough handles for each robot NotImplementedError: Multi-robot case with >2 robots \"\"\" # Handle inputs if isinstance ( robot_or_robots , Astrobee ) : # Single robot num_robots = 1 elif isinstance ( robot_or_robots , ( list , tuple )) : # Multi - robot if not all ( isinstance ( r , Astrobee ) for r in robot_or_robots ) : raise ValueError ( \"Non-Astrobee input detected\" ) num_robots = len ( robot_or_robots ) if self . num_handles < num_robots : raise ValueError ( f \"Bag does not have enough handles to support {num_robots} robots\" ) if num_robots == 1 : # Edge case : Unpack the list if only one robot robot_or_robots = robot_or_robots [ 0 ] else : raise ValueError ( \"Invalid input: Must provide either an Astrobee or a list of multiple Astrobees\" ) if object_to_move not in { \"robot\" , \"bag\" }: raise ValueError ( \"Invalid object to move: Must be either 'robot' or 'bag'.\" ) bag_to_world = pos_quat_to_tmat ( self . pose ) if num_robots == 1 : robot = robot_or_robots # Unpack list if object_to_move == \"robot\" : # Reset the position of the robot to interface with the handle handle_to_bag = self . grasp_transforms [ 0 ] handle_to_world = bag_to_world @ handle_to_bag handle_pose = tmat_to_pos_quat ( handle_to_world ) robot . reset_to_ee_pose ( handle_pose ) else : # Move the bag to the robot self . reset_to_handle_pose ( robot . ee_pose ) self . _attach ( robot , 0 ) elif num_robots == 2 : robot_1 , robot_2 = robot_or_robots # Unpack list if object_to_move == \"robot\" : # Reset the position of each robot to interface with the two handles handle_1_to_bag = self . grasp_transforms [ 0 ] handle_2_to_bag = self . grasp_transforms [ 1 ] handle_1_to_world = bag_to_world @ handle_1_to_bag handle_2_to_world = bag_to_world @ handle_2_to_bag robot_1 . reset_to_ee_pose ( tmat_to_pos_quat ( handle_1_to_world )) robot_2 . reset_to_ee_pose ( tmat_to_pos_quat ( handle_2_to_world )) self . _attach ( robot_1 , 0 ) self . _attach ( robot_2 , 1 ) else : # Move the bag while leaving the robots static raise NotImplementedError ( \"Attaching the bag to multiple robots requires moving at least 1 robot\" ) else : raise NotImplementedError ( \"The multi-robot case is only implemented for 2 Astrobees\" ) detach def detach ( self ) -> None Detach all connections to the bag View Source def detach ( self ) -> None : for cid in self . constraints : self . client . removeConstraint ( cid ) self . _constraints = {} self . _attached = [] detach_robot def detach_robot ( self , robot_id : int ) -> None Detaches a specific robot from the bag Parameters: Name Type Description Default robot_id int Pybullet ID of the robot to detach None View Source def detach_robot ( self , robot_id : int ) -> None : if robot_id not in self . attached : raise ValueError ( \"Cannot detach robot: ID unknown\" ) self . client . removeConstraint ( self . _constraints [ robot_id ] ) self . _constraints . pop ( robot_id ) self . _attached . remove ( robot_id ) get_handle_transform def get_handle_transform ( self , handle_index : int = 0 ) -> numpy . ndarray Calculates the transformation matrix (w.r.t the world) for a specified handle Parameters: Name Type Description Default handle_index int Index of the handle on the bag None Returns: Type Description np.ndarray Transformation matrix (handle to world). Shape = (4,4) View Source def get_handle_transform(self, handle_index: int = 0) -> np.ndarray: \"\"\"Calculates the transformation matrix (w.r.t the world) for a specified handle Args: handle_index (int): Index of the handle on the bag Returns: np.ndarray: Transformation matrix (handle to world). Shape = (4,4) \"\"\" if (handle_index + 1) > self.num_handles: raise ValueError( f\"Invalid handle index: {handle_index}. Bag only has {self.num_handles} handles\" ) handle_link_index = (handle_index + 1) * self.LINKS_PER_HANDLE - 1 link_state = self.client.getLinkState( self.id, handle_link_index, computeForwardKinematics=True ) pos, quat = link_state[:2] return make_transform_mat(quat_to_rmat(quat), pos) reset_dynamics def reset_dynamics ( self , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], lin_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], ang_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> None Resets the pose and velocities of the bag Parameters: Name Type Description Default pos npt.ArrayLike Position, shape (3,) None orn npt.ArrayLike XYZW quaternion orientation, shape (4,) None lin_vel npt.ArrayLike Linear velocity, shape (3,) None ang_vel npt.ArrayLike Angular velocity, shape (3,) None View Source def reset_dynamics ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , lin_vel : npt . ArrayLike , ang_vel : npt . ArrayLike , ) -> None : \"\"\"Resets the pose and velocities of the bag Args: pos (npt.ArrayLike): Position, shape (3,) orn (npt.ArrayLike): XYZW quaternion orientation, shape (4,) lin_vel (npt.ArrayLike): Linear velocity, shape (3,) ang_vel (npt.ArrayLike): Angular velocity, shape (3,) \"\"\" self . client . resetBasePositionAndOrientation ( self . id , pos , orn ) self . client . resetBaseVelocity ( self . id , lin_vel , ang_vel ) reset_to_handle_pose def reset_to_handle_pose ( self , handle_pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], handle_index : int = 0 ) -> None Resets the position of the bag so that the handle is positioned at a desired pose Parameters: Name Type Description Default handle_pose npt.ArrayLike Desired pose of the handle (\"handle-to-world\"), shape (7,) None handle_index int Index of the handle to align to the desired pose. Defaults to 0. 0 View Source def reset_to_handle_pose ( self , handle_pose : npt . ArrayLike , handle_index : int = 0 ) -> None : \"\"\"Resets the position of the bag so that the handle is positioned at a desired pose Args: handle_pose (npt.ArrayLike): Desired pose of the handle (\" handle - to - world \"), shape (7,) handle_index (int, optional): Index of the handle to align to the desired pose. Defaults to 0. \"\"\" handle_to_world = pos_quat_to_tmat ( handle_pose ) bag_to_handle = invert_transform_mat ( self . grasp_transforms [ handle_index ] ) bag_to_world = handle_to_world @ bag_to_handle bag_pose = tmat_to_pos_quat ( bag_to_world ) # This assumes that we want the bag to be stationary self . reset_dynamics ( bag_pose [ :3 ] , bag_pose [ 3: ] , np . zeros ( 3 ), np . zeros ( 3 )) unload def unload ( self ) -> None Removes the cargo bag from the simulation View Source def unload ( self ) -> None : \"\"\"Removes the cargo bag from the simulation\"\"\" self . detach () self . client . removeBody ( self . id ) self . id = None","title":"Rigid Bag"},{"location":"reference/pyastrobee/core/rigid_bag/#module-pyastrobeecorerigid_bag","text":"Rigid version of the cargo bag, using joints in the URDF to mimic what we would see from a deformable Documentation for inherited methods can be found in the base class View Source \"\"\"Rigid version of the cargo bag, using joints in the URDF to mimic what we would see from a deformable Documentation for inherited methods can be found in the base class \"\"\" # TODO tune the position control force on the handle import time from typing import Optional import pybullet from pybullet_utils.bullet_client import BulletClient import numpy as np import numpy.typing as npt from pyastrobee.core.astrobee import Astrobee from pyastrobee.core.abstract_bag import CargoBag from pyastrobee.utils.bullet_utils import initialize_pybullet from pyastrobee.utils.python_utils import print_green from pyastrobee.utils.transformations import make_transform_mat from pyastrobee.utils.rotations import quat_to_rmat from pyastrobee.utils.dynamics import box_inertia class RigidCargoBag ( CargoBag ): \"\"\"Class for loading and managing properties associated with the rigid URDF-based cargo bags Args: bag_name (str): Type of cargo bag to load. Single handle: \"front_handle\", \"right_handle\", \"top_handle\". Dual handle: \"front_back_handle\", \"right_left_handle\", \"top_bottom_handle\" mass (float): Mass of the cargo bag, in kg pos (npt.ArrayLike, optional): Initial XYZ position to load the bag. Defaults to (0, 0, 0) orn (npt.ArrayLike, optional): Initial XYZW quaternion to load the bag. Defaults to (0, 0, 0, 1) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" LINKS_PER_HANDLE = 4 # 3 dummy links for roll/pitch/yaw, plus the handle itself _urdfs = [ CargoBag . URDF_DIR + name + \"_rigid_bag.urdf\" for name in CargoBag . BAG_NAMES ] URDFS = dict ( zip ( CargoBag . BAG_NAMES , _urdfs )) def __init__ ( self , bag_name : str , mass : float , pos : npt . ArrayLike = ( 0 , 0 , 0 ), orn : npt . ArrayLike = ( 0 , 0 , 0 , 1 ), client : Optional [ BulletClient ] = None , ): # This inertia is slightly approximate because some mass is in the handle and dummy links self . inertia = box_inertia ( mass , self . LENGTH , self . WIDTH , self . HEIGHT ) # Initializations self . _name = bag_name # HACK (this gets set in super.init but we need to know it before calling that) self . _constraints = {} # Add position control to the handle(s) so its springs back into its natural position # to provide some resistance to motion like we would see in a deformable # The dummy joints are the joints associated with the motion of the handle if self . num_handles == 1 : self . num_joints = 4 # 3 for rpy, 1 for handle self . num_links = 5 # Base, 3 dummies for rpy, handle dummy_joint_ids = [ 0 , 1 , 2 ] elif self . num_handles == 2 : self . num_joints = 8 self . num_links = 9 dummy_joint_ids = [ 0 , 1 , 2 , 4 , 5 , 6 ] super () . __init__ ( bag_name , mass , pos , orn , client ) self . client . setJointMotorControlArray ( self . id , dummy_joint_ids , pybullet . POSITION_CONTROL , [ 0 ] * len ( dummy_joint_ids ), forces = [ 0.1 ] * len ( dummy_joint_ids ), # TODO tune force ) print_green ( \"Bag is ready\" ) # TODO make this structure consistent with the constraint bag @property def constraints ( self ) -> list [ int ]: \"\"\"Active IDs of constraints on the bag\"\"\" return list ( self . _constraints . values ()) def _load ( self , pos : npt . ArrayLike , orn : npt . ArrayLike ) -> int : bag_id = self . client . loadURDF ( self . URDFS [ self . name ], pos , orn ) # Update the mass of the bag based on the value provided at initialization # The other links in the URDF (e.g. the handle(s)) have some mass so we need to account for this link_mass = 0 for i in range ( self . num_links - 1 ): link_mass += self . client . getDynamicsInfo ( bag_id , i )[ 0 ] self . client . changeDynamics ( bag_id , - 1 , self . mass - link_mass ) return bag_id def _attach ( self , robot : Astrobee , handle_index : int ) -> None : handle_link_index = ( handle_index + 1 ) * self . LINKS_PER_HANDLE - 1 cid = self . client . createConstraint ( robot . id , robot . Links . ARM_DISTAL . value , self . id , handle_link_index , pybullet . JOINT_FIXED , [ 0 , 0 , 1 ], robot . TRANSFORMS . GRIPPER_TO_ARM_DISTAL [: 3 , 3 ], [ 0 , 0 , 0 ], ) self . _constraints . update ({ robot . id : cid }) self . _attached . append ( robot . id ) def detach ( self ) -> None : for cid in self . constraints : self . client . removeConstraint ( cid ) self . _constraints = {} self . _attached = [] def detach_robot ( self , robot_id : int ) -> None : if robot_id not in self . attached : raise ValueError ( \"Cannot detach robot: ID unknown\" ) self . client . removeConstraint ( self . _constraints [ robot_id ]) self . _constraints . pop ( robot_id ) self . _attached . remove ( robot_id ) def get_handle_transform ( self , handle_index : int = 0 ) -> np . ndarray : \"\"\"Calculates the transformation matrix (w.r.t the world) for a specified handle Args: handle_index (int): Index of the handle on the bag Returns: np.ndarray: Transformation matrix (handle to world). Shape = (4,4) \"\"\" if ( handle_index + 1 ) > self . num_handles : raise ValueError ( f \"Invalid handle index: { handle_index } . Bag only has { self . num_handles } handles\" ) handle_link_index = ( handle_index + 1 ) * self . LINKS_PER_HANDLE - 1 link_state = self . client . getLinkState ( self . id , handle_link_index , computeForwardKinematics = True ) pos , quat = link_state [: 2 ] return make_transform_mat ( quat_to_rmat ( quat ), pos ) def _single_handle_test ( bag_name : str ): # Very simple example of loading the bag and attaching a robot client = initialize_pybullet ( bg_color = ( 0.8 , 0.8 , 1 )) robot = Astrobee () bag = RigidCargoBag ( bag_name , 10 ) bag . attach_to ( robot ) while True : client . stepSimulation () time . sleep ( 1 / 120 ) def _two_handle_test ( bag_name : str ): # Load the bag and attach to two robots client = initialize_pybullet ( bg_color = ( 0.8 , 0.8 , 1 )) robot_1 = Astrobee () robot_2 = Astrobee () bag = RigidCargoBag ( bag_name , 10 ) bag . attach_to ([ robot_1 , robot_2 ]) while True : client . stepSimulation () time . sleep ( 1 / 120 ) if __name__ == \"__main__\" : # _single_handle_test(\"top_handle\") _two_handle_test ( \"top_bottom_handle\" )","title":"Module pyastrobee.core.rigid_bag"},{"location":"reference/pyastrobee/core/rigid_bag/#classes","text":"","title":"Classes"},{"location":"reference/pyastrobee/core/rigid_bag/#rigidcargobag","text":"class RigidCargoBag ( bag_name : str , mass : float , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 0 , 0 , 0 ), orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 0 , 0 , 0 , 1 ), client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) Class for loading and managing properties associated with the rigid URDF-based cargo bags","title":"RigidCargoBag"},{"location":"reference/pyastrobee/core/rigid_bag/#attributes","text":"Name Type Description Default bag_name str Type of cargo bag to load. Single handle: \"front_handle\", \"right_handle\", \"top_handle\". Dual handle: \"front_back_handle\", \"right_left_handle\", \"top_bottom_handle\" None mass float Mass of the cargo bag, in kg None pos npt.ArrayLike Initial XYZ position to load the bag. Defaults to (0, 0, 0) None orn npt.ArrayLike Initial XYZW quaternion to load the bag. Defaults to (0, 0, 0, 1) None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None View Source class RigidCargoBag ( CargoBag ): \"\"\"Class for loading and managing properties associated with the rigid URDF-based cargo bags Args: bag_name (str): Type of cargo bag to load. Single handle: \"front_handle\", \"right_handle\", \"top_handle\". Dual handle: \"front_back_handle\", \"right_left_handle\", \"top_bottom_handle\" mass (float): Mass of the cargo bag, in kg pos (npt.ArrayLike, optional): Initial XYZ position to load the bag. Defaults to (0, 0, 0) orn (npt.ArrayLike, optional): Initial XYZW quaternion to load the bag. Defaults to (0, 0, 0, 1) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" LINKS_PER_HANDLE = 4 # 3 dummy links for roll/pitch/yaw, plus the handle itself _urdfs = [ CargoBag . URDF_DIR + name + \"_rigid_bag.urdf\" for name in CargoBag . BAG_NAMES ] URDFS = dict ( zip ( CargoBag . BAG_NAMES , _urdfs )) def __init__ ( self , bag_name : str , mass : float , pos : npt . ArrayLike = ( 0 , 0 , 0 ), orn : npt . ArrayLike = ( 0 , 0 , 0 , 1 ), client : Optional [ BulletClient ] = None , ): # This inertia is slightly approximate because some mass is in the handle and dummy links self . inertia = box_inertia ( mass , self . LENGTH , self . WIDTH , self . HEIGHT ) # Initializations self . _name = bag_name # HACK (this gets set in super.init but we need to know it before calling that) self . _constraints = {} # Add position control to the handle(s) so its springs back into its natural position # to provide some resistance to motion like we would see in a deformable # The dummy joints are the joints associated with the motion of the handle if self . num_handles == 1 : self . num_joints = 4 # 3 for rpy, 1 for handle self . num_links = 5 # Base, 3 dummies for rpy, handle dummy_joint_ids = [ 0 , 1 , 2 ] elif self . num_handles == 2 : self . num_joints = 8 self . num_links = 9 dummy_joint_ids = [ 0 , 1 , 2 , 4 , 5 , 6 ] super () . __init__ ( bag_name , mass , pos , orn , client ) self . client . setJointMotorControlArray ( self . id , dummy_joint_ids , pybullet . POSITION_CONTROL , [ 0 ] * len ( dummy_joint_ids ), forces = [ 0.1 ] * len ( dummy_joint_ids ), # TODO tune force ) print_green ( \"Bag is ready\" ) # TODO make this structure consistent with the constraint bag @ property def constraints ( self ) -> list [ int ]: \"\"\"Active IDs of constraints on the bag\"\"\" return list ( self . _constraints . values ()) def _load ( self , pos : npt . ArrayLike , orn : npt . ArrayLike ) -> int : bag_id = self . client . loadURDF ( self . URDFS [ self . name ], pos , orn ) # Update the mass of the bag based on the value provided at initialization # The other links in the URDF (e.g. the handle(s)) have some mass so we need to account for this link_mass = 0 for i in range ( self . num_links - 1 ): link_mass += self . client . getDynamicsInfo ( bag_id , i )[ 0 ] self . client . changeDynamics ( bag_id , - 1 , self . mass - link_mass ) return bag_id def _attach ( self , robot : Astrobee , handle_index : int ) -> None : handle_link_index = ( handle_index + 1 ) * self . LINKS_PER_HANDLE - 1 cid = self . client . createConstraint ( robot . id , robot . Links . ARM_DISTAL . value , self . id , handle_link_index , pybullet . JOINT_FIXED , [ 0 , 0 , 1 ], robot . TRANSFORMS . GRIPPER_TO_ARM_DISTAL [: 3 , 3 ], [ 0 , 0 , 0 ], ) self . _constraints . update ({ robot . id : cid }) self . _attached . append ( robot . id ) def detach ( self ) -> None : for cid in self . constraints : self . client . removeConstraint ( cid ) self . _constraints = {} self . _attached = [] def detach_robot ( self , robot_id : int ) -> None : if robot_id not in self . attached : raise ValueError ( \"Cannot detach robot: ID unknown\" ) self . client . removeConstraint ( self . _constraints [ robot_id ]) self . _constraints . pop ( robot_id ) self . _attached . remove ( robot_id ) def get_handle_transform ( self , handle_index : int = 0 ) -> np . ndarray : \"\"\"Calculates the transformation matrix (w.r.t the world) for a specified handle Args: handle_index (int): Index of the handle on the bag Returns: np.ndarray: Transformation matrix (handle to world). Shape = (4,4) \"\"\" if ( handle_index + 1 ) > self . num_handles : raise ValueError ( f \"Invalid handle index: {handle_index}. Bag only has {self.num_handles} handles\" ) handle_link_index = ( handle_index + 1 ) * self . LINKS_PER_HANDLE - 1 link_state = self . client . getLinkState ( self . id , handle_link_index , computeForwardKinematics = True ) pos , quat = link_state [: 2 ] return make_transform_mat ( quat_to_rmat ( quat ), pos )","title":"Attributes"},{"location":"reference/pyastrobee/core/rigid_bag/#ancestors-in-mro","text":"pyastrobee.core.abstract_bag.CargoBag abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/pyastrobee/core/rigid_bag/#class-variables","text":"BAG_NAMES DUAL_HANDLE_BAGS HANDLE_TRANSFORMS HEIGHT LENGTH LINKS_PER_HANDLE MESH_DIR SINGLE_HANDLE_BAGS URDFS URDF_DIR WIDTH","title":"Class variables"},{"location":"reference/pyastrobee/core/rigid_bag/#instance-variables","text":"angular_velocity Current [wx, wy, wz] angular velocity of the cargo bag's COM frame If both velocity and angular velocity are desired, use the dynamics_state property instead attached ID(s) of the robot (or robots) grasping the bag. Empty if no robots are attached bounding_box Current axis-aligned bounding box of the bag (or just the main compartment), shape (2, 3) constraints Active IDs of constraints on the bag corner_positions Positions of the 8 corners of the main compartment of the bag, shape (8, 3) dynamics_state Current state of the bag dynamics: Position, orientation, linear vel, and angular vel grasp_transforms Transformation matrices \"handle to bag\" representing the grasp locations on the handles to the bag COM In the case of a single-handled bag, this list will only have one entry mass Mass of the cargo bag name Type of cargo bag num_handles Number of handles on the cargo bag orientation Current XYZW quaternion orientation of the cargo bag's COM frame pose Current position + XYZW quaternion pose of the bag position Current XYZ position of the origin (COM frame) of the cargo bag tmat Current transformation matrix for the cargo bag: (Bag to world) velocity Current [vx, vy, vz] velocity of the cargo bag's COM frame If both velocity and angular velocity are desired, use the dynamics_state property instead","title":"Instance variables"},{"location":"reference/pyastrobee/core/rigid_bag/#methods","text":"","title":"Methods"},{"location":"reference/pyastrobee/core/rigid_bag/#attach_to","text":"def attach_to ( self , robot_or_robots : Union [ pyastrobee . core . astrobee . Astrobee , list [ pyastrobee . core . astrobee . Astrobee ], tuple [ pyastrobee . core . astrobee . Astrobee ]], object_to_move : str = 'robot' ) -> None Attaches a robot (or multiple robots) to the handle(s) of the bag Parameters: Name Type Description Default robot_or_robots Union[Astrobee, list[Astrobee], tuple[Astrobee]] Robot(s) to attach to the bag None object_to_move str Either \"robot\" or \"bag\". This dictates what object will get its position reset in order to make the grasp connection. In general, it makes more sense to move the robot to the bag (default behavior) None Raises: Type Description ValueError For invalid inputs, or if the bag does not have enough handles for each robot NotImplementedError Multi-robot case with >2 robots View Source def attach_to ( self , robot_or_robots : Union [ Astrobee, list[Astrobee ] , tuple [ Astrobee ] ] , object_to_move : str = \"robot\" , ) -> None : \"\"\"Attaches a robot (or multiple robots) to the handle(s) of the bag Args: robot_or_robots (Union[Astrobee, list[Astrobee], tuple[Astrobee]]): Robot(s) to attach to the bag object_to_move (str, optional): Either \" robot \" or \" bag \". This dictates what object will get its position reset in order to make the grasp connection. In general, it makes more sense to move the robot to the bag (default behavior) Raises: ValueError: For invalid inputs, or if the bag does not have enough handles for each robot NotImplementedError: Multi-robot case with >2 robots \"\"\" # Handle inputs if isinstance ( robot_or_robots , Astrobee ) : # Single robot num_robots = 1 elif isinstance ( robot_or_robots , ( list , tuple )) : # Multi - robot if not all ( isinstance ( r , Astrobee ) for r in robot_or_robots ) : raise ValueError ( \"Non-Astrobee input detected\" ) num_robots = len ( robot_or_robots ) if self . num_handles < num_robots : raise ValueError ( f \"Bag does not have enough handles to support {num_robots} robots\" ) if num_robots == 1 : # Edge case : Unpack the list if only one robot robot_or_robots = robot_or_robots [ 0 ] else : raise ValueError ( \"Invalid input: Must provide either an Astrobee or a list of multiple Astrobees\" ) if object_to_move not in { \"robot\" , \"bag\" }: raise ValueError ( \"Invalid object to move: Must be either 'robot' or 'bag'.\" ) bag_to_world = pos_quat_to_tmat ( self . pose ) if num_robots == 1 : robot = robot_or_robots # Unpack list if object_to_move == \"robot\" : # Reset the position of the robot to interface with the handle handle_to_bag = self . grasp_transforms [ 0 ] handle_to_world = bag_to_world @ handle_to_bag handle_pose = tmat_to_pos_quat ( handle_to_world ) robot . reset_to_ee_pose ( handle_pose ) else : # Move the bag to the robot self . reset_to_handle_pose ( robot . ee_pose ) self . _attach ( robot , 0 ) elif num_robots == 2 : robot_1 , robot_2 = robot_or_robots # Unpack list if object_to_move == \"robot\" : # Reset the position of each robot to interface with the two handles handle_1_to_bag = self . grasp_transforms [ 0 ] handle_2_to_bag = self . grasp_transforms [ 1 ] handle_1_to_world = bag_to_world @ handle_1_to_bag handle_2_to_world = bag_to_world @ handle_2_to_bag robot_1 . reset_to_ee_pose ( tmat_to_pos_quat ( handle_1_to_world )) robot_2 . reset_to_ee_pose ( tmat_to_pos_quat ( handle_2_to_world )) self . _attach ( robot_1 , 0 ) self . _attach ( robot_2 , 1 ) else : # Move the bag while leaving the robots static raise NotImplementedError ( \"Attaching the bag to multiple robots requires moving at least 1 robot\" ) else : raise NotImplementedError ( \"The multi-robot case is only implemented for 2 Astrobees\" )","title":"attach_to"},{"location":"reference/pyastrobee/core/rigid_bag/#detach","text":"def detach ( self ) -> None Detach all connections to the bag View Source def detach ( self ) -> None : for cid in self . constraints : self . client . removeConstraint ( cid ) self . _constraints = {} self . _attached = []","title":"detach"},{"location":"reference/pyastrobee/core/rigid_bag/#detach_robot","text":"def detach_robot ( self , robot_id : int ) -> None Detaches a specific robot from the bag Parameters: Name Type Description Default robot_id int Pybullet ID of the robot to detach None View Source def detach_robot ( self , robot_id : int ) -> None : if robot_id not in self . attached : raise ValueError ( \"Cannot detach robot: ID unknown\" ) self . client . removeConstraint ( self . _constraints [ robot_id ] ) self . _constraints . pop ( robot_id ) self . _attached . remove ( robot_id )","title":"detach_robot"},{"location":"reference/pyastrobee/core/rigid_bag/#get_handle_transform","text":"def get_handle_transform ( self , handle_index : int = 0 ) -> numpy . ndarray Calculates the transformation matrix (w.r.t the world) for a specified handle Parameters: Name Type Description Default handle_index int Index of the handle on the bag None Returns: Type Description np.ndarray Transformation matrix (handle to world). Shape = (4,4) View Source def get_handle_transform(self, handle_index: int = 0) -> np.ndarray: \"\"\"Calculates the transformation matrix (w.r.t the world) for a specified handle Args: handle_index (int): Index of the handle on the bag Returns: np.ndarray: Transformation matrix (handle to world). Shape = (4,4) \"\"\" if (handle_index + 1) > self.num_handles: raise ValueError( f\"Invalid handle index: {handle_index}. Bag only has {self.num_handles} handles\" ) handle_link_index = (handle_index + 1) * self.LINKS_PER_HANDLE - 1 link_state = self.client.getLinkState( self.id, handle_link_index, computeForwardKinematics=True ) pos, quat = link_state[:2] return make_transform_mat(quat_to_rmat(quat), pos)","title":"get_handle_transform"},{"location":"reference/pyastrobee/core/rigid_bag/#reset_dynamics","text":"def reset_dynamics ( self , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], lin_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], ang_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> None Resets the pose and velocities of the bag Parameters: Name Type Description Default pos npt.ArrayLike Position, shape (3,) None orn npt.ArrayLike XYZW quaternion orientation, shape (4,) None lin_vel npt.ArrayLike Linear velocity, shape (3,) None ang_vel npt.ArrayLike Angular velocity, shape (3,) None View Source def reset_dynamics ( self , pos : npt . ArrayLike , orn : npt . ArrayLike , lin_vel : npt . ArrayLike , ang_vel : npt . ArrayLike , ) -> None : \"\"\"Resets the pose and velocities of the bag Args: pos (npt.ArrayLike): Position, shape (3,) orn (npt.ArrayLike): XYZW quaternion orientation, shape (4,) lin_vel (npt.ArrayLike): Linear velocity, shape (3,) ang_vel (npt.ArrayLike): Angular velocity, shape (3,) \"\"\" self . client . resetBasePositionAndOrientation ( self . id , pos , orn ) self . client . resetBaseVelocity ( self . id , lin_vel , ang_vel )","title":"reset_dynamics"},{"location":"reference/pyastrobee/core/rigid_bag/#reset_to_handle_pose","text":"def reset_to_handle_pose ( self , handle_pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], handle_index : int = 0 ) -> None Resets the position of the bag so that the handle is positioned at a desired pose Parameters: Name Type Description Default handle_pose npt.ArrayLike Desired pose of the handle (\"handle-to-world\"), shape (7,) None handle_index int Index of the handle to align to the desired pose. Defaults to 0. 0 View Source def reset_to_handle_pose ( self , handle_pose : npt . ArrayLike , handle_index : int = 0 ) -> None : \"\"\"Resets the position of the bag so that the handle is positioned at a desired pose Args: handle_pose (npt.ArrayLike): Desired pose of the handle (\" handle - to - world \"), shape (7,) handle_index (int, optional): Index of the handle to align to the desired pose. Defaults to 0. \"\"\" handle_to_world = pos_quat_to_tmat ( handle_pose ) bag_to_handle = invert_transform_mat ( self . grasp_transforms [ handle_index ] ) bag_to_world = handle_to_world @ bag_to_handle bag_pose = tmat_to_pos_quat ( bag_to_world ) # This assumes that we want the bag to be stationary self . reset_dynamics ( bag_pose [ :3 ] , bag_pose [ 3: ] , np . zeros ( 3 ), np . zeros ( 3 ))","title":"reset_to_handle_pose"},{"location":"reference/pyastrobee/core/rigid_bag/#unload","text":"def unload ( self ) -> None Removes the cargo bag from the simulation View Source def unload ( self ) -> None : \"\"\"Removes the cargo bag from the simulation\"\"\" self . detach () self . client . removeBody ( self . id ) self . id = None","title":"unload"},{"location":"reference/pyastrobee/trajectories/","text":"Module pyastrobee.trajectories Sub-modules pyastrobee.trajectories.arm_planner pyastrobee.trajectories.bezier pyastrobee.trajectories.bezier_slerp pyastrobee.trajectories.box_paths pyastrobee.trajectories.curve_utils pyastrobee.trajectories.decasteljau_slerp pyastrobee.trajectories.face_forward pyastrobee.trajectories.multi_robot_trajs pyastrobee.trajectories.planner pyastrobee.trajectories.polynomials pyastrobee.trajectories.quaternion_interpolation pyastrobee.trajectories.sampling pyastrobee.trajectories.simple_trajectories pyastrobee.trajectories.splines pyastrobee.trajectories.timing pyastrobee.trajectories.trajectory pyastrobee.trajectories.variable_time_curves","title":"Index"},{"location":"reference/pyastrobee/trajectories/#module-pyastrobeetrajectories","text":"","title":"Module pyastrobee.trajectories"},{"location":"reference/pyastrobee/trajectories/#sub-modules","text":"pyastrobee.trajectories.arm_planner pyastrobee.trajectories.bezier pyastrobee.trajectories.bezier_slerp pyastrobee.trajectories.box_paths pyastrobee.trajectories.curve_utils pyastrobee.trajectories.decasteljau_slerp pyastrobee.trajectories.face_forward pyastrobee.trajectories.multi_robot_trajs pyastrobee.trajectories.planner pyastrobee.trajectories.polynomials pyastrobee.trajectories.quaternion_interpolation pyastrobee.trajectories.sampling pyastrobee.trajectories.simple_trajectories pyastrobee.trajectories.splines pyastrobee.trajectories.timing pyastrobee.trajectories.trajectory pyastrobee.trajectories.variable_time_curves","title":"Sub-modules"},{"location":"reference/pyastrobee/trajectories/arm_planner/","text":"Module pyastrobee.trajectories.arm_planner Planning (relatively simple) trajectories for the arm during the manipulation motion View Source \"\"\"Planning (relatively simple) trajectories for the arm during the manipulation motion\"\"\" # Note: Some of the methods here are separated out into separate functions so we can test them individually import numpy as np from pyastrobee.trajectories.polynomials import fifth_order_poly from pyastrobee.trajectories.trajectory import Trajectory , ArmTrajectory def plan_arm_traj ( base_traj : Trajectory ) -> ArmTrajectory : \"\"\"Plans a motion for the arm so that we are dragging the bag behind the robot for most of the trajectory, but we start and end from the grasping position This will only use the shoulder joint -- other joints are less relevant for the motion of the bag/robot system This is essentially comprised of three parts: 1) Moving the arm from an initial grasp position to the \"dragging behind\" position 2) Maintaining the \"dragging behind\" position for most of the trajectory 3) Moving the arm to the grasp position again at the end of the trajectory Args: base_traj (Trajectory): Trajectory of the Astrobee base Returns: ArmTrajectory: Positional trajectory for the arm (shoulder joint only) \"\"\" times , transition_idxs = _get_arm_transition_times ( base_traj ) return _plan_arm_traj ( times , * transition_idxs ) def _get_arm_transition_times ( base_traj : Trajectory ) -> tuple [ np . ndarray , np . ndarray ]: \"\"\"Determine the transition times for the bag manipulation arm motions This will assume that we start in the \"grasp\" position, transition to \"drag\" for most of the trajectory, and then return to the \"grasp\" position when we're at the end These transition times will depend on how fast we're moving with the base - in essence, we want these arm motions to complete once the base travels a certain distance - so that the motion of the base and the arm work together and don't lead to excessive disturbances Args: base_traj (Trajectory): Trajectory for the Astrobee base Returns: tuple[np.ndarray, np.ndarray]: np.ndarray: Time information for the full trajectory np.ndarray: Transition times for each motion: \"begin_drag_motion\", \"end_drag_motion\", \"begin_grasp_motion\", and \"end_grasp_motion\" \"\"\" dists_from_start = np . linalg . norm ( base_traj . positions - base_traj . positions [ 0 ], axis = 1 ) dists_from_end = np . linalg . norm ( base_traj . positions - base_traj . positions [ - 1 ], axis = 1 ) # A little over 1 meter seems to work well for the deployment distance (TODO probably needs tuning) # For reference, the 0.23 number is how much the x position of the arm changes when it moves back dx_arm = 0.23162640743995172 * 5 # Note: originally I used searchsorted to find these indices, but these distances are not guaranteed to be sorted # if the trajectory has a lot of curvature drag_idx = np . flatnonzero ( dists_from_start >= dx_arm )[ 0 ] grasp_idx = np . flatnonzero ( dists_from_end <= dx_arm )[ 0 ] return ( base_traj . times , base_traj . times [ np . array ([ 0 , drag_idx , grasp_idx , - 1 ])], ) def _plan_arm_traj ( times : np . ndarray , drag_start_time : float , drag_end_time : float , grasp_start_time : float , grasp_end_time : float , ) -> ArmTrajectory : \"\"\"Helper function for plan_arm_traj to compute the trajectory based on times transition indices Args: times (np.ndarray): Trajectory time information, shape (n_timesteps,) drag_start_time (float): Time to start the arm dragging motion (usually 0) drag_end_time (float): Time to end the arm dragging motion grasp_start_time (float): Time to start the arm grasping motion grasp_end_time (float): Time to end the arm grasping motion (usually the final time) Returns: ArmTrajectory: Positional trajectory for the arm (shoulder joint only) \"\"\" # Shoulder joint parameters for Astrobee grasp_angle = 0 drag_angle = - 1.57079 shoulder_index = 1 drag_start_id = np . searchsorted ( times , drag_start_time ) drag_end_id = np . searchsorted ( times , drag_end_time ) grasp_start_id = np . searchsorted ( times , grasp_start_time ) grasp_end_id = np . searchsorted ( times , grasp_end_time ) # Edge case: in case the grasp end time is greater than the last time grasp_end_id = min ( len ( times ) - 1 , grasp_end_id ) # Generate polynomials to define the motions within their respective time periods drag_poly = fifth_order_poly ( drag_start_time , drag_end_time , grasp_angle , drag_angle , 0 , 0 , 0 , 0 ) grasp_poly = fifth_order_poly ( grasp_start_time , grasp_end_time , drag_angle , grasp_angle , 0 , 0 , 0 , 0 ) arm_motion = np . ones_like ( times ) * drag_angle arm_motion [ drag_start_id : drag_end_id + 1 ] = drag_poly ( times [ drag_start_id : drag_end_id + 1 ] ) arm_motion [ grasp_start_id : grasp_end_id + 1 ] = grasp_poly ( times [ grasp_start_id : grasp_end_id + 1 ] ) # key_times = _get_arm_transition_times(base_traj) # Edge case for short trajectories: not enough time to fully move arm there and back again overlap = drag_end_id > grasp_start_id if overlap : # Blend the two motions in the overlapping region overlap_poly = ( ( drag_poly - drag_angle ) + ( grasp_poly - drag_angle ) ) + drag_angle arm_motion [ grasp_start_id : drag_end_id + 1 ] = np . clip ( overlap_poly ( times [ grasp_start_id : drag_end_id + 1 ]), drag_angle , grasp_angle , ) key_times = { \"begin_drag_motion\" : drag_start_time , \"end_drag_motion\" : drag_end_time , \"begin_grasp_motion\" : grasp_start_time , \"end_grasp_motion\" : grasp_end_time , } return ArmTrajectory ( arm_motion , [ shoulder_index ], times , key_times ) def _main (): # Quick test/example to make sure that the polynomials blend properly at the transition times times = np . linspace ( 0 , 10 , 1000 ) traj = _plan_arm_traj ( times , 0 , 3 , 7 , 10 ) traj . plot () if __name__ == \"__main__\" : _main () Functions plan_arm_traj def plan_arm_traj ( base_traj : pyastrobee . trajectories . trajectory . Trajectory ) -> pyastrobee . trajectories . trajectory . ArmTrajectory Plans a motion for the arm so that we are dragging the bag behind the robot for most of the trajectory, but we start and end from the grasping position This will only use the shoulder joint -- other joints are less relevant for the motion of the bag/robot system This is essentially comprised of three parts: 1) Moving the arm from an initial grasp position to the \"dragging behind\" position 2) Maintaining the \"dragging behind\" position for most of the trajectory 3) Moving the arm to the grasp position again at the end of the trajectory Parameters: Name Type Description Default base_traj Trajectory Trajectory of the Astrobee base None Returns: Type Description ArmTrajectory Positional trajectory for the arm (shoulder joint only) View Source def plan_arm_traj(base_traj: Trajectory) -> ArmTrajectory: \"\"\"Plans a motion for the arm so that we are dragging the bag behind the robot for most of the trajectory, but we start and end from the grasping position This will only use the shoulder joint -- other joints are less relevant for the motion of the bag/robot system This is essentially comprised of three parts: 1) Moving the arm from an initial grasp position to the \"dragging behind\" position 2) Maintaining the \"dragging behind\" position for most of the trajectory 3) Moving the arm to the grasp position again at the end of the trajectory Args: base_traj (Trajectory): Trajectory of the Astrobee base Returns: ArmTrajectory: Positional trajectory for the arm (shoulder joint only) \"\"\" times, transition_idxs = _get_arm_transition_times(base_traj) return _plan_arm_traj(times, *transition_idxs)","title":"Arm Planner"},{"location":"reference/pyastrobee/trajectories/arm_planner/#module-pyastrobeetrajectoriesarm_planner","text":"Planning (relatively simple) trajectories for the arm during the manipulation motion View Source \"\"\"Planning (relatively simple) trajectories for the arm during the manipulation motion\"\"\" # Note: Some of the methods here are separated out into separate functions so we can test them individually import numpy as np from pyastrobee.trajectories.polynomials import fifth_order_poly from pyastrobee.trajectories.trajectory import Trajectory , ArmTrajectory def plan_arm_traj ( base_traj : Trajectory ) -> ArmTrajectory : \"\"\"Plans a motion for the arm so that we are dragging the bag behind the robot for most of the trajectory, but we start and end from the grasping position This will only use the shoulder joint -- other joints are less relevant for the motion of the bag/robot system This is essentially comprised of three parts: 1) Moving the arm from an initial grasp position to the \"dragging behind\" position 2) Maintaining the \"dragging behind\" position for most of the trajectory 3) Moving the arm to the grasp position again at the end of the trajectory Args: base_traj (Trajectory): Trajectory of the Astrobee base Returns: ArmTrajectory: Positional trajectory for the arm (shoulder joint only) \"\"\" times , transition_idxs = _get_arm_transition_times ( base_traj ) return _plan_arm_traj ( times , * transition_idxs ) def _get_arm_transition_times ( base_traj : Trajectory ) -> tuple [ np . ndarray , np . ndarray ]: \"\"\"Determine the transition times for the bag manipulation arm motions This will assume that we start in the \"grasp\" position, transition to \"drag\" for most of the trajectory, and then return to the \"grasp\" position when we're at the end These transition times will depend on how fast we're moving with the base - in essence, we want these arm motions to complete once the base travels a certain distance - so that the motion of the base and the arm work together and don't lead to excessive disturbances Args: base_traj (Trajectory): Trajectory for the Astrobee base Returns: tuple[np.ndarray, np.ndarray]: np.ndarray: Time information for the full trajectory np.ndarray: Transition times for each motion: \"begin_drag_motion\", \"end_drag_motion\", \"begin_grasp_motion\", and \"end_grasp_motion\" \"\"\" dists_from_start = np . linalg . norm ( base_traj . positions - base_traj . positions [ 0 ], axis = 1 ) dists_from_end = np . linalg . norm ( base_traj . positions - base_traj . positions [ - 1 ], axis = 1 ) # A little over 1 meter seems to work well for the deployment distance (TODO probably needs tuning) # For reference, the 0.23 number is how much the x position of the arm changes when it moves back dx_arm = 0.23162640743995172 * 5 # Note: originally I used searchsorted to find these indices, but these distances are not guaranteed to be sorted # if the trajectory has a lot of curvature drag_idx = np . flatnonzero ( dists_from_start >= dx_arm )[ 0 ] grasp_idx = np . flatnonzero ( dists_from_end <= dx_arm )[ 0 ] return ( base_traj . times , base_traj . times [ np . array ([ 0 , drag_idx , grasp_idx , - 1 ])], ) def _plan_arm_traj ( times : np . ndarray , drag_start_time : float , drag_end_time : float , grasp_start_time : float , grasp_end_time : float , ) -> ArmTrajectory : \"\"\"Helper function for plan_arm_traj to compute the trajectory based on times transition indices Args: times (np.ndarray): Trajectory time information, shape (n_timesteps,) drag_start_time (float): Time to start the arm dragging motion (usually 0) drag_end_time (float): Time to end the arm dragging motion grasp_start_time (float): Time to start the arm grasping motion grasp_end_time (float): Time to end the arm grasping motion (usually the final time) Returns: ArmTrajectory: Positional trajectory for the arm (shoulder joint only) \"\"\" # Shoulder joint parameters for Astrobee grasp_angle = 0 drag_angle = - 1.57079 shoulder_index = 1 drag_start_id = np . searchsorted ( times , drag_start_time ) drag_end_id = np . searchsorted ( times , drag_end_time ) grasp_start_id = np . searchsorted ( times , grasp_start_time ) grasp_end_id = np . searchsorted ( times , grasp_end_time ) # Edge case: in case the grasp end time is greater than the last time grasp_end_id = min ( len ( times ) - 1 , grasp_end_id ) # Generate polynomials to define the motions within their respective time periods drag_poly = fifth_order_poly ( drag_start_time , drag_end_time , grasp_angle , drag_angle , 0 , 0 , 0 , 0 ) grasp_poly = fifth_order_poly ( grasp_start_time , grasp_end_time , drag_angle , grasp_angle , 0 , 0 , 0 , 0 ) arm_motion = np . ones_like ( times ) * drag_angle arm_motion [ drag_start_id : drag_end_id + 1 ] = drag_poly ( times [ drag_start_id : drag_end_id + 1 ] ) arm_motion [ grasp_start_id : grasp_end_id + 1 ] = grasp_poly ( times [ grasp_start_id : grasp_end_id + 1 ] ) # key_times = _get_arm_transition_times(base_traj) # Edge case for short trajectories: not enough time to fully move arm there and back again overlap = drag_end_id > grasp_start_id if overlap : # Blend the two motions in the overlapping region overlap_poly = ( ( drag_poly - drag_angle ) + ( grasp_poly - drag_angle ) ) + drag_angle arm_motion [ grasp_start_id : drag_end_id + 1 ] = np . clip ( overlap_poly ( times [ grasp_start_id : drag_end_id + 1 ]), drag_angle , grasp_angle , ) key_times = { \"begin_drag_motion\" : drag_start_time , \"end_drag_motion\" : drag_end_time , \"begin_grasp_motion\" : grasp_start_time , \"end_grasp_motion\" : grasp_end_time , } return ArmTrajectory ( arm_motion , [ shoulder_index ], times , key_times ) def _main (): # Quick test/example to make sure that the polynomials blend properly at the transition times times = np . linspace ( 0 , 10 , 1000 ) traj = _plan_arm_traj ( times , 0 , 3 , 7 , 10 ) traj . plot () if __name__ == \"__main__\" : _main ()","title":"Module pyastrobee.trajectories.arm_planner"},{"location":"reference/pyastrobee/trajectories/arm_planner/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/trajectories/arm_planner/#plan_arm_traj","text":"def plan_arm_traj ( base_traj : pyastrobee . trajectories . trajectory . Trajectory ) -> pyastrobee . trajectories . trajectory . ArmTrajectory Plans a motion for the arm so that we are dragging the bag behind the robot for most of the trajectory, but we start and end from the grasping position This will only use the shoulder joint -- other joints are less relevant for the motion of the bag/robot system This is essentially comprised of three parts: 1) Moving the arm from an initial grasp position to the \"dragging behind\" position 2) Maintaining the \"dragging behind\" position for most of the trajectory 3) Moving the arm to the grasp position again at the end of the trajectory Parameters: Name Type Description Default base_traj Trajectory Trajectory of the Astrobee base None Returns: Type Description ArmTrajectory Positional trajectory for the arm (shoulder joint only) View Source def plan_arm_traj(base_traj: Trajectory) -> ArmTrajectory: \"\"\"Plans a motion for the arm so that we are dragging the bag behind the robot for most of the trajectory, but we start and end from the grasping position This will only use the shoulder joint -- other joints are less relevant for the motion of the bag/robot system This is essentially comprised of three parts: 1) Moving the arm from an initial grasp position to the \"dragging behind\" position 2) Maintaining the \"dragging behind\" position for most of the trajectory 3) Moving the arm to the grasp position again at the end of the trajectory Args: base_traj (Trajectory): Trajectory of the Astrobee base Returns: ArmTrajectory: Positional trajectory for the arm (shoulder joint only) \"\"\" times, transition_idxs = _get_arm_transition_times(base_traj) return _plan_arm_traj(times, *transition_idxs)","title":"plan_arm_traj"},{"location":"reference/pyastrobee/trajectories/bezier/","text":"Module pyastrobee.trajectories.bezier Generating trajectories using Bezier curves and Bernstein polynomials When compared with polynomial trajectories, these are: - More numerically stable during optimization - Easier to formulate constraints on maximum velocity, acceleration, ... - Easier to formulate cost functions (such as minimizing jerk) - Easier to specify motions within a safe convex set Imposing constraints on the curve and its derivatives: - This is quite simple. If we have boundary conditions on position, for instance, we can constraint the start and end points of the curve to our desired start/end positions. - Likewise, the derivative of a Bezier curve is also a Bezier curve (of lower order: M-1), so we can constrain the start/end points of the derivative curve to meet constraints on the derivative (velocity, for instance) - This can be extended to higher-order derivatives, provided that the original curve is of a high-enough order so that the reduced-order derivative curves still have enough control points to meet the constraints. Cost function: - The squared L2 norm of a Bezier curve is a natural (convex, quadratic) choice for a cost function. If we are minimizing jerk, for instance, we can use the third-derivative of a position curve with this function Safe motion: - If the free space is defined as a convex set, we can enforce that the trajectory remains within the free space by constraining the control points to remain in free space. Since the Bezier curve is contained within the convex hull of the control points, this ensures that the entire curve is in free space. Stephen Boyd and Tobia Marcucci recommended using these. Refer to \"Fast Path Planning Through Large Collections of Safe Boxes\" for more info, as well as Tobia's repository https://github.com/cvxgrp/fastpathplanning/ View Source \"\"\"Generating trajectories using Bezier curves and Bernstein polynomials When compared with polynomial trajectories, these are: - More numerically stable during optimization - Easier to formulate constraints on maximum velocity, acceleration, ... - Easier to formulate cost functions (such as minimizing jerk) - Easier to specify motions within a safe convex set Imposing constraints on the curve and its derivatives: - This is quite simple. If we have boundary conditions on position, for instance, we can constraint the start and end points of the curve to our desired start/end positions. - Likewise, the derivative of a Bezier curve is also a Bezier curve (of lower order: M-1), so we can constrain the start/end points of the derivative curve to meet constraints on the derivative (velocity, for instance) - This can be extended to higher-order derivatives, provided that the original curve is of a high-enough order so that the reduced-order derivative curves still have enough control points to meet the constraints. Cost function: - The squared L2 norm of a Bezier curve is a natural (convex, quadratic) choice for a cost function. If we are minimizing jerk, for instance, we can use the third-derivative of a position curve with this function Safe motion: - If the free space is defined as a convex set, we can enforce that the trajectory remains within the free space by constraining the control points to remain in free space. Since the Bezier curve is contained within the convex hull of the control points, this ensures that the entire curve is in free space. Stephen Boyd and Tobia Marcucci recommended using these. Refer to \"Fast Path Planning Through Large Collections of Safe Boxes\" for more info, as well as Tobia's repository https://github.com/cvxgrp/fastpathplanning/ \"\"\" # TODO # - The L2 squared metric seems to be nonconvex if the total duration of the curve is also an optimization variable... # See if there is a better way to formulate this from typing import Optional, Union import numpy as np import numpy.typing as npt import cvxpy as cp from scipy.special import binom import matplotlib.pyplot as plt from pyastrobee.utils.boxes import Box from pyastrobee.utils.errors import OptimizationError class BezierCurve: \"\"\"Bezier curve class for evaluating a curve, the basis polynomials, and its derivative To evaluate the curve at points t, call it with curve(t) On initialization, for a standard \"unit-time\" curve, set a = 0 and b = 1 Args: points (Union[cp.Variable, cp.Expression, np.ndarray]): Control points, or a cvxpy Variable/Expression of the control points. Shape (n_pts, dimension) a (float): Lower limit of the curve interval b (Union[float, cp.Variable, cp.Expression]): Upper limit of the curve interval. Variable if we are also optimizing the duration of the curve \"\"\" def __init__( self, points: Union[cp.Variable, cp.Expression, np.ndarray], a: float, b: Union[float, cp.Variable, cp.Expression], ): if not isinstance(b, (cp.Variable, cp.Expression)) and b < a: raise ValueError(f\"Invalid interval limits: ({a}, {b})\") self.points = points self.h = points.shape[0] - 1 # Degree of the curve (AKA M in Tobia's paper) self.d = points.shape[1] # Dimension of the space self.a = a # Lower interval limit self.b = b # Upper interval limit self.duration = b - a def __call__(self, t: Union[float, npt.ArrayLike]) - > np.ndarray: \"\"\"Evaluates the Bezier curve (a sum of Bernstein polynomials) at specified points Args: t (Union[float, npt.ArrayLike]): Evaluation points (for instance, trajectory times) Returns: np.ndarray: Points along the curve, shape (n_pts, dimension) \"\"\" c = np.array([self._bernstein(t, n) for n in range(self.h + 1)]) return c.T @ self.points def _bernstein(self, t: Union[float, npt.ArrayLike], n: int) -> npt.ArrayLike: \"\"\"Wrapper around the Bernstein polynomial function, using attributes of self@BezierCurve Args: t (Union[float, npt.ArrayLike]): Evaluation point(s) (for instance, trajectory times) n (int): Index of the Bernstein polynomial Returns: npt.ArrayLike: Evaluation(s) of the bernstein polynomial at point(s) t. Returns a float if t is a float, otherwise will return an array of evaluations \"\"\" return bernstein(self.h, n, self.a, self.b, t) @property def start_point(self) -> Union[np.ndarray, cp.Variable, cp.Expression]: \"\"\"Starting control point of the Bezier curve\"\"\" return self.points[0] @property def end_point(self) -> Union[np.ndarray, cp.Variable, cp.Expression]: \"\"\"Ending control point of the Bezier curve\"\"\" return self.points[-1] @property def derivative(self) -> \"BezierCurve\": \"\"\"Derivative of the Bezier curve (A Bezier curve of degree h-1)\"\"\" if isinstance(self.duration, (cp.Variable, cp.Expression)): points = ( (self.points[1:] - self.points[:-1]) * self.h * cp.inv_pos(self.duration) ) else: points = (self.points[1:] - self.points[:-1]) * (self.h / self.duration) return BezierCurve(points, self.a, self.b) @property def l2_squared(self) -> Union[float, cp.Expression]: \"\"\"Squared L2 norm of the curve\"\"\" A = np.zeros((self.h + 1, self.h + 1)) for m in range(self.h + 1): for n in range(self.h + 1): A[m, n] = binom(self.h, m) * binom(self.h, n) / binom(2 * self.h, m + n) if isinstance(self.duration, (cp.Variable, cp.Expression)): A = cp.multiply(A, self.duration / (2 * self.h + 1)) A = cp.kron(A, np.eye(self.d)) else: A *= self.duration / (2 * self.h + 1) A = np.kron(A, np.eye(self.d)) if isinstance(self.points, (cp.Variable, cp.Expression)): # Note: CVXPY flattens matrices by columns rather than rows (opposite of numpy) # So, flatten based on the transpose to make the math consistent p = self.points.T.flatten() return cp.quad_form(p, cp.psd_wrap(A)) elif isinstance(A, (cp.Variable, cp.Expression)): p = self.points.flatten() return cp.quad_form(p, cp.psd_wrap(A)) else: # Numpy p = self.points.flatten() return p.dot(A.dot(p)) @property def control_points_pathlength(self) -> Union[float, cp.Expression]: \"\"\"Sum of the distances between consecutive control points This is an upper bound on the length of the curve itself, so we can use this in a cost function if we are trying to minimize the pathlength of a trajectory Returns: Union[float, cp.Expression]: Float if the points are a numpy array, otherwise yields a (convex, nonnegative) expression for this length \"\"\" if isinstance(self.points, (cp.Variable, cp.Expression)): length = 0 for i in range(self.h): length += cp.norm2(self.points[i + 1] - self.points[i]) return length else: return np.sum(np.linalg.norm(np.gradient(self.points, axis=0), axis=1)) def bernstein( h: int, n: int, a: float, b: Union[float, cp.Variable, cp.Expression], t: Union[float, npt.ArrayLike], ) -> npt.ArrayLike: \"\"\"Evaluate the nth Bernstein polynomial of degree h at a point (points) t Args: h (int): Degree of the Bernstein basis n (int): Index of the Bernstein polynomial a (float): Interval minimum value (e.g. starting time of trajectory) b (float): Interval maximum value (e.g. ending time of trajectory) t (Union[float, npt.ArrayLike]): Evaluation point(s) (for instance, trajectory times) Returns: npt.ArrayLike: Evaluation(s) of the Bernstein polynomial at point(s) t. Returns a float if t is a float, otherwise will return an array of evaluations \"\"\" if n > h: raise ValueError( \"Bernstein polynomial index cannot be larger than the degree of the basis\" ) if np.ndim(t) >= 0: t = np.asarray(t) if not isinstance(b, (cp.Variable, cp.Expression)): if b < = a: raise ValueError(f\"Invalid interval limits: ({a}, {b})\") if not (np.all(a < = t) and np.all(t < = b)): raise ValueError( \"Cannot evaluate at points outside of the specified interval\" ) return binom(h, n) * ((t - a) / (b - a)) ** n * ((b - t) / (b - a)) ** (h - n) def bezier_trajectory( p0: npt.ArrayLike, pf: npt.ArrayLike, t0: float, tf: float, n_control_pts: int, v0: Optional[npt.ArrayLike] = None, vf: Optional[npt.ArrayLike] = None, a0: Optional[npt.ArrayLike] = None, af: Optional[npt.ArrayLike] = None, box: Optional[Box] = None, v_max: Optional[float] = None, a_max: Optional[float] = None, time_weight: float = 0, ) -> tuple[BezierCurve, float]: \"\"\"Evaluate an optimal min-jerk trajectory based on Bezier curves which meets the specified constraints Args: p0 (npt.ArrayLike): Initial position, shape (3,) pf (npt.ArrayLike): Final position, shape (3,) t0 (float): Starting time tf (float): Ending time n_control_pts (int): Number of control points for the Bezier curve. Must be >= to the number of constraints, and should not be too large (>15ish) as this can reduce optimization performance. 6-10 is usually good v0 (Optional[npt.ArrayLike]): Initial velocity, shape (3,). Defaults to None (unconstrained) vf (Optional[npt.ArrayLike]): Final velocity, shape (3,). Defaults to None (unconstrained) a0 (Optional[npt.ArrayLike]): Initial acceleration, shape (3,). Defaults to None (unconstrained) af (Optional[npt.ArrayLike]): Final acceleration, shape (3,). Defaults to None (unconstrained) box (Optional[Box]): Box constraint on (lower, upper) position bounds. Defaults to None (unconstrained) v_max (Optional[float]): Maximum L2 norm of the velocity. Defaults to None (unconstrained) a_max (Optional[float]): Maximum L2 norm of the acceleration. Defaults to None (unconstrained) time_weight (float, optional): Objective function weight corresponding to a linear penalty on the duration. Defaults to 0 (minimize jerk only). Note: this should be > 0 if evaluating the free-final-time case Raises: OptimizationError: If the optimization failed to find a valid solution (typically this is due to constraints which are too restrictive) Returns: tuple[BezierCurve, float]: BezierCurve: The optimal curve for the position component of the trajectory. Note: derivatives can be evaluated using the curve.derivative property float: The optimal cost of the objective function \"\"\" # Check inputs n_constraints = sum(c is not None for c in [p0, pf, v0, vf, a0, af]) if n_constraints > n_control_pts: raise ValueError( \"Number of control points must be at least the number of constraints\" ) if tf < = t0: raise ValueError(f\"Invalid time interval: ({t0}, {tf})\") dim = len(p0) # Form the main Variable (the control points for the position curve) and get the Expressions # for the control points of the derivative curves pos_pts = cp.Variable((n_control_pts, dim)) pos_curve = BezierCurve(pos_pts, t0, tf) vel_curve = pos_curve.derivative vel_pts = vel_curve.points accel_curve = vel_curve.derivative accel_pts = accel_curve.points jerk_curve = accel_curve.derivative # Form the constraint list depending on what was specified in the inputs constraints = [pos_pts[0] == p0, pos_pts[-1] == pf] if v0 is not None: constraints.append(vel_pts[0] == v0) if vf is not None: constraints.append(vel_pts[-1] == vf) if a0 is not None: constraints.append(accel_pts[0] == a0) if af is not None: constraints.append(accel_pts[-1] == af) if box is not None: lower, upper = box constraints.append(pos_pts >= np.tile(lower, (n_control_pts, 1))) constraints.append(pos_pts < = np.tile(upper, (n_control_pts, 1))) if v_max is not None: constraints.append(cp.norm2(vel_pts, axis=1) < = v_max) if a_max is not None: constraints.append(cp.norm2(accel_pts, axis=1) < = a_max) # Objective function criteria jerk = jerk_curve.l2_squared # Form the objective function based on the relative weighting between the criteria objective = cp.Minimize(jerk + time_weight * (tf - t0)) # Form the problem and solve it # Note: Clarabel is apparently better for quadratic objectives (like our jerk criteria) prob = cp.Problem(objective, constraints) try: prob.solve(solver=cp.CLARABEL) except cp.error.SolverError as e: raise OptimizationError(\"Cannot generate the trajectory - Solver error!\") from e if prob.status != cp.OPTIMAL: raise OptimizationError( f\"Unable to generate the trajectory (solver status: {prob.status}).\\n\" + \"Check on the feasibility of the constraints\" ) # Construct the Bezier curve from the solved control points return BezierCurve(pos_pts.value, t0, tf), prob.value def _test_plot_bernstein_polys(): \"\"\"Example to visualize Bernstein polynomials of various degrees\"\"\" a = 0 b = 10 n = 50 t = np.linspace(a, b, n, endpoint=True) M = 4 fig = plt.figure() for n in range(M + 1): evals = bernstein(M, n, a, b, t) plt.plot(t, evals, label=str(n)) plt.legend() plt.title(\"Bernstein Polynomials\") plt.show() if __name__ == \"__main__\": _test_plot_bernstein_polys() Variables binom Functions bernstein def bernstein ( h : int , n : int , a : float , b : Union [ float , cvxpy . expressions . variable . Variable , cvxpy . expressions . expression . Expression ], t : Union [ float , numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] Evaluate the nth Bernstein polynomial of degree h at a point (points) t Parameters: Name Type Description Default h int Degree of the Bernstein basis None n int Index of the Bernstein polynomial None a float Interval minimum value (e.g. starting time of trajectory) None b float Interval maximum value (e.g. ending time of trajectory) None t Union[float, npt.ArrayLike] Evaluation point(s) (for instance, trajectory times) None Returns: Type Description npt.ArrayLike Evaluation(s) of the Bernstein polynomial at point(s) t. Returns a float if t is a float, otherwise will return an array of evaluations View Source def bernstein( h: int, n: int, a: float, b: Union[float, cp.Variable, cp.Expression], t: Union[float, npt.ArrayLike], ) -> npt.ArrayLike: \"\"\"Evaluate the nth Bernstein polynomial of degree h at a point (points) t Args: h (int): Degree of the Bernstein basis n (int): Index of the Bernstein polynomial a (float): Interval minimum value (e.g. starting time of trajectory) b (float): Interval maximum value (e.g. ending time of trajectory) t (Union[float, npt.ArrayLike]): Evaluation point(s) (for instance, trajectory times) Returns: npt.ArrayLike: Evaluation(s) of the Bernstein polynomial at point(s) t. Returns a float if t is a float, otherwise will return an array of evaluations \"\"\" if n > h: raise ValueError( \"Bernstein polynomial index cannot be larger than the degree of the basis\" ) if np.ndim(t) >= 0: t = np.asarray(t) if not isinstance(b, (cp.Variable, cp.Expression)): if b < = a: raise ValueError(f\"Invalid interval limits: ({a}, {b})\") if not (np.all(a < = t) and np.all(t < = b)): raise ValueError( \"Cannot evaluate at points outside of the specified interval\" ) return binom(h, n) * ((t - a) / (b - a)) ** n * ((b - t) / (b - a)) ** (h - n) bezier_trajectory def bezier_trajectory ( p0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], t0 : float , tf : float , n_control_pts : int , v0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , vf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , a0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , af : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , box : Optional [ pyastrobee . utils . boxes . Box ] = None , v_max : Optional [ float ] = None , a_max : Optional [ float ] = None , time_weight : float = 0 ) -> tuple [ pyastrobee . trajectories . bezier . BezierCurve , float ] Evaluate an optimal min-jerk trajectory based on Bezier curves which meets the specified constraints Parameters: Name Type Description Default p0 npt.ArrayLike Initial position, shape (3,) None pf npt.ArrayLike Final position, shape (3,) None t0 float Starting time None tf float Ending time None n_control_pts int Number of control points for the Bezier curve. Must be >= to the number of constraints, and should not be too large (>15ish) as this can reduce optimization performance. 6-10 is usually good None v0 Optional[npt.ArrayLike] Initial velocity, shape (3,). Defaults to None (unconstrained) None vf Optional[npt.ArrayLike] Final velocity, shape (3,). Defaults to None (unconstrained) None a0 Optional[npt.ArrayLike] Initial acceleration, shape (3,). Defaults to None (unconstrained) None af Optional[npt.ArrayLike] Final acceleration, shape (3,). Defaults to None (unconstrained) None box Optional[Box] Box constraint on (lower, upper) position bounds. Defaults to None (unconstrained) None v_max Optional[float] Maximum L2 norm of the velocity. Defaults to None (unconstrained) None a_max Optional[float] Maximum L2 norm of the acceleration. Defaults to None (unconstrained) None time_weight float Objective function weight corresponding to a linear penalty on the duration. Defaults to 0 (minimize jerk only). Note: this should be > 0 if evaluating the free-final-time case None Returns: Type Description tuple[BezierCurve, float] BezierCurve: The optimal curve for the position component of the trajectory. Note: derivatives can be evaluated using the curve.derivative property float: The optimal cost of the objective function Raises: Type Description OptimizationError If the optimization failed to find a valid solution (typically this is due to constraints which are too restrictive) View Source def bezier_trajectory ( p0 : npt . ArrayLike , pf : npt . ArrayLike , t0 : float , tf : float , n_control_pts : int , v0 : Optional [ npt.ArrayLike ] = None , vf : Optional [ npt.ArrayLike ] = None , a0 : Optional [ npt.ArrayLike ] = None , af : Optional [ npt.ArrayLike ] = None , box : Optional [ Box ] = None , v_max : Optional [ float ] = None , a_max : Optional [ float ] = None , time_weight : float = 0 , ) -> tuple [ BezierCurve, float ] : \"\"\"Evaluate an optimal min-jerk trajectory based on Bezier curves which meets the specified constraints Args: p0 (npt.ArrayLike): Initial position, shape (3,) pf (npt.ArrayLike): Final position, shape (3,) t0 (float): Starting time tf (float): Ending time n_control_pts (int): Number of control points for the Bezier curve. Must be >= to the number of constraints, and should not be too large (>15ish) as this can reduce optimization performance. 6-10 is usually good v0 (Optional[npt.ArrayLike]): Initial velocity, shape (3,). Defaults to None (unconstrained) vf (Optional[npt.ArrayLike]): Final velocity, shape (3,). Defaults to None (unconstrained) a0 (Optional[npt.ArrayLike]): Initial acceleration, shape (3,). Defaults to None (unconstrained) af (Optional[npt.ArrayLike]): Final acceleration, shape (3,). Defaults to None (unconstrained) box (Optional[Box]): Box constraint on (lower, upper) position bounds. Defaults to None (unconstrained) v_max (Optional[float]): Maximum L2 norm of the velocity. Defaults to None (unconstrained) a_max (Optional[float]): Maximum L2 norm of the acceleration. Defaults to None (unconstrained) time_weight (float, optional): Objective function weight corresponding to a linear penalty on the duration. Defaults to 0 (minimize jerk only). Note: this should be > 0 if evaluating the free-final-time case Raises: OptimizationError: If the optimization failed to find a valid solution (typically this is due to constraints which are too restrictive) Returns: tuple[BezierCurve, float]: BezierCurve: The optimal curve for the position component of the trajectory. Note: derivatives can be evaluated using the curve.derivative property float: The optimal cost of the objective function \"\"\" # Check inputs n_constraints = sum ( c is not None for c in [ p0, pf, v0, vf, a0, af ] ) if n_constraints > n_control_pts : raise ValueError ( \"Number of control points must be at least the number of constraints\" ) if tf <= t0 : raise ValueError ( f \"Invalid time interval: ({t0}, {tf})\" ) dim = len ( p0 ) # Form the main Variable ( the control points for the position curve ) and get the Expressions # for the control points of the derivative curves pos_pts = cp . Variable (( n_control_pts , dim )) pos_curve = BezierCurve ( pos_pts , t0 , tf ) vel_curve = pos_curve . derivative vel_pts = vel_curve . points accel_curve = vel_curve . derivative accel_pts = accel_curve . points jerk_curve = accel_curve . derivative # Form the constraint list depending on what was specified in the inputs constraints = [ pos_pts[0 ] == p0 , pos_pts [ -1 ] == pf ] if v0 is not None : constraints . append ( vel_pts [ 0 ] == v0 ) if vf is not None : constraints . append ( vel_pts [ -1 ] == vf ) if a0 is not None : constraints . append ( accel_pts [ 0 ] == a0 ) if af is not None : constraints . append ( accel_pts [ -1 ] == af ) if box is not None : lower , upper = box constraints . append ( pos_pts >= np . tile ( lower , ( n_control_pts , 1 ))) constraints . append ( pos_pts <= np . tile ( upper , ( n_control_pts , 1 ))) if v_max is not None : constraints . append ( cp . norm2 ( vel_pts , axis = 1 ) <= v_max ) if a_max is not None : constraints . append ( cp . norm2 ( accel_pts , axis = 1 ) <= a_max ) # Objective function criteria jerk = jerk_curve . l2_squared # Form the objective function based on the relative weighting between the criteria objective = cp . Minimize ( jerk + time_weight * ( tf - t0 )) # Form the problem and solve it # Note : Clarabel is apparently better for quadratic objectives ( like our jerk criteria ) prob = cp . Problem ( objective , constraints ) try : prob . solve ( solver = cp . CLARABEL ) except cp . error . SolverError as e : raise OptimizationError ( \"Cannot generate the trajectory - Solver error!\" ) from e if prob . status != cp . OPTIMAL : raise OptimizationError ( f \"Unable to generate the trajectory (solver status: {prob.status}).\\n\" + \"Check on the feasibility of the constraints\" ) # Construct the Bezier curve from the solved control points return BezierCurve ( pos_pts . value , t0 , tf ), prob . value Classes BezierCurve class BezierCurve ( points : Union [ cvxpy . expressions . variable . Variable , cvxpy . expressions . expression . Expression , numpy . ndarray ], a : float , b : Union [ float , cvxpy . expressions . variable . Variable , cvxpy . expressions . expression . Expression ] ) Bezier curve class for evaluating a curve, the basis polynomials, and its derivative To evaluate the curve at points t, call it with curve(t) On initialization, for a standard \"unit-time\" curve, set a = 0 and b = 1 Attributes Name Type Description Default points Union[cp.Variable, cp.Expression, np.ndarray] Control points, or a cvxpy Variable/Expression of the control points. Shape (n_pts, dimension) None a float Lower limit of the curve interval None b Union[float, cp.Variable, cp.Expression] Upper limit of the curve interval. Variable if we are also optimizing the duration of the curve None View Source class BezierCurve: \"\"\"Bezier curve class for evaluating a curve, the basis polynomials, and its derivative To evaluate the curve at points t, call it with curve(t) On initialization, for a standard \"unit-time\" curve, set a = 0 and b = 1 Args: points (Union[cp.Variable, cp.Expression, np.ndarray]): Control points, or a cvxpy Variable/Expression of the control points. Shape (n_pts, dimension) a (float): Lower limit of the curve interval b (Union[float, cp.Variable, cp.Expression]): Upper limit of the curve interval. Variable if we are also optimizing the duration of the curve \"\"\" def __init__( self, points: Union[cp.Variable, cp.Expression, np.ndarray], a: float, b: Union[float, cp.Variable, cp.Expression], ): if not isinstance(b, (cp.Variable, cp.Expression)) and b < a: raise ValueError(f\"Invalid interval limits: ({a}, {b})\") self.points = points self.h = points.shape[0] - 1 # Degree of the curve (AKA M in Tobia's paper) self.d = points.shape[1] # Dimension of the space self.a = a # Lower interval limit self.b = b # Upper interval limit self.duration = b - a def __call__(self, t: Union[float, npt.ArrayLike]) - > np.ndarray: \"\"\"Evaluates the Bezier curve (a sum of Bernstein polynomials) at specified points Args: t (Union[float, npt.ArrayLike]): Evaluation points (for instance, trajectory times) Returns: np.ndarray: Points along the curve, shape (n_pts, dimension) \"\"\" c = np.array([self._bernstein(t, n) for n in range(self.h + 1)]) return c.T @ self.points def _bernstein(self, t: Union[float, npt.ArrayLike], n: int) -> npt.ArrayLike: \"\"\"Wrapper around the Bernstein polynomial function, using attributes of self@BezierCurve Args: t (Union[float, npt.ArrayLike]): Evaluation point(s) (for instance, trajectory times) n (int): Index of the Bernstein polynomial Returns: npt.ArrayLike: Evaluation(s) of the bernstein polynomial at point(s) t. Returns a float if t is a float, otherwise will return an array of evaluations \"\"\" return bernstein(self.h, n, self.a, self.b, t) @property def start_point(self) -> Union[np.ndarray, cp.Variable, cp.Expression]: \"\"\"Starting control point of the Bezier curve\"\"\" return self.points[0] @property def end_point(self) -> Union[np.ndarray, cp.Variable, cp.Expression]: \"\"\"Ending control point of the Bezier curve\"\"\" return self.points[-1] @property def derivative(self) -> \"BezierCurve\": \"\"\"Derivative of the Bezier curve (A Bezier curve of degree h-1)\"\"\" if isinstance(self.duration, (cp.Variable, cp.Expression)): points = ( (self.points[1:] - self.points[:-1]) * self.h * cp.inv_pos(self.duration) ) else: points = (self.points[1:] - self.points[:-1]) * (self.h / self.duration) return BezierCurve(points, self.a, self.b) @property def l2_squared(self) -> Union[float, cp.Expression]: \"\"\"Squared L2 norm of the curve\"\"\" A = np.zeros((self.h + 1, self.h + 1)) for m in range(self.h + 1): for n in range(self.h + 1): A[m, n] = binom(self.h, m) * binom(self.h, n) / binom(2 * self.h, m + n) if isinstance(self.duration, (cp.Variable, cp.Expression)): A = cp.multiply(A, self.duration / (2 * self.h + 1)) A = cp.kron(A, np.eye(self.d)) else: A *= self.duration / (2 * self.h + 1) A = np.kron(A, np.eye(self.d)) if isinstance(self.points, (cp.Variable, cp.Expression)): # Note: CVXPY flattens matrices by columns rather than rows (opposite of numpy) # So, flatten based on the transpose to make the math consistent p = self.points.T.flatten() return cp.quad_form(p, cp.psd_wrap(A)) elif isinstance(A, (cp.Variable, cp.Expression)): p = self.points.flatten() return cp.quad_form(p, cp.psd_wrap(A)) else: # Numpy p = self.points.flatten() return p.dot(A.dot(p)) @property def control_points_pathlength(self) -> Union[float, cp.Expression]: \"\"\"Sum of the distances between consecutive control points This is an upper bound on the length of the curve itself, so we can use this in a cost function if we are trying to minimize the pathlength of a trajectory Returns: Union[float, cp.Expression]: Float if the points are a numpy array, otherwise yields a (convex, nonnegative) expression for this length \"\"\" if isinstance(self.points, (cp.Variable, cp.Expression)): length = 0 for i in range(self.h): length += cp.norm2(self.points[i + 1] - self.points[i]) return length else: return np.sum(np.linalg.norm(np.gradient(self.points, axis=0), axis=1)) Instance variables control_points_pathlength Sum of the distances between consecutive control points This is an upper bound on the length of the curve itself, so we can use this in a cost function if we are trying to minimize the pathlength of a trajectory derivative Derivative of the Bezier curve (A Bezier curve of degree h-1) end_point Ending control point of the Bezier curve l2_squared Squared L2 norm of the curve start_point Starting control point of the Bezier curve","title":"Bezier"},{"location":"reference/pyastrobee/trajectories/bezier/#module-pyastrobeetrajectoriesbezier","text":"Generating trajectories using Bezier curves and Bernstein polynomials When compared with polynomial trajectories, these are: - More numerically stable during optimization - Easier to formulate constraints on maximum velocity, acceleration, ... - Easier to formulate cost functions (such as minimizing jerk) - Easier to specify motions within a safe convex set Imposing constraints on the curve and its derivatives: - This is quite simple. If we have boundary conditions on position, for instance, we can constraint the start and end points of the curve to our desired start/end positions. - Likewise, the derivative of a Bezier curve is also a Bezier curve (of lower order: M-1), so we can constrain the start/end points of the derivative curve to meet constraints on the derivative (velocity, for instance) - This can be extended to higher-order derivatives, provided that the original curve is of a high-enough order so that the reduced-order derivative curves still have enough control points to meet the constraints. Cost function: - The squared L2 norm of a Bezier curve is a natural (convex, quadratic) choice for a cost function. If we are minimizing jerk, for instance, we can use the third-derivative of a position curve with this function Safe motion: - If the free space is defined as a convex set, we can enforce that the trajectory remains within the free space by constraining the control points to remain in free space. Since the Bezier curve is contained within the convex hull of the control points, this ensures that the entire curve is in free space. Stephen Boyd and Tobia Marcucci recommended using these. Refer to \"Fast Path Planning Through Large Collections of Safe Boxes\" for more info, as well as Tobia's repository https://github.com/cvxgrp/fastpathplanning/ View Source \"\"\"Generating trajectories using Bezier curves and Bernstein polynomials When compared with polynomial trajectories, these are: - More numerically stable during optimization - Easier to formulate constraints on maximum velocity, acceleration, ... - Easier to formulate cost functions (such as minimizing jerk) - Easier to specify motions within a safe convex set Imposing constraints on the curve and its derivatives: - This is quite simple. If we have boundary conditions on position, for instance, we can constraint the start and end points of the curve to our desired start/end positions. - Likewise, the derivative of a Bezier curve is also a Bezier curve (of lower order: M-1), so we can constrain the start/end points of the derivative curve to meet constraints on the derivative (velocity, for instance) - This can be extended to higher-order derivatives, provided that the original curve is of a high-enough order so that the reduced-order derivative curves still have enough control points to meet the constraints. Cost function: - The squared L2 norm of a Bezier curve is a natural (convex, quadratic) choice for a cost function. If we are minimizing jerk, for instance, we can use the third-derivative of a position curve with this function Safe motion: - If the free space is defined as a convex set, we can enforce that the trajectory remains within the free space by constraining the control points to remain in free space. Since the Bezier curve is contained within the convex hull of the control points, this ensures that the entire curve is in free space. Stephen Boyd and Tobia Marcucci recommended using these. Refer to \"Fast Path Planning Through Large Collections of Safe Boxes\" for more info, as well as Tobia's repository https://github.com/cvxgrp/fastpathplanning/ \"\"\" # TODO # - The L2 squared metric seems to be nonconvex if the total duration of the curve is also an optimization variable... # See if there is a better way to formulate this from typing import Optional, Union import numpy as np import numpy.typing as npt import cvxpy as cp from scipy.special import binom import matplotlib.pyplot as plt from pyastrobee.utils.boxes import Box from pyastrobee.utils.errors import OptimizationError class BezierCurve: \"\"\"Bezier curve class for evaluating a curve, the basis polynomials, and its derivative To evaluate the curve at points t, call it with curve(t) On initialization, for a standard \"unit-time\" curve, set a = 0 and b = 1 Args: points (Union[cp.Variable, cp.Expression, np.ndarray]): Control points, or a cvxpy Variable/Expression of the control points. Shape (n_pts, dimension) a (float): Lower limit of the curve interval b (Union[float, cp.Variable, cp.Expression]): Upper limit of the curve interval. Variable if we are also optimizing the duration of the curve \"\"\" def __init__( self, points: Union[cp.Variable, cp.Expression, np.ndarray], a: float, b: Union[float, cp.Variable, cp.Expression], ): if not isinstance(b, (cp.Variable, cp.Expression)) and b < a: raise ValueError(f\"Invalid interval limits: ({a}, {b})\") self.points = points self.h = points.shape[0] - 1 # Degree of the curve (AKA M in Tobia's paper) self.d = points.shape[1] # Dimension of the space self.a = a # Lower interval limit self.b = b # Upper interval limit self.duration = b - a def __call__(self, t: Union[float, npt.ArrayLike]) - > np.ndarray: \"\"\"Evaluates the Bezier curve (a sum of Bernstein polynomials) at specified points Args: t (Union[float, npt.ArrayLike]): Evaluation points (for instance, trajectory times) Returns: np.ndarray: Points along the curve, shape (n_pts, dimension) \"\"\" c = np.array([self._bernstein(t, n) for n in range(self.h + 1)]) return c.T @ self.points def _bernstein(self, t: Union[float, npt.ArrayLike], n: int) -> npt.ArrayLike: \"\"\"Wrapper around the Bernstein polynomial function, using attributes of self@BezierCurve Args: t (Union[float, npt.ArrayLike]): Evaluation point(s) (for instance, trajectory times) n (int): Index of the Bernstein polynomial Returns: npt.ArrayLike: Evaluation(s) of the bernstein polynomial at point(s) t. Returns a float if t is a float, otherwise will return an array of evaluations \"\"\" return bernstein(self.h, n, self.a, self.b, t) @property def start_point(self) -> Union[np.ndarray, cp.Variable, cp.Expression]: \"\"\"Starting control point of the Bezier curve\"\"\" return self.points[0] @property def end_point(self) -> Union[np.ndarray, cp.Variable, cp.Expression]: \"\"\"Ending control point of the Bezier curve\"\"\" return self.points[-1] @property def derivative(self) -> \"BezierCurve\": \"\"\"Derivative of the Bezier curve (A Bezier curve of degree h-1)\"\"\" if isinstance(self.duration, (cp.Variable, cp.Expression)): points = ( (self.points[1:] - self.points[:-1]) * self.h * cp.inv_pos(self.duration) ) else: points = (self.points[1:] - self.points[:-1]) * (self.h / self.duration) return BezierCurve(points, self.a, self.b) @property def l2_squared(self) -> Union[float, cp.Expression]: \"\"\"Squared L2 norm of the curve\"\"\" A = np.zeros((self.h + 1, self.h + 1)) for m in range(self.h + 1): for n in range(self.h + 1): A[m, n] = binom(self.h, m) * binom(self.h, n) / binom(2 * self.h, m + n) if isinstance(self.duration, (cp.Variable, cp.Expression)): A = cp.multiply(A, self.duration / (2 * self.h + 1)) A = cp.kron(A, np.eye(self.d)) else: A *= self.duration / (2 * self.h + 1) A = np.kron(A, np.eye(self.d)) if isinstance(self.points, (cp.Variable, cp.Expression)): # Note: CVXPY flattens matrices by columns rather than rows (opposite of numpy) # So, flatten based on the transpose to make the math consistent p = self.points.T.flatten() return cp.quad_form(p, cp.psd_wrap(A)) elif isinstance(A, (cp.Variable, cp.Expression)): p = self.points.flatten() return cp.quad_form(p, cp.psd_wrap(A)) else: # Numpy p = self.points.flatten() return p.dot(A.dot(p)) @property def control_points_pathlength(self) -> Union[float, cp.Expression]: \"\"\"Sum of the distances between consecutive control points This is an upper bound on the length of the curve itself, so we can use this in a cost function if we are trying to minimize the pathlength of a trajectory Returns: Union[float, cp.Expression]: Float if the points are a numpy array, otherwise yields a (convex, nonnegative) expression for this length \"\"\" if isinstance(self.points, (cp.Variable, cp.Expression)): length = 0 for i in range(self.h): length += cp.norm2(self.points[i + 1] - self.points[i]) return length else: return np.sum(np.linalg.norm(np.gradient(self.points, axis=0), axis=1)) def bernstein( h: int, n: int, a: float, b: Union[float, cp.Variable, cp.Expression], t: Union[float, npt.ArrayLike], ) -> npt.ArrayLike: \"\"\"Evaluate the nth Bernstein polynomial of degree h at a point (points) t Args: h (int): Degree of the Bernstein basis n (int): Index of the Bernstein polynomial a (float): Interval minimum value (e.g. starting time of trajectory) b (float): Interval maximum value (e.g. ending time of trajectory) t (Union[float, npt.ArrayLike]): Evaluation point(s) (for instance, trajectory times) Returns: npt.ArrayLike: Evaluation(s) of the Bernstein polynomial at point(s) t. Returns a float if t is a float, otherwise will return an array of evaluations \"\"\" if n > h: raise ValueError( \"Bernstein polynomial index cannot be larger than the degree of the basis\" ) if np.ndim(t) >= 0: t = np.asarray(t) if not isinstance(b, (cp.Variable, cp.Expression)): if b < = a: raise ValueError(f\"Invalid interval limits: ({a}, {b})\") if not (np.all(a < = t) and np.all(t < = b)): raise ValueError( \"Cannot evaluate at points outside of the specified interval\" ) return binom(h, n) * ((t - a) / (b - a)) ** n * ((b - t) / (b - a)) ** (h - n) def bezier_trajectory( p0: npt.ArrayLike, pf: npt.ArrayLike, t0: float, tf: float, n_control_pts: int, v0: Optional[npt.ArrayLike] = None, vf: Optional[npt.ArrayLike] = None, a0: Optional[npt.ArrayLike] = None, af: Optional[npt.ArrayLike] = None, box: Optional[Box] = None, v_max: Optional[float] = None, a_max: Optional[float] = None, time_weight: float = 0, ) -> tuple[BezierCurve, float]: \"\"\"Evaluate an optimal min-jerk trajectory based on Bezier curves which meets the specified constraints Args: p0 (npt.ArrayLike): Initial position, shape (3,) pf (npt.ArrayLike): Final position, shape (3,) t0 (float): Starting time tf (float): Ending time n_control_pts (int): Number of control points for the Bezier curve. Must be >= to the number of constraints, and should not be too large (>15ish) as this can reduce optimization performance. 6-10 is usually good v0 (Optional[npt.ArrayLike]): Initial velocity, shape (3,). Defaults to None (unconstrained) vf (Optional[npt.ArrayLike]): Final velocity, shape (3,). Defaults to None (unconstrained) a0 (Optional[npt.ArrayLike]): Initial acceleration, shape (3,). Defaults to None (unconstrained) af (Optional[npt.ArrayLike]): Final acceleration, shape (3,). Defaults to None (unconstrained) box (Optional[Box]): Box constraint on (lower, upper) position bounds. Defaults to None (unconstrained) v_max (Optional[float]): Maximum L2 norm of the velocity. Defaults to None (unconstrained) a_max (Optional[float]): Maximum L2 norm of the acceleration. Defaults to None (unconstrained) time_weight (float, optional): Objective function weight corresponding to a linear penalty on the duration. Defaults to 0 (minimize jerk only). Note: this should be > 0 if evaluating the free-final-time case Raises: OptimizationError: If the optimization failed to find a valid solution (typically this is due to constraints which are too restrictive) Returns: tuple[BezierCurve, float]: BezierCurve: The optimal curve for the position component of the trajectory. Note: derivatives can be evaluated using the curve.derivative property float: The optimal cost of the objective function \"\"\" # Check inputs n_constraints = sum(c is not None for c in [p0, pf, v0, vf, a0, af]) if n_constraints > n_control_pts: raise ValueError( \"Number of control points must be at least the number of constraints\" ) if tf < = t0: raise ValueError(f\"Invalid time interval: ({t0}, {tf})\") dim = len(p0) # Form the main Variable (the control points for the position curve) and get the Expressions # for the control points of the derivative curves pos_pts = cp.Variable((n_control_pts, dim)) pos_curve = BezierCurve(pos_pts, t0, tf) vel_curve = pos_curve.derivative vel_pts = vel_curve.points accel_curve = vel_curve.derivative accel_pts = accel_curve.points jerk_curve = accel_curve.derivative # Form the constraint list depending on what was specified in the inputs constraints = [pos_pts[0] == p0, pos_pts[-1] == pf] if v0 is not None: constraints.append(vel_pts[0] == v0) if vf is not None: constraints.append(vel_pts[-1] == vf) if a0 is not None: constraints.append(accel_pts[0] == a0) if af is not None: constraints.append(accel_pts[-1] == af) if box is not None: lower, upper = box constraints.append(pos_pts >= np.tile(lower, (n_control_pts, 1))) constraints.append(pos_pts < = np.tile(upper, (n_control_pts, 1))) if v_max is not None: constraints.append(cp.norm2(vel_pts, axis=1) < = v_max) if a_max is not None: constraints.append(cp.norm2(accel_pts, axis=1) < = a_max) # Objective function criteria jerk = jerk_curve.l2_squared # Form the objective function based on the relative weighting between the criteria objective = cp.Minimize(jerk + time_weight * (tf - t0)) # Form the problem and solve it # Note: Clarabel is apparently better for quadratic objectives (like our jerk criteria) prob = cp.Problem(objective, constraints) try: prob.solve(solver=cp.CLARABEL) except cp.error.SolverError as e: raise OptimizationError(\"Cannot generate the trajectory - Solver error!\") from e if prob.status != cp.OPTIMAL: raise OptimizationError( f\"Unable to generate the trajectory (solver status: {prob.status}).\\n\" + \"Check on the feasibility of the constraints\" ) # Construct the Bezier curve from the solved control points return BezierCurve(pos_pts.value, t0, tf), prob.value def _test_plot_bernstein_polys(): \"\"\"Example to visualize Bernstein polynomials of various degrees\"\"\" a = 0 b = 10 n = 50 t = np.linspace(a, b, n, endpoint=True) M = 4 fig = plt.figure() for n in range(M + 1): evals = bernstein(M, n, a, b, t) plt.plot(t, evals, label=str(n)) plt.legend() plt.title(\"Bernstein Polynomials\") plt.show() if __name__ == \"__main__\": _test_plot_bernstein_polys()","title":"Module pyastrobee.trajectories.bezier"},{"location":"reference/pyastrobee/trajectories/bezier/#variables","text":"binom","title":"Variables"},{"location":"reference/pyastrobee/trajectories/bezier/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/trajectories/bezier/#bernstein","text":"def bernstein ( h : int , n : int , a : float , b : Union [ float , cvxpy . expressions . variable . Variable , cvxpy . expressions . expression . Expression ], t : Union [ float , numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] Evaluate the nth Bernstein polynomial of degree h at a point (points) t Parameters: Name Type Description Default h int Degree of the Bernstein basis None n int Index of the Bernstein polynomial None a float Interval minimum value (e.g. starting time of trajectory) None b float Interval maximum value (e.g. ending time of trajectory) None t Union[float, npt.ArrayLike] Evaluation point(s) (for instance, trajectory times) None Returns: Type Description npt.ArrayLike Evaluation(s) of the Bernstein polynomial at point(s) t. Returns a float if t is a float, otherwise will return an array of evaluations View Source def bernstein( h: int, n: int, a: float, b: Union[float, cp.Variable, cp.Expression], t: Union[float, npt.ArrayLike], ) -> npt.ArrayLike: \"\"\"Evaluate the nth Bernstein polynomial of degree h at a point (points) t Args: h (int): Degree of the Bernstein basis n (int): Index of the Bernstein polynomial a (float): Interval minimum value (e.g. starting time of trajectory) b (float): Interval maximum value (e.g. ending time of trajectory) t (Union[float, npt.ArrayLike]): Evaluation point(s) (for instance, trajectory times) Returns: npt.ArrayLike: Evaluation(s) of the Bernstein polynomial at point(s) t. Returns a float if t is a float, otherwise will return an array of evaluations \"\"\" if n > h: raise ValueError( \"Bernstein polynomial index cannot be larger than the degree of the basis\" ) if np.ndim(t) >= 0: t = np.asarray(t) if not isinstance(b, (cp.Variable, cp.Expression)): if b < = a: raise ValueError(f\"Invalid interval limits: ({a}, {b})\") if not (np.all(a < = t) and np.all(t < = b)): raise ValueError( \"Cannot evaluate at points outside of the specified interval\" ) return binom(h, n) * ((t - a) / (b - a)) ** n * ((b - t) / (b - a)) ** (h - n)","title":"bernstein"},{"location":"reference/pyastrobee/trajectories/bezier/#bezier_trajectory","text":"def bezier_trajectory ( p0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], t0 : float , tf : float , n_control_pts : int , v0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , vf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , a0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , af : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , box : Optional [ pyastrobee . utils . boxes . Box ] = None , v_max : Optional [ float ] = None , a_max : Optional [ float ] = None , time_weight : float = 0 ) -> tuple [ pyastrobee . trajectories . bezier . BezierCurve , float ] Evaluate an optimal min-jerk trajectory based on Bezier curves which meets the specified constraints Parameters: Name Type Description Default p0 npt.ArrayLike Initial position, shape (3,) None pf npt.ArrayLike Final position, shape (3,) None t0 float Starting time None tf float Ending time None n_control_pts int Number of control points for the Bezier curve. Must be >= to the number of constraints, and should not be too large (>15ish) as this can reduce optimization performance. 6-10 is usually good None v0 Optional[npt.ArrayLike] Initial velocity, shape (3,). Defaults to None (unconstrained) None vf Optional[npt.ArrayLike] Final velocity, shape (3,). Defaults to None (unconstrained) None a0 Optional[npt.ArrayLike] Initial acceleration, shape (3,). Defaults to None (unconstrained) None af Optional[npt.ArrayLike] Final acceleration, shape (3,). Defaults to None (unconstrained) None box Optional[Box] Box constraint on (lower, upper) position bounds. Defaults to None (unconstrained) None v_max Optional[float] Maximum L2 norm of the velocity. Defaults to None (unconstrained) None a_max Optional[float] Maximum L2 norm of the acceleration. Defaults to None (unconstrained) None time_weight float Objective function weight corresponding to a linear penalty on the duration. Defaults to 0 (minimize jerk only). Note: this should be > 0 if evaluating the free-final-time case None Returns: Type Description tuple[BezierCurve, float] BezierCurve: The optimal curve for the position component of the trajectory. Note: derivatives can be evaluated using the curve.derivative property float: The optimal cost of the objective function Raises: Type Description OptimizationError If the optimization failed to find a valid solution (typically this is due to constraints which are too restrictive) View Source def bezier_trajectory ( p0 : npt . ArrayLike , pf : npt . ArrayLike , t0 : float , tf : float , n_control_pts : int , v0 : Optional [ npt.ArrayLike ] = None , vf : Optional [ npt.ArrayLike ] = None , a0 : Optional [ npt.ArrayLike ] = None , af : Optional [ npt.ArrayLike ] = None , box : Optional [ Box ] = None , v_max : Optional [ float ] = None , a_max : Optional [ float ] = None , time_weight : float = 0 , ) -> tuple [ BezierCurve, float ] : \"\"\"Evaluate an optimal min-jerk trajectory based on Bezier curves which meets the specified constraints Args: p0 (npt.ArrayLike): Initial position, shape (3,) pf (npt.ArrayLike): Final position, shape (3,) t0 (float): Starting time tf (float): Ending time n_control_pts (int): Number of control points for the Bezier curve. Must be >= to the number of constraints, and should not be too large (>15ish) as this can reduce optimization performance. 6-10 is usually good v0 (Optional[npt.ArrayLike]): Initial velocity, shape (3,). Defaults to None (unconstrained) vf (Optional[npt.ArrayLike]): Final velocity, shape (3,). Defaults to None (unconstrained) a0 (Optional[npt.ArrayLike]): Initial acceleration, shape (3,). Defaults to None (unconstrained) af (Optional[npt.ArrayLike]): Final acceleration, shape (3,). Defaults to None (unconstrained) box (Optional[Box]): Box constraint on (lower, upper) position bounds. Defaults to None (unconstrained) v_max (Optional[float]): Maximum L2 norm of the velocity. Defaults to None (unconstrained) a_max (Optional[float]): Maximum L2 norm of the acceleration. Defaults to None (unconstrained) time_weight (float, optional): Objective function weight corresponding to a linear penalty on the duration. Defaults to 0 (minimize jerk only). Note: this should be > 0 if evaluating the free-final-time case Raises: OptimizationError: If the optimization failed to find a valid solution (typically this is due to constraints which are too restrictive) Returns: tuple[BezierCurve, float]: BezierCurve: The optimal curve for the position component of the trajectory. Note: derivatives can be evaluated using the curve.derivative property float: The optimal cost of the objective function \"\"\" # Check inputs n_constraints = sum ( c is not None for c in [ p0, pf, v0, vf, a0, af ] ) if n_constraints > n_control_pts : raise ValueError ( \"Number of control points must be at least the number of constraints\" ) if tf <= t0 : raise ValueError ( f \"Invalid time interval: ({t0}, {tf})\" ) dim = len ( p0 ) # Form the main Variable ( the control points for the position curve ) and get the Expressions # for the control points of the derivative curves pos_pts = cp . Variable (( n_control_pts , dim )) pos_curve = BezierCurve ( pos_pts , t0 , tf ) vel_curve = pos_curve . derivative vel_pts = vel_curve . points accel_curve = vel_curve . derivative accel_pts = accel_curve . points jerk_curve = accel_curve . derivative # Form the constraint list depending on what was specified in the inputs constraints = [ pos_pts[0 ] == p0 , pos_pts [ -1 ] == pf ] if v0 is not None : constraints . append ( vel_pts [ 0 ] == v0 ) if vf is not None : constraints . append ( vel_pts [ -1 ] == vf ) if a0 is not None : constraints . append ( accel_pts [ 0 ] == a0 ) if af is not None : constraints . append ( accel_pts [ -1 ] == af ) if box is not None : lower , upper = box constraints . append ( pos_pts >= np . tile ( lower , ( n_control_pts , 1 ))) constraints . append ( pos_pts <= np . tile ( upper , ( n_control_pts , 1 ))) if v_max is not None : constraints . append ( cp . norm2 ( vel_pts , axis = 1 ) <= v_max ) if a_max is not None : constraints . append ( cp . norm2 ( accel_pts , axis = 1 ) <= a_max ) # Objective function criteria jerk = jerk_curve . l2_squared # Form the objective function based on the relative weighting between the criteria objective = cp . Minimize ( jerk + time_weight * ( tf - t0 )) # Form the problem and solve it # Note : Clarabel is apparently better for quadratic objectives ( like our jerk criteria ) prob = cp . Problem ( objective , constraints ) try : prob . solve ( solver = cp . CLARABEL ) except cp . error . SolverError as e : raise OptimizationError ( \"Cannot generate the trajectory - Solver error!\" ) from e if prob . status != cp . OPTIMAL : raise OptimizationError ( f \"Unable to generate the trajectory (solver status: {prob.status}).\\n\" + \"Check on the feasibility of the constraints\" ) # Construct the Bezier curve from the solved control points return BezierCurve ( pos_pts . value , t0 , tf ), prob . value","title":"bezier_trajectory"},{"location":"reference/pyastrobee/trajectories/bezier/#classes","text":"","title":"Classes"},{"location":"reference/pyastrobee/trajectories/bezier/#beziercurve","text":"class BezierCurve ( points : Union [ cvxpy . expressions . variable . Variable , cvxpy . expressions . expression . Expression , numpy . ndarray ], a : float , b : Union [ float , cvxpy . expressions . variable . Variable , cvxpy . expressions . expression . Expression ] ) Bezier curve class for evaluating a curve, the basis polynomials, and its derivative To evaluate the curve at points t, call it with curve(t) On initialization, for a standard \"unit-time\" curve, set a = 0 and b = 1","title":"BezierCurve"},{"location":"reference/pyastrobee/trajectories/bezier/#attributes","text":"Name Type Description Default points Union[cp.Variable, cp.Expression, np.ndarray] Control points, or a cvxpy Variable/Expression of the control points. Shape (n_pts, dimension) None a float Lower limit of the curve interval None b Union[float, cp.Variable, cp.Expression] Upper limit of the curve interval. Variable if we are also optimizing the duration of the curve None View Source class BezierCurve: \"\"\"Bezier curve class for evaluating a curve, the basis polynomials, and its derivative To evaluate the curve at points t, call it with curve(t) On initialization, for a standard \"unit-time\" curve, set a = 0 and b = 1 Args: points (Union[cp.Variable, cp.Expression, np.ndarray]): Control points, or a cvxpy Variable/Expression of the control points. Shape (n_pts, dimension) a (float): Lower limit of the curve interval b (Union[float, cp.Variable, cp.Expression]): Upper limit of the curve interval. Variable if we are also optimizing the duration of the curve \"\"\" def __init__( self, points: Union[cp.Variable, cp.Expression, np.ndarray], a: float, b: Union[float, cp.Variable, cp.Expression], ): if not isinstance(b, (cp.Variable, cp.Expression)) and b < a: raise ValueError(f\"Invalid interval limits: ({a}, {b})\") self.points = points self.h = points.shape[0] - 1 # Degree of the curve (AKA M in Tobia's paper) self.d = points.shape[1] # Dimension of the space self.a = a # Lower interval limit self.b = b # Upper interval limit self.duration = b - a def __call__(self, t: Union[float, npt.ArrayLike]) - > np.ndarray: \"\"\"Evaluates the Bezier curve (a sum of Bernstein polynomials) at specified points Args: t (Union[float, npt.ArrayLike]): Evaluation points (for instance, trajectory times) Returns: np.ndarray: Points along the curve, shape (n_pts, dimension) \"\"\" c = np.array([self._bernstein(t, n) for n in range(self.h + 1)]) return c.T @ self.points def _bernstein(self, t: Union[float, npt.ArrayLike], n: int) -> npt.ArrayLike: \"\"\"Wrapper around the Bernstein polynomial function, using attributes of self@BezierCurve Args: t (Union[float, npt.ArrayLike]): Evaluation point(s) (for instance, trajectory times) n (int): Index of the Bernstein polynomial Returns: npt.ArrayLike: Evaluation(s) of the bernstein polynomial at point(s) t. Returns a float if t is a float, otherwise will return an array of evaluations \"\"\" return bernstein(self.h, n, self.a, self.b, t) @property def start_point(self) -> Union[np.ndarray, cp.Variable, cp.Expression]: \"\"\"Starting control point of the Bezier curve\"\"\" return self.points[0] @property def end_point(self) -> Union[np.ndarray, cp.Variable, cp.Expression]: \"\"\"Ending control point of the Bezier curve\"\"\" return self.points[-1] @property def derivative(self) -> \"BezierCurve\": \"\"\"Derivative of the Bezier curve (A Bezier curve of degree h-1)\"\"\" if isinstance(self.duration, (cp.Variable, cp.Expression)): points = ( (self.points[1:] - self.points[:-1]) * self.h * cp.inv_pos(self.duration) ) else: points = (self.points[1:] - self.points[:-1]) * (self.h / self.duration) return BezierCurve(points, self.a, self.b) @property def l2_squared(self) -> Union[float, cp.Expression]: \"\"\"Squared L2 norm of the curve\"\"\" A = np.zeros((self.h + 1, self.h + 1)) for m in range(self.h + 1): for n in range(self.h + 1): A[m, n] = binom(self.h, m) * binom(self.h, n) / binom(2 * self.h, m + n) if isinstance(self.duration, (cp.Variable, cp.Expression)): A = cp.multiply(A, self.duration / (2 * self.h + 1)) A = cp.kron(A, np.eye(self.d)) else: A *= self.duration / (2 * self.h + 1) A = np.kron(A, np.eye(self.d)) if isinstance(self.points, (cp.Variable, cp.Expression)): # Note: CVXPY flattens matrices by columns rather than rows (opposite of numpy) # So, flatten based on the transpose to make the math consistent p = self.points.T.flatten() return cp.quad_form(p, cp.psd_wrap(A)) elif isinstance(A, (cp.Variable, cp.Expression)): p = self.points.flatten() return cp.quad_form(p, cp.psd_wrap(A)) else: # Numpy p = self.points.flatten() return p.dot(A.dot(p)) @property def control_points_pathlength(self) -> Union[float, cp.Expression]: \"\"\"Sum of the distances between consecutive control points This is an upper bound on the length of the curve itself, so we can use this in a cost function if we are trying to minimize the pathlength of a trajectory Returns: Union[float, cp.Expression]: Float if the points are a numpy array, otherwise yields a (convex, nonnegative) expression for this length \"\"\" if isinstance(self.points, (cp.Variable, cp.Expression)): length = 0 for i in range(self.h): length += cp.norm2(self.points[i + 1] - self.points[i]) return length else: return np.sum(np.linalg.norm(np.gradient(self.points, axis=0), axis=1))","title":"Attributes"},{"location":"reference/pyastrobee/trajectories/bezier/#instance-variables","text":"control_points_pathlength Sum of the distances between consecutive control points This is an upper bound on the length of the curve itself, so we can use this in a cost function if we are trying to minimize the pathlength of a trajectory derivative Derivative of the Bezier curve (A Bezier curve of degree h-1) end_point Ending control point of the Bezier curve l2_squared Squared L2 norm of the curve start_point Starting control point of the Bezier curve","title":"Instance variables"},{"location":"reference/pyastrobee/trajectories/bezier_slerp/","text":"Module pyastrobee.trajectories.bezier_slerp Using Bezier curves to optimize SLERPs with constrained derivatives and derivative magnitudes View Source \"\"\"Using Bezier curves to optimize SLERPs with constrained derivatives and derivative magnitudes\"\"\" from typing import Optional import cvxpy as cp import numpy as np import numpy.typing as npt import matplotlib.pyplot as plt from pyastrobee.utils.errors import OptimizationError from pyastrobee.utils.quaternions import ( quaternion_slerp , quaternion_dist , random_quaternion , quats_to_angular_velocities , ) from pyastrobee.trajectories.bezier import BezierCurve from pyastrobee.trajectories.curve_utils import plot_1d_bezier_curve from pyastrobee.trajectories.trajectory import Trajectory def bezier_slerp ( q1 : npt . ArrayLike , q2 : npt . ArrayLike , n : int , T : float , w_max : Optional [ float ] = None , dw_max : Optional [ float ] = None , ): \"\"\"SLERP based on a Bezier-curve discretization with 0 first and second derivative at either end, and limits on the maximum angular velocity/acceleration (if desired) The angular velocity vector has a fixed direction since this is a limitation of a single SLERP arc Args: q1 (npt.ArrayLike): Starting XYZW quaternion, shape (4,). q2 (npt.ArrayLike): Ending XYZW quaternion, shape (4,). n (int): Number of points at which to evaluate the SLERP T (float): Time period for the SLERP. Used in conjunction with the w_max and dw_max parameters. If this is not of interest, set T = 1 w_max (Optional[float]): Maximum angular velocity magnitude. Defaults to None (unconstrained). dw_max (Optional[float]): Maximum angular acceleration magnitude. Defaults to None (unconstrained). Returns: np.ndarray: The interpolated XYZW quaternions, shape = (n, 4) \"\"\" # If we have constraints on the max velocity/acceleration, bump up the degree of the curve by a lot to make sure # that the convex hull of the control points will be a tighter bound on the curve (so that our constraints are not # overly restrictive) if w_max is not None or dw_max is not None : n_control_pts = 20 else : n_control_pts = 10 # Determine the maximum derivatives of the interpolation curve based on the quaternion distance metric q_dist = quaternion_dist ( q1 , q2 ) d_max = None if w_max is None else w_max * T / q_dist d2_max = None if dw_max is None else dw_max * T ** 2 / q_dist solved_curve = bezier_interpolation_curve ( n_control_pts , 0 , 0 , 0 , 0 , d_max , d2_max ) pcts = solved_curve ( np . linspace ( 0 , 1 , n )) # Clamp between 0 and 1 to account for any numerical issues, and convert to 1d array pcts = np . ravel ( np . clip ( pcts , 0 , 1 )) return quaternion_slerp ( q1 , q2 , pcts ) def bezier_interpolation_curve ( n_control_pts : int , d0 : Optional [ float ] = None , df : Optional [ float ] = None , d20 : Optional [ float ] = None , d2f : Optional [ float ] = None , d_max : Optional [ float ] = None , d2_max : Optional [ float ] = None , ) -> BezierCurve : \"\"\"Use a min-jerk Bezier curve to define discretization percentages between two interpolated points Interpolation percentages can be found by evaluating the curve on an array with uniform-spaced times between 0 and 1 This curve will satisfy derivative boundary conditions and constraints on maximum derivatives (as specified) Args: n_control_pts (int): Number of control points of the Bezier curve. Must be at least the number of constraints that are specified. More control points (~20) will lead to a tighter convex hull of the curve, meaning constraints on maximum velocity/acceleration will be more precise d0 (Optional[float]): Initial derivative. Defaults to None (unconstrained). df (Optional[float]): Final derivative. Defaults to None (unconstrained). d20 (Optional[float]): Initial second derivative. Defaults to None (unconstrained). d2f (Optional[float]): Final second derivative. Defaults to None (unconstrained). d_max (Optional[float]): Maximum derivative. Defaults to None (unconstrained). d2_max (Optional[float]): Maximum second derivative. Defaults to None (unconstrained). Raises: OptimizationError: If a solution cannot be found. If this happens, try increasing the number of control points, which may lead to a more feasible constraints. Otherwise, the problem may have no solution Returns: BezierCurve: Curve to use for interpolation \"\"\" t0 = 0 tf = 1 # Unit time pts = cp . Variable (( n_control_pts , 1 )) curve = BezierCurve ( pts , t0 , tf ) d_curve = curve . derivative d_pts = d_curve . points d2_curve = d_curve . derivative d2_pts = d2_curve . points d3_curve = d2_curve . derivative # Form the constraint list depending on what was specified in the inputs constraints = [ pts [ 0 ] == 0 , pts [ - 1 ] == 1 ] if d0 is not None : constraints . append ( d_pts [ 0 ] == d0 ) if df is not None : constraints . append ( d_pts [ - 1 ] == df ) if d20 is not None : constraints . append ( d2_pts [ 0 ] == d20 ) if d2f is not None : constraints . append ( d2_pts [ - 1 ] == d2f ) if d_max is not None : constraints . append ( cp . max ( cp . abs ( d_pts )) <= d_max ) if d2_max is not None : constraints . append ( cp . max ( cp . abs ( d2_pts )) <= d2_max ) # Form the problem and solve it jerk = d3_curve . l2_squared objective = cp . Minimize ( jerk ) prob = cp . Problem ( objective , constraints ) # Note: Clarabel is apparently better for quadratic objectives (like our jerk criteria) prob . solve ( solver = cp . CLARABEL ) if prob . status != cp . OPTIMAL : raise OptimizationError ( f \"Unable to generate the trajectory (solver status: { prob . status } ). \\n \" + \"Check on the feasibility of the constraints\" ) # Construct the Bezier curves from the solved control points, and return their evaluations at each time solved_curve = BezierCurve ( pts . value , t0 , tf ) return solved_curve def _test_constraint_example (): np . random . seed ( 0 ) q1 = np . array ([ 0 , 0 , 0 , 1 ]) # random_quaternion() q2 = random_quaternion () print ( \"Quaternion distance: \" , quaternion_dist ( q1 , q2 )) T = 10 n = 500 dt = T / n w_max = 0.40 dw_max = 0.20 print ( \"Maximum angular velocity constraint: \" , w_max ) print ( \"Maximum angular acceleration constraint: \" , dw_max ) quats = bezier_slerp ( q1 , q2 , n , T , w_max , dw_max ) omega = quats_to_angular_velocities ( quats , dt ) alpha = np . gradient ( omega , dt , axis = 0 ) print ( \"Maximum angular velocity from curve: \" , np . max ( np . linalg . norm ( omega , axis = 1 )) ) print ( \"Maximum angular acceleration from curve: \" , np . max ( np . linalg . norm ( alpha , axis = 1 )), ) traj = Trajectory ( None , quats , None , omega , None , alpha ) traj . plot () def _test_1d_interpolation (): curve = bezier_interpolation_curve ( 20 , 0 , 0 , 0 , 0 ) plt . figure () plot_1d_bezier_curve ( curve , show = False ) plt . title ( \"Position\" ) plt . figure () plot_1d_bezier_curve ( curve . derivative , show = False ) plt . title ( \"Velocity\" ) plt . figure () plot_1d_bezier_curve ( curve . derivative . derivative , show = False ) plt . title ( \"Acceleration\" ) plt . show () if __name__ == \"__main__\" : _test_constraint_example () _test_1d_interpolation () Functions bezier_interpolation_curve def bezier_interpolation_curve ( n_control_pts : int , d0 : Optional [ float ] = None , df : Optional [ float ] = None , d20 : Optional [ float ] = None , d2f : Optional [ float ] = None , d_max : Optional [ float ] = None , d2_max : Optional [ float ] = None ) -> pyastrobee . trajectories . bezier . BezierCurve Use a min-jerk Bezier curve to define discretization percentages between two interpolated points Interpolation percentages can be found by evaluating the curve on an array with uniform-spaced times between 0 and 1 This curve will satisfy derivative boundary conditions and constraints on maximum derivatives (as specified) Parameters: Name Type Description Default n_control_pts int Number of control points of the Bezier curve. Must be at least the number of constraints that are specified. More control points (~20) will lead to a tighter convex hull of the curve, meaning constraints on maximum velocity/acceleration will be more precise None d0 Optional[float] Initial derivative. Defaults to None (unconstrained). None (unconstrained) df Optional[float] Final derivative. Defaults to None (unconstrained). None (unconstrained) d20 Optional[float] Initial second derivative. Defaults to None (unconstrained). None (unconstrained) d2f Optional[float] Final second derivative. Defaults to None (unconstrained). None (unconstrained) d_max Optional[float] Maximum derivative. Defaults to None (unconstrained). None (unconstrained) d2_max Optional[float] Maximum second derivative. Defaults to None (unconstrained). None (unconstrained) Returns: Type Description BezierCurve Curve to use for interpolation Raises: Type Description OptimizationError If a solution cannot be found. If this happens, try increasing the number of control points, which may lead to a more feasible constraints. Otherwise, the problem may have no solution View Source def bezier_interpolation_curve ( n_control_pts : int , d0 : Optional [ float ] = None , df : Optional [ float ] = None , d20 : Optional [ float ] = None , d2f : Optional [ float ] = None , d_max : Optional [ float ] = None , d2_max : Optional [ float ] = None , ) -> BezierCurve : \"\"\"Use a min-jerk Bezier curve to define discretization percentages between two interpolated points Interpolation percentages can be found by evaluating the curve on an array with uniform-spaced times between 0 and 1 This curve will satisfy derivative boundary conditions and constraints on maximum derivatives (as specified) Args: n_control_pts (int): Number of control points of the Bezier curve. Must be at least the number of constraints that are specified. More control points (~20) will lead to a tighter convex hull of the curve, meaning constraints on maximum velocity/acceleration will be more precise d0 (Optional[float]): Initial derivative. Defaults to None (unconstrained). df (Optional[float]): Final derivative. Defaults to None (unconstrained). d20 (Optional[float]): Initial second derivative. Defaults to None (unconstrained). d2f (Optional[float]): Final second derivative. Defaults to None (unconstrained). d_max (Optional[float]): Maximum derivative. Defaults to None (unconstrained). d2_max (Optional[float]): Maximum second derivative. Defaults to None (unconstrained). Raises: OptimizationError: If a solution cannot be found. If this happens, try increasing the number of control points, which may lead to a more feasible constraints. Otherwise, the problem may have no solution Returns: BezierCurve: Curve to use for interpolation \"\"\" t0 = 0 tf = 1 # Unit time pts = cp . Variable (( n_control_pts , 1 )) curve = BezierCurve ( pts , t0 , tf ) d_curve = curve . derivative d_pts = d_curve . points d2_curve = d_curve . derivative d2_pts = d2_curve . points d3_curve = d2_curve . derivative # Form the constraint list depending on what was specified in the inputs constraints = [ pts[0 ] == 0 , pts [ -1 ] == 1 ] if d0 is not None : constraints . append ( d_pts [ 0 ] == d0 ) if df is not None : constraints . append ( d_pts [ -1 ] == df ) if d20 is not None : constraints . append ( d2_pts [ 0 ] == d20 ) if d2f is not None : constraints . append ( d2_pts [ -1 ] == d2f ) if d_max is not None : constraints . append ( cp . max ( cp . abs ( d_pts )) <= d_max ) if d2_max is not None : constraints . append ( cp . max ( cp . abs ( d2_pts )) <= d2_max ) # Form the problem and solve it jerk = d3_curve . l2_squared objective = cp . Minimize ( jerk ) prob = cp . Problem ( objective , constraints ) # Note : Clarabel is apparently better for quadratic objectives ( like our jerk criteria ) prob . solve ( solver = cp . CLARABEL ) if prob . status != cp . OPTIMAL : raise OptimizationError ( f \"Unable to generate the trajectory (solver status: {prob.status}).\\n\" + \"Check on the feasibility of the constraints\" ) # Construct the Bezier curves from the solved control points , and return their evaluations at each time solved_curve = BezierCurve ( pts . value , t0 , tf ) return solved_curve bezier_slerp def bezier_slerp ( q1 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], q2 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], n : int , T : float , w_max : Optional [ float ] = None , dw_max : Optional [ float ] = None ) SLERP based on a Bezier-curve discretization with 0 first and second derivative at either end, and limits on the maximum angular velocity/acceleration (if desired) The angular velocity vector has a fixed direction since this is a limitation of a single SLERP arc Parameters: Name Type Description Default q1 npt.ArrayLike Starting XYZW quaternion, shape (4,). None q2 npt.ArrayLike Ending XYZW quaternion, shape (4,). None n int Number of points at which to evaluate the SLERP None T float Time period for the SLERP. Used in conjunction with the w_max and dw_max parameters. If this is not of interest, set T = 1 None w_max Optional[float] Maximum angular velocity magnitude. Defaults to None (unconstrained). None (unconstrained) dw_max Optional[float] Maximum angular acceleration magnitude. Defaults to None (unconstrained). None (unconstrained) Returns: Type Description np.ndarray The interpolated XYZW quaternions, shape = (n, 4) View Source def bezier_slerp ( q1 : npt . ArrayLike , q2 : npt . ArrayLike , n : int , T : float , w_max : Optional [ float ] = None , dw_max : Optional [ float ] = None , ) : \"\"\"SLERP based on a Bezier-curve discretization with 0 first and second derivative at either end, and limits on the maximum angular velocity/acceleration (if desired) The angular velocity vector has a fixed direction since this is a limitation of a single SLERP arc Args: q1 (npt.ArrayLike): Starting XYZW quaternion, shape (4,). q2 (npt.ArrayLike): Ending XYZW quaternion, shape (4,). n (int): Number of points at which to evaluate the SLERP T (float): Time period for the SLERP. Used in conjunction with the w_max and dw_max parameters. If this is not of interest, set T = 1 w_max (Optional[float]): Maximum angular velocity magnitude. Defaults to None (unconstrained). dw_max (Optional[float]): Maximum angular acceleration magnitude. Defaults to None (unconstrained). Returns: np.ndarray: The interpolated XYZW quaternions, shape = (n, 4) \"\"\" # If we have constraints on the max velocity / acceleration , bump up the degree of the curve by a lot to make sure # that the convex hull of the control points will be a tighter bound on the curve ( so that our constraints are not # overly restrictive ) if w_max is not None or dw_max is not None : n_control_pts = 20 else : n_control_pts = 10 # Determine the maximum derivatives of the interpolation curve based on the quaternion distance metric q_dist = quaternion_dist ( q1 , q2 ) d_max = None if w_max is None else w_max * T / q_dist d2_max = None if dw_max is None else dw_max * T ** 2 / q_dist solved_curve = bezier_interpolation_curve ( n_control_pts , 0 , 0 , 0 , 0 , d_max , d2_max ) pcts = solved_curve ( np . linspace ( 0 , 1 , n )) # Clamp between 0 and 1 to account for any numerical issues , and convert to 1 d array pcts = np . ravel ( np . clip ( pcts , 0 , 1 )) return quaternion_slerp ( q1 , q2 , pcts )","title":"Bezier Slerp"},{"location":"reference/pyastrobee/trajectories/bezier_slerp/#module-pyastrobeetrajectoriesbezier_slerp","text":"Using Bezier curves to optimize SLERPs with constrained derivatives and derivative magnitudes View Source \"\"\"Using Bezier curves to optimize SLERPs with constrained derivatives and derivative magnitudes\"\"\" from typing import Optional import cvxpy as cp import numpy as np import numpy.typing as npt import matplotlib.pyplot as plt from pyastrobee.utils.errors import OptimizationError from pyastrobee.utils.quaternions import ( quaternion_slerp , quaternion_dist , random_quaternion , quats_to_angular_velocities , ) from pyastrobee.trajectories.bezier import BezierCurve from pyastrobee.trajectories.curve_utils import plot_1d_bezier_curve from pyastrobee.trajectories.trajectory import Trajectory def bezier_slerp ( q1 : npt . ArrayLike , q2 : npt . ArrayLike , n : int , T : float , w_max : Optional [ float ] = None , dw_max : Optional [ float ] = None , ): \"\"\"SLERP based on a Bezier-curve discretization with 0 first and second derivative at either end, and limits on the maximum angular velocity/acceleration (if desired) The angular velocity vector has a fixed direction since this is a limitation of a single SLERP arc Args: q1 (npt.ArrayLike): Starting XYZW quaternion, shape (4,). q2 (npt.ArrayLike): Ending XYZW quaternion, shape (4,). n (int): Number of points at which to evaluate the SLERP T (float): Time period for the SLERP. Used in conjunction with the w_max and dw_max parameters. If this is not of interest, set T = 1 w_max (Optional[float]): Maximum angular velocity magnitude. Defaults to None (unconstrained). dw_max (Optional[float]): Maximum angular acceleration magnitude. Defaults to None (unconstrained). Returns: np.ndarray: The interpolated XYZW quaternions, shape = (n, 4) \"\"\" # If we have constraints on the max velocity/acceleration, bump up the degree of the curve by a lot to make sure # that the convex hull of the control points will be a tighter bound on the curve (so that our constraints are not # overly restrictive) if w_max is not None or dw_max is not None : n_control_pts = 20 else : n_control_pts = 10 # Determine the maximum derivatives of the interpolation curve based on the quaternion distance metric q_dist = quaternion_dist ( q1 , q2 ) d_max = None if w_max is None else w_max * T / q_dist d2_max = None if dw_max is None else dw_max * T ** 2 / q_dist solved_curve = bezier_interpolation_curve ( n_control_pts , 0 , 0 , 0 , 0 , d_max , d2_max ) pcts = solved_curve ( np . linspace ( 0 , 1 , n )) # Clamp between 0 and 1 to account for any numerical issues, and convert to 1d array pcts = np . ravel ( np . clip ( pcts , 0 , 1 )) return quaternion_slerp ( q1 , q2 , pcts ) def bezier_interpolation_curve ( n_control_pts : int , d0 : Optional [ float ] = None , df : Optional [ float ] = None , d20 : Optional [ float ] = None , d2f : Optional [ float ] = None , d_max : Optional [ float ] = None , d2_max : Optional [ float ] = None , ) -> BezierCurve : \"\"\"Use a min-jerk Bezier curve to define discretization percentages between two interpolated points Interpolation percentages can be found by evaluating the curve on an array with uniform-spaced times between 0 and 1 This curve will satisfy derivative boundary conditions and constraints on maximum derivatives (as specified) Args: n_control_pts (int): Number of control points of the Bezier curve. Must be at least the number of constraints that are specified. More control points (~20) will lead to a tighter convex hull of the curve, meaning constraints on maximum velocity/acceleration will be more precise d0 (Optional[float]): Initial derivative. Defaults to None (unconstrained). df (Optional[float]): Final derivative. Defaults to None (unconstrained). d20 (Optional[float]): Initial second derivative. Defaults to None (unconstrained). d2f (Optional[float]): Final second derivative. Defaults to None (unconstrained). d_max (Optional[float]): Maximum derivative. Defaults to None (unconstrained). d2_max (Optional[float]): Maximum second derivative. Defaults to None (unconstrained). Raises: OptimizationError: If a solution cannot be found. If this happens, try increasing the number of control points, which may lead to a more feasible constraints. Otherwise, the problem may have no solution Returns: BezierCurve: Curve to use for interpolation \"\"\" t0 = 0 tf = 1 # Unit time pts = cp . Variable (( n_control_pts , 1 )) curve = BezierCurve ( pts , t0 , tf ) d_curve = curve . derivative d_pts = d_curve . points d2_curve = d_curve . derivative d2_pts = d2_curve . points d3_curve = d2_curve . derivative # Form the constraint list depending on what was specified in the inputs constraints = [ pts [ 0 ] == 0 , pts [ - 1 ] == 1 ] if d0 is not None : constraints . append ( d_pts [ 0 ] == d0 ) if df is not None : constraints . append ( d_pts [ - 1 ] == df ) if d20 is not None : constraints . append ( d2_pts [ 0 ] == d20 ) if d2f is not None : constraints . append ( d2_pts [ - 1 ] == d2f ) if d_max is not None : constraints . append ( cp . max ( cp . abs ( d_pts )) <= d_max ) if d2_max is not None : constraints . append ( cp . max ( cp . abs ( d2_pts )) <= d2_max ) # Form the problem and solve it jerk = d3_curve . l2_squared objective = cp . Minimize ( jerk ) prob = cp . Problem ( objective , constraints ) # Note: Clarabel is apparently better for quadratic objectives (like our jerk criteria) prob . solve ( solver = cp . CLARABEL ) if prob . status != cp . OPTIMAL : raise OptimizationError ( f \"Unable to generate the trajectory (solver status: { prob . status } ). \\n \" + \"Check on the feasibility of the constraints\" ) # Construct the Bezier curves from the solved control points, and return their evaluations at each time solved_curve = BezierCurve ( pts . value , t0 , tf ) return solved_curve def _test_constraint_example (): np . random . seed ( 0 ) q1 = np . array ([ 0 , 0 , 0 , 1 ]) # random_quaternion() q2 = random_quaternion () print ( \"Quaternion distance: \" , quaternion_dist ( q1 , q2 )) T = 10 n = 500 dt = T / n w_max = 0.40 dw_max = 0.20 print ( \"Maximum angular velocity constraint: \" , w_max ) print ( \"Maximum angular acceleration constraint: \" , dw_max ) quats = bezier_slerp ( q1 , q2 , n , T , w_max , dw_max ) omega = quats_to_angular_velocities ( quats , dt ) alpha = np . gradient ( omega , dt , axis = 0 ) print ( \"Maximum angular velocity from curve: \" , np . max ( np . linalg . norm ( omega , axis = 1 )) ) print ( \"Maximum angular acceleration from curve: \" , np . max ( np . linalg . norm ( alpha , axis = 1 )), ) traj = Trajectory ( None , quats , None , omega , None , alpha ) traj . plot () def _test_1d_interpolation (): curve = bezier_interpolation_curve ( 20 , 0 , 0 , 0 , 0 ) plt . figure () plot_1d_bezier_curve ( curve , show = False ) plt . title ( \"Position\" ) plt . figure () plot_1d_bezier_curve ( curve . derivative , show = False ) plt . title ( \"Velocity\" ) plt . figure () plot_1d_bezier_curve ( curve . derivative . derivative , show = False ) plt . title ( \"Acceleration\" ) plt . show () if __name__ == \"__main__\" : _test_constraint_example () _test_1d_interpolation ()","title":"Module pyastrobee.trajectories.bezier_slerp"},{"location":"reference/pyastrobee/trajectories/bezier_slerp/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/trajectories/bezier_slerp/#bezier_interpolation_curve","text":"def bezier_interpolation_curve ( n_control_pts : int , d0 : Optional [ float ] = None , df : Optional [ float ] = None , d20 : Optional [ float ] = None , d2f : Optional [ float ] = None , d_max : Optional [ float ] = None , d2_max : Optional [ float ] = None ) -> pyastrobee . trajectories . bezier . BezierCurve Use a min-jerk Bezier curve to define discretization percentages between two interpolated points Interpolation percentages can be found by evaluating the curve on an array with uniform-spaced times between 0 and 1 This curve will satisfy derivative boundary conditions and constraints on maximum derivatives (as specified) Parameters: Name Type Description Default n_control_pts int Number of control points of the Bezier curve. Must be at least the number of constraints that are specified. More control points (~20) will lead to a tighter convex hull of the curve, meaning constraints on maximum velocity/acceleration will be more precise None d0 Optional[float] Initial derivative. Defaults to None (unconstrained). None (unconstrained) df Optional[float] Final derivative. Defaults to None (unconstrained). None (unconstrained) d20 Optional[float] Initial second derivative. Defaults to None (unconstrained). None (unconstrained) d2f Optional[float] Final second derivative. Defaults to None (unconstrained). None (unconstrained) d_max Optional[float] Maximum derivative. Defaults to None (unconstrained). None (unconstrained) d2_max Optional[float] Maximum second derivative. Defaults to None (unconstrained). None (unconstrained) Returns: Type Description BezierCurve Curve to use for interpolation Raises: Type Description OptimizationError If a solution cannot be found. If this happens, try increasing the number of control points, which may lead to a more feasible constraints. Otherwise, the problem may have no solution View Source def bezier_interpolation_curve ( n_control_pts : int , d0 : Optional [ float ] = None , df : Optional [ float ] = None , d20 : Optional [ float ] = None , d2f : Optional [ float ] = None , d_max : Optional [ float ] = None , d2_max : Optional [ float ] = None , ) -> BezierCurve : \"\"\"Use a min-jerk Bezier curve to define discretization percentages between two interpolated points Interpolation percentages can be found by evaluating the curve on an array with uniform-spaced times between 0 and 1 This curve will satisfy derivative boundary conditions and constraints on maximum derivatives (as specified) Args: n_control_pts (int): Number of control points of the Bezier curve. Must be at least the number of constraints that are specified. More control points (~20) will lead to a tighter convex hull of the curve, meaning constraints on maximum velocity/acceleration will be more precise d0 (Optional[float]): Initial derivative. Defaults to None (unconstrained). df (Optional[float]): Final derivative. Defaults to None (unconstrained). d20 (Optional[float]): Initial second derivative. Defaults to None (unconstrained). d2f (Optional[float]): Final second derivative. Defaults to None (unconstrained). d_max (Optional[float]): Maximum derivative. Defaults to None (unconstrained). d2_max (Optional[float]): Maximum second derivative. Defaults to None (unconstrained). Raises: OptimizationError: If a solution cannot be found. If this happens, try increasing the number of control points, which may lead to a more feasible constraints. Otherwise, the problem may have no solution Returns: BezierCurve: Curve to use for interpolation \"\"\" t0 = 0 tf = 1 # Unit time pts = cp . Variable (( n_control_pts , 1 )) curve = BezierCurve ( pts , t0 , tf ) d_curve = curve . derivative d_pts = d_curve . points d2_curve = d_curve . derivative d2_pts = d2_curve . points d3_curve = d2_curve . derivative # Form the constraint list depending on what was specified in the inputs constraints = [ pts[0 ] == 0 , pts [ -1 ] == 1 ] if d0 is not None : constraints . append ( d_pts [ 0 ] == d0 ) if df is not None : constraints . append ( d_pts [ -1 ] == df ) if d20 is not None : constraints . append ( d2_pts [ 0 ] == d20 ) if d2f is not None : constraints . append ( d2_pts [ -1 ] == d2f ) if d_max is not None : constraints . append ( cp . max ( cp . abs ( d_pts )) <= d_max ) if d2_max is not None : constraints . append ( cp . max ( cp . abs ( d2_pts )) <= d2_max ) # Form the problem and solve it jerk = d3_curve . l2_squared objective = cp . Minimize ( jerk ) prob = cp . Problem ( objective , constraints ) # Note : Clarabel is apparently better for quadratic objectives ( like our jerk criteria ) prob . solve ( solver = cp . CLARABEL ) if prob . status != cp . OPTIMAL : raise OptimizationError ( f \"Unable to generate the trajectory (solver status: {prob.status}).\\n\" + \"Check on the feasibility of the constraints\" ) # Construct the Bezier curves from the solved control points , and return their evaluations at each time solved_curve = BezierCurve ( pts . value , t0 , tf ) return solved_curve","title":"bezier_interpolation_curve"},{"location":"reference/pyastrobee/trajectories/bezier_slerp/#bezier_slerp","text":"def bezier_slerp ( q1 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], q2 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], n : int , T : float , w_max : Optional [ float ] = None , dw_max : Optional [ float ] = None ) SLERP based on a Bezier-curve discretization with 0 first and second derivative at either end, and limits on the maximum angular velocity/acceleration (if desired) The angular velocity vector has a fixed direction since this is a limitation of a single SLERP arc Parameters: Name Type Description Default q1 npt.ArrayLike Starting XYZW quaternion, shape (4,). None q2 npt.ArrayLike Ending XYZW quaternion, shape (4,). None n int Number of points at which to evaluate the SLERP None T float Time period for the SLERP. Used in conjunction with the w_max and dw_max parameters. If this is not of interest, set T = 1 None w_max Optional[float] Maximum angular velocity magnitude. Defaults to None (unconstrained). None (unconstrained) dw_max Optional[float] Maximum angular acceleration magnitude. Defaults to None (unconstrained). None (unconstrained) Returns: Type Description np.ndarray The interpolated XYZW quaternions, shape = (n, 4) View Source def bezier_slerp ( q1 : npt . ArrayLike , q2 : npt . ArrayLike , n : int , T : float , w_max : Optional [ float ] = None , dw_max : Optional [ float ] = None , ) : \"\"\"SLERP based on a Bezier-curve discretization with 0 first and second derivative at either end, and limits on the maximum angular velocity/acceleration (if desired) The angular velocity vector has a fixed direction since this is a limitation of a single SLERP arc Args: q1 (npt.ArrayLike): Starting XYZW quaternion, shape (4,). q2 (npt.ArrayLike): Ending XYZW quaternion, shape (4,). n (int): Number of points at which to evaluate the SLERP T (float): Time period for the SLERP. Used in conjunction with the w_max and dw_max parameters. If this is not of interest, set T = 1 w_max (Optional[float]): Maximum angular velocity magnitude. Defaults to None (unconstrained). dw_max (Optional[float]): Maximum angular acceleration magnitude. Defaults to None (unconstrained). Returns: np.ndarray: The interpolated XYZW quaternions, shape = (n, 4) \"\"\" # If we have constraints on the max velocity / acceleration , bump up the degree of the curve by a lot to make sure # that the convex hull of the control points will be a tighter bound on the curve ( so that our constraints are not # overly restrictive ) if w_max is not None or dw_max is not None : n_control_pts = 20 else : n_control_pts = 10 # Determine the maximum derivatives of the interpolation curve based on the quaternion distance metric q_dist = quaternion_dist ( q1 , q2 ) d_max = None if w_max is None else w_max * T / q_dist d2_max = None if dw_max is None else dw_max * T ** 2 / q_dist solved_curve = bezier_interpolation_curve ( n_control_pts , 0 , 0 , 0 , 0 , d_max , d2_max ) pcts = solved_curve ( np . linspace ( 0 , 1 , n )) # Clamp between 0 and 1 to account for any numerical issues , and convert to 1 d array pcts = np . ravel ( np . clip ( pcts , 0 , 1 )) return quaternion_slerp ( q1 , q2 , pcts )","title":"bezier_slerp"},{"location":"reference/pyastrobee/trajectories/box_paths/","text":"Module pyastrobee.trajectories.box_paths Different ways of characterizing paths between regions of the environment These are mainly used for timing heuristics for splines right now - for instance, using a simple method of traversing the environment to create an estimate of how long we will spend in each region View Source \"\"\"Different ways of characterizing paths between regions of the environment These are mainly used for timing heuristics for splines right now - for instance, using a simple method of traversing the environment to create an estimate of how long we will spend in each region \"\"\" import time import numpy as np import numpy.typing as npt import cvxpy as cp import pybullet from pyastrobee.utils.boxes import Box , intersect_boxes , visualize_3D_box from pyastrobee.utils.debug_visualizer import visualize_path , visualize_points from pyastrobee.utils.errors import OptimizationError def min_length_path ( start_pt : npt . ArrayLike , end_pt : npt . ArrayLike , boxes : list [ Box ] ) -> np . ndarray : \"\"\"Determine the minimum-length path between two points through a sequence of safe boxes Args: start_pt (npt.ArrayLike): Starting XYZ position, shape (3,) end_pt (npt.ArrayLike): Ending XYZ position, shape (3,) boxes (list[Box]): Sequence of safe boxes to pass through Returns: np.ndarray: Path from start to end, shape (n_boxes + 1, 3) \"\"\" n_boxes = len ( boxes ) points = cp . Variable (( n_boxes + 1 , 3 )) pathlength = cp . sum ( cp . norm2 ( cp . diff ( points , axis = 0 ), axis = 1 )) objective = cp . Minimize ( pathlength ) constraints = [ points [ 0 ] == start_pt , points [ - 1 ] == end_pt ] for i , box in enumerate ( boxes ): lower , upper = box constraints . append ( points [ i ] >= lower ) constraints . append ( points [ i ] <= upper ) constraints . append ( points [ i + 1 ] >= lower ) constraints . append ( points [ i + 1 ] <= upper ) prob = cp . Problem ( objective , constraints ) prob . solve () if prob . status != cp . OPTIMAL : raise OptimizationError ( \"Unable to find a solution. \\n \" + \"Check that the set of boxes is connected and that the start/end points are contained in the boxes\" ) return points . value def centerpoint_path ( start_pt : npt . ArrayLike , end_pt : npt . ArrayLike , boxes : list [ Box ] ) -> np . ndarray : \"\"\"Determine a path between two points, using the center points of boxes and their intersections as waypoints Args: start_pt (npt.ArrayLike): Starting XYZ position, shape (3,) end_pt (npt.ArrayLike): Ending XYZ position, shape (3,) boxes (list[Box]): Sequence of safe boxes to pass through Returns: np.ndarray: Path from start to end, shape (2 * n_boxes + 1, 3) \"\"\" n_boxes = len ( boxes ) # One point per box, one point per box intersection, and two points for start/end n_points = 2 * n_boxes + 1 points = np . empty (( n_points , 3 )) points [ 0 ] = start_pt points [ - 1 ] = end_pt for i in range ( n_boxes ): points [ 2 * i + 1 ] = boxes [ i ] . center if i < n_boxes - 1 : # Not the last box points [ 2 * i + 2 ] = intersect_boxes ( boxes [ i ], boxes [ i + 1 ]) . center return points def intersection_path ( start_pt : npt . ArrayLike , end_pt : npt . ArrayLike , boxes : list [ Box ] ) -> np . ndarray : \"\"\"Determine a path between two points, using the intersections between consecutive boxes as waypoints Args: start_pt (npt.ArrayLike): Starting XYZ position, shape (3,) end_pt (npt.ArrayLike): Ending XYZ position, shape (3,) boxes (list[Box]): Sequence of safe boxes to pass through Returns: np.ndarray: Path from start to end, shape (n_boxes + 1, 3) \"\"\" n_boxes = len ( boxes ) n_points = n_boxes + 1 points = np . empty (( n_points , 3 )) points [ 0 ] = start_pt points [ - 1 ] = end_pt for i in range ( n_boxes - 1 ): points [ i + 1 ] = intersect_boxes ( boxes [ i ], boxes [ i + 1 ]) . center return points def _test_path_methods (): start_pt = [ 0.1 , 0.2 , 0.3 ] end_pt = [ 1.5 , 5 , 1.7 ] boxes = [ Box (( 0 , 0 , 0 ), ( 1 , 1 , 1 )), Box (( 0.5 , 0.5 , 0.5 ), ( 1.5 , 5 , 1.5 )), Box (( 1 , 4.5 , 1 ), ( 2 , 5.5 , 2 )), ] time_a = time . time () min_length_solution = min_length_path ( start_pt , end_pt , boxes ) time_b = time . time () centerpoint_solution = centerpoint_path ( start_pt , end_pt , boxes ) time_c = time . time () intersection_solution = intersection_path ( start_pt , end_pt , boxes ) time_d = time . time () print ( \"min length time: \" , time_b - time_a ) print ( \"centerpoint time: \" , time_c - time_b ) print ( \"intersection time: \" , time_d - time_c ) pybullet . connect ( pybullet . GUI ) min_length_color = ( 1 , 0 , 0 ) centerpoint_color = ( 0 , 1 , 0 ) intersection_color = ( 0 , 0 , 1 ) visualize_path ( min_length_solution , color = min_length_color ) visualize_path ( centerpoint_solution , color = centerpoint_color ) visualize_path ( intersection_solution , color = intersection_color ) visualize_points ( min_length_solution , color = min_length_color ) visualize_points ( centerpoint_solution , color = centerpoint_color ) visualize_points ( intersection_solution , color = intersection_color ) for box in boxes : visualize_3D_box ( box ) pybullet . addUserDebugText ( \"Min length\" , [ 0 , 0 , - 0.2 ], min_length_color ) pybullet . addUserDebugText ( \"Centerpoint\" , [ 0 , 0 , - 0.4 ], centerpoint_color ) pybullet . addUserDebugText ( \"Intersection\" , [ 0 , 0 , - 0.6 ], intersection_color ) input ( \"Press Enter to close\" ) if __name__ == \"__main__\" : _test_path_methods () Functions centerpoint_path def centerpoint_path ( start_pt : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], end_pt : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], boxes : list [ pyastrobee . utils . boxes . Box ] ) -> numpy . ndarray Determine a path between two points, using the center points of boxes and their intersections as waypoints Parameters: Name Type Description Default start_pt npt.ArrayLike Starting XYZ position, shape (3,) None end_pt npt.ArrayLike Ending XYZ position, shape (3,) None boxes list[Box] Sequence of safe boxes to pass through None Returns: Type Description np.ndarray Path from start to end, shape (2 * n_boxes + 1, 3) View Source def centerpoint_path ( start_pt : npt . ArrayLike , end_pt : npt . ArrayLike , boxes : list [ Box ] ) -> np . ndarray : \"\"\"Determine a path between two points, using the center points of boxes and their intersections as waypoints Args: start_pt (npt.ArrayLike): Starting XYZ position, shape (3,) end_pt (npt.ArrayLike): Ending XYZ position, shape (3,) boxes (list[Box]): Sequence of safe boxes to pass through Returns: np.ndarray: Path from start to end, shape (2 * n_boxes + 1, 3) \"\"\" n_boxes = len ( boxes ) # One point per box , one point per box intersection , and two points for start / end n_points = 2 * n_boxes + 1 points = np . empty (( n_points , 3 )) points [ 0 ] = start_pt points [ -1 ] = end_pt for i in range ( n_boxes ) : points [ 2 * i + 1 ] = boxes [ i ] . center if i < n_boxes - 1 : # Not the last box points [ 2 * i + 2 ] = intersect_boxes ( boxes [ i ] , boxes [ i + 1 ] ). center return points intersection_path def intersection_path ( start_pt : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], end_pt : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], boxes : list [ pyastrobee . utils . boxes . Box ] ) -> numpy . ndarray Determine a path between two points, using the intersections between consecutive boxes as waypoints Parameters: Name Type Description Default start_pt npt.ArrayLike Starting XYZ position, shape (3,) None end_pt npt.ArrayLike Ending XYZ position, shape (3,) None boxes list[Box] Sequence of safe boxes to pass through None Returns: Type Description np.ndarray Path from start to end, shape (n_boxes + 1, 3) View Source def intersection_path ( start_pt : npt . ArrayLike , end_pt : npt . ArrayLike , boxes : list [ Box ] ) -> np . ndarray : \"\"\"Determine a path between two points, using the intersections between consecutive boxes as waypoints Args: start_pt (npt.ArrayLike): Starting XYZ position, shape (3,) end_pt (npt.ArrayLike): Ending XYZ position, shape (3,) boxes (list[Box]): Sequence of safe boxes to pass through Returns: np.ndarray: Path from start to end, shape (n_boxes + 1, 3) \"\"\" n_boxes = len ( boxes ) n_points = n_boxes + 1 points = np . empty (( n_points , 3 )) points [ 0 ] = start_pt points [ -1 ] = end_pt for i in range ( n_boxes - 1 ) : points [ i + 1 ] = intersect_boxes ( boxes [ i ] , boxes [ i + 1 ] ). center return points min_length_path def min_length_path ( start_pt : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], end_pt : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], boxes : list [ pyastrobee . utils . boxes . Box ] ) -> numpy . ndarray Determine the minimum-length path between two points through a sequence of safe boxes Parameters: Name Type Description Default start_pt npt.ArrayLike Starting XYZ position, shape (3,) None end_pt npt.ArrayLike Ending XYZ position, shape (3,) None boxes list[Box] Sequence of safe boxes to pass through None Returns: Type Description np.ndarray Path from start to end, shape (n_boxes + 1, 3) View Source def min_length_path ( start_pt : npt . ArrayLike , end_pt : npt . ArrayLike , boxes : list [ Box ] ) -> np . ndarray : \"\"\"Determine the minimum-length path between two points through a sequence of safe boxes Args: start_pt (npt.ArrayLike): Starting XYZ position, shape (3,) end_pt (npt.ArrayLike): Ending XYZ position, shape (3,) boxes (list[Box]): Sequence of safe boxes to pass through Returns: np.ndarray: Path from start to end, shape (n_boxes + 1, 3) \"\"\" n_boxes = len ( boxes ) points = cp . Variable (( n_boxes + 1 , 3 )) pathlength = cp . sum ( cp . norm2 ( cp . diff ( points , axis = 0 ), axis = 1 )) objective = cp . Minimize ( pathlength ) constraints = [ points[0 ] == start_pt , points [ -1 ] == end_pt ] for i , box in enumerate ( boxes ) : lower , upper = box constraints . append ( points [ i ] >= lower ) constraints . append ( points [ i ] <= upper ) constraints . append ( points [ i + 1 ] >= lower ) constraints . append ( points [ i + 1 ] <= upper ) prob = cp . Problem ( objective , constraints ) prob . solve () if prob . status != cp . OPTIMAL : raise OptimizationError ( \"Unable to find a solution.\\n\" + \"Check that the set of boxes is connected and that the start/end points are contained in the boxes\" ) return points . value","title":"Box Paths"},{"location":"reference/pyastrobee/trajectories/box_paths/#module-pyastrobeetrajectoriesbox_paths","text":"Different ways of characterizing paths between regions of the environment These are mainly used for timing heuristics for splines right now - for instance, using a simple method of traversing the environment to create an estimate of how long we will spend in each region View Source \"\"\"Different ways of characterizing paths between regions of the environment These are mainly used for timing heuristics for splines right now - for instance, using a simple method of traversing the environment to create an estimate of how long we will spend in each region \"\"\" import time import numpy as np import numpy.typing as npt import cvxpy as cp import pybullet from pyastrobee.utils.boxes import Box , intersect_boxes , visualize_3D_box from pyastrobee.utils.debug_visualizer import visualize_path , visualize_points from pyastrobee.utils.errors import OptimizationError def min_length_path ( start_pt : npt . ArrayLike , end_pt : npt . ArrayLike , boxes : list [ Box ] ) -> np . ndarray : \"\"\"Determine the minimum-length path between two points through a sequence of safe boxes Args: start_pt (npt.ArrayLike): Starting XYZ position, shape (3,) end_pt (npt.ArrayLike): Ending XYZ position, shape (3,) boxes (list[Box]): Sequence of safe boxes to pass through Returns: np.ndarray: Path from start to end, shape (n_boxes + 1, 3) \"\"\" n_boxes = len ( boxes ) points = cp . Variable (( n_boxes + 1 , 3 )) pathlength = cp . sum ( cp . norm2 ( cp . diff ( points , axis = 0 ), axis = 1 )) objective = cp . Minimize ( pathlength ) constraints = [ points [ 0 ] == start_pt , points [ - 1 ] == end_pt ] for i , box in enumerate ( boxes ): lower , upper = box constraints . append ( points [ i ] >= lower ) constraints . append ( points [ i ] <= upper ) constraints . append ( points [ i + 1 ] >= lower ) constraints . append ( points [ i + 1 ] <= upper ) prob = cp . Problem ( objective , constraints ) prob . solve () if prob . status != cp . OPTIMAL : raise OptimizationError ( \"Unable to find a solution. \\n \" + \"Check that the set of boxes is connected and that the start/end points are contained in the boxes\" ) return points . value def centerpoint_path ( start_pt : npt . ArrayLike , end_pt : npt . ArrayLike , boxes : list [ Box ] ) -> np . ndarray : \"\"\"Determine a path between two points, using the center points of boxes and their intersections as waypoints Args: start_pt (npt.ArrayLike): Starting XYZ position, shape (3,) end_pt (npt.ArrayLike): Ending XYZ position, shape (3,) boxes (list[Box]): Sequence of safe boxes to pass through Returns: np.ndarray: Path from start to end, shape (2 * n_boxes + 1, 3) \"\"\" n_boxes = len ( boxes ) # One point per box, one point per box intersection, and two points for start/end n_points = 2 * n_boxes + 1 points = np . empty (( n_points , 3 )) points [ 0 ] = start_pt points [ - 1 ] = end_pt for i in range ( n_boxes ): points [ 2 * i + 1 ] = boxes [ i ] . center if i < n_boxes - 1 : # Not the last box points [ 2 * i + 2 ] = intersect_boxes ( boxes [ i ], boxes [ i + 1 ]) . center return points def intersection_path ( start_pt : npt . ArrayLike , end_pt : npt . ArrayLike , boxes : list [ Box ] ) -> np . ndarray : \"\"\"Determine a path between two points, using the intersections between consecutive boxes as waypoints Args: start_pt (npt.ArrayLike): Starting XYZ position, shape (3,) end_pt (npt.ArrayLike): Ending XYZ position, shape (3,) boxes (list[Box]): Sequence of safe boxes to pass through Returns: np.ndarray: Path from start to end, shape (n_boxes + 1, 3) \"\"\" n_boxes = len ( boxes ) n_points = n_boxes + 1 points = np . empty (( n_points , 3 )) points [ 0 ] = start_pt points [ - 1 ] = end_pt for i in range ( n_boxes - 1 ): points [ i + 1 ] = intersect_boxes ( boxes [ i ], boxes [ i + 1 ]) . center return points def _test_path_methods (): start_pt = [ 0.1 , 0.2 , 0.3 ] end_pt = [ 1.5 , 5 , 1.7 ] boxes = [ Box (( 0 , 0 , 0 ), ( 1 , 1 , 1 )), Box (( 0.5 , 0.5 , 0.5 ), ( 1.5 , 5 , 1.5 )), Box (( 1 , 4.5 , 1 ), ( 2 , 5.5 , 2 )), ] time_a = time . time () min_length_solution = min_length_path ( start_pt , end_pt , boxes ) time_b = time . time () centerpoint_solution = centerpoint_path ( start_pt , end_pt , boxes ) time_c = time . time () intersection_solution = intersection_path ( start_pt , end_pt , boxes ) time_d = time . time () print ( \"min length time: \" , time_b - time_a ) print ( \"centerpoint time: \" , time_c - time_b ) print ( \"intersection time: \" , time_d - time_c ) pybullet . connect ( pybullet . GUI ) min_length_color = ( 1 , 0 , 0 ) centerpoint_color = ( 0 , 1 , 0 ) intersection_color = ( 0 , 0 , 1 ) visualize_path ( min_length_solution , color = min_length_color ) visualize_path ( centerpoint_solution , color = centerpoint_color ) visualize_path ( intersection_solution , color = intersection_color ) visualize_points ( min_length_solution , color = min_length_color ) visualize_points ( centerpoint_solution , color = centerpoint_color ) visualize_points ( intersection_solution , color = intersection_color ) for box in boxes : visualize_3D_box ( box ) pybullet . addUserDebugText ( \"Min length\" , [ 0 , 0 , - 0.2 ], min_length_color ) pybullet . addUserDebugText ( \"Centerpoint\" , [ 0 , 0 , - 0.4 ], centerpoint_color ) pybullet . addUserDebugText ( \"Intersection\" , [ 0 , 0 , - 0.6 ], intersection_color ) input ( \"Press Enter to close\" ) if __name__ == \"__main__\" : _test_path_methods ()","title":"Module pyastrobee.trajectories.box_paths"},{"location":"reference/pyastrobee/trajectories/box_paths/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/trajectories/box_paths/#centerpoint_path","text":"def centerpoint_path ( start_pt : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], end_pt : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], boxes : list [ pyastrobee . utils . boxes . Box ] ) -> numpy . ndarray Determine a path between two points, using the center points of boxes and their intersections as waypoints Parameters: Name Type Description Default start_pt npt.ArrayLike Starting XYZ position, shape (3,) None end_pt npt.ArrayLike Ending XYZ position, shape (3,) None boxes list[Box] Sequence of safe boxes to pass through None Returns: Type Description np.ndarray Path from start to end, shape (2 * n_boxes + 1, 3) View Source def centerpoint_path ( start_pt : npt . ArrayLike , end_pt : npt . ArrayLike , boxes : list [ Box ] ) -> np . ndarray : \"\"\"Determine a path between two points, using the center points of boxes and their intersections as waypoints Args: start_pt (npt.ArrayLike): Starting XYZ position, shape (3,) end_pt (npt.ArrayLike): Ending XYZ position, shape (3,) boxes (list[Box]): Sequence of safe boxes to pass through Returns: np.ndarray: Path from start to end, shape (2 * n_boxes + 1, 3) \"\"\" n_boxes = len ( boxes ) # One point per box , one point per box intersection , and two points for start / end n_points = 2 * n_boxes + 1 points = np . empty (( n_points , 3 )) points [ 0 ] = start_pt points [ -1 ] = end_pt for i in range ( n_boxes ) : points [ 2 * i + 1 ] = boxes [ i ] . center if i < n_boxes - 1 : # Not the last box points [ 2 * i + 2 ] = intersect_boxes ( boxes [ i ] , boxes [ i + 1 ] ). center return points","title":"centerpoint_path"},{"location":"reference/pyastrobee/trajectories/box_paths/#intersection_path","text":"def intersection_path ( start_pt : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], end_pt : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], boxes : list [ pyastrobee . utils . boxes . Box ] ) -> numpy . ndarray Determine a path between two points, using the intersections between consecutive boxes as waypoints Parameters: Name Type Description Default start_pt npt.ArrayLike Starting XYZ position, shape (3,) None end_pt npt.ArrayLike Ending XYZ position, shape (3,) None boxes list[Box] Sequence of safe boxes to pass through None Returns: Type Description np.ndarray Path from start to end, shape (n_boxes + 1, 3) View Source def intersection_path ( start_pt : npt . ArrayLike , end_pt : npt . ArrayLike , boxes : list [ Box ] ) -> np . ndarray : \"\"\"Determine a path between two points, using the intersections between consecutive boxes as waypoints Args: start_pt (npt.ArrayLike): Starting XYZ position, shape (3,) end_pt (npt.ArrayLike): Ending XYZ position, shape (3,) boxes (list[Box]): Sequence of safe boxes to pass through Returns: np.ndarray: Path from start to end, shape (n_boxes + 1, 3) \"\"\" n_boxes = len ( boxes ) n_points = n_boxes + 1 points = np . empty (( n_points , 3 )) points [ 0 ] = start_pt points [ -1 ] = end_pt for i in range ( n_boxes - 1 ) : points [ i + 1 ] = intersect_boxes ( boxes [ i ] , boxes [ i + 1 ] ). center return points","title":"intersection_path"},{"location":"reference/pyastrobee/trajectories/box_paths/#min_length_path","text":"def min_length_path ( start_pt : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], end_pt : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], boxes : list [ pyastrobee . utils . boxes . Box ] ) -> numpy . ndarray Determine the minimum-length path between two points through a sequence of safe boxes Parameters: Name Type Description Default start_pt npt.ArrayLike Starting XYZ position, shape (3,) None end_pt npt.ArrayLike Ending XYZ position, shape (3,) None boxes list[Box] Sequence of safe boxes to pass through None Returns: Type Description np.ndarray Path from start to end, shape (n_boxes + 1, 3) View Source def min_length_path ( start_pt : npt . ArrayLike , end_pt : npt . ArrayLike , boxes : list [ Box ] ) -> np . ndarray : \"\"\"Determine the minimum-length path between two points through a sequence of safe boxes Args: start_pt (npt.ArrayLike): Starting XYZ position, shape (3,) end_pt (npt.ArrayLike): Ending XYZ position, shape (3,) boxes (list[Box]): Sequence of safe boxes to pass through Returns: np.ndarray: Path from start to end, shape (n_boxes + 1, 3) \"\"\" n_boxes = len ( boxes ) points = cp . Variable (( n_boxes + 1 , 3 )) pathlength = cp . sum ( cp . norm2 ( cp . diff ( points , axis = 0 ), axis = 1 )) objective = cp . Minimize ( pathlength ) constraints = [ points[0 ] == start_pt , points [ -1 ] == end_pt ] for i , box in enumerate ( boxes ) : lower , upper = box constraints . append ( points [ i ] >= lower ) constraints . append ( points [ i ] <= upper ) constraints . append ( points [ i + 1 ] >= lower ) constraints . append ( points [ i + 1 ] <= upper ) prob = cp . Problem ( objective , constraints ) prob . solve () if prob . status != cp . OPTIMAL : raise OptimizationError ( \"Unable to find a solution.\\n\" + \"Check that the set of boxes is connected and that the start/end points are contained in the boxes\" ) return points . value","title":"min_length_path"},{"location":"reference/pyastrobee/trajectories/curve_utils/","text":"Module pyastrobee.trajectories.curve_utils Curve tools: Plotting, trajectory construction, and more View Source \"\"\"Curve tools: Plotting, trajectory construction, and more\"\"\" from typing import Union , Optional import cvxpy as cp import numpy as np import matplotlib.pyplot as plt from scipy.spatial import ConvexHull from matplotlib.patches import Polygon from pyastrobee.trajectories.trajectory import Trajectory from pyastrobee.trajectories.bezier import BezierCurve , bezier_trajectory from pyastrobee.trajectories.splines import CompositeBezierCurve def traj_from_curve ( curve : Union [ BezierCurve , CompositeBezierCurve ], dt : float ) -> Trajectory : \"\"\"Construct a position-only trajectory from a Bezier curve or spline Args: curve (Union[BezierCurve, CompositeBezierCurve]): Curve for the position motion dt (float): Timestep Returns: Trajectory: Position (and derivatives) trajectory information \"\"\" t0 = curve . a tf = curve . b . value if isinstance ( curve . b , ( cp . Variable , cp . Expression )) else curve . b # TODO see if we can refine how this time works... The spacing isn't going to be exactly dt times = np . linspace ( t0 , tf , round (( tf - t0 ) / dt )) pos = curve ( times ) vel = curve . derivative ( times ) accel = curve . derivative . derivative ( times ) return Trajectory ( pos , None , vel , None , accel , None , times ) def plot_1d_bezier_curve ( curve : BezierCurve , n_pts : int = 50 , plot_pts : bool = True , plot_hull : bool = True , ax : Optional [ plt . Axes ] = None , show : bool = True , ** kwargs , ) -> plt . Axes : \"\"\"Plots a 1D Bezier curve assuming the control points are evenly spaced in time Args: curve (BezierCurve): Bezier curve to plot n_pts (int): Number of points to evaluate the curve. Defaults to 50. plot_pts (bool, optional): Whether or not to display the curve's control points. Defaults to True. plot_hull (bool, optional): Whether or not to display the convex hull of the control points. Defaults to True. ax (Optional[plt.Axes]): Axes for plotting, if re-using an existing plot. Defaults to None (create new plot). show (bool, optional): Whether or not to show the plot. Defaults to True. Returns: plt.Axes: The plot \"\"\" assert curve . d == 1 points = np . ravel ( curve . points ) # Times to evaluate the curve t = np . linspace ( curve . a , curve . b , n_pts , endpoint = True ) # \"Times\" at which we assign the control points along the x axis x = np . linspace ( curve . a , curve . b , len ( points ), endpoint = True ) if ax is None : ax = plt . gca () ax . plot ( t , curve ( t ), ** kwargs ) ax . set_xlabel ( \"Time\" ) ax . set_ylabel ( \"Variable\" ) color = ax . lines [ - 1 ] . get_color () if plot_pts : ax . scatter ( x , points , c = color , ** kwargs ) if plot_hull : hull = ConvexHull ( np . column_stack ([ x , points ])) ordered_points = hull . points [ hull . vertices ] poly = Polygon ( ordered_points , fc = color , alpha = 0.5 , ** kwargs ) ax . add_patch ( poly ) if show : plt . show () return ax def plot_2d_bezier_curve ( curve : BezierCurve , n_pts : int = 50 , plot_pts : bool = True , plot_hull : bool = True , ax : Optional [ plt . Axes ] = None , show : bool = True , ** kwargs , ) -> plt . Axes : \"\"\"Plots a 2D Bezier curve Args: curve (BezierCurve): Bezier curve to plot n_pts (int): Number of points to evaluate the curve. Defaults to 50. plot_pts (bool, optional): Whether or not to display the curve's control points. Defaults to True. plot_hull (bool, optional): Whether or not to display the convex hull of the control points. Defaults to True. ax (Optional[plt.Axes]): Axes for plotting, if re-using an existing plot. Defaults to None (create new plot). show (bool, optional): Whether or not to show the plot. Defaults to True. Returns: plt.Axes: The plot \"\"\" assert curve . d == 2 t = np . linspace ( curve . a , curve . b , n_pts , endpoint = True ) if ax is None : ax = plt . gca () ax . plot ( * curve ( t ) . T , ** kwargs ) ax . set_xlabel ( \"X\" ) ax . set_ylabel ( \"Y\" ) color = ax . lines [ - 1 ] . get_color () if plot_pts : ax . scatter ( * curve . points . T , c = color , ** kwargs ) if plot_hull : hull = ConvexHull ( curve . points ) ordered_points = hull . points [ hull . vertices ] poly = Polygon ( ordered_points , fc = color , alpha = 0.5 , ** kwargs ) ax . add_patch ( poly ) if show : plt . show () return ax def plot_3d_bezier_traj ( curve : BezierCurve , n_pts : int = 50 ): \"\"\"Plots the trajectory components of a Bezier curve, including its first and second derivatives Args: curve (BezierCurve): Bezier curve used for a position trajectory n_pts (int): Number of points to plot. Defaults to 50. \"\"\" assert curve . d == 3 t = np . linspace ( curve . a , curve . b , n_pts , endpoint = True ) # Evaluate the positions, velocities, and accelerations on the curve at specified times pos_evals = curve ( t ) vel_curve = curve . derivative vel_evals = vel_curve ( t ) accel_curve = vel_curve . derivative accel_evals = accel_curve ( t ) # Plot the position, velocity, acceleration components on separate axes fig = plt . figure () subfigs = fig . subfigures ( 1 , 3 ) left = subfigs [ 0 ] . subplots ( 1 , 3 ) middle = subfigs [ 1 ] . subplots ( 1 , 3 ) right = subfigs [ 2 ] . subplots ( 1 , 3 ) pos_labels = [ \"x\" , \"y\" , \"z\" ] vel_labels = [ \"vx\" , \"vy\" , \"vz\" ] accel_labels = [ \"ax\" , \"ay\" , \"az\" ] for i , ax in enumerate ( left ): ax . plot ( pos_evals [:, i ]) ax . set_title ( pos_labels [ i ]) for i , ax in enumerate ( middle ): ax . plot ( vel_evals [:, i ]) ax . set_title ( vel_labels [ i ]) for i , ax in enumerate ( right ): ax . plot ( accel_evals [:, i ]) ax . set_title ( accel_labels [ i ]) plt . show () def plot_1d_composite_bezier_curve ( curve : CompositeBezierCurve , n_pts : int = 50 , plot_pts : bool = True , plot_hull : bool = True , ax : Optional [ plt . Axes ] = None , show : bool = True , ** kwargs , ) -> plt . Axes : \"\"\"Plots a 1D composite Bezier curve Args: curve (BezierCurve): Composite Bezier curve to plot n_pts (int): Number of points to evaluate the curve. Defaults to 50. plot_pts (bool, optional): Whether or not to display the curve's control points. Defaults to True. plot_hull (bool, optional): Whether or not to display the convex hull of the control points. Defaults to True. ax (Optional[plt.Axes]): Axes for plotting, if re-using an existing plot. Defaults to None (create new plot). show (bool, optional): Whether or not to show the plot. Defaults to True. Returns: plt.Axes: The plot \"\"\" assert curve . d == 1 if ax is None : ax = plt . gca () for bez in curve . beziers : # Assign the number of points to plot based on the fraction of the total interval # for a single bezier curve within the whole composite curve n = round (( bez . duration / curve . duration ) * n_pts ) ax = plot_1d_bezier_curve ( bez , n , plot_pts , plot_hull , ax , show = False , ** kwargs ) if show : plt . show () return ax def plot_2d_composite_bezier_curve ( curve : CompositeBezierCurve , n_pts : int = 50 , plot_pts : bool = True , plot_hull : bool = True , ax : Optional [ plt . Axes ] = None , show : bool = True , ** kwargs , ) -> plt . Axes : \"\"\"Plots a 2D composite Bezier curve Args: curve (BezierCurve): Composite Bezier curve to plot n_pts (int): Number of points to evaluate the curve. Defaults to 50. plot_pts (bool, optional): Whether or not to display the curve's control points. Defaults to True. plot_hull (bool, optional): Whether or not to display the convex hull of the control points. Defaults to True. ax (Optional[plt.Axes]): Axes for plotting, if re-using an existing plot. Defaults to None (create new plot). show (bool, optional): Whether or not to show the plot. Defaults to True. Returns: plt.Axes: The plot \"\"\" assert curve . d == 2 if ax is None : ax = plt . gca () for bez in curve . beziers : # Assign the number of points to plot based on the fraction of the total interval # for a single bezier curve within the whole composite curve n = round (( bez . duration / curve . duration ) * n_pts ) ax = plot_2d_bezier_curve ( bez , n , plot_pts , plot_hull , ax , show = False , ** kwargs ) if show : plt . show () return ax def _test_plotting_spline (): # Create a test composite curve from three children # These curves are randomly selected and do not enforce continuity in any derivatives pts_a = np . array ([[ 0 , 0 ], [ 1 , 3 ], [ 3 , 1 ], [ 5 , 5 ]]) pts_b = np . array ([[ 5 , 5 ], [ 6 , 5 ], [ 7 , 4 ], [ 8 , 3 ]]) pts_c = np . array ([[ 8 , 3 ], [ 10 , 3 ], [ 9 , 5 ], [ 12 , 7 ]]) curve_a = BezierCurve ( pts_a , 0 , 2 ) curve_b = BezierCurve ( pts_b , 2 , 3 ) curve_c = BezierCurve ( pts_c , 3 , 5 ) curves = [ curve_a , curve_b , curve_c ] spline = CompositeBezierCurve ( curves ) ax = plot_2d_composite_bezier_curve ( spline , 30 , True , True , show = False ) plt . show () def _test_bezier_traj (): p0 = [ 1 , 2 , 3 ] pf = [ 2 , 3 , 4 ] t0 = 0 tf = 5 n_control_pts = 10 dt = 0.1 v0 = [ - 0.1 , - 0.2 , - 0.3 ] vf = [ - 0.2 , - 0.2 , - 0.2 ] a0 = [ 0 , 0 , 0 ] af = [ 0.1 , 0.1 , 0.1 ] curve , _ = bezier_trajectory ( p0 , pf , t0 , tf , n_control_pts , v0 , vf , a0 , af ) # Leaving out any rotational info for now traj = traj_from_curve ( curve , dt ) traj . plot () if __name__ == \"__main__\" : _test_plotting_spline () _test_bezier_traj () Functions plot_1d_bezier_curve def plot_1d_bezier_curve ( curve : pyastrobee . trajectories . bezier . BezierCurve , n_pts : int = 50 , plot_pts : bool = True , plot_hull : bool = True , ax : Optional [ matplotlib . axes . _axes . Axes ] = None , show : bool = True , ** kwargs ) -> matplotlib . axes . _axes . Axes Plots a 1D Bezier curve assuming the control points are evenly spaced in time Parameters: Name Type Description Default curve BezierCurve Bezier curve to plot None n_pts int Number of points to evaluate the curve. Defaults to 50. 50 plot_pts bool Whether or not to display the curve's control points. Defaults to True. True plot_hull bool Whether or not to display the convex hull of the control points. Defaults to True. True ax Optional[plt.Axes] Axes for plotting, if re-using an existing plot. Defaults to None (create new plot). None (create new plot) show bool Whether or not to show the plot. Defaults to True. True Returns: Type Description plt.Axes The plot View Source def plot_1d_bezier_curve ( curve: BezierCurve , n_pts: int = 50 , plot_pts: bool = True , plot_hull: bool = True , ax: Optional [ plt . Axes ] = None , show: bool = True , ** kwargs , ) -> plt . Axes: \"\"\"Plots a 1D Bezier curve assuming the control points are evenly spaced in time Args: curve ( BezierCurve ) : Bezier curve to plot n_pts ( int ) : Number of points to evaluate the curve . Defaults to 50. plot_pts ( bool , optional ) : Whether or not to display the curve ' s control points . Defaults to True . plot_hull ( bool , optional ) : Whether or not to display the convex hull of the control points . Defaults to True . ax ( Optional [ plt . Axes ]) : Axes for plotting , if re - using an existing plot . Defaults to None ( create new plot ). show ( bool , optional ) : Whether or not to show the plot . Defaults to True . Returns: plt . Axes: The plot \"\"\" assert curve . d == 1 points = np . ravel ( curve . points ) # Times to evaluate the curve t = np . linspace ( curve . a , curve . b , n_pts , endpoint = True ) # \"Times\" at which we assign the control points along the x axis x = np . linspace ( curve . a , curve . b , len ( points ), endpoint = True ) if ax is None: ax = plt . gca () ax . plot ( t , curve ( t ), ** kwargs ) ax . set_xlabel ( \"Time\" ) ax . set_ylabel ( \"Variable\" ) color = ax . lines [ - 1 ]. get_color () if plot_pts: ax . scatter ( x , points , c = color , ** kwargs ) if plot_hull: hull = ConvexHull ( np . column_stack ([ x , points ])) ordered_points = hull . points [ hull . vertices ] poly = Polygon ( ordered_points , fc = color , alpha = 0.5 , ** kwargs ) ax . add_patch ( poly ) if show: plt . show () return ax plot_1d_composite_bezier_curve def plot_1d_composite_bezier_curve ( curve : pyastrobee . trajectories . splines . CompositeBezierCurve , n_pts : int = 50 , plot_pts : bool = True , plot_hull : bool = True , ax : Optional [ matplotlib . axes . _axes . Axes ] = None , show : bool = True , ** kwargs ) -> matplotlib . axes . _axes . Axes Plots a 1D composite Bezier curve Parameters: Name Type Description Default curve BezierCurve Composite Bezier curve to plot None n_pts int Number of points to evaluate the curve. Defaults to 50. 50 plot_pts bool Whether or not to display the curve's control points. Defaults to True. True plot_hull bool Whether or not to display the convex hull of the control points. Defaults to True. True ax Optional[plt.Axes] Axes for plotting, if re-using an existing plot. Defaults to None (create new plot). None (create new plot) show bool Whether or not to show the plot. Defaults to True. True Returns: Type Description plt.Axes The plot View Source def plot_1d_composite_bezier_curve( curve: CompositeBezierCurve, n_pts: int = 50, plot_pts: bool = True, plot_hull: bool = True, ax: Optional[plt.Axes] = None, show: bool = True, **kwargs, ) -> plt.Axes: \"\"\"Plots a 1D composite Bezier curve Args: curve (BezierCurve): Composite Bezier curve to plot n_pts (int): Number of points to evaluate the curve. Defaults to 50. plot_pts (bool, optional): Whether or not to display the curve's control points. Defaults to True. plot_hull (bool, optional): Whether or not to display the convex hull of the control points. Defaults to True. ax (Optional[plt.Axes]): Axes for plotting, if re-using an existing plot. Defaults to None (create new plot). show (bool, optional): Whether or not to show the plot. Defaults to True. Returns: plt.Axes: The plot \"\"\" assert curve.d == 1 if ax is None: ax = plt.gca() for bez in curve.beziers: # Assign the number of points to plot based on the fraction of the total interval # for a single bezier curve within the whole composite curve n = round((bez.duration / curve.duration) * n_pts) ax = plot_1d_bezier_curve(bez, n, plot_pts, plot_hull, ax, show=False, * *kwargs) if show: plt.show() return ax plot_2d_bezier_curve def plot_2d_bezier_curve ( curve : pyastrobee . trajectories . bezier . BezierCurve , n_pts : int = 50 , plot_pts : bool = True , plot_hull : bool = True , ax : Optional [ matplotlib . axes . _axes . Axes ] = None , show : bool = True , ** kwargs ) -> matplotlib . axes . _axes . Axes Plots a 2D Bezier curve Parameters: Name Type Description Default curve BezierCurve Bezier curve to plot None n_pts int Number of points to evaluate the curve. Defaults to 50. 50 plot_pts bool Whether or not to display the curve's control points. Defaults to True. True plot_hull bool Whether or not to display the convex hull of the control points. Defaults to True. True ax Optional[plt.Axes] Axes for plotting, if re-using an existing plot. Defaults to None (create new plot). None (create new plot) show bool Whether or not to show the plot. Defaults to True. True Returns: Type Description plt.Axes The plot View Source def plot_2d_bezier_curve( curve: BezierCurve, n_pts: int = 50, plot_pts: bool = True, plot_hull: bool = True, ax: Optional[plt.Axes] = None, show: bool = True, **kwargs, ) -> plt.Axes: \"\"\"Plots a 2D Bezier curve Args: curve (BezierCurve): Bezier curve to plot n_pts (int): Number of points to evaluate the curve. Defaults to 50. plot_pts (bool, optional): Whether or not to display the curve's control points. Defaults to True. plot_hull (bool, optional): Whether or not to display the convex hull of the control points. Defaults to True. ax (Optional[plt.Axes]): Axes for plotting, if re-using an existing plot. Defaults to None (create new plot). show (bool, optional): Whether or not to show the plot. Defaults to True. Returns: plt.Axes: The plot \"\"\" assert curve.d == 2 t = np.linspace(curve.a, curve.b, n_pts, endpoint=True) if ax is None: ax = plt.gca() ax.plot(*curve(t).T, **kwargs) ax.set_xlabel(\"X\") ax.set_ylabel(\"Y\") color = ax.lines[-1].get_color() if plot_pts: ax.scatter(*curve.points.T, c=color, **kwargs) if plot_hull: hull = ConvexHull(curve.points) ordered_points = hull.points[hull.vertices] poly = Polygon(ordered_points, fc=color, alpha=0.5, **kwargs) ax.add_patch(poly) if show: plt.show() return ax plot_2d_composite_bezier_curve def plot_2d_composite_bezier_curve ( curve : pyastrobee . trajectories . splines . CompositeBezierCurve , n_pts : int = 50 , plot_pts : bool = True , plot_hull : bool = True , ax : Optional [ matplotlib . axes . _axes . Axes ] = None , show : bool = True , ** kwargs ) -> matplotlib . axes . _axes . Axes Plots a 2D composite Bezier curve Parameters: Name Type Description Default curve BezierCurve Composite Bezier curve to plot None n_pts int Number of points to evaluate the curve. Defaults to 50. 50 plot_pts bool Whether or not to display the curve's control points. Defaults to True. True plot_hull bool Whether or not to display the convex hull of the control points. Defaults to True. True ax Optional[plt.Axes] Axes for plotting, if re-using an existing plot. Defaults to None (create new plot). None (create new plot) show bool Whether or not to show the plot. Defaults to True. True Returns: Type Description plt.Axes The plot View Source def plot_2d_composite_bezier_curve( curve: CompositeBezierCurve, n_pts: int = 50, plot_pts: bool = True, plot_hull: bool = True, ax: Optional[plt.Axes] = None, show: bool = True, **kwargs, ) -> plt.Axes: \"\"\"Plots a 2D composite Bezier curve Args: curve (BezierCurve): Composite Bezier curve to plot n_pts (int): Number of points to evaluate the curve. Defaults to 50. plot_pts (bool, optional): Whether or not to display the curve's control points. Defaults to True. plot_hull (bool, optional): Whether or not to display the convex hull of the control points. Defaults to True. ax (Optional[plt.Axes]): Axes for plotting, if re-using an existing plot. Defaults to None (create new plot). show (bool, optional): Whether or not to show the plot. Defaults to True. Returns: plt.Axes: The plot \"\"\" assert curve.d == 2 if ax is None: ax = plt.gca() for bez in curve.beziers: # Assign the number of points to plot based on the fraction of the total interval # for a single bezier curve within the whole composite curve n = round((bez.duration / curve.duration) * n_pts) ax = plot_2d_bezier_curve(bez, n, plot_pts, plot_hull, ax, show=False, * *kwargs) if show: plt.show() return ax plot_3d_bezier_traj def plot_3d_bezier_traj ( curve : pyastrobee . trajectories . bezier . BezierCurve , n_pts : int = 50 ) Plots the trajectory components of a Bezier curve, including its first and second derivatives Parameters: Name Type Description Default curve BezierCurve Bezier curve used for a position trajectory None n_pts int Number of points to plot. Defaults to 50. 50 View Source def plot_3d_bezier_traj ( curve : BezierCurve , n_pts : int = 50 ) : \"\"\"Plots the trajectory components of a Bezier curve, including its first and second derivatives Args: curve (BezierCurve): Bezier curve used for a position trajectory n_pts (int): Number of points to plot. Defaults to 50. \"\"\" assert curve . d == 3 t = np . linspace ( curve . a , curve . b , n_pts , endpoint = True ) # Evaluate the positions , velocities , and accelerations on the curve at specified times pos_evals = curve ( t ) vel_curve = curve . derivative vel_evals = vel_curve ( t ) accel_curve = vel_curve . derivative accel_evals = accel_curve ( t ) # Plot the position , velocity , acceleration components on separate axes fig = plt . figure () subfigs = fig . subfigures ( 1 , 3 ) left = subfigs [ 0 ] . subplots ( 1 , 3 ) middle = subfigs [ 1 ] . subplots ( 1 , 3 ) right = subfigs [ 2 ] . subplots ( 1 , 3 ) pos_labels = [ \"x\", \"y\", \"z\" ] vel_labels = [ \"vx\", \"vy\", \"vz\" ] accel_labels = [ \"ax\", \"ay\", \"az\" ] for i , ax in enumerate ( left ) : ax . plot ( pos_evals [ :, i ] ) ax . set_title ( pos_labels [ i ] ) for i , ax in enumerate ( middle ) : ax . plot ( vel_evals [ :, i ] ) ax . set_title ( vel_labels [ i ] ) for i , ax in enumerate ( right ) : ax . plot ( accel_evals [ :, i ] ) ax . set_title ( accel_labels [ i ] ) plt . show () traj_from_curve def traj_from_curve ( curve : Union [ pyastrobee . trajectories . bezier . BezierCurve , pyastrobee . trajectories . splines . CompositeBezierCurve ], dt : float ) -> pyastrobee . trajectories . trajectory . Trajectory Construct a position-only trajectory from a Bezier curve or spline Parameters: Name Type Description Default curve Union[BezierCurve, CompositeBezierCurve] Curve for the position motion None dt float Timestep None Returns: Type Description Trajectory Position (and derivatives) trajectory information View Source def traj_from_curve ( curve : Union [ BezierCurve , CompositeBezierCurve ], dt : float ) -> Trajectory : \"\"\"Construct a position-only trajectory from a Bezier curve or spline Args: curve (Union[BezierCurve, CompositeBezierCurve]): Curve for the position motion dt (float): Timestep Returns: Trajectory: Position (and derivatives) trajectory information \"\"\" t0 = curve . a tf = curve . b . value if isinstance ( curve . b , ( cp . Variable , cp . Expression )) else curve . b # TODO see if we can refine how this time works ... The spacing isn 't going to be exactly dt times = np.linspace(t0, tf, round((tf - t0) / dt)) pos = curve(times) vel = curve.derivative(times) accel = curve.derivative.derivative(times) return Trajectory(pos, None, vel, None, accel, None, times)","title":"Curve Utils"},{"location":"reference/pyastrobee/trajectories/curve_utils/#module-pyastrobeetrajectoriescurve_utils","text":"Curve tools: Plotting, trajectory construction, and more View Source \"\"\"Curve tools: Plotting, trajectory construction, and more\"\"\" from typing import Union , Optional import cvxpy as cp import numpy as np import matplotlib.pyplot as plt from scipy.spatial import ConvexHull from matplotlib.patches import Polygon from pyastrobee.trajectories.trajectory import Trajectory from pyastrobee.trajectories.bezier import BezierCurve , bezier_trajectory from pyastrobee.trajectories.splines import CompositeBezierCurve def traj_from_curve ( curve : Union [ BezierCurve , CompositeBezierCurve ], dt : float ) -> Trajectory : \"\"\"Construct a position-only trajectory from a Bezier curve or spline Args: curve (Union[BezierCurve, CompositeBezierCurve]): Curve for the position motion dt (float): Timestep Returns: Trajectory: Position (and derivatives) trajectory information \"\"\" t0 = curve . a tf = curve . b . value if isinstance ( curve . b , ( cp . Variable , cp . Expression )) else curve . b # TODO see if we can refine how this time works... The spacing isn't going to be exactly dt times = np . linspace ( t0 , tf , round (( tf - t0 ) / dt )) pos = curve ( times ) vel = curve . derivative ( times ) accel = curve . derivative . derivative ( times ) return Trajectory ( pos , None , vel , None , accel , None , times ) def plot_1d_bezier_curve ( curve : BezierCurve , n_pts : int = 50 , plot_pts : bool = True , plot_hull : bool = True , ax : Optional [ plt . Axes ] = None , show : bool = True , ** kwargs , ) -> plt . Axes : \"\"\"Plots a 1D Bezier curve assuming the control points are evenly spaced in time Args: curve (BezierCurve): Bezier curve to plot n_pts (int): Number of points to evaluate the curve. Defaults to 50. plot_pts (bool, optional): Whether or not to display the curve's control points. Defaults to True. plot_hull (bool, optional): Whether or not to display the convex hull of the control points. Defaults to True. ax (Optional[plt.Axes]): Axes for plotting, if re-using an existing plot. Defaults to None (create new plot). show (bool, optional): Whether or not to show the plot. Defaults to True. Returns: plt.Axes: The plot \"\"\" assert curve . d == 1 points = np . ravel ( curve . points ) # Times to evaluate the curve t = np . linspace ( curve . a , curve . b , n_pts , endpoint = True ) # \"Times\" at which we assign the control points along the x axis x = np . linspace ( curve . a , curve . b , len ( points ), endpoint = True ) if ax is None : ax = plt . gca () ax . plot ( t , curve ( t ), ** kwargs ) ax . set_xlabel ( \"Time\" ) ax . set_ylabel ( \"Variable\" ) color = ax . lines [ - 1 ] . get_color () if plot_pts : ax . scatter ( x , points , c = color , ** kwargs ) if plot_hull : hull = ConvexHull ( np . column_stack ([ x , points ])) ordered_points = hull . points [ hull . vertices ] poly = Polygon ( ordered_points , fc = color , alpha = 0.5 , ** kwargs ) ax . add_patch ( poly ) if show : plt . show () return ax def plot_2d_bezier_curve ( curve : BezierCurve , n_pts : int = 50 , plot_pts : bool = True , plot_hull : bool = True , ax : Optional [ plt . Axes ] = None , show : bool = True , ** kwargs , ) -> plt . Axes : \"\"\"Plots a 2D Bezier curve Args: curve (BezierCurve): Bezier curve to plot n_pts (int): Number of points to evaluate the curve. Defaults to 50. plot_pts (bool, optional): Whether or not to display the curve's control points. Defaults to True. plot_hull (bool, optional): Whether or not to display the convex hull of the control points. Defaults to True. ax (Optional[plt.Axes]): Axes for plotting, if re-using an existing plot. Defaults to None (create new plot). show (bool, optional): Whether or not to show the plot. Defaults to True. Returns: plt.Axes: The plot \"\"\" assert curve . d == 2 t = np . linspace ( curve . a , curve . b , n_pts , endpoint = True ) if ax is None : ax = plt . gca () ax . plot ( * curve ( t ) . T , ** kwargs ) ax . set_xlabel ( \"X\" ) ax . set_ylabel ( \"Y\" ) color = ax . lines [ - 1 ] . get_color () if plot_pts : ax . scatter ( * curve . points . T , c = color , ** kwargs ) if plot_hull : hull = ConvexHull ( curve . points ) ordered_points = hull . points [ hull . vertices ] poly = Polygon ( ordered_points , fc = color , alpha = 0.5 , ** kwargs ) ax . add_patch ( poly ) if show : plt . show () return ax def plot_3d_bezier_traj ( curve : BezierCurve , n_pts : int = 50 ): \"\"\"Plots the trajectory components of a Bezier curve, including its first and second derivatives Args: curve (BezierCurve): Bezier curve used for a position trajectory n_pts (int): Number of points to plot. Defaults to 50. \"\"\" assert curve . d == 3 t = np . linspace ( curve . a , curve . b , n_pts , endpoint = True ) # Evaluate the positions, velocities, and accelerations on the curve at specified times pos_evals = curve ( t ) vel_curve = curve . derivative vel_evals = vel_curve ( t ) accel_curve = vel_curve . derivative accel_evals = accel_curve ( t ) # Plot the position, velocity, acceleration components on separate axes fig = plt . figure () subfigs = fig . subfigures ( 1 , 3 ) left = subfigs [ 0 ] . subplots ( 1 , 3 ) middle = subfigs [ 1 ] . subplots ( 1 , 3 ) right = subfigs [ 2 ] . subplots ( 1 , 3 ) pos_labels = [ \"x\" , \"y\" , \"z\" ] vel_labels = [ \"vx\" , \"vy\" , \"vz\" ] accel_labels = [ \"ax\" , \"ay\" , \"az\" ] for i , ax in enumerate ( left ): ax . plot ( pos_evals [:, i ]) ax . set_title ( pos_labels [ i ]) for i , ax in enumerate ( middle ): ax . plot ( vel_evals [:, i ]) ax . set_title ( vel_labels [ i ]) for i , ax in enumerate ( right ): ax . plot ( accel_evals [:, i ]) ax . set_title ( accel_labels [ i ]) plt . show () def plot_1d_composite_bezier_curve ( curve : CompositeBezierCurve , n_pts : int = 50 , plot_pts : bool = True , plot_hull : bool = True , ax : Optional [ plt . Axes ] = None , show : bool = True , ** kwargs , ) -> plt . Axes : \"\"\"Plots a 1D composite Bezier curve Args: curve (BezierCurve): Composite Bezier curve to plot n_pts (int): Number of points to evaluate the curve. Defaults to 50. plot_pts (bool, optional): Whether or not to display the curve's control points. Defaults to True. plot_hull (bool, optional): Whether or not to display the convex hull of the control points. Defaults to True. ax (Optional[plt.Axes]): Axes for plotting, if re-using an existing plot. Defaults to None (create new plot). show (bool, optional): Whether or not to show the plot. Defaults to True. Returns: plt.Axes: The plot \"\"\" assert curve . d == 1 if ax is None : ax = plt . gca () for bez in curve . beziers : # Assign the number of points to plot based on the fraction of the total interval # for a single bezier curve within the whole composite curve n = round (( bez . duration / curve . duration ) * n_pts ) ax = plot_1d_bezier_curve ( bez , n , plot_pts , plot_hull , ax , show = False , ** kwargs ) if show : plt . show () return ax def plot_2d_composite_bezier_curve ( curve : CompositeBezierCurve , n_pts : int = 50 , plot_pts : bool = True , plot_hull : bool = True , ax : Optional [ plt . Axes ] = None , show : bool = True , ** kwargs , ) -> plt . Axes : \"\"\"Plots a 2D composite Bezier curve Args: curve (BezierCurve): Composite Bezier curve to plot n_pts (int): Number of points to evaluate the curve. Defaults to 50. plot_pts (bool, optional): Whether or not to display the curve's control points. Defaults to True. plot_hull (bool, optional): Whether or not to display the convex hull of the control points. Defaults to True. ax (Optional[plt.Axes]): Axes for plotting, if re-using an existing plot. Defaults to None (create new plot). show (bool, optional): Whether or not to show the plot. Defaults to True. Returns: plt.Axes: The plot \"\"\" assert curve . d == 2 if ax is None : ax = plt . gca () for bez in curve . beziers : # Assign the number of points to plot based on the fraction of the total interval # for a single bezier curve within the whole composite curve n = round (( bez . duration / curve . duration ) * n_pts ) ax = plot_2d_bezier_curve ( bez , n , plot_pts , plot_hull , ax , show = False , ** kwargs ) if show : plt . show () return ax def _test_plotting_spline (): # Create a test composite curve from three children # These curves are randomly selected and do not enforce continuity in any derivatives pts_a = np . array ([[ 0 , 0 ], [ 1 , 3 ], [ 3 , 1 ], [ 5 , 5 ]]) pts_b = np . array ([[ 5 , 5 ], [ 6 , 5 ], [ 7 , 4 ], [ 8 , 3 ]]) pts_c = np . array ([[ 8 , 3 ], [ 10 , 3 ], [ 9 , 5 ], [ 12 , 7 ]]) curve_a = BezierCurve ( pts_a , 0 , 2 ) curve_b = BezierCurve ( pts_b , 2 , 3 ) curve_c = BezierCurve ( pts_c , 3 , 5 ) curves = [ curve_a , curve_b , curve_c ] spline = CompositeBezierCurve ( curves ) ax = plot_2d_composite_bezier_curve ( spline , 30 , True , True , show = False ) plt . show () def _test_bezier_traj (): p0 = [ 1 , 2 , 3 ] pf = [ 2 , 3 , 4 ] t0 = 0 tf = 5 n_control_pts = 10 dt = 0.1 v0 = [ - 0.1 , - 0.2 , - 0.3 ] vf = [ - 0.2 , - 0.2 , - 0.2 ] a0 = [ 0 , 0 , 0 ] af = [ 0.1 , 0.1 , 0.1 ] curve , _ = bezier_trajectory ( p0 , pf , t0 , tf , n_control_pts , v0 , vf , a0 , af ) # Leaving out any rotational info for now traj = traj_from_curve ( curve , dt ) traj . plot () if __name__ == \"__main__\" : _test_plotting_spline () _test_bezier_traj ()","title":"Module pyastrobee.trajectories.curve_utils"},{"location":"reference/pyastrobee/trajectories/curve_utils/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/trajectories/curve_utils/#plot_1d_bezier_curve","text":"def plot_1d_bezier_curve ( curve : pyastrobee . trajectories . bezier . BezierCurve , n_pts : int = 50 , plot_pts : bool = True , plot_hull : bool = True , ax : Optional [ matplotlib . axes . _axes . Axes ] = None , show : bool = True , ** kwargs ) -> matplotlib . axes . _axes . Axes Plots a 1D Bezier curve assuming the control points are evenly spaced in time Parameters: Name Type Description Default curve BezierCurve Bezier curve to plot None n_pts int Number of points to evaluate the curve. Defaults to 50. 50 plot_pts bool Whether or not to display the curve's control points. Defaults to True. True plot_hull bool Whether or not to display the convex hull of the control points. Defaults to True. True ax Optional[plt.Axes] Axes for plotting, if re-using an existing plot. Defaults to None (create new plot). None (create new plot) show bool Whether or not to show the plot. Defaults to True. True Returns: Type Description plt.Axes The plot View Source def plot_1d_bezier_curve ( curve: BezierCurve , n_pts: int = 50 , plot_pts: bool = True , plot_hull: bool = True , ax: Optional [ plt . Axes ] = None , show: bool = True , ** kwargs , ) -> plt . Axes: \"\"\"Plots a 1D Bezier curve assuming the control points are evenly spaced in time Args: curve ( BezierCurve ) : Bezier curve to plot n_pts ( int ) : Number of points to evaluate the curve . Defaults to 50. plot_pts ( bool , optional ) : Whether or not to display the curve ' s control points . Defaults to True . plot_hull ( bool , optional ) : Whether or not to display the convex hull of the control points . Defaults to True . ax ( Optional [ plt . Axes ]) : Axes for plotting , if re - using an existing plot . Defaults to None ( create new plot ). show ( bool , optional ) : Whether or not to show the plot . Defaults to True . Returns: plt . Axes: The plot \"\"\" assert curve . d == 1 points = np . ravel ( curve . points ) # Times to evaluate the curve t = np . linspace ( curve . a , curve . b , n_pts , endpoint = True ) # \"Times\" at which we assign the control points along the x axis x = np . linspace ( curve . a , curve . b , len ( points ), endpoint = True ) if ax is None: ax = plt . gca () ax . plot ( t , curve ( t ), ** kwargs ) ax . set_xlabel ( \"Time\" ) ax . set_ylabel ( \"Variable\" ) color = ax . lines [ - 1 ]. get_color () if plot_pts: ax . scatter ( x , points , c = color , ** kwargs ) if plot_hull: hull = ConvexHull ( np . column_stack ([ x , points ])) ordered_points = hull . points [ hull . vertices ] poly = Polygon ( ordered_points , fc = color , alpha = 0.5 , ** kwargs ) ax . add_patch ( poly ) if show: plt . show () return ax","title":"plot_1d_bezier_curve"},{"location":"reference/pyastrobee/trajectories/curve_utils/#plot_1d_composite_bezier_curve","text":"def plot_1d_composite_bezier_curve ( curve : pyastrobee . trajectories . splines . CompositeBezierCurve , n_pts : int = 50 , plot_pts : bool = True , plot_hull : bool = True , ax : Optional [ matplotlib . axes . _axes . Axes ] = None , show : bool = True , ** kwargs ) -> matplotlib . axes . _axes . Axes Plots a 1D composite Bezier curve Parameters: Name Type Description Default curve BezierCurve Composite Bezier curve to plot None n_pts int Number of points to evaluate the curve. Defaults to 50. 50 plot_pts bool Whether or not to display the curve's control points. Defaults to True. True plot_hull bool Whether or not to display the convex hull of the control points. Defaults to True. True ax Optional[plt.Axes] Axes for plotting, if re-using an existing plot. Defaults to None (create new plot). None (create new plot) show bool Whether or not to show the plot. Defaults to True. True Returns: Type Description plt.Axes The plot View Source def plot_1d_composite_bezier_curve( curve: CompositeBezierCurve, n_pts: int = 50, plot_pts: bool = True, plot_hull: bool = True, ax: Optional[plt.Axes] = None, show: bool = True, **kwargs, ) -> plt.Axes: \"\"\"Plots a 1D composite Bezier curve Args: curve (BezierCurve): Composite Bezier curve to plot n_pts (int): Number of points to evaluate the curve. Defaults to 50. plot_pts (bool, optional): Whether or not to display the curve's control points. Defaults to True. plot_hull (bool, optional): Whether or not to display the convex hull of the control points. Defaults to True. ax (Optional[plt.Axes]): Axes for plotting, if re-using an existing plot. Defaults to None (create new plot). show (bool, optional): Whether or not to show the plot. Defaults to True. Returns: plt.Axes: The plot \"\"\" assert curve.d == 1 if ax is None: ax = plt.gca() for bez in curve.beziers: # Assign the number of points to plot based on the fraction of the total interval # for a single bezier curve within the whole composite curve n = round((bez.duration / curve.duration) * n_pts) ax = plot_1d_bezier_curve(bez, n, plot_pts, plot_hull, ax, show=False, * *kwargs) if show: plt.show() return ax","title":"plot_1d_composite_bezier_curve"},{"location":"reference/pyastrobee/trajectories/curve_utils/#plot_2d_bezier_curve","text":"def plot_2d_bezier_curve ( curve : pyastrobee . trajectories . bezier . BezierCurve , n_pts : int = 50 , plot_pts : bool = True , plot_hull : bool = True , ax : Optional [ matplotlib . axes . _axes . Axes ] = None , show : bool = True , ** kwargs ) -> matplotlib . axes . _axes . Axes Plots a 2D Bezier curve Parameters: Name Type Description Default curve BezierCurve Bezier curve to plot None n_pts int Number of points to evaluate the curve. Defaults to 50. 50 plot_pts bool Whether or not to display the curve's control points. Defaults to True. True plot_hull bool Whether or not to display the convex hull of the control points. Defaults to True. True ax Optional[plt.Axes] Axes for plotting, if re-using an existing plot. Defaults to None (create new plot). None (create new plot) show bool Whether or not to show the plot. Defaults to True. True Returns: Type Description plt.Axes The plot View Source def plot_2d_bezier_curve( curve: BezierCurve, n_pts: int = 50, plot_pts: bool = True, plot_hull: bool = True, ax: Optional[plt.Axes] = None, show: bool = True, **kwargs, ) -> plt.Axes: \"\"\"Plots a 2D Bezier curve Args: curve (BezierCurve): Bezier curve to plot n_pts (int): Number of points to evaluate the curve. Defaults to 50. plot_pts (bool, optional): Whether or not to display the curve's control points. Defaults to True. plot_hull (bool, optional): Whether or not to display the convex hull of the control points. Defaults to True. ax (Optional[plt.Axes]): Axes for plotting, if re-using an existing plot. Defaults to None (create new plot). show (bool, optional): Whether or not to show the plot. Defaults to True. Returns: plt.Axes: The plot \"\"\" assert curve.d == 2 t = np.linspace(curve.a, curve.b, n_pts, endpoint=True) if ax is None: ax = plt.gca() ax.plot(*curve(t).T, **kwargs) ax.set_xlabel(\"X\") ax.set_ylabel(\"Y\") color = ax.lines[-1].get_color() if plot_pts: ax.scatter(*curve.points.T, c=color, **kwargs) if plot_hull: hull = ConvexHull(curve.points) ordered_points = hull.points[hull.vertices] poly = Polygon(ordered_points, fc=color, alpha=0.5, **kwargs) ax.add_patch(poly) if show: plt.show() return ax","title":"plot_2d_bezier_curve"},{"location":"reference/pyastrobee/trajectories/curve_utils/#plot_2d_composite_bezier_curve","text":"def plot_2d_composite_bezier_curve ( curve : pyastrobee . trajectories . splines . CompositeBezierCurve , n_pts : int = 50 , plot_pts : bool = True , plot_hull : bool = True , ax : Optional [ matplotlib . axes . _axes . Axes ] = None , show : bool = True , ** kwargs ) -> matplotlib . axes . _axes . Axes Plots a 2D composite Bezier curve Parameters: Name Type Description Default curve BezierCurve Composite Bezier curve to plot None n_pts int Number of points to evaluate the curve. Defaults to 50. 50 plot_pts bool Whether or not to display the curve's control points. Defaults to True. True plot_hull bool Whether or not to display the convex hull of the control points. Defaults to True. True ax Optional[plt.Axes] Axes for plotting, if re-using an existing plot. Defaults to None (create new plot). None (create new plot) show bool Whether or not to show the plot. Defaults to True. True Returns: Type Description plt.Axes The plot View Source def plot_2d_composite_bezier_curve( curve: CompositeBezierCurve, n_pts: int = 50, plot_pts: bool = True, plot_hull: bool = True, ax: Optional[plt.Axes] = None, show: bool = True, **kwargs, ) -> plt.Axes: \"\"\"Plots a 2D composite Bezier curve Args: curve (BezierCurve): Composite Bezier curve to plot n_pts (int): Number of points to evaluate the curve. Defaults to 50. plot_pts (bool, optional): Whether or not to display the curve's control points. Defaults to True. plot_hull (bool, optional): Whether or not to display the convex hull of the control points. Defaults to True. ax (Optional[plt.Axes]): Axes for plotting, if re-using an existing plot. Defaults to None (create new plot). show (bool, optional): Whether or not to show the plot. Defaults to True. Returns: plt.Axes: The plot \"\"\" assert curve.d == 2 if ax is None: ax = plt.gca() for bez in curve.beziers: # Assign the number of points to plot based on the fraction of the total interval # for a single bezier curve within the whole composite curve n = round((bez.duration / curve.duration) * n_pts) ax = plot_2d_bezier_curve(bez, n, plot_pts, plot_hull, ax, show=False, * *kwargs) if show: plt.show() return ax","title":"plot_2d_composite_bezier_curve"},{"location":"reference/pyastrobee/trajectories/curve_utils/#plot_3d_bezier_traj","text":"def plot_3d_bezier_traj ( curve : pyastrobee . trajectories . bezier . BezierCurve , n_pts : int = 50 ) Plots the trajectory components of a Bezier curve, including its first and second derivatives Parameters: Name Type Description Default curve BezierCurve Bezier curve used for a position trajectory None n_pts int Number of points to plot. Defaults to 50. 50 View Source def plot_3d_bezier_traj ( curve : BezierCurve , n_pts : int = 50 ) : \"\"\"Plots the trajectory components of a Bezier curve, including its first and second derivatives Args: curve (BezierCurve): Bezier curve used for a position trajectory n_pts (int): Number of points to plot. Defaults to 50. \"\"\" assert curve . d == 3 t = np . linspace ( curve . a , curve . b , n_pts , endpoint = True ) # Evaluate the positions , velocities , and accelerations on the curve at specified times pos_evals = curve ( t ) vel_curve = curve . derivative vel_evals = vel_curve ( t ) accel_curve = vel_curve . derivative accel_evals = accel_curve ( t ) # Plot the position , velocity , acceleration components on separate axes fig = plt . figure () subfigs = fig . subfigures ( 1 , 3 ) left = subfigs [ 0 ] . subplots ( 1 , 3 ) middle = subfigs [ 1 ] . subplots ( 1 , 3 ) right = subfigs [ 2 ] . subplots ( 1 , 3 ) pos_labels = [ \"x\", \"y\", \"z\" ] vel_labels = [ \"vx\", \"vy\", \"vz\" ] accel_labels = [ \"ax\", \"ay\", \"az\" ] for i , ax in enumerate ( left ) : ax . plot ( pos_evals [ :, i ] ) ax . set_title ( pos_labels [ i ] ) for i , ax in enumerate ( middle ) : ax . plot ( vel_evals [ :, i ] ) ax . set_title ( vel_labels [ i ] ) for i , ax in enumerate ( right ) : ax . plot ( accel_evals [ :, i ] ) ax . set_title ( accel_labels [ i ] ) plt . show ()","title":"plot_3d_bezier_traj"},{"location":"reference/pyastrobee/trajectories/curve_utils/#traj_from_curve","text":"def traj_from_curve ( curve : Union [ pyastrobee . trajectories . bezier . BezierCurve , pyastrobee . trajectories . splines . CompositeBezierCurve ], dt : float ) -> pyastrobee . trajectories . trajectory . Trajectory Construct a position-only trajectory from a Bezier curve or spline Parameters: Name Type Description Default curve Union[BezierCurve, CompositeBezierCurve] Curve for the position motion None dt float Timestep None Returns: Type Description Trajectory Position (and derivatives) trajectory information View Source def traj_from_curve ( curve : Union [ BezierCurve , CompositeBezierCurve ], dt : float ) -> Trajectory : \"\"\"Construct a position-only trajectory from a Bezier curve or spline Args: curve (Union[BezierCurve, CompositeBezierCurve]): Curve for the position motion dt (float): Timestep Returns: Trajectory: Position (and derivatives) trajectory information \"\"\" t0 = curve . a tf = curve . b . value if isinstance ( curve . b , ( cp . Variable , cp . Expression )) else curve . b # TODO see if we can refine how this time works ... The spacing isn 't going to be exactly dt times = np.linspace(t0, tf, round((tf - t0) / dt)) pos = curve(times) vel = curve.derivative(times) accel = curve.derivative.derivative(times) return Trajectory(pos, None, vel, None, accel, None, times)","title":"traj_from_curve"},{"location":"reference/pyastrobee/trajectories/decasteljau_slerp/","text":"Module pyastrobee.trajectories.decasteljau_slerp More rotation interpolation methods that naturally account for boundary conditions and guarantee quaternion normalization, unlike the quaternion polynomial method These \"spherical bezier curves\" are relatively computationally intensive to solve, because it requires a lot of calls to SLERP for each point we're interpolating (due to the recursive nature of De Casteljau's algorithm) In most cases it will be better to use fast approximate methods to rotation planning, but this can serve as a good reference curve Reference: https://www.cs.cmu.edu/~kiranb/animation/p245-shoemake.pdf https://web.archive.org/web/20120915153625/http://courses.cms.caltech.edu/cs171/quatut.pdf https://splines.readthedocs.io/en/latest/rotation/index.html View Source \"\"\"More rotation interpolation methods that naturally account for boundary conditions and guarantee quaternion normalization, unlike the quaternion polynomial method These \"spherical bezier curves\" are relatively computationally intensive to solve, because it requires a lot of calls to SLERP for each point we're interpolating (due to the recursive nature of De Casteljau's algorithm) In most cases it will be better to use fast approximate methods to rotation planning, but this can serve as a good reference curve Reference: https://www.cs.cmu.edu/~kiranb/animation/p245-shoemake.pdf https://web.archive.org/web/20120915153625/http://courses.cms.caltech.edu/cs171/quatut.pdf https://splines.readthedocs.io/en/latest/rotation/index.html \"\"\" # TODO # - This file needs a lot of cleanup if we are in fact using some of these methods # - Move quaternion math operations to the main quaternions file? # - Get nonzero angular acceleration vector BCs implemented (currently can only handle zero magnitude in accel) # - Check out the SQUAD algorithm. This seems very similar to a cubic decasteljau spherical bezier curve but with a # different parameterization of the \"t\" interpolation value import pybullet import numpy as np from pyastrobee . utils . quaternions import ( quaternion_slerp , random_quaternion , quats_to_angular_velocities , conjugate , exponential_map , log_map , pure , multiply , ) from pyastrobee . trajectories . trajectory import Trajectory from pyastrobee . utils . debug_visualizer import animate_rotation # Interpolation methods def cubic_decasteljau_slerp ( q0 , q1 , q2 , q3 , t ): if not np . isscalar ( t ): # If t is a list, return a list of unit quaternions return [ cubic_decasteljau_slerp ( q0 , q1 , q2 , q3 , t_i ) for t_i in t ] slerp_01 = quaternion_slerp ( q0 , q1 , t ) slerp_12 = quaternion_slerp ( q1 , q2 , t ) slerp_23 = quaternion_slerp ( q2 , q3 , t ) return quaternion_slerp ( quaternion_slerp ( slerp_01 , slerp_12 , t ), quaternion_slerp ( slerp_12 , slerp_23 , t ), t , ) def quintic_decasteljau_slerp ( q0 , q1 , q2 , q3 , q4 , q5 , t ): if not np . isscalar ( t ): # If t is a list, return a list of unit quaternions return [ quintic_decasteljau_slerp ( q0 , q1 , q2 , q3 , q4 , q5 , t_i ) for t_i in t ] slerp_01 = quaternion_slerp ( q0 , q1 , t ) slerp_12 = quaternion_slerp ( q1 , q2 , t ) slerp_23 = quaternion_slerp ( q2 , q3 , t ) slerp_34 = quaternion_slerp ( q3 , q4 , t ) slerp_45 = quaternion_slerp ( q4 , q5 , t ) slerp_012 = quaternion_slerp ( slerp_01 , slerp_12 , t ) slerp_123 = quaternion_slerp ( slerp_12 , slerp_23 , t ) slerp_234 = quaternion_slerp ( slerp_23 , slerp_34 , t ) slerp_345 = quaternion_slerp ( slerp_34 , slerp_45 , t ) slerp_0123 = quaternion_slerp ( slerp_012 , slerp_123 , t ) slerp_1234 = quaternion_slerp ( slerp_123 , slerp_234 , t ) slerp_2345 = quaternion_slerp ( slerp_234 , slerp_345 , t ) slerp_01234 = quaternion_slerp ( slerp_0123 , slerp_1234 , t ) slerp_12345 = quaternion_slerp ( slerp_1234 , slerp_2345 , t ) return quaternion_slerp ( slerp_01234 , slerp_12345 , t ) # This parameterization of t is the same as in the Shoemake paper but it doesn't seem to make any sense, # because it's a quadratic that doesn't actually reach 1, so we don't get to the final interpolated quaternion? # Though, I might be doing this wrong def squad ( q0 , q1 , q2 , q3 , t ): return cubic_decasteljau_slerp ( q0 , q1 , q2 , q3 , 2 * t * ( 1 - t )) # Given an initial quaternion q and an initial angular velocity w, find another quaternion such that the SLERP arc # yields an angular velocity vector parallel to w. Since the length of this arc doesn't affect the direction of this # angular velocity vector (just the magnitude), c is a constant scaling factor that is tunable def q_for_w ( q , w , c ): return conjugate ( multiply ( conjugate ( q ), exponential_map ( c * w ))) # This doesn't work... sad. Try to figure out the actual math behind this curvature condition def q_for_a ( q , w , a , c ): c = 1 / 5 # hardcode hack qw = q_for_w ( q , w , c ) qw2 = q_for_w ( qw , a , c ) return qw2 # Interpolate two rotations, matching boundary conditions on angular velocity def decasteljau_vel_bcs ( q0 , qf , w0 , wf , t ): q1 = q_for_w ( q0 , - w0 , 1 / 3 ) q2 = q_for_w ( qf , wf , 1 / 3 ) return cubic_decasteljau_slerp ( q0 , q1 , q2 , qf , t ) # Interpolate two rotations, matching boundary conditions on angular velocity, and set the angular acceleration at # either end to be 0 def decasteljau_vel_0_accel_bc ( q0 , qf , w0 , wf , t ): # NOTE: # I tried setting the control points for arbitrary alpha vectors but could not get this to work properly # Instead, the control points are placed so that the angular aceleration at either end is 0 q1 = q_for_w ( q0 , - w0 , 1 / 5 ) q2 = q_for_w ( q0 , - w0 , 2 / 5 ) q3 = q_for_w ( qf , wf , 2 / 5 ) q4 = q_for_w ( qf , wf , 1 / 5 ) return quintic_decasteljau_slerp ( q0 , q1 , q2 , q3 , q4 , qf , t ) def _test_vel_bcs (): # np.random.seed(0) q0 = random_quaternion () qf = random_quaternion () print ( \"Start q: \" , q0 ) print ( \"End q: \" , qf ) w0 = np . array ([ 0.1 , 0.2 , 0.3 ]) wf = np . array ([ 0.15 , 0.25 , 0.35 ]) t = np . linspace ( 0 , 1 , 500 ) dt = t [ 1 ] - t [ 0 ] quats = decasteljau_vel_bcs ( q0 , qf , w0 , wf , t ) omega = quats_to_angular_velocities ( quats , dt ) alpha = np . gradient ( omega , dt , axis = 0 ) traj = Trajectory ( None , quats , None , omega , None , alpha , t ) print ( \"Start w: \" , omega [ 0 ]) print ( \"End w: \" , omega [ - 1 ]) pybullet . connect ( pybullet . GUI ) animate_rotation ( traj . quaternions , 5 ) input ( \"Animation complete, press Enter to exit\" ) pybullet . disconnect () traj . plot () def _test_vel_accel_bcs (): # np.random.seed(0) q0 = random_quaternion () qf = random_quaternion () print ( \"Start q: \" , q0 ) print ( \"End q: \" , qf ) w0 = np . array ([ 0.1 , 0.2 , 0.3 ]) wf = np . array ([ 0.15 , 0.25 , 0.35 ]) t = np . linspace ( 0 , 1 , 500 ) dt = t [ 1 ] - t [ 0 ] quats = decasteljau_vel_0_accel_bc ( q0 , qf , w0 , wf , t ) omega = quats_to_angular_velocities ( quats , dt ) alpha = np . gradient ( omega , dt , axis = 0 ) traj = Trajectory ( None , quats , None , omega , None , alpha , t ) print ( \"Start w: \" , omega [ 0 ]) print ( \"End w: \" , omega [ - 1 ]) print ( \"Start a: \" , alpha [ 0 ]) print ( \"End a: \" , alpha [ - 1 ]) pybullet . connect ( pybullet . GUI ) animate_rotation ( traj . quaternions , 5 ) input ( \"Animation complete, press Enter to exit\" ) pybullet . disconnect () traj . plot () if __name__ == \"__main__\" : _test_vel_bcs () _test_vel_accel_bcs () Functions cubic_decasteljau_slerp def cubic_decasteljau_slerp ( q0 , q1 , q2 , q3 , t ) View Source def cubic_decasteljau_slerp(q0, q1, q2, q3, t): if not np.isscalar(t): # If t is a list, return a list of unit quaternions return [cubic_decasteljau_slerp(q0, q1, q2, q3, t_i) for t_i in t] slerp_01 = quaternion_slerp(q0, q1, t) slerp_12 = quaternion_slerp(q1, q2, t) slerp_23 = quaternion_slerp(q2, q3, t) return quaternion_slerp( quaternion_slerp(slerp_01, slerp_12, t), quaternion_slerp(slerp_12, slerp_23, t), t, ) decasteljau_vel_0_accel_bc def decasteljau_vel_0_accel_bc ( q0 , qf , w0 , wf , t ) View Source def decasteljau_vel_0_accel_bc(q0, qf, w0, wf, t): # NOTE: # I tried setting the control points for arbitrary alpha vectors but could not get this to work properly # Instead, the control points are placed so that the angular aceleration at either end is 0 q1 = q_for_w(q0, -w0, 1 / 5) q2 = q_for_w(q0, -w0, 2 / 5) q3 = q_for_w(qf, wf, 2 / 5) q4 = q_for_w(qf, wf, 1 / 5) return quintic_decasteljau_slerp(q0, q1, q2, q3, q4, qf, t) decasteljau_vel_bcs def decasteljau_vel_bcs ( q0 , qf , w0 , wf , t ) View Source def decasteljau_vel_bcs(q0, qf, w0, wf, t): q1 = q_for_w(q0, -w0, 1 / 3) q2 = q_for_w(qf, wf, 1 / 3) return cubic_decasteljau_slerp(q0, q1, q2, qf, t) q_for_a def q_for_a ( q , w , a , c ) View Source def q_for_a(q, w, a, c): c = 1 / 5 # hardcode hack qw = q_for_w(q, w, c) qw2 = q_for_w(qw, a, c) return qw2 q_for_w def q_for_w ( q , w , c ) View Source def q_for_w(q, w, c): return conjugate(multiply(conjugate(q), exponential_map(c * w))) quintic_decasteljau_slerp def quintic_decasteljau_slerp ( q0 , q1 , q2 , q3 , q4 , q5 , t ) View Source def quintic_decasteljau_slerp(q0, q1, q2, q3, q4, q5, t): if not np.isscalar(t): # If t is a list, return a list of unit quaternions return [quintic_decasteljau_slerp(q0, q1, q2, q3, q4, q5, t_i) for t_i in t] slerp_01 = quaternion_slerp(q0, q1, t) slerp_12 = quaternion_slerp(q1, q2, t) slerp_23 = quaternion_slerp(q2, q3, t) slerp_34 = quaternion_slerp(q3, q4, t) slerp_45 = quaternion_slerp(q4, q5, t) slerp_012 = quaternion_slerp(slerp_01, slerp_12, t) slerp_123 = quaternion_slerp(slerp_12, slerp_23, t) slerp_234 = quaternion_slerp(slerp_23, slerp_34, t) slerp_345 = quaternion_slerp(slerp_34, slerp_45, t) slerp_0123 = quaternion_slerp(slerp_012, slerp_123, t) slerp_1234 = quaternion_slerp(slerp_123, slerp_234, t) slerp_2345 = quaternion_slerp(slerp_234, slerp_345, t) slerp_01234 = quaternion_slerp(slerp_0123, slerp_1234, t) slerp_12345 = quaternion_slerp(slerp_1234, slerp_2345, t) return quaternion_slerp(slerp_01234, slerp_12345, t) squad def squad ( q0 , q1 , q2 , q3 , t ) View Source def squad(q0, q1, q2, q3, t): return cubic_decasteljau_slerp(q0, q1, q2, q3, 2 * t * (1 - t))","title":"Decasteljau Slerp"},{"location":"reference/pyastrobee/trajectories/decasteljau_slerp/#module-pyastrobeetrajectoriesdecasteljau_slerp","text":"More rotation interpolation methods that naturally account for boundary conditions and guarantee quaternion normalization, unlike the quaternion polynomial method These \"spherical bezier curves\" are relatively computationally intensive to solve, because it requires a lot of calls to SLERP for each point we're interpolating (due to the recursive nature of De Casteljau's algorithm) In most cases it will be better to use fast approximate methods to rotation planning, but this can serve as a good reference curve Reference: https://www.cs.cmu.edu/~kiranb/animation/p245-shoemake.pdf https://web.archive.org/web/20120915153625/http://courses.cms.caltech.edu/cs171/quatut.pdf https://splines.readthedocs.io/en/latest/rotation/index.html View Source \"\"\"More rotation interpolation methods that naturally account for boundary conditions and guarantee quaternion normalization, unlike the quaternion polynomial method These \"spherical bezier curves\" are relatively computationally intensive to solve, because it requires a lot of calls to SLERP for each point we're interpolating (due to the recursive nature of De Casteljau's algorithm) In most cases it will be better to use fast approximate methods to rotation planning, but this can serve as a good reference curve Reference: https://www.cs.cmu.edu/~kiranb/animation/p245-shoemake.pdf https://web.archive.org/web/20120915153625/http://courses.cms.caltech.edu/cs171/quatut.pdf https://splines.readthedocs.io/en/latest/rotation/index.html \"\"\" # TODO # - This file needs a lot of cleanup if we are in fact using some of these methods # - Move quaternion math operations to the main quaternions file? # - Get nonzero angular acceleration vector BCs implemented (currently can only handle zero magnitude in accel) # - Check out the SQUAD algorithm. This seems very similar to a cubic decasteljau spherical bezier curve but with a # different parameterization of the \"t\" interpolation value import pybullet import numpy as np from pyastrobee . utils . quaternions import ( quaternion_slerp , random_quaternion , quats_to_angular_velocities , conjugate , exponential_map , log_map , pure , multiply , ) from pyastrobee . trajectories . trajectory import Trajectory from pyastrobee . utils . debug_visualizer import animate_rotation # Interpolation methods def cubic_decasteljau_slerp ( q0 , q1 , q2 , q3 , t ): if not np . isscalar ( t ): # If t is a list, return a list of unit quaternions return [ cubic_decasteljau_slerp ( q0 , q1 , q2 , q3 , t_i ) for t_i in t ] slerp_01 = quaternion_slerp ( q0 , q1 , t ) slerp_12 = quaternion_slerp ( q1 , q2 , t ) slerp_23 = quaternion_slerp ( q2 , q3 , t ) return quaternion_slerp ( quaternion_slerp ( slerp_01 , slerp_12 , t ), quaternion_slerp ( slerp_12 , slerp_23 , t ), t , ) def quintic_decasteljau_slerp ( q0 , q1 , q2 , q3 , q4 , q5 , t ): if not np . isscalar ( t ): # If t is a list, return a list of unit quaternions return [ quintic_decasteljau_slerp ( q0 , q1 , q2 , q3 , q4 , q5 , t_i ) for t_i in t ] slerp_01 = quaternion_slerp ( q0 , q1 , t ) slerp_12 = quaternion_slerp ( q1 , q2 , t ) slerp_23 = quaternion_slerp ( q2 , q3 , t ) slerp_34 = quaternion_slerp ( q3 , q4 , t ) slerp_45 = quaternion_slerp ( q4 , q5 , t ) slerp_012 = quaternion_slerp ( slerp_01 , slerp_12 , t ) slerp_123 = quaternion_slerp ( slerp_12 , slerp_23 , t ) slerp_234 = quaternion_slerp ( slerp_23 , slerp_34 , t ) slerp_345 = quaternion_slerp ( slerp_34 , slerp_45 , t ) slerp_0123 = quaternion_slerp ( slerp_012 , slerp_123 , t ) slerp_1234 = quaternion_slerp ( slerp_123 , slerp_234 , t ) slerp_2345 = quaternion_slerp ( slerp_234 , slerp_345 , t ) slerp_01234 = quaternion_slerp ( slerp_0123 , slerp_1234 , t ) slerp_12345 = quaternion_slerp ( slerp_1234 , slerp_2345 , t ) return quaternion_slerp ( slerp_01234 , slerp_12345 , t ) # This parameterization of t is the same as in the Shoemake paper but it doesn't seem to make any sense, # because it's a quadratic that doesn't actually reach 1, so we don't get to the final interpolated quaternion? # Though, I might be doing this wrong def squad ( q0 , q1 , q2 , q3 , t ): return cubic_decasteljau_slerp ( q0 , q1 , q2 , q3 , 2 * t * ( 1 - t )) # Given an initial quaternion q and an initial angular velocity w, find another quaternion such that the SLERP arc # yields an angular velocity vector parallel to w. Since the length of this arc doesn't affect the direction of this # angular velocity vector (just the magnitude), c is a constant scaling factor that is tunable def q_for_w ( q , w , c ): return conjugate ( multiply ( conjugate ( q ), exponential_map ( c * w ))) # This doesn't work... sad. Try to figure out the actual math behind this curvature condition def q_for_a ( q , w , a , c ): c = 1 / 5 # hardcode hack qw = q_for_w ( q , w , c ) qw2 = q_for_w ( qw , a , c ) return qw2 # Interpolate two rotations, matching boundary conditions on angular velocity def decasteljau_vel_bcs ( q0 , qf , w0 , wf , t ): q1 = q_for_w ( q0 , - w0 , 1 / 3 ) q2 = q_for_w ( qf , wf , 1 / 3 ) return cubic_decasteljau_slerp ( q0 , q1 , q2 , qf , t ) # Interpolate two rotations, matching boundary conditions on angular velocity, and set the angular acceleration at # either end to be 0 def decasteljau_vel_0_accel_bc ( q0 , qf , w0 , wf , t ): # NOTE: # I tried setting the control points for arbitrary alpha vectors but could not get this to work properly # Instead, the control points are placed so that the angular aceleration at either end is 0 q1 = q_for_w ( q0 , - w0 , 1 / 5 ) q2 = q_for_w ( q0 , - w0 , 2 / 5 ) q3 = q_for_w ( qf , wf , 2 / 5 ) q4 = q_for_w ( qf , wf , 1 / 5 ) return quintic_decasteljau_slerp ( q0 , q1 , q2 , q3 , q4 , qf , t ) def _test_vel_bcs (): # np.random.seed(0) q0 = random_quaternion () qf = random_quaternion () print ( \"Start q: \" , q0 ) print ( \"End q: \" , qf ) w0 = np . array ([ 0.1 , 0.2 , 0.3 ]) wf = np . array ([ 0.15 , 0.25 , 0.35 ]) t = np . linspace ( 0 , 1 , 500 ) dt = t [ 1 ] - t [ 0 ] quats = decasteljau_vel_bcs ( q0 , qf , w0 , wf , t ) omega = quats_to_angular_velocities ( quats , dt ) alpha = np . gradient ( omega , dt , axis = 0 ) traj = Trajectory ( None , quats , None , omega , None , alpha , t ) print ( \"Start w: \" , omega [ 0 ]) print ( \"End w: \" , omega [ - 1 ]) pybullet . connect ( pybullet . GUI ) animate_rotation ( traj . quaternions , 5 ) input ( \"Animation complete, press Enter to exit\" ) pybullet . disconnect () traj . plot () def _test_vel_accel_bcs (): # np.random.seed(0) q0 = random_quaternion () qf = random_quaternion () print ( \"Start q: \" , q0 ) print ( \"End q: \" , qf ) w0 = np . array ([ 0.1 , 0.2 , 0.3 ]) wf = np . array ([ 0.15 , 0.25 , 0.35 ]) t = np . linspace ( 0 , 1 , 500 ) dt = t [ 1 ] - t [ 0 ] quats = decasteljau_vel_0_accel_bc ( q0 , qf , w0 , wf , t ) omega = quats_to_angular_velocities ( quats , dt ) alpha = np . gradient ( omega , dt , axis = 0 ) traj = Trajectory ( None , quats , None , omega , None , alpha , t ) print ( \"Start w: \" , omega [ 0 ]) print ( \"End w: \" , omega [ - 1 ]) print ( \"Start a: \" , alpha [ 0 ]) print ( \"End a: \" , alpha [ - 1 ]) pybullet . connect ( pybullet . GUI ) animate_rotation ( traj . quaternions , 5 ) input ( \"Animation complete, press Enter to exit\" ) pybullet . disconnect () traj . plot () if __name__ == \"__main__\" : _test_vel_bcs () _test_vel_accel_bcs ()","title":"Module pyastrobee.trajectories.decasteljau_slerp"},{"location":"reference/pyastrobee/trajectories/decasteljau_slerp/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/trajectories/decasteljau_slerp/#cubic_decasteljau_slerp","text":"def cubic_decasteljau_slerp ( q0 , q1 , q2 , q3 , t ) View Source def cubic_decasteljau_slerp(q0, q1, q2, q3, t): if not np.isscalar(t): # If t is a list, return a list of unit quaternions return [cubic_decasteljau_slerp(q0, q1, q2, q3, t_i) for t_i in t] slerp_01 = quaternion_slerp(q0, q1, t) slerp_12 = quaternion_slerp(q1, q2, t) slerp_23 = quaternion_slerp(q2, q3, t) return quaternion_slerp( quaternion_slerp(slerp_01, slerp_12, t), quaternion_slerp(slerp_12, slerp_23, t), t, )","title":"cubic_decasteljau_slerp"},{"location":"reference/pyastrobee/trajectories/decasteljau_slerp/#decasteljau_vel_0_accel_bc","text":"def decasteljau_vel_0_accel_bc ( q0 , qf , w0 , wf , t ) View Source def decasteljau_vel_0_accel_bc(q0, qf, w0, wf, t): # NOTE: # I tried setting the control points for arbitrary alpha vectors but could not get this to work properly # Instead, the control points are placed so that the angular aceleration at either end is 0 q1 = q_for_w(q0, -w0, 1 / 5) q2 = q_for_w(q0, -w0, 2 / 5) q3 = q_for_w(qf, wf, 2 / 5) q4 = q_for_w(qf, wf, 1 / 5) return quintic_decasteljau_slerp(q0, q1, q2, q3, q4, qf, t)","title":"decasteljau_vel_0_accel_bc"},{"location":"reference/pyastrobee/trajectories/decasteljau_slerp/#decasteljau_vel_bcs","text":"def decasteljau_vel_bcs ( q0 , qf , w0 , wf , t ) View Source def decasteljau_vel_bcs(q0, qf, w0, wf, t): q1 = q_for_w(q0, -w0, 1 / 3) q2 = q_for_w(qf, wf, 1 / 3) return cubic_decasteljau_slerp(q0, q1, q2, qf, t)","title":"decasteljau_vel_bcs"},{"location":"reference/pyastrobee/trajectories/decasteljau_slerp/#q_for_a","text":"def q_for_a ( q , w , a , c ) View Source def q_for_a(q, w, a, c): c = 1 / 5 # hardcode hack qw = q_for_w(q, w, c) qw2 = q_for_w(qw, a, c) return qw2","title":"q_for_a"},{"location":"reference/pyastrobee/trajectories/decasteljau_slerp/#q_for_w","text":"def q_for_w ( q , w , c ) View Source def q_for_w(q, w, c): return conjugate(multiply(conjugate(q), exponential_map(c * w)))","title":"q_for_w"},{"location":"reference/pyastrobee/trajectories/decasteljau_slerp/#quintic_decasteljau_slerp","text":"def quintic_decasteljau_slerp ( q0 , q1 , q2 , q3 , q4 , q5 , t ) View Source def quintic_decasteljau_slerp(q0, q1, q2, q3, q4, q5, t): if not np.isscalar(t): # If t is a list, return a list of unit quaternions return [quintic_decasteljau_slerp(q0, q1, q2, q3, q4, q5, t_i) for t_i in t] slerp_01 = quaternion_slerp(q0, q1, t) slerp_12 = quaternion_slerp(q1, q2, t) slerp_23 = quaternion_slerp(q2, q3, t) slerp_34 = quaternion_slerp(q3, q4, t) slerp_45 = quaternion_slerp(q4, q5, t) slerp_012 = quaternion_slerp(slerp_01, slerp_12, t) slerp_123 = quaternion_slerp(slerp_12, slerp_23, t) slerp_234 = quaternion_slerp(slerp_23, slerp_34, t) slerp_345 = quaternion_slerp(slerp_34, slerp_45, t) slerp_0123 = quaternion_slerp(slerp_012, slerp_123, t) slerp_1234 = quaternion_slerp(slerp_123, slerp_234, t) slerp_2345 = quaternion_slerp(slerp_234, slerp_345, t) slerp_01234 = quaternion_slerp(slerp_0123, slerp_1234, t) slerp_12345 = quaternion_slerp(slerp_1234, slerp_2345, t) return quaternion_slerp(slerp_01234, slerp_12345, t)","title":"quintic_decasteljau_slerp"},{"location":"reference/pyastrobee/trajectories/decasteljau_slerp/#squad","text":"def squad ( q0 , q1 , q2 , q3 , t ) View Source def squad(q0, q1, q2, q3, t): return cubic_decasteljau_slerp(q0, q1, q2, q3, 2 * t * (1 - t))","title":"squad"},{"location":"reference/pyastrobee/trajectories/face_forward/","text":"Module pyastrobee.trajectories.face_forward View Source import numpy as np import numpy.typing as npt from pyastrobee.trajectories.trajectory import Trajectory from pyastrobee.utils.rotations import axis_angle_between_two_vectors from pyastrobee.utils.quaternions import ( get_closest_heading_quat , quaternion_angular_error , quats_to_angular_velocities , ) from pyastrobee.utils.math_utils import normalize from pyastrobee.trajectories.polynomials import polynomial_slerp from pyastrobee.trajectories.quaternion_interpolation import ( quaternion_interpolation_with_bcs , ) from pyastrobee.config.astrobee_motion import ANGULAR_SPEED_LIMIT def heading_alignment_orn_traj ( q0 : npt . ArrayLike , w0 : npt . ArrayLike , dw0 : npt . ArrayLike , heading : npt . ArrayLike , dt : float , ): qf = get_closest_heading_quat ( q0 , heading ) # Get a timing heuristic based on the quaternion error # (not guaranteed to satisfy constraints) err = quaternion_angular_error ( q0 , qf ) w_nom = 0.5 * ANGULAR_SPEED_LIMIT alignment_time = np . linalg . norm ( err ) / w_nom num_alignment_timesteps = int ( alignment_time // dt ) return quaternion_interpolation_with_bcs ( q0 , qf , w0 , np . zeros ( 3 ), dw0 , np . zeros ( 3 ), alignment_time , num_alignment_timesteps , ) def face_forward_traj ( path : np . ndarray , q0 : npt . ArrayLike , w0 : npt . ArrayLike , dw0 : npt . ArrayLike , dt : float , ) -> Trajectory : # If the initial heading is not aligned with the start of the path, # we have to rotate to get to that point # TODO handle if the initial heading IS aligned? heading quat will be identity init_heading = path [ 1 ] - path [ 0 ] err_tol = 1e-2 if ( np . linalg . norm ( quaternion_angular_error ( q0 , get_closest_heading_quat ( q0 , init_heading )) ) > err_tol ): quats_1 = heading_alignment_orn_traj ( q0 , w0 , dw0 , init_heading , dt ) else : quats_1 = np . atleast_2d ( q0 ) # Find the rotation to change the heading at each point in the trajectory n = path . shape [ 0 ] cur_q = quats_1 [ - 1 ] quats_2 = np . empty (( path . shape [ 0 ], 4 )) for i in range ( n - 1 ): heading = path [ i + 1 ] - path [ i ] quats_2 [ i ] = get_closest_heading_quat ( cur_q , heading ) quats_2 [ - 1 ] = quats_2 [ - 2 ] all_quats = np . vstack (( quats_1 , quats_2 )) all_positions = np . vstack (( np . tile ( path [ 0 ], ( quats_1 . shape [ 0 ], 1 )), path )) omega = quats_to_angular_velocities ( all_quats , dt ) alpha = np . gradient ( omega , dt , axis = 0 ) velocities = np . gradient ( all_positions , dt , axis = 0 ) accels = np . gradient ( velocities , dt , axis = 0 ) total_n = all_positions . shape [ 0 ] times = np . linspace ( 0 , dt * total_n , total_n , endpoint = True ) return Trajectory ( all_positions , all_quats , velocities , omega , accels , alpha , times ) Variables ANGULAR_SPEED_LIMIT Functions face_forward_traj def face_forward_traj ( path : numpy . ndarray , q0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], w0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], dw0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], dt : float ) -> pyastrobee . trajectories . trajectory . Trajectory View Source def face_forward_traj ( path : np . ndarray , q0 : npt . ArrayLike , w0 : npt . ArrayLike , dw0 : npt . ArrayLike , dt : float , ) -> Trajectory : # If the initial heading is not aligned with the start of the path , # we have to rotate to get to that point # TODO handle if the initial heading IS aligned ? heading quat will be identity init_heading = path [ 1 ] - path [ 0 ] err_tol = 1e-2 if ( np . linalg . norm ( quaternion_angular_error ( q0 , get_closest_heading_quat ( q0 , init_heading )) ) > err_tol ) : quats_1 = heading_alignment_orn_traj ( q0 , w0 , dw0 , init_heading , dt ) else : quats_1 = np . atleast_2d ( q0 ) # Find the rotation to change the heading at each point in the trajectory n = path . shape [ 0 ] cur_q = quats_1 [ -1 ] quats_2 = np . empty (( path . shape [ 0 ] , 4 )) for i in range ( n - 1 ) : heading = path [ i + 1 ] - path [ i ] quats_2 [ i ] = get_closest_heading_quat ( cur_q , heading ) quats_2 [ -1 ] = quats_2 [ -2 ] all_quats = np . vstack (( quats_1 , quats_2 )) all_positions = np . vstack (( np . tile ( path [ 0 ] , ( quats_1 . shape [ 0 ] , 1 )), path )) omega = quats_to_angular_velocities ( all_quats , dt ) alpha = np . gradient ( omega , dt , axis = 0 ) velocities = np . gradient ( all_positions , dt , axis = 0 ) accels = np . gradient ( velocities , dt , axis = 0 ) total_n = all_positions . shape [ 0 ] times = np . linspace ( 0 , dt * total_n , total_n , endpoint = True ) return Trajectory ( all_positions , all_quats , velocities , omega , accels , alpha , times ) heading_alignment_orn_traj def heading_alignment_orn_traj ( q0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], w0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], dw0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], heading : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], dt : float ) View Source def heading_alignment_orn_traj ( q0 : npt . ArrayLike , w0 : npt . ArrayLike , dw0 : npt . ArrayLike , heading : npt . ArrayLike , dt : float , ): qf = get_closest_heading_quat ( q0 , heading ) # Get a timing heuristic based on the quaternion error # (not guaranteed to satisfy constraints) err = quaternion_angular_error ( q0 , qf ) w_nom = 0.5 * ANGULAR_SPEED_LIMIT alignment_time = np . linalg . norm ( err ) / w_nom num_alignment_timesteps = int ( alignment_time // dt ) return quaternion_interpolation_with_bcs ( q0 , qf , w0 , np . zeros ( 3 ), dw0 , np . zeros ( 3 ), alignment_time , num_alignment_timesteps , )","title":"Face Forward"},{"location":"reference/pyastrobee/trajectories/face_forward/#module-pyastrobeetrajectoriesface_forward","text":"View Source import numpy as np import numpy.typing as npt from pyastrobee.trajectories.trajectory import Trajectory from pyastrobee.utils.rotations import axis_angle_between_two_vectors from pyastrobee.utils.quaternions import ( get_closest_heading_quat , quaternion_angular_error , quats_to_angular_velocities , ) from pyastrobee.utils.math_utils import normalize from pyastrobee.trajectories.polynomials import polynomial_slerp from pyastrobee.trajectories.quaternion_interpolation import ( quaternion_interpolation_with_bcs , ) from pyastrobee.config.astrobee_motion import ANGULAR_SPEED_LIMIT def heading_alignment_orn_traj ( q0 : npt . ArrayLike , w0 : npt . ArrayLike , dw0 : npt . ArrayLike , heading : npt . ArrayLike , dt : float , ): qf = get_closest_heading_quat ( q0 , heading ) # Get a timing heuristic based on the quaternion error # (not guaranteed to satisfy constraints) err = quaternion_angular_error ( q0 , qf ) w_nom = 0.5 * ANGULAR_SPEED_LIMIT alignment_time = np . linalg . norm ( err ) / w_nom num_alignment_timesteps = int ( alignment_time // dt ) return quaternion_interpolation_with_bcs ( q0 , qf , w0 , np . zeros ( 3 ), dw0 , np . zeros ( 3 ), alignment_time , num_alignment_timesteps , ) def face_forward_traj ( path : np . ndarray , q0 : npt . ArrayLike , w0 : npt . ArrayLike , dw0 : npt . ArrayLike , dt : float , ) -> Trajectory : # If the initial heading is not aligned with the start of the path, # we have to rotate to get to that point # TODO handle if the initial heading IS aligned? heading quat will be identity init_heading = path [ 1 ] - path [ 0 ] err_tol = 1e-2 if ( np . linalg . norm ( quaternion_angular_error ( q0 , get_closest_heading_quat ( q0 , init_heading )) ) > err_tol ): quats_1 = heading_alignment_orn_traj ( q0 , w0 , dw0 , init_heading , dt ) else : quats_1 = np . atleast_2d ( q0 ) # Find the rotation to change the heading at each point in the trajectory n = path . shape [ 0 ] cur_q = quats_1 [ - 1 ] quats_2 = np . empty (( path . shape [ 0 ], 4 )) for i in range ( n - 1 ): heading = path [ i + 1 ] - path [ i ] quats_2 [ i ] = get_closest_heading_quat ( cur_q , heading ) quats_2 [ - 1 ] = quats_2 [ - 2 ] all_quats = np . vstack (( quats_1 , quats_2 )) all_positions = np . vstack (( np . tile ( path [ 0 ], ( quats_1 . shape [ 0 ], 1 )), path )) omega = quats_to_angular_velocities ( all_quats , dt ) alpha = np . gradient ( omega , dt , axis = 0 ) velocities = np . gradient ( all_positions , dt , axis = 0 ) accels = np . gradient ( velocities , dt , axis = 0 ) total_n = all_positions . shape [ 0 ] times = np . linspace ( 0 , dt * total_n , total_n , endpoint = True ) return Trajectory ( all_positions , all_quats , velocities , omega , accels , alpha , times )","title":"Module pyastrobee.trajectories.face_forward"},{"location":"reference/pyastrobee/trajectories/face_forward/#variables","text":"ANGULAR_SPEED_LIMIT","title":"Variables"},{"location":"reference/pyastrobee/trajectories/face_forward/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/trajectories/face_forward/#face_forward_traj","text":"def face_forward_traj ( path : numpy . ndarray , q0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], w0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], dw0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], dt : float ) -> pyastrobee . trajectories . trajectory . Trajectory View Source def face_forward_traj ( path : np . ndarray , q0 : npt . ArrayLike , w0 : npt . ArrayLike , dw0 : npt . ArrayLike , dt : float , ) -> Trajectory : # If the initial heading is not aligned with the start of the path , # we have to rotate to get to that point # TODO handle if the initial heading IS aligned ? heading quat will be identity init_heading = path [ 1 ] - path [ 0 ] err_tol = 1e-2 if ( np . linalg . norm ( quaternion_angular_error ( q0 , get_closest_heading_quat ( q0 , init_heading )) ) > err_tol ) : quats_1 = heading_alignment_orn_traj ( q0 , w0 , dw0 , init_heading , dt ) else : quats_1 = np . atleast_2d ( q0 ) # Find the rotation to change the heading at each point in the trajectory n = path . shape [ 0 ] cur_q = quats_1 [ -1 ] quats_2 = np . empty (( path . shape [ 0 ] , 4 )) for i in range ( n - 1 ) : heading = path [ i + 1 ] - path [ i ] quats_2 [ i ] = get_closest_heading_quat ( cur_q , heading ) quats_2 [ -1 ] = quats_2 [ -2 ] all_quats = np . vstack (( quats_1 , quats_2 )) all_positions = np . vstack (( np . tile ( path [ 0 ] , ( quats_1 . shape [ 0 ] , 1 )), path )) omega = quats_to_angular_velocities ( all_quats , dt ) alpha = np . gradient ( omega , dt , axis = 0 ) velocities = np . gradient ( all_positions , dt , axis = 0 ) accels = np . gradient ( velocities , dt , axis = 0 ) total_n = all_positions . shape [ 0 ] times = np . linspace ( 0 , dt * total_n , total_n , endpoint = True ) return Trajectory ( all_positions , all_quats , velocities , omega , accels , alpha , times )","title":"face_forward_traj"},{"location":"reference/pyastrobee/trajectories/face_forward/#heading_alignment_orn_traj","text":"def heading_alignment_orn_traj ( q0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], w0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], dw0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], heading : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], dt : float ) View Source def heading_alignment_orn_traj ( q0 : npt . ArrayLike , w0 : npt . ArrayLike , dw0 : npt . ArrayLike , heading : npt . ArrayLike , dt : float , ): qf = get_closest_heading_quat ( q0 , heading ) # Get a timing heuristic based on the quaternion error # (not guaranteed to satisfy constraints) err = quaternion_angular_error ( q0 , qf ) w_nom = 0.5 * ANGULAR_SPEED_LIMIT alignment_time = np . linalg . norm ( err ) / w_nom num_alignment_timesteps = int ( alignment_time // dt ) return quaternion_interpolation_with_bcs ( q0 , qf , w0 , np . zeros ( 3 ), dw0 , np . zeros ( 3 ), alignment_time , num_alignment_timesteps , )","title":"heading_alignment_orn_traj"},{"location":"reference/pyastrobee/trajectories/multi_robot_trajs/","text":"Module pyastrobee.trajectories.multi_robot_trajs Trajectory generation methods for the multi-robot case View Source \"\"\"Trajectory generation methods for the multi-robot case\"\"\" import numpy as np from pyastrobee.trajectories.trajectory import Trajectory from pyastrobee.utils.poses import pos_quat_to_tmat from pyastrobee.utils.rotations import rmat_to_quat from pyastrobee.utils.quaternions import quats_to_angular_velocities def offset_trajectory ( reference_traj : Trajectory , offset_transform : np . ndarray ) -> Trajectory : \"\"\"Construct a trajectory with a fixed offset to a given reference trajectory This can also be thought as \"Leader/Follower\" where leader has the reference trajectory, and follower has the offset trajectory. However, this can generalize to more cases than just leader/follower Args: reference_traj (Trajectory): Trajectory to use as a reference offset_transform (np.ndarray): \"Offset to reference\" transformation matrix, dictating the positional/angular difference from the reference trajectory. Shape (4, 4) Returns: Trajectory: Trajectory with a fixed offset to the reference trajectory \"\"\" # TODO: check that the transformation matrix is valid? # Transform each pose according to the offset transform offset_positions = np . zeros_like ( reference_traj . positions ) offset_quats = np . zeros_like ( reference_traj . quaternions ) for i in range ( reference_traj . num_timesteps ): pose = reference_traj . poses [ i ] T_R2W = pos_quat_to_tmat ( pose ) # Reference to World T_O2W = T_R2W @ offset_transform # Offset to World offset_positions [ i ] = T_O2W [: 3 , 3 ] offset_quats [ i ] = rmat_to_quat ( T_O2W [: 3 , : 3 ]) # Take the gradients of the poses to determine derivative information offset_vels = np . gradient ( offset_positions , reference_traj . times , axis = 0 ) offset_accels = np . gradient ( offset_vels , reference_traj . times , axis = 0 ) offset_omegas = quats_to_angular_velocities ( offset_quats , np . gradient ( reference_traj . times ) ) offset_alphas = np . gradient ( offset_omegas , reference_traj . times , axis = 0 ) return Trajectory ( offset_positions , offset_quats , offset_vels , offset_omegas , offset_accels , offset_alphas , reference_traj . times , ) def multi_trajectory ( reference_traj : Trajectory , transforms : list [ np . ndarray ] ) -> list [ Trajectory ]: \"\"\"Construct multiple trajectories moving about a reference trajectory with fixed offset transformations For instance: This can be used as a slightly better formulation of leader/follower to ensure similar trajectory dynamics for two robots moving together about a reference Args: reference_traj (Trajectory): Trajectory to use as a central reference trajectory transforms (list[np.ndarray]): \"Offset to reference\" transformation matrices for each trajectory Returns: list[Trajectory]: The trajectories, each offset about the reference \"\"\" return [ offset_trajectory ( reference_traj , T ) for T in transforms ] Functions multi_trajectory def multi_trajectory ( reference_traj : pyastrobee . trajectories . trajectory . Trajectory , transforms : list [ numpy . ndarray ] ) -> list [ pyastrobee . trajectories . trajectory . Trajectory ] Construct multiple trajectories moving about a reference trajectory with fixed offset transformations For instance: This can be used as a slightly better formulation of leader/follower to ensure similar trajectory dynamics for two robots moving together about a reference Parameters: Name Type Description Default reference_traj Trajectory Trajectory to use as a central reference trajectory None transforms list[np.ndarray] \"Offset to reference\" transformation matrices for each trajectory None Returns: Type Description list[Trajectory] The trajectories, each offset about the reference View Source def multi_trajectory ( reference_traj : Trajectory , transforms : list [ np.ndarray ] ) -> list [ Trajectory ] : \"\"\"Construct multiple trajectories moving about a reference trajectory with fixed offset transformations For instance: This can be used as a slightly better formulation of leader/follower to ensure similar trajectory dynamics for two robots moving together about a reference Args: reference_traj (Trajectory): Trajectory to use as a central reference trajectory transforms (list[np.ndarray]): \" Offset to reference \" transformation matrices for each trajectory Returns: list[Trajectory]: The trajectories, each offset about the reference \"\"\" return [ offset_trajectory(reference_traj, T) for T in transforms ] offset_trajectory def offset_trajectory ( reference_traj : pyastrobee . trajectories . trajectory . Trajectory , offset_transform : numpy . ndarray ) -> pyastrobee . trajectories . trajectory . Trajectory Construct a trajectory with a fixed offset to a given reference trajectory This can also be thought as \"Leader/Follower\" where leader has the reference trajectory, and follower has the offset trajectory. However, this can generalize to more cases than just leader/follower Parameters: Name Type Description Default reference_traj Trajectory Trajectory to use as a reference None offset_transform np.ndarray \"Offset to reference\" transformation matrix, dictating the positional/angular difference from the reference trajectory. Shape (4, 4) None Returns: Type Description Trajectory Trajectory with a fixed offset to the reference trajectory View Source def offset_trajectory ( reference_traj : Trajectory , offset_transform : np . ndarray ) -> Trajectory : \"\"\"Construct a trajectory with a fixed offset to a given reference trajectory This can also be thought as \" Leader / Follower \" where leader has the reference trajectory, and follower has the offset trajectory. However, this can generalize to more cases than just leader/follower Args: reference_traj (Trajectory): Trajectory to use as a reference offset_transform (np.ndarray): \" Offset to reference \" transformation matrix, dictating the positional/angular difference from the reference trajectory. Shape (4, 4) Returns: Trajectory: Trajectory with a fixed offset to the reference trajectory \"\"\" # TODO : check that the transformation matrix is valid ? # Transform each pose according to the offset transform offset_positions = np . zeros_like ( reference_traj . positions ) offset_quats = np . zeros_like ( reference_traj . quaternions ) for i in range ( reference_traj . num_timesteps ) : pose = reference_traj . poses [ i ] T_R2W = pos_quat_to_tmat ( pose ) # Reference to World T_O2W = T_R2W @ offset_transform # Offset to World offset_positions [ i ] = T_O2W [ :3, 3 ] offset_quats [ i ] = rmat_to_quat ( T_O2W [ :3, :3 ] ) # Take the gradients of the poses to determine derivative information offset_vels = np . gradient ( offset_positions , reference_traj . times , axis = 0 ) offset_accels = np . gradient ( offset_vels , reference_traj . times , axis = 0 ) offset_omegas = quats_to_angular_velocities ( offset_quats , np . gradient ( reference_traj . times ) ) offset_alphas = np . gradient ( offset_omegas , reference_traj . times , axis = 0 ) return Trajectory ( offset_positions , offset_quats , offset_vels , offset_omegas , offset_accels , offset_alphas , reference_traj . times , )","title":"Multi Robot Trajs"},{"location":"reference/pyastrobee/trajectories/multi_robot_trajs/#module-pyastrobeetrajectoriesmulti_robot_trajs","text":"Trajectory generation methods for the multi-robot case View Source \"\"\"Trajectory generation methods for the multi-robot case\"\"\" import numpy as np from pyastrobee.trajectories.trajectory import Trajectory from pyastrobee.utils.poses import pos_quat_to_tmat from pyastrobee.utils.rotations import rmat_to_quat from pyastrobee.utils.quaternions import quats_to_angular_velocities def offset_trajectory ( reference_traj : Trajectory , offset_transform : np . ndarray ) -> Trajectory : \"\"\"Construct a trajectory with a fixed offset to a given reference trajectory This can also be thought as \"Leader/Follower\" where leader has the reference trajectory, and follower has the offset trajectory. However, this can generalize to more cases than just leader/follower Args: reference_traj (Trajectory): Trajectory to use as a reference offset_transform (np.ndarray): \"Offset to reference\" transformation matrix, dictating the positional/angular difference from the reference trajectory. Shape (4, 4) Returns: Trajectory: Trajectory with a fixed offset to the reference trajectory \"\"\" # TODO: check that the transformation matrix is valid? # Transform each pose according to the offset transform offset_positions = np . zeros_like ( reference_traj . positions ) offset_quats = np . zeros_like ( reference_traj . quaternions ) for i in range ( reference_traj . num_timesteps ): pose = reference_traj . poses [ i ] T_R2W = pos_quat_to_tmat ( pose ) # Reference to World T_O2W = T_R2W @ offset_transform # Offset to World offset_positions [ i ] = T_O2W [: 3 , 3 ] offset_quats [ i ] = rmat_to_quat ( T_O2W [: 3 , : 3 ]) # Take the gradients of the poses to determine derivative information offset_vels = np . gradient ( offset_positions , reference_traj . times , axis = 0 ) offset_accels = np . gradient ( offset_vels , reference_traj . times , axis = 0 ) offset_omegas = quats_to_angular_velocities ( offset_quats , np . gradient ( reference_traj . times ) ) offset_alphas = np . gradient ( offset_omegas , reference_traj . times , axis = 0 ) return Trajectory ( offset_positions , offset_quats , offset_vels , offset_omegas , offset_accels , offset_alphas , reference_traj . times , ) def multi_trajectory ( reference_traj : Trajectory , transforms : list [ np . ndarray ] ) -> list [ Trajectory ]: \"\"\"Construct multiple trajectories moving about a reference trajectory with fixed offset transformations For instance: This can be used as a slightly better formulation of leader/follower to ensure similar trajectory dynamics for two robots moving together about a reference Args: reference_traj (Trajectory): Trajectory to use as a central reference trajectory transforms (list[np.ndarray]): \"Offset to reference\" transformation matrices for each trajectory Returns: list[Trajectory]: The trajectories, each offset about the reference \"\"\" return [ offset_trajectory ( reference_traj , T ) for T in transforms ]","title":"Module pyastrobee.trajectories.multi_robot_trajs"},{"location":"reference/pyastrobee/trajectories/multi_robot_trajs/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/trajectories/multi_robot_trajs/#multi_trajectory","text":"def multi_trajectory ( reference_traj : pyastrobee . trajectories . trajectory . Trajectory , transforms : list [ numpy . ndarray ] ) -> list [ pyastrobee . trajectories . trajectory . Trajectory ] Construct multiple trajectories moving about a reference trajectory with fixed offset transformations For instance: This can be used as a slightly better formulation of leader/follower to ensure similar trajectory dynamics for two robots moving together about a reference Parameters: Name Type Description Default reference_traj Trajectory Trajectory to use as a central reference trajectory None transforms list[np.ndarray] \"Offset to reference\" transformation matrices for each trajectory None Returns: Type Description list[Trajectory] The trajectories, each offset about the reference View Source def multi_trajectory ( reference_traj : Trajectory , transforms : list [ np.ndarray ] ) -> list [ Trajectory ] : \"\"\"Construct multiple trajectories moving about a reference trajectory with fixed offset transformations For instance: This can be used as a slightly better formulation of leader/follower to ensure similar trajectory dynamics for two robots moving together about a reference Args: reference_traj (Trajectory): Trajectory to use as a central reference trajectory transforms (list[np.ndarray]): \" Offset to reference \" transformation matrices for each trajectory Returns: list[Trajectory]: The trajectories, each offset about the reference \"\"\" return [ offset_trajectory(reference_traj, T) for T in transforms ]","title":"multi_trajectory"},{"location":"reference/pyastrobee/trajectories/multi_robot_trajs/#offset_trajectory","text":"def offset_trajectory ( reference_traj : pyastrobee . trajectories . trajectory . Trajectory , offset_transform : numpy . ndarray ) -> pyastrobee . trajectories . trajectory . Trajectory Construct a trajectory with a fixed offset to a given reference trajectory This can also be thought as \"Leader/Follower\" where leader has the reference trajectory, and follower has the offset trajectory. However, this can generalize to more cases than just leader/follower Parameters: Name Type Description Default reference_traj Trajectory Trajectory to use as a reference None offset_transform np.ndarray \"Offset to reference\" transformation matrix, dictating the positional/angular difference from the reference trajectory. Shape (4, 4) None Returns: Type Description Trajectory Trajectory with a fixed offset to the reference trajectory View Source def offset_trajectory ( reference_traj : Trajectory , offset_transform : np . ndarray ) -> Trajectory : \"\"\"Construct a trajectory with a fixed offset to a given reference trajectory This can also be thought as \" Leader / Follower \" where leader has the reference trajectory, and follower has the offset trajectory. However, this can generalize to more cases than just leader/follower Args: reference_traj (Trajectory): Trajectory to use as a reference offset_transform (np.ndarray): \" Offset to reference \" transformation matrix, dictating the positional/angular difference from the reference trajectory. Shape (4, 4) Returns: Trajectory: Trajectory with a fixed offset to the reference trajectory \"\"\" # TODO : check that the transformation matrix is valid ? # Transform each pose according to the offset transform offset_positions = np . zeros_like ( reference_traj . positions ) offset_quats = np . zeros_like ( reference_traj . quaternions ) for i in range ( reference_traj . num_timesteps ) : pose = reference_traj . poses [ i ] T_R2W = pos_quat_to_tmat ( pose ) # Reference to World T_O2W = T_R2W @ offset_transform # Offset to World offset_positions [ i ] = T_O2W [ :3, 3 ] offset_quats [ i ] = rmat_to_quat ( T_O2W [ :3, :3 ] ) # Take the gradients of the poses to determine derivative information offset_vels = np . gradient ( offset_positions , reference_traj . times , axis = 0 ) offset_accels = np . gradient ( offset_vels , reference_traj . times , axis = 0 ) offset_omegas = quats_to_angular_velocities ( offset_quats , np . gradient ( reference_traj . times ) ) offset_alphas = np . gradient ( offset_omegas , reference_traj . times , axis = 0 ) return Trajectory ( offset_positions , offset_quats , offset_vels , offset_omegas , offset_accels , offset_alphas , reference_traj . times , )","title":"offset_trajectory"},{"location":"reference/pyastrobee/trajectories/planner/","text":"Module pyastrobee.trajectories.planner The main trajectory planning structure for Astrobee We use a global/local hierarchy where: The global planner computes a reference trajectory which enforces all of the required constraints, such as Astrobee's speed/acceleration limits, as well as collision avoidance The local planner handles very fast trajectory generation between states with arbitrary boundary conditions on dynamics, but does not enforce some of the more computationally intensive optimizations and constraints This also assumes decoupled dynamics between the position and orientation components Note: the orientation component of the trajectories technically isn't \"optimal\", but it works View Source \"\"\"The main trajectory planning structure for Astrobee We use a global/local hierarchy where: - The global planner computes a reference trajectory which enforces all of the required constraints, such as Astrobee's speed/acceleration limits, as well as collision avoidance - The local planner handles very fast trajectory generation between states with arbitrary boundary conditions on dynamics, but does not enforce some of the more computationally intensive optimizations and constraints This also assumes decoupled dynamics between the position and orientation components Note: the orientation component of the trajectories technically isn't \"optimal\", but it works \"\"\" # TODO add the max-angular-velocity-constrained rotation planner into the global planner (would only really be needed if # we have a very short time horizon on the position component, i.e. if we're not moving much but rotating a lot) from typing import Optional import numpy as np import numpy.typing as npt from pyastrobee.trajectories.trajectory import Trajectory from pyastrobee.trajectories.bezier import bezier_trajectory from pyastrobee.trajectories.quaternion_interpolation import ( quaternion_interpolation_with_bcs , ) from pyastrobee.utils.quaternions import quats_to_angular_velocities from pyastrobee.trajectories.timing import ( spline_duration_heuristic , rotation_duration_heuristic , ) from pyastrobee.config.astrobee_motion import LINEAR_SPEED_LIMIT , LINEAR_ACCEL_LIMIT from pyastrobee.config.iss_safe_boxes import ROBOT_SAFE_SET from pyastrobee.config.iss_paths import GRAPH , PATHS from pyastrobee.utils.boxes import Box , find_containing_box_name , compute_graph from pyastrobee.utils.algos import dfs from pyastrobee.trajectories.curve_utils import traj_from_curve from pyastrobee.trajectories.variable_time_curves import ( free_final_time_bezier , free_final_time_spline , ) def local_planner ( p0 : npt . ArrayLike , q0 : npt . ArrayLike , v0 : Optional [ npt . ArrayLike ], w0 : npt . ArrayLike , a0 : Optional [ npt . ArrayLike ], dw0 : npt . ArrayLike , pf : npt . ArrayLike , qf : npt . ArrayLike , vf : Optional [ npt . ArrayLike ], wf : npt . ArrayLike , af : Optional [ npt . ArrayLike ], dwf : npt . ArrayLike , duration : float , dt : float , ) -> Trajectory : \"\"\"Generate an optimal Bezier-curve-based position trajectory with a polynomial orientation component Note that this planner prioritizes solve time over constraint enforcement. This will plan with boundary conditions in mind, but other than that, it does not enforce things like speed/acceleration limits or collision avoidance. This allows us to use this in very fast online applications. In general, this should be paired with the global planner, so that we can precompute a reference trajectory which does enforce all constraints (and takes a bit longer to solve), and use this local planner to evaluate different rollouts between states along this reference trajectory Args: p0 (npt.ArrayLike): Initial position, shape (3,) q0 (npt.ArrayLike): Initial XYZW quaternion, shape (4,) v0 (npt.ArrayLike): Initial linear velocity, shape (3,) w0 (npt.ArrayLike): Initial angular velocity, shape (3,) a0 (npt.ArrayLike): Initial linear acceleration, shape (3,) dw0 (npt.ArrayLike): Initial angular acceleration, shape (3,) pf (npt.ArrayLike): Final position, shape (3,) qf (npt.ArrayLike): Final XYZW quaternion, shape (4,) vf (npt.ArrayLike): Final linear velocity, shape (3,) wf (npt.ArrayLike): Final angular velocity, shape (3,) af (npt.ArrayLike): Final linear acceleration, shape (3,) dwf (npt.ArrayLike): Final angular acceleration, shape (3,) duration (float): Trajectory duration (seconds) dt (float): Sampling period (seconds) Returns: Trajectory: The optimal local trajectory plan \"\"\" # Min-jerk position traj # Don't need a ton of control points because we're not enforcing constraints n_control_pts = 8 curve , _ = bezier_trajectory ( p0 , pf , 0 , duration , n_control_pts , v0 , vf , a0 , af , time_weight = 0 ) pos_traj = traj_from_curve ( curve , dt ) n_timesteps = len ( pos_traj . times ) quats = quaternion_interpolation_with_bcs ( q0 , qf , w0 , wf , dw0 , dwf , duration , n_timesteps ) omega = quats_to_angular_velocities ( quats , dt ) alpha = np . gradient ( omega , dt , axis = 0 ) return Trajectory ( positions = pos_traj . positions , quats = quats , lin_vels = pos_traj . linear_velocities , ang_vels = omega , lin_accels = pos_traj . linear_accels , ang_accels = alpha , times = pos_traj . times , ) def global_planner ( p0 : npt . ArrayLike , q0 : npt . ArrayLike , pf : npt . ArrayLike , qf : npt . ArrayLike , dt : float , safe_set : dict [ str , Box ] = ROBOT_SAFE_SET , graph : Optional [ dict [ str , list [ str ]]] = GRAPH , ) -> Trajectory : \"\"\"Generate an optimal spline-based position trajectory with a polynomial orientation component This will enforce all of the Astrobee's constraints (such as maximum velocity/acceleration and collision avoidance). It will also be time-optimal in the sense that 1) The total duration of the curve is minimized, and 2) each Bezier curve in the spline will have its relative duration (w.r.t. the total duration) optimized to minimize jerk Note that this can take on the order of 10 seconds to compute, so it is not something that should be called online Args: p0 (npt.ArrayLike): Initial position, shape (3,) q0 (npt.ArrayLike): Initial XYZW quaternion, shape (4,) pf (npt.ArrayLike): Final position, shape (3,) qf (npt.ArrayLike): Final XYZW quaternion, shape (4,) dt (float): Sampling period (seconds) safe_set (dict[str, Box], optional): Description of the safe set of the environment. Defaults to ROBOT_SAFE_SET (the precomputed safe-set decomposition for the ISS, accounting for the robot's collision radius) graph (Optional[dict[str, list[str]]], optional): The graph defining the connections between the safe boxes in the environment. Defaults to GRAPH (the precomputed safe-set graph for the ISS). Note: if set to None, this graph will be recomputed from the ROBOT_SAFE_SET parameter Returns: Trajectory: The optimal global trajectory plan \"\"\" # Dynamics parameters: Assume start and end from rest, satisfy operating limits t0 = 0 v0 = np . zeros ( 3 ) vf = np . zeros ( 3 ) a0 = np . zeros ( 3 ) af = np . zeros ( 3 ) w0 = np . zeros ( 3 ) wf = np . zeros ( 3 ) dw0 = np . zeros ( 3 ) dwf = np . zeros ( 3 ) v_max = LINEAR_SPEED_LIMIT a_max = LINEAR_ACCEL_LIMIT # Parameters associated with the retiming optimization or the free-final-time optimization # will be left at the default values for now # Determine the path through the safe-space graph start = find_containing_box_name ( p0 , safe_set ) end = find_containing_box_name ( pf , safe_set ) if graph is None : graph = compute_graph ( safe_set ) path = dfs ( graph , start , end ) box_path = [ safe_set [ p ] for p in path ] init_angular_duration = rotation_duration_heuristic ( q0 , qf ) init_pos_duration , init_timing_fractions = spline_duration_heuristic ( p0 , pf , box_path ) # TODO enforce a minimum final time in the free-final-time optimization # to make sure that the rotation plan still has enough time to execute duration = max ( init_pos_duration , init_angular_duration ) init_curve_durations = duration * init_timing_fractions if len ( box_path ) == 1 : # Crank up the control points for a single Bezier curve so that we can be nice and tight # against the velocity/accel constraints n_control_pts = 20 # If our start and end positions are contained within the same free box, # we can construct the trajectory from a single Bezier curve curve = free_final_time_bezier ( p0 , pf , t0 , duration , n_control_pts , v0 , vf , a0 , af , box_path [ 0 ], v_max , a_max , ) else : # Our start/end positions are not in the same box, so use a spline between boxes # Use less control points for the spline for optimization stability n_control_pts = 10 curve = free_final_time_spline ( p0 , pf , t0 , duration , n_control_pts , box_path , init_curve_durations , v0 , vf , a0 , af , v_max , a_max , ) pos_traj = traj_from_curve ( curve , dt ) n_timesteps = pos_traj . num_timesteps quats = quaternion_interpolation_with_bcs ( q0 , qf , w0 , wf , dw0 , dwf , duration , n_timesteps ) omega = quats_to_angular_velocities ( quats , dt ) alpha = np . gradient ( omega , dt , axis = 0 ) return Trajectory ( pos_traj . positions , quats , pos_traj . linear_velocities , omega , pos_traj . linear_accels , alpha , pos_traj . times , ) Variables GRAPH LINEAR_ACCEL_LIMIT LINEAR_SPEED_LIMIT PATHS ROBOT_SAFE_SET Functions global_planner def global_planner ( p0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], q0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], qf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], dt : float , safe_set : dict [ str , pyastrobee . utils . boxes . Box ] = { 'jpm' : Box ( lower = [ 3.47650494853664 , - 0.4984950514633599 , - 0.7234950514633598 ], upper = [ 10.22349505146336 , 0.6354950514633599 , 0.7234950514633598 ]), 'node_2' : Box ( lower = [ - 0.7234950514633598 , - 2.18149505146336 , - 0.8234950514633599 ], upper = [ 0.8234950514633599 , 0.8144950514633598 , 0.64749505146336 ]), 'eu_lab' : Box ( lower = [ - 7.42649505146336 , - 0.5894950514633599 , - 0.7234950514633598 ], upper = [ - 3.67650494853664 , 0.6484950514633598 , 0.7234950514633598 ]), 'us_lab' : Box ( lower = [ - 0.7234950514633598 , - 10.98849505146336 , - 0.7234950514633598 ], upper = [ 0.5974950514633599 , - 6.0825049485366405 , 0.7234950514633598 ]), 'node_1' : Box ( lower = [ - 0.6754950514633598 , - 16.88849505146336 , - 0.7234950514633598 ], upper = [ 0.7234950514633598 , - 13.72550494853664 , 0.7514950514633598 ]), 'node_3_a' : Box ( lower = [ 3.17650494853664 , - 15.31249505146336 , - 0.7234950514633598 ], upper = [ 6.04549505146336 , - 14.97650494853664 , 0.3114950514633598 ]), 'node_3_b' : Box ( lower = [ 5.234504948536641 , - 15.253495051463359 , - 0.7234950514633598 ], upper = [ 7.3694950514633595 , - 14.38350494853664 , 0.6624950514633599 ]), 'cupola' : Box ( lower = [ 6.176504948536641 , - 14.90349505146336 , 1.6435049485366402 ], upper = [ 6.3854950514633595 , - 14.56150494853664 , 2.88149505146336 ]), 'jpm_n2_corridor' : Box ( lower = [ 0.3765049485366402 , - 0.19849505146335983 , - 0.32349505146335983 ], upper = [ 4.523495051463359 , 0.19849505146335983 , 0.32349505146335983 ]), 'n2_eu_corridor' : Box ( lower = [ - 4.523495051463359 , - 0.19849505146335983 , - 0.32349505146335983 ], upper = [ - 0.3765049485366402 , 0.19849505146335983 , 0.32349505146335983 ]), 'n2_us_corridor' : Box ( lower = [ - 0.32349505146335983 , - 6.62549505146336 , - 0.32349505146335983 ], upper = [ 0.32349505146335983 , - 1.6245049485366403 , 0.32349505146335983 ]), 'us_n1_corridor' : Box ( lower = [ - 0.32349505146335983 , - 14.07349505146336 , - 0.32349505146335983 ], upper = [ 0.32349505146335983 , - 10.47650494853664 , 0.32349505146335983 ]), 'n1_n3_corridor' : Box ( lower = [ 0.17650494853664014 , - 15.12349505146336 , - 0.32349505146335983 ], upper = [ 3.9034950514633597 , - 14.67650494853664 , 0.32349505146335983 ]), 'n3_cupola_corridor' : Box ( lower = [ 6.07650494853664 , - 15.144495051463359 , 0.39550494853664014 ], upper = [ 6.72349505146336 , - 14.37650494853664 , 1.9024950514633596 ])}, graph : Optional [ dict [ str , list [ str ]]] = { 'cupola' : [ 'n3_cupola_corridor' ], 'eu_lab' : [ 'n2_eu_corridor' ], 'jpm' : [ 'jpm_n2_corridor' ], 'jpm_n2_corridor' : [ 'jpm' , 'node_2' ], 'n1_n3_corridor' : [ 'node_1' , 'node_3_a' ], 'n2_eu_corridor' : [ 'node_2' , 'eu_lab' ], 'n2_us_corridor' : [ 'node_2' , 'us_lab' ], 'n3_cupola_corridor' : [ 'node_3_b' , 'cupola' ], 'node_1' : [ 'us_n1_corridor' , 'n1_n3_corridor' ], 'node_2' : [ 'jpm_n2_corridor' , 'n2_eu_corridor' , 'n2_us_corridor' ], 'node_3_a' : [ 'node_3_b' , 'n1_n3_corridor' ], 'node_3_b' : [ 'node_3_a' , 'n3_cupola_corridor' ], 'us_lab' : [ 'n2_us_corridor' , 'us_n1_corridor' ], 'us_n1_corridor' : [ 'us_lab' , 'node_1' ]} ) -> pyastrobee . trajectories . trajectory . Trajectory Generate an optimal spline-based position trajectory with a polynomial orientation component This will enforce all of the Astrobee's constraints (such as maximum velocity/acceleration and collision avoidance). It will also be time-optimal in the sense that 1) The total duration of the curve is minimized, and 2) each Bezier curve in the spline will have its relative duration (w.r.t. the total duration) optimized to minimize jerk Note that this can take on the order of 10 seconds to compute, so it is not something that should be called online Parameters: Name Type Description Default p0 npt.ArrayLike Initial position, shape (3,) None q0 npt.ArrayLike Initial XYZW quaternion, shape (4,) None pf npt.ArrayLike Final position, shape (3,) None qf npt.ArrayLike Final XYZW quaternion, shape (4,) None dt float Sampling period (seconds) None safe_set dict[str, Box] Description of the safe set of the environment. Defaults to ROBOT_SAFE_SET (the precomputed safe-set decomposition for the ISS, accounting for the robot's collision radius) None graph Optional[dict[str, list[str]]] The graph defining the connections between the safe boxes in the environment. Defaults to GRAPH (the precomputed safe-set graph for the ISS). Note: if set to None, this graph will be recomputed from the ROBOT_SAFE_SET parameter None Returns: Type Description Trajectory The optimal global trajectory plan View Source def global_planner ( p0 : npt . ArrayLike , q0 : npt . ArrayLike , pf : npt . ArrayLike , qf : npt . ArrayLike , dt : float , safe_set : dict [ str, Box ] = ROBOT_SAFE_SET , graph : Optional [ dict[str, list[str ] ]] = GRAPH , ) -> Trajectory : \"\"\"Generate an optimal spline-based position trajectory with a polynomial orientation component This will enforce all of the Astrobee's constraints (such as maximum velocity/acceleration and collision avoidance). It will also be time-optimal in the sense that 1) The total duration of the curve is minimized, and 2) each Bezier curve in the spline will have its relative duration (w.r.t. the total duration) optimized to minimize jerk Note that this can take on the order of 10 seconds to compute, so it is not something that should be called online Args: p0 (npt.ArrayLike): Initial position, shape (3,) q0 (npt.ArrayLike): Initial XYZW quaternion, shape (4,) pf (npt.ArrayLike): Final position, shape (3,) qf (npt.ArrayLike): Final XYZW quaternion, shape (4,) dt (float): Sampling period (seconds) safe_set (dict[str, Box], optional): Description of the safe set of the environment. Defaults to ROBOT_SAFE_SET (the precomputed safe-set decomposition for the ISS, accounting for the robot's collision radius) graph (Optional[dict[str, list[str]]], optional): The graph defining the connections between the safe boxes in the environment. Defaults to GRAPH (the precomputed safe-set graph for the ISS). Note: if set to None, this graph will be recomputed from the ROBOT_SAFE_SET parameter Returns: Trajectory: The optimal global trajectory plan \"\"\" # Dynamics parameters : Assume start and end from rest , satisfy operating limits t0 = 0 v0 = np . zeros ( 3 ) vf = np . zeros ( 3 ) a0 = np . zeros ( 3 ) af = np . zeros ( 3 ) w0 = np . zeros ( 3 ) wf = np . zeros ( 3 ) dw0 = np . zeros ( 3 ) dwf = np . zeros ( 3 ) v_max = LINEAR_SPEED_LIMIT a_max = LINEAR_ACCEL_LIMIT # Parameters associated with the retiming optimization or the free - final - time optimization # will be left at the default values for now # Determine the path through the safe - space graph start = find_containing_box_name ( p0 , safe_set ) end = find_containing_box_name ( pf , safe_set ) if graph is None : graph = compute_graph ( safe_set ) path = dfs ( graph , start , end ) box_path = [ safe_set[p ] for p in path ] init_angular_duration = rotation_duration_heuristic ( q0 , qf ) init_pos_duration , init_timing_fractions = spline_duration_heuristic ( p0 , pf , box_path ) # TODO enforce a minimum final time in the free - final - time optimization # to make sure that the rotation plan still has enough time to execute duration = max ( init_pos_duration , init_angular_duration ) init_curve_durations = duration * init_timing_fractions if len ( box_path ) == 1 : # Crank up the control points for a single Bezier curve so that we can be nice and tight # against the velocity / accel constraints n_control_pts = 20 # If our start and end positions are contained within the same free box , # we can construct the trajectory from a single Bezier curve curve = free_final_time_bezier ( p0 , pf , t0 , duration , n_control_pts , v0 , vf , a0 , af , box_path [ 0 ] , v_max , a_max , ) else : # Our start / end positions are not in the same box , so use a spline between boxes # Use less control points for the spline for optimization stability n_control_pts = 10 curve = free_final_time_spline ( p0 , pf , t0 , duration , n_control_pts , box_path , init_curve_durations , v0 , vf , a0 , af , v_max , a_max , ) pos_traj = traj_from_curve ( curve , dt ) n_timesteps = pos_traj . num_timesteps quats = quaternion_interpolation_with_bcs ( q0 , qf , w0 , wf , dw0 , dwf , duration , n_timesteps ) omega = quats_to_angular_velocities ( quats , dt ) alpha = np . gradient ( omega , dt , axis = 0 ) return Trajectory ( pos_traj . positions , quats , pos_traj . linear_velocities , omega , pos_traj . linear_accels , alpha , pos_traj . times , ) local_planner def local_planner ( p0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], q0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], v0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ], w0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], a0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ], dw0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], qf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], vf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ], wf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], af : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ], dwf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], duration : float , dt : float ) -> pyastrobee . trajectories . trajectory . Trajectory Generate an optimal Bezier-curve-based position trajectory with a polynomial orientation component Note that this planner prioritizes solve time over constraint enforcement. This will plan with boundary conditions in mind, but other than that, it does not enforce things like speed/acceleration limits or collision avoidance. This allows us to use this in very fast online applications. In general, this should be paired with the global planner, so that we can precompute a reference trajectory which does enforce all constraints (and takes a bit longer to solve), and use this local planner to evaluate different rollouts between states along this reference trajectory Parameters: Name Type Description Default p0 npt.ArrayLike Initial position, shape (3,) None q0 npt.ArrayLike Initial XYZW quaternion, shape (4,) None v0 npt.ArrayLike Initial linear velocity, shape (3,) None w0 npt.ArrayLike Initial angular velocity, shape (3,) None a0 npt.ArrayLike Initial linear acceleration, shape (3,) None dw0 npt.ArrayLike Initial angular acceleration, shape (3,) None pf npt.ArrayLike Final position, shape (3,) None qf npt.ArrayLike Final XYZW quaternion, shape (4,) None vf npt.ArrayLike Final linear velocity, shape (3,) None wf npt.ArrayLike Final angular velocity, shape (3,) None af npt.ArrayLike Final linear acceleration, shape (3,) None dwf npt.ArrayLike Final angular acceleration, shape (3,) None duration float Trajectory duration (seconds) None dt float Sampling period (seconds) None Returns: Type Description Trajectory The optimal local trajectory plan View Source def local_planner ( p0 : npt . ArrayLike , q0 : npt . ArrayLike , v0 : Optional [ npt . ArrayLike ], w0 : npt . ArrayLike , a0 : Optional [ npt . ArrayLike ], dw0 : npt . ArrayLike , pf : npt . ArrayLike , qf : npt . ArrayLike , vf : Optional [ npt . ArrayLike ], wf : npt . ArrayLike , af : Optional [ npt . ArrayLike ], dwf : npt . ArrayLike , duration : float , dt : float , ) -> Trajectory : \"\"\"Generate an optimal Bezier-curve-based position trajectory with a polynomial orientation component Note that this planner prioritizes solve time over constraint enforcement. This will plan with boundary conditions in mind, but other than that, it does not enforce things like speed/acceleration limits or collision avoidance. This allows us to use this in very fast online applications. In general, this should be paired with the global planner, so that we can precompute a reference trajectory which does enforce all constraints (and takes a bit longer to solve), and use this local planner to evaluate different rollouts between states along this reference trajectory Args: p0 (npt.ArrayLike): Initial position, shape (3,) q0 (npt.ArrayLike): Initial XYZW quaternion, shape (4,) v0 (npt.ArrayLike): Initial linear velocity, shape (3,) w0 (npt.ArrayLike): Initial angular velocity, shape (3,) a0 (npt.ArrayLike): Initial linear acceleration, shape (3,) dw0 (npt.ArrayLike): Initial angular acceleration, shape (3,) pf (npt.ArrayLike): Final position, shape (3,) qf (npt.ArrayLike): Final XYZW quaternion, shape (4,) vf (npt.ArrayLike): Final linear velocity, shape (3,) wf (npt.ArrayLike): Final angular velocity, shape (3,) af (npt.ArrayLike): Final linear acceleration, shape (3,) dwf (npt.ArrayLike): Final angular acceleration, shape (3,) duration (float): Trajectory duration (seconds) dt (float): Sampling period (seconds) Returns: Trajectory: The optimal local trajectory plan \"\"\" # Min-jerk position traj # Don't need a ton of control points because we're not enforcing constraints n_control_pts = 8 curve , _ = bezier_trajectory ( p0 , pf , 0 , duration , n_control_pts , v0 , vf , a0 , af , time_weight = 0 ) pos_traj = traj_from_curve ( curve , dt ) n_timesteps = len ( pos_traj . times ) quats = quaternion_interpolation_with_bcs ( q0 , qf , w0 , wf , dw0 , dwf , duration , n_timesteps ) omega = quats_to_angular_velocities ( quats , dt ) alpha = np . gradient ( omega , dt , axis = 0 ) return Trajectory ( positions = pos_traj . positions , quats = quats , lin_vels = pos_traj . linear_velocities , ang_vels = omega , lin_accels = pos_traj . linear_accels , ang_accels = alpha , times = pos_traj . times , )","title":"Planner"},{"location":"reference/pyastrobee/trajectories/planner/#module-pyastrobeetrajectoriesplanner","text":"The main trajectory planning structure for Astrobee We use a global/local hierarchy where: The global planner computes a reference trajectory which enforces all of the required constraints, such as Astrobee's speed/acceleration limits, as well as collision avoidance The local planner handles very fast trajectory generation between states with arbitrary boundary conditions on dynamics, but does not enforce some of the more computationally intensive optimizations and constraints This also assumes decoupled dynamics between the position and orientation components Note: the orientation component of the trajectories technically isn't \"optimal\", but it works View Source \"\"\"The main trajectory planning structure for Astrobee We use a global/local hierarchy where: - The global planner computes a reference trajectory which enforces all of the required constraints, such as Astrobee's speed/acceleration limits, as well as collision avoidance - The local planner handles very fast trajectory generation between states with arbitrary boundary conditions on dynamics, but does not enforce some of the more computationally intensive optimizations and constraints This also assumes decoupled dynamics between the position and orientation components Note: the orientation component of the trajectories technically isn't \"optimal\", but it works \"\"\" # TODO add the max-angular-velocity-constrained rotation planner into the global planner (would only really be needed if # we have a very short time horizon on the position component, i.e. if we're not moving much but rotating a lot) from typing import Optional import numpy as np import numpy.typing as npt from pyastrobee.trajectories.trajectory import Trajectory from pyastrobee.trajectories.bezier import bezier_trajectory from pyastrobee.trajectories.quaternion_interpolation import ( quaternion_interpolation_with_bcs , ) from pyastrobee.utils.quaternions import quats_to_angular_velocities from pyastrobee.trajectories.timing import ( spline_duration_heuristic , rotation_duration_heuristic , ) from pyastrobee.config.astrobee_motion import LINEAR_SPEED_LIMIT , LINEAR_ACCEL_LIMIT from pyastrobee.config.iss_safe_boxes import ROBOT_SAFE_SET from pyastrobee.config.iss_paths import GRAPH , PATHS from pyastrobee.utils.boxes import Box , find_containing_box_name , compute_graph from pyastrobee.utils.algos import dfs from pyastrobee.trajectories.curve_utils import traj_from_curve from pyastrobee.trajectories.variable_time_curves import ( free_final_time_bezier , free_final_time_spline , ) def local_planner ( p0 : npt . ArrayLike , q0 : npt . ArrayLike , v0 : Optional [ npt . ArrayLike ], w0 : npt . ArrayLike , a0 : Optional [ npt . ArrayLike ], dw0 : npt . ArrayLike , pf : npt . ArrayLike , qf : npt . ArrayLike , vf : Optional [ npt . ArrayLike ], wf : npt . ArrayLike , af : Optional [ npt . ArrayLike ], dwf : npt . ArrayLike , duration : float , dt : float , ) -> Trajectory : \"\"\"Generate an optimal Bezier-curve-based position trajectory with a polynomial orientation component Note that this planner prioritizes solve time over constraint enforcement. This will plan with boundary conditions in mind, but other than that, it does not enforce things like speed/acceleration limits or collision avoidance. This allows us to use this in very fast online applications. In general, this should be paired with the global planner, so that we can precompute a reference trajectory which does enforce all constraints (and takes a bit longer to solve), and use this local planner to evaluate different rollouts between states along this reference trajectory Args: p0 (npt.ArrayLike): Initial position, shape (3,) q0 (npt.ArrayLike): Initial XYZW quaternion, shape (4,) v0 (npt.ArrayLike): Initial linear velocity, shape (3,) w0 (npt.ArrayLike): Initial angular velocity, shape (3,) a0 (npt.ArrayLike): Initial linear acceleration, shape (3,) dw0 (npt.ArrayLike): Initial angular acceleration, shape (3,) pf (npt.ArrayLike): Final position, shape (3,) qf (npt.ArrayLike): Final XYZW quaternion, shape (4,) vf (npt.ArrayLike): Final linear velocity, shape (3,) wf (npt.ArrayLike): Final angular velocity, shape (3,) af (npt.ArrayLike): Final linear acceleration, shape (3,) dwf (npt.ArrayLike): Final angular acceleration, shape (3,) duration (float): Trajectory duration (seconds) dt (float): Sampling period (seconds) Returns: Trajectory: The optimal local trajectory plan \"\"\" # Min-jerk position traj # Don't need a ton of control points because we're not enforcing constraints n_control_pts = 8 curve , _ = bezier_trajectory ( p0 , pf , 0 , duration , n_control_pts , v0 , vf , a0 , af , time_weight = 0 ) pos_traj = traj_from_curve ( curve , dt ) n_timesteps = len ( pos_traj . times ) quats = quaternion_interpolation_with_bcs ( q0 , qf , w0 , wf , dw0 , dwf , duration , n_timesteps ) omega = quats_to_angular_velocities ( quats , dt ) alpha = np . gradient ( omega , dt , axis = 0 ) return Trajectory ( positions = pos_traj . positions , quats = quats , lin_vels = pos_traj . linear_velocities , ang_vels = omega , lin_accels = pos_traj . linear_accels , ang_accels = alpha , times = pos_traj . times , ) def global_planner ( p0 : npt . ArrayLike , q0 : npt . ArrayLike , pf : npt . ArrayLike , qf : npt . ArrayLike , dt : float , safe_set : dict [ str , Box ] = ROBOT_SAFE_SET , graph : Optional [ dict [ str , list [ str ]]] = GRAPH , ) -> Trajectory : \"\"\"Generate an optimal spline-based position trajectory with a polynomial orientation component This will enforce all of the Astrobee's constraints (such as maximum velocity/acceleration and collision avoidance). It will also be time-optimal in the sense that 1) The total duration of the curve is minimized, and 2) each Bezier curve in the spline will have its relative duration (w.r.t. the total duration) optimized to minimize jerk Note that this can take on the order of 10 seconds to compute, so it is not something that should be called online Args: p0 (npt.ArrayLike): Initial position, shape (3,) q0 (npt.ArrayLike): Initial XYZW quaternion, shape (4,) pf (npt.ArrayLike): Final position, shape (3,) qf (npt.ArrayLike): Final XYZW quaternion, shape (4,) dt (float): Sampling period (seconds) safe_set (dict[str, Box], optional): Description of the safe set of the environment. Defaults to ROBOT_SAFE_SET (the precomputed safe-set decomposition for the ISS, accounting for the robot's collision radius) graph (Optional[dict[str, list[str]]], optional): The graph defining the connections between the safe boxes in the environment. Defaults to GRAPH (the precomputed safe-set graph for the ISS). Note: if set to None, this graph will be recomputed from the ROBOT_SAFE_SET parameter Returns: Trajectory: The optimal global trajectory plan \"\"\" # Dynamics parameters: Assume start and end from rest, satisfy operating limits t0 = 0 v0 = np . zeros ( 3 ) vf = np . zeros ( 3 ) a0 = np . zeros ( 3 ) af = np . zeros ( 3 ) w0 = np . zeros ( 3 ) wf = np . zeros ( 3 ) dw0 = np . zeros ( 3 ) dwf = np . zeros ( 3 ) v_max = LINEAR_SPEED_LIMIT a_max = LINEAR_ACCEL_LIMIT # Parameters associated with the retiming optimization or the free-final-time optimization # will be left at the default values for now # Determine the path through the safe-space graph start = find_containing_box_name ( p0 , safe_set ) end = find_containing_box_name ( pf , safe_set ) if graph is None : graph = compute_graph ( safe_set ) path = dfs ( graph , start , end ) box_path = [ safe_set [ p ] for p in path ] init_angular_duration = rotation_duration_heuristic ( q0 , qf ) init_pos_duration , init_timing_fractions = spline_duration_heuristic ( p0 , pf , box_path ) # TODO enforce a minimum final time in the free-final-time optimization # to make sure that the rotation plan still has enough time to execute duration = max ( init_pos_duration , init_angular_duration ) init_curve_durations = duration * init_timing_fractions if len ( box_path ) == 1 : # Crank up the control points for a single Bezier curve so that we can be nice and tight # against the velocity/accel constraints n_control_pts = 20 # If our start and end positions are contained within the same free box, # we can construct the trajectory from a single Bezier curve curve = free_final_time_bezier ( p0 , pf , t0 , duration , n_control_pts , v0 , vf , a0 , af , box_path [ 0 ], v_max , a_max , ) else : # Our start/end positions are not in the same box, so use a spline between boxes # Use less control points for the spline for optimization stability n_control_pts = 10 curve = free_final_time_spline ( p0 , pf , t0 , duration , n_control_pts , box_path , init_curve_durations , v0 , vf , a0 , af , v_max , a_max , ) pos_traj = traj_from_curve ( curve , dt ) n_timesteps = pos_traj . num_timesteps quats = quaternion_interpolation_with_bcs ( q0 , qf , w0 , wf , dw0 , dwf , duration , n_timesteps ) omega = quats_to_angular_velocities ( quats , dt ) alpha = np . gradient ( omega , dt , axis = 0 ) return Trajectory ( pos_traj . positions , quats , pos_traj . linear_velocities , omega , pos_traj . linear_accels , alpha , pos_traj . times , )","title":"Module pyastrobee.trajectories.planner"},{"location":"reference/pyastrobee/trajectories/planner/#variables","text":"GRAPH LINEAR_ACCEL_LIMIT LINEAR_SPEED_LIMIT PATHS ROBOT_SAFE_SET","title":"Variables"},{"location":"reference/pyastrobee/trajectories/planner/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/trajectories/planner/#global_planner","text":"def global_planner ( p0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], q0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], qf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], dt : float , safe_set : dict [ str , pyastrobee . utils . boxes . Box ] = { 'jpm' : Box ( lower = [ 3.47650494853664 , - 0.4984950514633599 , - 0.7234950514633598 ], upper = [ 10.22349505146336 , 0.6354950514633599 , 0.7234950514633598 ]), 'node_2' : Box ( lower = [ - 0.7234950514633598 , - 2.18149505146336 , - 0.8234950514633599 ], upper = [ 0.8234950514633599 , 0.8144950514633598 , 0.64749505146336 ]), 'eu_lab' : Box ( lower = [ - 7.42649505146336 , - 0.5894950514633599 , - 0.7234950514633598 ], upper = [ - 3.67650494853664 , 0.6484950514633598 , 0.7234950514633598 ]), 'us_lab' : Box ( lower = [ - 0.7234950514633598 , - 10.98849505146336 , - 0.7234950514633598 ], upper = [ 0.5974950514633599 , - 6.0825049485366405 , 0.7234950514633598 ]), 'node_1' : Box ( lower = [ - 0.6754950514633598 , - 16.88849505146336 , - 0.7234950514633598 ], upper = [ 0.7234950514633598 , - 13.72550494853664 , 0.7514950514633598 ]), 'node_3_a' : Box ( lower = [ 3.17650494853664 , - 15.31249505146336 , - 0.7234950514633598 ], upper = [ 6.04549505146336 , - 14.97650494853664 , 0.3114950514633598 ]), 'node_3_b' : Box ( lower = [ 5.234504948536641 , - 15.253495051463359 , - 0.7234950514633598 ], upper = [ 7.3694950514633595 , - 14.38350494853664 , 0.6624950514633599 ]), 'cupola' : Box ( lower = [ 6.176504948536641 , - 14.90349505146336 , 1.6435049485366402 ], upper = [ 6.3854950514633595 , - 14.56150494853664 , 2.88149505146336 ]), 'jpm_n2_corridor' : Box ( lower = [ 0.3765049485366402 , - 0.19849505146335983 , - 0.32349505146335983 ], upper = [ 4.523495051463359 , 0.19849505146335983 , 0.32349505146335983 ]), 'n2_eu_corridor' : Box ( lower = [ - 4.523495051463359 , - 0.19849505146335983 , - 0.32349505146335983 ], upper = [ - 0.3765049485366402 , 0.19849505146335983 , 0.32349505146335983 ]), 'n2_us_corridor' : Box ( lower = [ - 0.32349505146335983 , - 6.62549505146336 , - 0.32349505146335983 ], upper = [ 0.32349505146335983 , - 1.6245049485366403 , 0.32349505146335983 ]), 'us_n1_corridor' : Box ( lower = [ - 0.32349505146335983 , - 14.07349505146336 , - 0.32349505146335983 ], upper = [ 0.32349505146335983 , - 10.47650494853664 , 0.32349505146335983 ]), 'n1_n3_corridor' : Box ( lower = [ 0.17650494853664014 , - 15.12349505146336 , - 0.32349505146335983 ], upper = [ 3.9034950514633597 , - 14.67650494853664 , 0.32349505146335983 ]), 'n3_cupola_corridor' : Box ( lower = [ 6.07650494853664 , - 15.144495051463359 , 0.39550494853664014 ], upper = [ 6.72349505146336 , - 14.37650494853664 , 1.9024950514633596 ])}, graph : Optional [ dict [ str , list [ str ]]] = { 'cupola' : [ 'n3_cupola_corridor' ], 'eu_lab' : [ 'n2_eu_corridor' ], 'jpm' : [ 'jpm_n2_corridor' ], 'jpm_n2_corridor' : [ 'jpm' , 'node_2' ], 'n1_n3_corridor' : [ 'node_1' , 'node_3_a' ], 'n2_eu_corridor' : [ 'node_2' , 'eu_lab' ], 'n2_us_corridor' : [ 'node_2' , 'us_lab' ], 'n3_cupola_corridor' : [ 'node_3_b' , 'cupola' ], 'node_1' : [ 'us_n1_corridor' , 'n1_n3_corridor' ], 'node_2' : [ 'jpm_n2_corridor' , 'n2_eu_corridor' , 'n2_us_corridor' ], 'node_3_a' : [ 'node_3_b' , 'n1_n3_corridor' ], 'node_3_b' : [ 'node_3_a' , 'n3_cupola_corridor' ], 'us_lab' : [ 'n2_us_corridor' , 'us_n1_corridor' ], 'us_n1_corridor' : [ 'us_lab' , 'node_1' ]} ) -> pyastrobee . trajectories . trajectory . Trajectory Generate an optimal spline-based position trajectory with a polynomial orientation component This will enforce all of the Astrobee's constraints (such as maximum velocity/acceleration and collision avoidance). It will also be time-optimal in the sense that 1) The total duration of the curve is minimized, and 2) each Bezier curve in the spline will have its relative duration (w.r.t. the total duration) optimized to minimize jerk Note that this can take on the order of 10 seconds to compute, so it is not something that should be called online Parameters: Name Type Description Default p0 npt.ArrayLike Initial position, shape (3,) None q0 npt.ArrayLike Initial XYZW quaternion, shape (4,) None pf npt.ArrayLike Final position, shape (3,) None qf npt.ArrayLike Final XYZW quaternion, shape (4,) None dt float Sampling period (seconds) None safe_set dict[str, Box] Description of the safe set of the environment. Defaults to ROBOT_SAFE_SET (the precomputed safe-set decomposition for the ISS, accounting for the robot's collision radius) None graph Optional[dict[str, list[str]]] The graph defining the connections between the safe boxes in the environment. Defaults to GRAPH (the precomputed safe-set graph for the ISS). Note: if set to None, this graph will be recomputed from the ROBOT_SAFE_SET parameter None Returns: Type Description Trajectory The optimal global trajectory plan View Source def global_planner ( p0 : npt . ArrayLike , q0 : npt . ArrayLike , pf : npt . ArrayLike , qf : npt . ArrayLike , dt : float , safe_set : dict [ str, Box ] = ROBOT_SAFE_SET , graph : Optional [ dict[str, list[str ] ]] = GRAPH , ) -> Trajectory : \"\"\"Generate an optimal spline-based position trajectory with a polynomial orientation component This will enforce all of the Astrobee's constraints (such as maximum velocity/acceleration and collision avoidance). It will also be time-optimal in the sense that 1) The total duration of the curve is minimized, and 2) each Bezier curve in the spline will have its relative duration (w.r.t. the total duration) optimized to minimize jerk Note that this can take on the order of 10 seconds to compute, so it is not something that should be called online Args: p0 (npt.ArrayLike): Initial position, shape (3,) q0 (npt.ArrayLike): Initial XYZW quaternion, shape (4,) pf (npt.ArrayLike): Final position, shape (3,) qf (npt.ArrayLike): Final XYZW quaternion, shape (4,) dt (float): Sampling period (seconds) safe_set (dict[str, Box], optional): Description of the safe set of the environment. Defaults to ROBOT_SAFE_SET (the precomputed safe-set decomposition for the ISS, accounting for the robot's collision radius) graph (Optional[dict[str, list[str]]], optional): The graph defining the connections between the safe boxes in the environment. Defaults to GRAPH (the precomputed safe-set graph for the ISS). Note: if set to None, this graph will be recomputed from the ROBOT_SAFE_SET parameter Returns: Trajectory: The optimal global trajectory plan \"\"\" # Dynamics parameters : Assume start and end from rest , satisfy operating limits t0 = 0 v0 = np . zeros ( 3 ) vf = np . zeros ( 3 ) a0 = np . zeros ( 3 ) af = np . zeros ( 3 ) w0 = np . zeros ( 3 ) wf = np . zeros ( 3 ) dw0 = np . zeros ( 3 ) dwf = np . zeros ( 3 ) v_max = LINEAR_SPEED_LIMIT a_max = LINEAR_ACCEL_LIMIT # Parameters associated with the retiming optimization or the free - final - time optimization # will be left at the default values for now # Determine the path through the safe - space graph start = find_containing_box_name ( p0 , safe_set ) end = find_containing_box_name ( pf , safe_set ) if graph is None : graph = compute_graph ( safe_set ) path = dfs ( graph , start , end ) box_path = [ safe_set[p ] for p in path ] init_angular_duration = rotation_duration_heuristic ( q0 , qf ) init_pos_duration , init_timing_fractions = spline_duration_heuristic ( p0 , pf , box_path ) # TODO enforce a minimum final time in the free - final - time optimization # to make sure that the rotation plan still has enough time to execute duration = max ( init_pos_duration , init_angular_duration ) init_curve_durations = duration * init_timing_fractions if len ( box_path ) == 1 : # Crank up the control points for a single Bezier curve so that we can be nice and tight # against the velocity / accel constraints n_control_pts = 20 # If our start and end positions are contained within the same free box , # we can construct the trajectory from a single Bezier curve curve = free_final_time_bezier ( p0 , pf , t0 , duration , n_control_pts , v0 , vf , a0 , af , box_path [ 0 ] , v_max , a_max , ) else : # Our start / end positions are not in the same box , so use a spline between boxes # Use less control points for the spline for optimization stability n_control_pts = 10 curve = free_final_time_spline ( p0 , pf , t0 , duration , n_control_pts , box_path , init_curve_durations , v0 , vf , a0 , af , v_max , a_max , ) pos_traj = traj_from_curve ( curve , dt ) n_timesteps = pos_traj . num_timesteps quats = quaternion_interpolation_with_bcs ( q0 , qf , w0 , wf , dw0 , dwf , duration , n_timesteps ) omega = quats_to_angular_velocities ( quats , dt ) alpha = np . gradient ( omega , dt , axis = 0 ) return Trajectory ( pos_traj . positions , quats , pos_traj . linear_velocities , omega , pos_traj . linear_accels , alpha , pos_traj . times , )","title":"global_planner"},{"location":"reference/pyastrobee/trajectories/planner/#local_planner","text":"def local_planner ( p0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], q0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], v0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ], w0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], a0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ], dw0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], qf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], vf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ], wf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], af : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ], dwf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], duration : float , dt : float ) -> pyastrobee . trajectories . trajectory . Trajectory Generate an optimal Bezier-curve-based position trajectory with a polynomial orientation component Note that this planner prioritizes solve time over constraint enforcement. This will plan with boundary conditions in mind, but other than that, it does not enforce things like speed/acceleration limits or collision avoidance. This allows us to use this in very fast online applications. In general, this should be paired with the global planner, so that we can precompute a reference trajectory which does enforce all constraints (and takes a bit longer to solve), and use this local planner to evaluate different rollouts between states along this reference trajectory Parameters: Name Type Description Default p0 npt.ArrayLike Initial position, shape (3,) None q0 npt.ArrayLike Initial XYZW quaternion, shape (4,) None v0 npt.ArrayLike Initial linear velocity, shape (3,) None w0 npt.ArrayLike Initial angular velocity, shape (3,) None a0 npt.ArrayLike Initial linear acceleration, shape (3,) None dw0 npt.ArrayLike Initial angular acceleration, shape (3,) None pf npt.ArrayLike Final position, shape (3,) None qf npt.ArrayLike Final XYZW quaternion, shape (4,) None vf npt.ArrayLike Final linear velocity, shape (3,) None wf npt.ArrayLike Final angular velocity, shape (3,) None af npt.ArrayLike Final linear acceleration, shape (3,) None dwf npt.ArrayLike Final angular acceleration, shape (3,) None duration float Trajectory duration (seconds) None dt float Sampling period (seconds) None Returns: Type Description Trajectory The optimal local trajectory plan View Source def local_planner ( p0 : npt . ArrayLike , q0 : npt . ArrayLike , v0 : Optional [ npt . ArrayLike ], w0 : npt . ArrayLike , a0 : Optional [ npt . ArrayLike ], dw0 : npt . ArrayLike , pf : npt . ArrayLike , qf : npt . ArrayLike , vf : Optional [ npt . ArrayLike ], wf : npt . ArrayLike , af : Optional [ npt . ArrayLike ], dwf : npt . ArrayLike , duration : float , dt : float , ) -> Trajectory : \"\"\"Generate an optimal Bezier-curve-based position trajectory with a polynomial orientation component Note that this planner prioritizes solve time over constraint enforcement. This will plan with boundary conditions in mind, but other than that, it does not enforce things like speed/acceleration limits or collision avoidance. This allows us to use this in very fast online applications. In general, this should be paired with the global planner, so that we can precompute a reference trajectory which does enforce all constraints (and takes a bit longer to solve), and use this local planner to evaluate different rollouts between states along this reference trajectory Args: p0 (npt.ArrayLike): Initial position, shape (3,) q0 (npt.ArrayLike): Initial XYZW quaternion, shape (4,) v0 (npt.ArrayLike): Initial linear velocity, shape (3,) w0 (npt.ArrayLike): Initial angular velocity, shape (3,) a0 (npt.ArrayLike): Initial linear acceleration, shape (3,) dw0 (npt.ArrayLike): Initial angular acceleration, shape (3,) pf (npt.ArrayLike): Final position, shape (3,) qf (npt.ArrayLike): Final XYZW quaternion, shape (4,) vf (npt.ArrayLike): Final linear velocity, shape (3,) wf (npt.ArrayLike): Final angular velocity, shape (3,) af (npt.ArrayLike): Final linear acceleration, shape (3,) dwf (npt.ArrayLike): Final angular acceleration, shape (3,) duration (float): Trajectory duration (seconds) dt (float): Sampling period (seconds) Returns: Trajectory: The optimal local trajectory plan \"\"\" # Min-jerk position traj # Don't need a ton of control points because we're not enforcing constraints n_control_pts = 8 curve , _ = bezier_trajectory ( p0 , pf , 0 , duration , n_control_pts , v0 , vf , a0 , af , time_weight = 0 ) pos_traj = traj_from_curve ( curve , dt ) n_timesteps = len ( pos_traj . times ) quats = quaternion_interpolation_with_bcs ( q0 , qf , w0 , wf , dw0 , dwf , duration , n_timesteps ) omega = quats_to_angular_velocities ( quats , dt ) alpha = np . gradient ( omega , dt , axis = 0 ) return Trajectory ( positions = pos_traj . positions , quats = quats , lin_vels = pos_traj . linear_velocities , ang_vels = omega , lin_accels = pos_traj . linear_accels , ang_accels = alpha , times = pos_traj . times , )","title":"local_planner"},{"location":"reference/pyastrobee/trajectories/polynomials/","text":"Module pyastrobee.trajectories.polynomials Generating trajectories via polynomials Assorted ideas - Add a \"glide\" section to the trajectory? e.g. reach the max velocity and then glide until we need to decelerate - Enforce actuator limits - make sure that the trajectory doesn't exceed the max velocity values. If so, increase the duration View Source \"\"\"Generating trajectories via polynomials Assorted ideas - Add a \"glide\" section to the trajectory? e.g. reach the max velocity and then glide until we need to decelerate - Enforce actuator limits - make sure that the trajectory doesn't exceed the max velocity values. If so, increase the duration \"\"\" import numpy as np import numpy.typing as npt from numpy.polynomial.polynomial import Polynomial from pyastrobee.trajectories.trajectory import Trajectory from pyastrobee.utils.quaternions import ( random_quaternion , quaternion_slerp , quats_to_angular_velocities , ) from pyastrobee.trajectories.quaternion_interpolation import ( quaternion_interpolation_with_bcs , ) def polynomial_slerp ( q1 : npt . ArrayLike , q2 : npt . ArrayLike , n : int ) -> np . ndarray : \"\"\"SLERP based on a third-order polynomial discretization This will interpolate quaternions based on a polynomial spacing rather than a linear spacing. The resulting angular velocity vector has a constant direction, but will be quadratic, starting and ending at 0 Args: q1 (npt.ArrayLike): Starting XYZW quaternion, shape (4,) q2 (npt.ArrayLike): Ending XYZW quaternion, shape (4,) n (int): Number of points at which to evaluate the polynomial-based SLERP Returns: np.ndarray: The interpolated XYZW quaternions, shape = (n, 4) \"\"\" # Generate our evaluation points for SLERP so that: # - We evaluate over a domain of [0, 1] with n steps # - We want to start at 0 and end at 1 with 0 derivative at either end pcts = third_order_poly ( 0 , 1 , 0 , 1 , 0 , 0 )( np . linspace ( 0 , 1 , n , endpoint = True )) return quaternion_slerp ( q1 , q2 , pcts ) def third_order_poly ( t0 : float , tf : float , x0 : float , xf : float , v0 : float , vf : float , ) -> Polynomial : \"\"\"Generate a third-order polynomial over a time domain based on boundary conditions We will refer to the variables in terms of position and velocity, but in general, this can be applied to any variable and its derivative Args: t0 (float): Start time tf (float): End time x0 (float): Initial position xf (float): Final position v0 (float): Initial velocity vf (float): Final velocity Returns: Polynomial: The polynomial which satisfies the boundary conditions. Evaluate the polynomial by calling it with the evaluation times. e.g. xs = solved_polynomial(times) \"\"\" # Form linear system of equations: we have four polynomial coefficients for a third-order poly # and have four constraints on the endpoints (initial/final position/velocity) A = np . array ( [ [ 1 , t0 , t0 ** 2 , t0 ** 3 ], [ 1 , tf , tf ** 2 , tf ** 3 ], [ 0 , 1 , 2 * t0 , 3 * t0 ** 2 ], [ 0 , 1 , 2 * tf , 3 * tf ** 2 ], ] ) b = np . array ([ x0 , xf , v0 , vf ]) coeffs = np . linalg . solve ( A , b ) return Polynomial ( coeffs ) def fifth_order_poly ( t0 : float , tf : float , x0 : float , xf : float , v0 : float , vf : float , a0 : float , af : float , ) -> Polynomial : \"\"\"Generate a fifth-order polynomial over a time domain based on boundary conditions We will refer to the variables in terms of position and velocity, but in general, this can be applied to any variable and its derivative Args: t0 (float): Start time tf (float): End time x0 (float): Initial position xf (float): Final position v0 (float): Initial velocity vf (float): Final velocity a0 (float): Initial acceleration af (float): Final acceleration Returns: Polynomial: The polynomial which satisfies the boundary conditions. Evaluate the polynomial by calling it with the evaluation times. e.g. xs = solved_polynomial(times) \"\"\" # Form linear system of equations: we have six polynomial coefficients for a fifth-order poly # and have six constraints on the endpoints (initial/final position/velocity/acceleration) A = np . array ( [ [ 1 , t0 , t0 ** 2 , t0 ** 3 , t0 ** 4 , t0 ** 5 ], [ 1 , tf , tf ** 2 , tf ** 3 , tf ** 4 , tf ** 5 ], [ 0 , 1 , 2 * t0 , 3 * t0 ** 2 , 4 * t0 ** 3 , 5 * t0 ** 4 ], [ 0 , 1 , 2 * tf , 3 * tf ** 2 , 4 * tf ** 3 , 5 * tf ** 4 ], [ 0 , 0 , 2 , 6 * t0 , 12 * t0 ** 2 , 20 * t0 ** 3 ], [ 0 , 0 , 2 , 6 * tf , 12 * tf ** 2 , 20 * tf ** 3 ], ] ) b = np . array ([ x0 , xf , v0 , vf , a0 , af ]) coeffs = np . linalg . solve ( A , b ) return Polynomial ( coeffs ) def polynomial_trajectory ( pose_1 : npt . ArrayLike , pose_2 : npt . ArrayLike , duration : float , dt : float ) -> Trajectory : \"\"\"Generate a third-order polynomial trajectory between two poses Args: pose_1 (npt.ArrayLike): Starting position + XYZW quaternion pose, shape (7,) pose_2 (npt.ArrayLike): Ending position + XYZW quaternion pose, shape (7,) duration (float): Trajectory duration (seconds) dt (float): Sampling period (seconds) Returns: Trajectory: Trajectory with position, orientation, lin/ang velocity, lin/ang acceleration, and time info \"\"\" times = np . arange ( 0 , duration + dt , dt ) n = len ( times ) x0 , y0 , z0 = pose_1 [: 3 ] q0 = pose_1 [ 3 :] xf , yf , zf = pose_2 [: 3 ] qf = pose_2 [ 3 :] t0 = times [ 0 ] tf = times [ - 1 ] v0 = 0 vf = 0 f_x = third_order_poly ( t0 , tf , x0 , xf , v0 , vf ) f_y = third_order_poly ( t0 , tf , y0 , yf , v0 , vf ) f_z = third_order_poly ( t0 , tf , z0 , zf , v0 , vf ) f_vx : Polynomial = f_x . deriv () f_vy : Polynomial = f_y . deriv () f_vz : Polynomial = f_z . deriv () f_ax : Polynomial = f_vx . deriv () f_ay : Polynomial = f_vy . deriv () f_az : Polynomial = f_vz . deriv () q = polynomial_slerp ( q0 , qf , n ) omega = quats_to_angular_velocities ( q , dt ) alpha = np . gradient ( omega , dt , axis = 0 ) return Trajectory ( positions = np . column_stack ([ f_x ( times ), f_y ( times ), f_z ( times )]), quats = q , lin_vels = np . column_stack ([ f_vx ( times ), f_vy ( times ), f_vz ( times )]), ang_vels = omega , lin_accels = np . column_stack ([ f_ax ( times ), f_ay ( times ), f_az ( times )]), ang_accels = alpha , times = times , ) def polynomial_traj_with_velocity_bcs ( p0 : npt . ArrayLike , q0 : npt . ArrayLike , v0 : npt . ArrayLike , w0 : npt . ArrayLike , pf : npt . ArrayLike , qf : npt . ArrayLike , vf : npt . ArrayLike , wf : npt . ArrayLike , duration : float , dt : float , ) -> Trajectory : \"\"\"Generate a polynomial trajectory between two poses, with velocity boundary conditions on either end Args: p0 (npt.ArrayLike): Initial position, shape (3,) q0 (npt.ArrayLike): Initial XYZW quaternion, shape (4,) v0 (npt.ArrayLike): Initial linear velocity, shape (3,) w0 (npt.ArrayLike): Initial angular velocity, shape (3,) pf (npt.ArrayLike): Final position, shape (3,) qf (npt.ArrayLike): Final XYZW quaternion, shape (4,) vf (npt.ArrayLike): Final linear velocity, shape (3,) wf (npt.ArrayLike): Final angular velocity, shape (3,) duration (float): Trajectory duration (seconds) dt (float): Sampling period (seconds) Returns: Trajectory: Trajectory with position, orientation, lin/ang velocity, lin/ang acceleration, and time info \"\"\" times = np . arange ( 0 , duration + dt , dt ) n = len ( times ) x0 , y0 , z0 = p0 xf , yf , zf = pf t0 = times [ 0 ] tf = times [ - 1 ] vx0 , vy0 , vz0 = v0 vxf , vyf , vzf = vf f_x = third_order_poly ( t0 , tf , x0 , xf , vx0 , vxf ) f_y = third_order_poly ( t0 , tf , y0 , yf , vy0 , vyf ) f_z = third_order_poly ( t0 , tf , z0 , zf , vz0 , vzf ) f_vx : Polynomial = f_x . deriv () f_vy : Polynomial = f_y . deriv () f_vz : Polynomial = f_z . deriv () f_ax : Polynomial = f_vx . deriv () f_ay : Polynomial = f_vy . deriv () f_az : Polynomial = f_vz . deriv () # TODO make these an input. It's a bit weird that we don't have the acceleration constraint though # since we're using the third-order poly on the position traj... Figure this out dw0 = np . zeros ( 3 ) dwf = np . zeros ( 3 ) q = quaternion_interpolation_with_bcs ( q0 , qf , w0 , wf , dw0 , dwf , duration , n ) omega = quats_to_angular_velocities ( q , dt ) alpha = np . gradient ( omega , dt , axis = 0 ) return Trajectory ( positions = np . column_stack ([ f_x ( times ), f_y ( times ), f_z ( times )]), quats = q , lin_vels = np . column_stack ([ f_vx ( times ), f_vy ( times ), f_vz ( times )]), ang_vels = omega , lin_accels = np . column_stack ([ f_ax ( times ), f_ay ( times ), f_az ( times )]), ang_accels = alpha , times = times , ) def fifth_order_polynomial_traj_with_velocity_bcs ( p0 : npt . ArrayLike , q0 : npt . ArrayLike , v0 : npt . ArrayLike , w0 : npt . ArrayLike , a0 : npt . ArrayLike , dw0 : npt . ArrayLike , pf : npt . ArrayLike , qf : npt . ArrayLike , vf : npt . ArrayLike , wf : npt . ArrayLike , af : npt . ArrayLike , dwf : npt . ArrayLike , duration : float , dt : float , ) -> Trajectory : \"\"\"Generate a polynomial trajectory between two poses, with velocity boundary conditions on either end Args: p0 (npt.ArrayLike): Initial position, shape (3,) q0 (npt.ArrayLike): Initial XYZW quaternion, shape (4,) v0 (npt.ArrayLike): Initial linear velocity, shape (3,) w0 (npt.ArrayLike): Initial angular velocity, shape (3,) a0 (npt.ArrayLike): Initial linear acceleration, shape (3,) dw0 (npt.ArrayLike): Initial angular acceleration, shape (3,) pf (npt.ArrayLike): Final position, shape (3,) qf (npt.ArrayLike): Final XYZW quaternion, shape (4,) vf (npt.ArrayLike): Final linear velocity, shape (3,) wf (npt.ArrayLike): Final angular velocity, shape (3,) af (npt.ArrayLike): Final linear acceleration, shape (3,) dwf (npt.ArrayLike): Final angular acceleration, shape (3,) duration (float): Trajectory duration (seconds) dt (float): Sampling period (seconds) Returns: Trajectory: Trajectory with position, orientation, lin/ang velocity, lin/ang acceleration, and time info \"\"\" times = np . arange ( 0 , duration + dt , dt ) n = len ( times ) x0 , y0 , z0 = p0 xf , yf , zf = pf t0 = times [ 0 ] tf = times [ - 1 ] vx0 , vy0 , vz0 = v0 vxf , vyf , vzf = vf ax0 , ay0 , az0 = a0 axf , ayf , azf = af f_x = fifth_order_poly ( t0 , tf , x0 , xf , vx0 , vxf , ax0 , axf ) f_y = fifth_order_poly ( t0 , tf , y0 , yf , vy0 , vyf , ay0 , ayf ) f_z = fifth_order_poly ( t0 , tf , z0 , zf , vz0 , vzf , az0 , azf ) f_vx : Polynomial = f_x . deriv () f_vy : Polynomial = f_y . deriv () f_vz : Polynomial = f_z . deriv () f_ax : Polynomial = f_vx . deriv () f_ay : Polynomial = f_vy . deriv () f_az : Polynomial = f_vz . deriv () q = quaternion_interpolation_with_bcs ( q0 , qf , w0 , wf , dw0 , dwf , duration , n ) omega = quats_to_angular_velocities ( q , dt ) alpha = np . gradient ( omega , dt , axis = 0 ) return Trajectory ( positions = np . column_stack ([ f_x ( times ), f_y ( times ), f_z ( times )]), quats = q , lin_vels = np . column_stack ([ f_vx ( times ), f_vy ( times ), f_vz ( times )]), ang_vels = omega , lin_accels = np . column_stack ([ f_ax ( times ), f_ay ( times ), f_az ( times )]), ang_accels = alpha , times = times , ) def _main (): # TODO add the astrobee following the trajectory?? # Update these values depending on what examples you want to run RUN_NO_BC_EXAMPLE = True RUN_BC_EXAMPLE = True # Example with no boundary conditions if RUN_NO_BC_EXAMPLE : np . random . seed ( 0 ) pose1 = np . array ([ 0 , 0 , 0 , 0 , 0 , 0 , 1 ]) pose2 = np . array ([ 1 , 1 , 1 , * random_quaternion ()]) traj = polynomial_trajectory ( pose1 , pose2 , 5 , 0.1 ) print ( \"Plotting trajectory information\" ) traj . plot () input ( \"Press Enter to visualize the trajectory in pybullet, when ready\" ) traj . visualize () # Example with boundary conditions on the initial/final velocities if RUN_BC_EXAMPLE : p0 = np . array ([ 1 , 2 , 3 ]) q0 = np . array ([ 1 , 2 , 3 , 4 ]) / np . linalg . norm ([ 1 , 2 , 3 , 4 ]) v0 = np . array ([ 1 , 2 , 3 ]) w0 = np . array ([ 0.1 , 0.2 , 0.3 ]) pf = np . array ([ 2 , 3 , 4 ]) qf = np . array ([ 2 , 3 , 4 , 5 ]) / np . linalg . norm ([ 2 , 3 , 4 , 5 ]) vf = np . array ([ 2 , 3 , 4 ]) wf = np . array ([ 0.2 , 0.3 , 0.4 ]) duration = 10 dt = 0.1 # Arbitrary traj = polynomial_traj_with_velocity_bcs ( p0 , q0 , v0 , w0 , pf , qf , vf , wf , duration , dt ) traj . plot () traj . visualize () if __name__ == \"__main__\" : _main () Functions fifth_order_poly def fifth_order_poly ( t0 : float , tf : float , x0 : float , xf : float , v0 : float , vf : float , a0 : float , af : float ) -> numpy . polynomial . polynomial . Polynomial Generate a fifth-order polynomial over a time domain based on boundary conditions We will refer to the variables in terms of position and velocity, but in general, this can be applied to any variable and its derivative Parameters: Name Type Description Default t0 float Start time None tf float End time None x0 float Initial position None xf float Final position None v0 float Initial velocity None vf float Final velocity None a0 float Initial acceleration None af float Final acceleration None Returns: Type Description Polynomial The polynomial which satisfies the boundary conditions. Evaluate the polynomial by calling it with the evaluation times. e.g. xs = solved_polynomial(times) View Source def fifth_order_poly ( t0 : float , tf : float , x0 : float , xf : float , v0 : float , vf : float , a0 : float , af : float , ) -> Polynomial : \"\"\"Generate a fifth-order polynomial over a time domain based on boundary conditions We will refer to the variables in terms of position and velocity, but in general, this can be applied to any variable and its derivative Args: t0 (float): Start time tf (float): End time x0 (float): Initial position xf (float): Final position v0 (float): Initial velocity vf (float): Final velocity a0 (float): Initial acceleration af (float): Final acceleration Returns: Polynomial: The polynomial which satisfies the boundary conditions. Evaluate the polynomial by calling it with the evaluation times. e.g. xs = solved_polynomial(times) \"\"\" # Form linear system of equations: we have six polynomial coefficients for a fifth-order poly # and have six constraints on the endpoints (initial/final position/velocity/acceleration) A = np . array ( [ [ 1 , t0 , t0 ** 2 , t0 ** 3 , t0 ** 4 , t0 ** 5 ], [ 1 , tf , tf ** 2 , tf ** 3 , tf ** 4 , tf ** 5 ], [ 0 , 1 , 2 * t0 , 3 * t0 ** 2 , 4 * t0 ** 3 , 5 * t0 ** 4 ], [ 0 , 1 , 2 * tf , 3 * tf ** 2 , 4 * tf ** 3 , 5 * tf ** 4 ], [ 0 , 0 , 2 , 6 * t0 , 12 * t0 ** 2 , 20 * t0 ** 3 ], [ 0 , 0 , 2 , 6 * tf , 12 * tf ** 2 , 20 * tf ** 3 ], ] ) b = np . array ([ x0 , xf , v0 , vf , a0 , af ]) coeffs = np . linalg . solve ( A , b ) return Polynomial ( coeffs ) fifth_order_polynomial_traj_with_velocity_bcs def fifth_order_polynomial_traj_with_velocity_bcs ( p0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], q0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], v0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], w0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], a0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], dw0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], qf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], vf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], wf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], af : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], dwf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], duration : float , dt : float ) -> pyastrobee . trajectories . trajectory . Trajectory Generate a polynomial trajectory between two poses, with velocity boundary conditions on either end Parameters: Name Type Description Default p0 npt.ArrayLike Initial position, shape (3,) None q0 npt.ArrayLike Initial XYZW quaternion, shape (4,) None v0 npt.ArrayLike Initial linear velocity, shape (3,) None w0 npt.ArrayLike Initial angular velocity, shape (3,) None a0 npt.ArrayLike Initial linear acceleration, shape (3,) None dw0 npt.ArrayLike Initial angular acceleration, shape (3,) None pf npt.ArrayLike Final position, shape (3,) None qf npt.ArrayLike Final XYZW quaternion, shape (4,) None vf npt.ArrayLike Final linear velocity, shape (3,) None wf npt.ArrayLike Final angular velocity, shape (3,) None af npt.ArrayLike Final linear acceleration, shape (3,) None dwf npt.ArrayLike Final angular acceleration, shape (3,) None duration float Trajectory duration (seconds) None dt float Sampling period (seconds) None Returns: Type Description Trajectory Trajectory with position, orientation, lin/ang velocity, lin/ang acceleration, and time info View Source def fifth_order_polynomial_traj_with_velocity_bcs ( p0 : npt . ArrayLike , q0 : npt . ArrayLike , v0 : npt . ArrayLike , w0 : npt . ArrayLike , a0 : npt . ArrayLike , dw0 : npt . ArrayLike , pf : npt . ArrayLike , qf : npt . ArrayLike , vf : npt . ArrayLike , wf : npt . ArrayLike , af : npt . ArrayLike , dwf : npt . ArrayLike , duration : float , dt : float , ) -> Trajectory : \"\"\"Generate a polynomial trajectory between two poses, with velocity boundary conditions on either end Args: p0 (npt.ArrayLike): Initial position, shape (3,) q0 (npt.ArrayLike): Initial XYZW quaternion, shape (4,) v0 (npt.ArrayLike): Initial linear velocity, shape (3,) w0 (npt.ArrayLike): Initial angular velocity, shape (3,) a0 (npt.ArrayLike): Initial linear acceleration, shape (3,) dw0 (npt.ArrayLike): Initial angular acceleration, shape (3,) pf (npt.ArrayLike): Final position, shape (3,) qf (npt.ArrayLike): Final XYZW quaternion, shape (4,) vf (npt.ArrayLike): Final linear velocity, shape (3,) wf (npt.ArrayLike): Final angular velocity, shape (3,) af (npt.ArrayLike): Final linear acceleration, shape (3,) dwf (npt.ArrayLike): Final angular acceleration, shape (3,) duration (float): Trajectory duration (seconds) dt (float): Sampling period (seconds) Returns: Trajectory: Trajectory with position, orientation, lin/ang velocity, lin/ang acceleration, and time info \"\"\" times = np . arange ( 0 , duration + dt , dt ) n = len ( times ) x0 , y0 , z0 = p0 xf , yf , zf = pf t0 = times [ 0 ] tf = times [ - 1 ] vx0 , vy0 , vz0 = v0 vxf , vyf , vzf = vf ax0 , ay0 , az0 = a0 axf , ayf , azf = af f_x = fifth_order_poly ( t0 , tf , x0 , xf , vx0 , vxf , ax0 , axf ) f_y = fifth_order_poly ( t0 , tf , y0 , yf , vy0 , vyf , ay0 , ayf ) f_z = fifth_order_poly ( t0 , tf , z0 , zf , vz0 , vzf , az0 , azf ) f_vx : Polynomial = f_x . deriv () f_vy : Polynomial = f_y . deriv () f_vz : Polynomial = f_z . deriv () f_ax : Polynomial = f_vx . deriv () f_ay : Polynomial = f_vy . deriv () f_az : Polynomial = f_vz . deriv () q = quaternion_interpolation_with_bcs ( q0 , qf , w0 , wf , dw0 , dwf , duration , n ) omega = quats_to_angular_velocities ( q , dt ) alpha = np . gradient ( omega , dt , axis = 0 ) return Trajectory ( positions = np . column_stack ([ f_x ( times ), f_y ( times ), f_z ( times )]), quats = q , lin_vels = np . column_stack ([ f_vx ( times ), f_vy ( times ), f_vz ( times )]), ang_vels = omega , lin_accels = np . column_stack ([ f_ax ( times ), f_ay ( times ), f_az ( times )]), ang_accels = alpha , times = times , ) polynomial_slerp def polynomial_slerp ( q1 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], q2 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], n : int ) -> numpy . ndarray SLERP based on a third-order polynomial discretization This will interpolate quaternions based on a polynomial spacing rather than a linear spacing. The resulting angular velocity vector has a constant direction, but will be quadratic, starting and ending at 0 Parameters: Name Type Description Default q1 npt.ArrayLike Starting XYZW quaternion, shape (4,) None q2 npt.ArrayLike Ending XYZW quaternion, shape (4,) None n int Number of points at which to evaluate the polynomial-based SLERP None Returns: Type Description np.ndarray The interpolated XYZW quaternions, shape = (n, 4) View Source def polynomial_slerp ( q1 : npt . ArrayLike , q2 : npt . ArrayLike , n : int ) -> np . ndarray : \"\"\"SLERP based on a third-order polynomial discretization This will interpolate quaternions based on a polynomial spacing rather than a linear spacing. The resulting angular velocity vector has a constant direction, but will be quadratic, starting and ending at 0 Args: q1 (npt.ArrayLike): Starting XYZW quaternion, shape (4,) q2 (npt.ArrayLike): Ending XYZW quaternion, shape (4,) n (int): Number of points at which to evaluate the polynomial-based SLERP Returns: np.ndarray: The interpolated XYZW quaternions, shape = (n, 4) \"\"\" # Generate our evaluation points for SLERP so that: # - We evaluate over a domain of [0, 1] with n steps # - We want to start at 0 and end at 1 with 0 derivative at either end pcts = third_order_poly ( 0 , 1 , 0 , 1 , 0 , 0 )( np . linspace ( 0 , 1 , n , endpoint = True )) return quaternion_slerp ( q1 , q2 , pcts ) polynomial_traj_with_velocity_bcs def polynomial_traj_with_velocity_bcs ( p0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], q0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], v0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], w0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], qf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], vf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], wf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], duration : float , dt : float ) -> pyastrobee . trajectories . trajectory . Trajectory Generate a polynomial trajectory between two poses, with velocity boundary conditions on either end Parameters: Name Type Description Default p0 npt.ArrayLike Initial position, shape (3,) None q0 npt.ArrayLike Initial XYZW quaternion, shape (4,) None v0 npt.ArrayLike Initial linear velocity, shape (3,) None w0 npt.ArrayLike Initial angular velocity, shape (3,) None pf npt.ArrayLike Final position, shape (3,) None qf npt.ArrayLike Final XYZW quaternion, shape (4,) None vf npt.ArrayLike Final linear velocity, shape (3,) None wf npt.ArrayLike Final angular velocity, shape (3,) None duration float Trajectory duration (seconds) None dt float Sampling period (seconds) None Returns: Type Description Trajectory Trajectory with position, orientation, lin/ang velocity, lin/ang acceleration, and time info View Source def polynomial_traj_with_velocity_bcs ( p0 : npt . ArrayLike , q0 : npt . ArrayLike , v0 : npt . ArrayLike , w0 : npt . ArrayLike , pf : npt . ArrayLike , qf : npt . ArrayLike , vf : npt . ArrayLike , wf : npt . ArrayLike , duration : float , dt : float , ) -> Trajectory : \"\"\"Generate a polynomial trajectory between two poses, with velocity boundary conditions on either end Args: p0 (npt.ArrayLike): Initial position, shape (3,) q0 (npt.ArrayLike): Initial XYZW quaternion, shape (4,) v0 (npt.ArrayLike): Initial linear velocity, shape (3,) w0 (npt.ArrayLike): Initial angular velocity, shape (3,) pf (npt.ArrayLike): Final position, shape (3,) qf (npt.ArrayLike): Final XYZW quaternion, shape (4,) vf (npt.ArrayLike): Final linear velocity, shape (3,) wf (npt.ArrayLike): Final angular velocity, shape (3,) duration (float): Trajectory duration (seconds) dt (float): Sampling period (seconds) Returns: Trajectory: Trajectory with position, orientation, lin/ang velocity, lin/ang acceleration, and time info \"\"\" times = np . arange ( 0 , duration + dt , dt ) n = len ( times ) x0 , y0 , z0 = p0 xf , yf , zf = pf t0 = times [ 0 ] tf = times [ - 1 ] vx0 , vy0 , vz0 = v0 vxf , vyf , vzf = vf f_x = third_order_poly ( t0 , tf , x0 , xf , vx0 , vxf ) f_y = third_order_poly ( t0 , tf , y0 , yf , vy0 , vyf ) f_z = third_order_poly ( t0 , tf , z0 , zf , vz0 , vzf ) f_vx : Polynomial = f_x . deriv () f_vy : Polynomial = f_y . deriv () f_vz : Polynomial = f_z . deriv () f_ax : Polynomial = f_vx . deriv () f_ay : Polynomial = f_vy . deriv () f_az : Polynomial = f_vz . deriv () # TODO make these an input. It's a bit weird that we don't have the acceleration constraint though # since we're using the third-order poly on the position traj... Figure this out dw0 = np . zeros ( 3 ) dwf = np . zeros ( 3 ) q = quaternion_interpolation_with_bcs ( q0 , qf , w0 , wf , dw0 , dwf , duration , n ) omega = quats_to_angular_velocities ( q , dt ) alpha = np . gradient ( omega , dt , axis = 0 ) return Trajectory ( positions = np . column_stack ([ f_x ( times ), f_y ( times ), f_z ( times )]), quats = q , lin_vels = np . column_stack ([ f_vx ( times ), f_vy ( times ), f_vz ( times )]), ang_vels = omega , lin_accels = np . column_stack ([ f_ax ( times ), f_ay ( times ), f_az ( times )]), ang_accels = alpha , times = times , ) polynomial_trajectory def polynomial_trajectory ( pose_1 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pose_2 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], duration : float , dt : float ) -> pyastrobee . trajectories . trajectory . Trajectory Generate a third-order polynomial trajectory between two poses Parameters: Name Type Description Default pose_1 npt.ArrayLike Starting position + XYZW quaternion pose, shape (7,) None pose_2 npt.ArrayLike Ending position + XYZW quaternion pose, shape (7,) None duration float Trajectory duration (seconds) None dt float Sampling period (seconds) None Returns: Type Description Trajectory Trajectory with position, orientation, lin/ang velocity, lin/ang acceleration, and time info View Source def polynomial_trajectory ( pose_1 : npt . ArrayLike , pose_2 : npt . ArrayLike , duration : float , dt : float ) -> Trajectory : \"\"\"Generate a third-order polynomial trajectory between two poses Args: pose_1 (npt.ArrayLike): Starting position + XYZW quaternion pose, shape (7,) pose_2 (npt.ArrayLike): Ending position + XYZW quaternion pose, shape (7,) duration (float): Trajectory duration (seconds) dt (float): Sampling period (seconds) Returns: Trajectory: Trajectory with position, orientation, lin/ang velocity, lin/ang acceleration, and time info \"\"\" times = np . arange ( 0 , duration + dt , dt ) n = len ( times ) x0 , y0 , z0 = pose_1 [ : 3 ] q0 = pose_1 [ 3 : ] xf , yf , zf = pose_2 [ : 3 ] qf = pose_2 [ 3 : ] t0 = times [ 0 ] tf = times [ - 1 ] v0 = 0 vf = 0 f_x = third_order_poly ( t0 , tf , x0 , xf , v0 , vf ) f_y = third_order_poly ( t0 , tf , y0 , yf , v0 , vf ) f_z = third_order_poly ( t0 , tf , z0 , zf , v0 , vf ) f_vx : Polynomial = f_x . deriv () f_vy : Polynomial = f_y . deriv () f_vz : Polynomial = f_z . deriv () f_ax : Polynomial = f_vx . deriv () f_ay : Polynomial = f_vy . deriv () f_az : Polynomial = f_vz . deriv () q = polynomial_slerp ( q0 , qf , n ) omega = quats_to_angular_velocities ( q , dt ) alpha = np . gradient ( omega , dt , axis = 0 ) return Trajectory ( positions = np . column_stack ([ f_x ( times ), f_y ( times ), f_z ( times )]), quats = q , lin_vels = np . column_stack ([ f_vx ( times ), f_vy ( times ), f_vz ( times )]), ang_vels = omega , lin_accels = np . column_stack ([ f_ax ( times ), f_ay ( times ), f_az ( times )]), ang_accels = alpha , times = times , ) third_order_poly def third_order_poly ( t0 : float , tf : float , x0 : float , xf : float , v0 : float , vf : float ) -> numpy . polynomial . polynomial . Polynomial Generate a third-order polynomial over a time domain based on boundary conditions We will refer to the variables in terms of position and velocity, but in general, this can be applied to any variable and its derivative Parameters: Name Type Description Default t0 float Start time None tf float End time None x0 float Initial position None xf float Final position None v0 float Initial velocity None vf float Final velocity None Returns: Type Description Polynomial The polynomial which satisfies the boundary conditions. Evaluate the polynomial by calling it with the evaluation times. e.g. xs = solved_polynomial(times) View Source def third_order_poly ( t0 : float , tf : float , x0 : float , xf : float , v0 : float , vf : float , ) -> Polynomial : \"\"\"Generate a third-order polynomial over a time domain based on boundary conditions We will refer to the variables in terms of position and velocity, but in general, this can be applied to any variable and its derivative Args: t0 (float): Start time tf (float): End time x0 (float): Initial position xf (float): Final position v0 (float): Initial velocity vf (float): Final velocity Returns: Polynomial: The polynomial which satisfies the boundary conditions. Evaluate the polynomial by calling it with the evaluation times. e.g. xs = solved_polynomial(times) \"\"\" # Form linear system of equations: we have four polynomial coefficients for a third-order poly # and have four constraints on the endpoints (initial/final position/velocity) A = np . array ( [ [ 1 , t0 , t0 ** 2 , t0 ** 3 ], [ 1 , tf , tf ** 2 , tf ** 3 ], [ 0 , 1 , 2 * t0 , 3 * t0 ** 2 ], [ 0 , 1 , 2 * tf , 3 * tf ** 2 ], ] ) b = np . array ([ x0 , xf , v0 , vf ]) coeffs = np . linalg . solve ( A , b ) return Polynomial ( coeffs )","title":"Polynomials"},{"location":"reference/pyastrobee/trajectories/polynomials/#module-pyastrobeetrajectoriespolynomials","text":"Generating trajectories via polynomials Assorted ideas - Add a \"glide\" section to the trajectory? e.g. reach the max velocity and then glide until we need to decelerate - Enforce actuator limits - make sure that the trajectory doesn't exceed the max velocity values. If so, increase the duration View Source \"\"\"Generating trajectories via polynomials Assorted ideas - Add a \"glide\" section to the trajectory? e.g. reach the max velocity and then glide until we need to decelerate - Enforce actuator limits - make sure that the trajectory doesn't exceed the max velocity values. If so, increase the duration \"\"\" import numpy as np import numpy.typing as npt from numpy.polynomial.polynomial import Polynomial from pyastrobee.trajectories.trajectory import Trajectory from pyastrobee.utils.quaternions import ( random_quaternion , quaternion_slerp , quats_to_angular_velocities , ) from pyastrobee.trajectories.quaternion_interpolation import ( quaternion_interpolation_with_bcs , ) def polynomial_slerp ( q1 : npt . ArrayLike , q2 : npt . ArrayLike , n : int ) -> np . ndarray : \"\"\"SLERP based on a third-order polynomial discretization This will interpolate quaternions based on a polynomial spacing rather than a linear spacing. The resulting angular velocity vector has a constant direction, but will be quadratic, starting and ending at 0 Args: q1 (npt.ArrayLike): Starting XYZW quaternion, shape (4,) q2 (npt.ArrayLike): Ending XYZW quaternion, shape (4,) n (int): Number of points at which to evaluate the polynomial-based SLERP Returns: np.ndarray: The interpolated XYZW quaternions, shape = (n, 4) \"\"\" # Generate our evaluation points for SLERP so that: # - We evaluate over a domain of [0, 1] with n steps # - We want to start at 0 and end at 1 with 0 derivative at either end pcts = third_order_poly ( 0 , 1 , 0 , 1 , 0 , 0 )( np . linspace ( 0 , 1 , n , endpoint = True )) return quaternion_slerp ( q1 , q2 , pcts ) def third_order_poly ( t0 : float , tf : float , x0 : float , xf : float , v0 : float , vf : float , ) -> Polynomial : \"\"\"Generate a third-order polynomial over a time domain based on boundary conditions We will refer to the variables in terms of position and velocity, but in general, this can be applied to any variable and its derivative Args: t0 (float): Start time tf (float): End time x0 (float): Initial position xf (float): Final position v0 (float): Initial velocity vf (float): Final velocity Returns: Polynomial: The polynomial which satisfies the boundary conditions. Evaluate the polynomial by calling it with the evaluation times. e.g. xs = solved_polynomial(times) \"\"\" # Form linear system of equations: we have four polynomial coefficients for a third-order poly # and have four constraints on the endpoints (initial/final position/velocity) A = np . array ( [ [ 1 , t0 , t0 ** 2 , t0 ** 3 ], [ 1 , tf , tf ** 2 , tf ** 3 ], [ 0 , 1 , 2 * t0 , 3 * t0 ** 2 ], [ 0 , 1 , 2 * tf , 3 * tf ** 2 ], ] ) b = np . array ([ x0 , xf , v0 , vf ]) coeffs = np . linalg . solve ( A , b ) return Polynomial ( coeffs ) def fifth_order_poly ( t0 : float , tf : float , x0 : float , xf : float , v0 : float , vf : float , a0 : float , af : float , ) -> Polynomial : \"\"\"Generate a fifth-order polynomial over a time domain based on boundary conditions We will refer to the variables in terms of position and velocity, but in general, this can be applied to any variable and its derivative Args: t0 (float): Start time tf (float): End time x0 (float): Initial position xf (float): Final position v0 (float): Initial velocity vf (float): Final velocity a0 (float): Initial acceleration af (float): Final acceleration Returns: Polynomial: The polynomial which satisfies the boundary conditions. Evaluate the polynomial by calling it with the evaluation times. e.g. xs = solved_polynomial(times) \"\"\" # Form linear system of equations: we have six polynomial coefficients for a fifth-order poly # and have six constraints on the endpoints (initial/final position/velocity/acceleration) A = np . array ( [ [ 1 , t0 , t0 ** 2 , t0 ** 3 , t0 ** 4 , t0 ** 5 ], [ 1 , tf , tf ** 2 , tf ** 3 , tf ** 4 , tf ** 5 ], [ 0 , 1 , 2 * t0 , 3 * t0 ** 2 , 4 * t0 ** 3 , 5 * t0 ** 4 ], [ 0 , 1 , 2 * tf , 3 * tf ** 2 , 4 * tf ** 3 , 5 * tf ** 4 ], [ 0 , 0 , 2 , 6 * t0 , 12 * t0 ** 2 , 20 * t0 ** 3 ], [ 0 , 0 , 2 , 6 * tf , 12 * tf ** 2 , 20 * tf ** 3 ], ] ) b = np . array ([ x0 , xf , v0 , vf , a0 , af ]) coeffs = np . linalg . solve ( A , b ) return Polynomial ( coeffs ) def polynomial_trajectory ( pose_1 : npt . ArrayLike , pose_2 : npt . ArrayLike , duration : float , dt : float ) -> Trajectory : \"\"\"Generate a third-order polynomial trajectory between two poses Args: pose_1 (npt.ArrayLike): Starting position + XYZW quaternion pose, shape (7,) pose_2 (npt.ArrayLike): Ending position + XYZW quaternion pose, shape (7,) duration (float): Trajectory duration (seconds) dt (float): Sampling period (seconds) Returns: Trajectory: Trajectory with position, orientation, lin/ang velocity, lin/ang acceleration, and time info \"\"\" times = np . arange ( 0 , duration + dt , dt ) n = len ( times ) x0 , y0 , z0 = pose_1 [: 3 ] q0 = pose_1 [ 3 :] xf , yf , zf = pose_2 [: 3 ] qf = pose_2 [ 3 :] t0 = times [ 0 ] tf = times [ - 1 ] v0 = 0 vf = 0 f_x = third_order_poly ( t0 , tf , x0 , xf , v0 , vf ) f_y = third_order_poly ( t0 , tf , y0 , yf , v0 , vf ) f_z = third_order_poly ( t0 , tf , z0 , zf , v0 , vf ) f_vx : Polynomial = f_x . deriv () f_vy : Polynomial = f_y . deriv () f_vz : Polynomial = f_z . deriv () f_ax : Polynomial = f_vx . deriv () f_ay : Polynomial = f_vy . deriv () f_az : Polynomial = f_vz . deriv () q = polynomial_slerp ( q0 , qf , n ) omega = quats_to_angular_velocities ( q , dt ) alpha = np . gradient ( omega , dt , axis = 0 ) return Trajectory ( positions = np . column_stack ([ f_x ( times ), f_y ( times ), f_z ( times )]), quats = q , lin_vels = np . column_stack ([ f_vx ( times ), f_vy ( times ), f_vz ( times )]), ang_vels = omega , lin_accels = np . column_stack ([ f_ax ( times ), f_ay ( times ), f_az ( times )]), ang_accels = alpha , times = times , ) def polynomial_traj_with_velocity_bcs ( p0 : npt . ArrayLike , q0 : npt . ArrayLike , v0 : npt . ArrayLike , w0 : npt . ArrayLike , pf : npt . ArrayLike , qf : npt . ArrayLike , vf : npt . ArrayLike , wf : npt . ArrayLike , duration : float , dt : float , ) -> Trajectory : \"\"\"Generate a polynomial trajectory between two poses, with velocity boundary conditions on either end Args: p0 (npt.ArrayLike): Initial position, shape (3,) q0 (npt.ArrayLike): Initial XYZW quaternion, shape (4,) v0 (npt.ArrayLike): Initial linear velocity, shape (3,) w0 (npt.ArrayLike): Initial angular velocity, shape (3,) pf (npt.ArrayLike): Final position, shape (3,) qf (npt.ArrayLike): Final XYZW quaternion, shape (4,) vf (npt.ArrayLike): Final linear velocity, shape (3,) wf (npt.ArrayLike): Final angular velocity, shape (3,) duration (float): Trajectory duration (seconds) dt (float): Sampling period (seconds) Returns: Trajectory: Trajectory with position, orientation, lin/ang velocity, lin/ang acceleration, and time info \"\"\" times = np . arange ( 0 , duration + dt , dt ) n = len ( times ) x0 , y0 , z0 = p0 xf , yf , zf = pf t0 = times [ 0 ] tf = times [ - 1 ] vx0 , vy0 , vz0 = v0 vxf , vyf , vzf = vf f_x = third_order_poly ( t0 , tf , x0 , xf , vx0 , vxf ) f_y = third_order_poly ( t0 , tf , y0 , yf , vy0 , vyf ) f_z = third_order_poly ( t0 , tf , z0 , zf , vz0 , vzf ) f_vx : Polynomial = f_x . deriv () f_vy : Polynomial = f_y . deriv () f_vz : Polynomial = f_z . deriv () f_ax : Polynomial = f_vx . deriv () f_ay : Polynomial = f_vy . deriv () f_az : Polynomial = f_vz . deriv () # TODO make these an input. It's a bit weird that we don't have the acceleration constraint though # since we're using the third-order poly on the position traj... Figure this out dw0 = np . zeros ( 3 ) dwf = np . zeros ( 3 ) q = quaternion_interpolation_with_bcs ( q0 , qf , w0 , wf , dw0 , dwf , duration , n ) omega = quats_to_angular_velocities ( q , dt ) alpha = np . gradient ( omega , dt , axis = 0 ) return Trajectory ( positions = np . column_stack ([ f_x ( times ), f_y ( times ), f_z ( times )]), quats = q , lin_vels = np . column_stack ([ f_vx ( times ), f_vy ( times ), f_vz ( times )]), ang_vels = omega , lin_accels = np . column_stack ([ f_ax ( times ), f_ay ( times ), f_az ( times )]), ang_accels = alpha , times = times , ) def fifth_order_polynomial_traj_with_velocity_bcs ( p0 : npt . ArrayLike , q0 : npt . ArrayLike , v0 : npt . ArrayLike , w0 : npt . ArrayLike , a0 : npt . ArrayLike , dw0 : npt . ArrayLike , pf : npt . ArrayLike , qf : npt . ArrayLike , vf : npt . ArrayLike , wf : npt . ArrayLike , af : npt . ArrayLike , dwf : npt . ArrayLike , duration : float , dt : float , ) -> Trajectory : \"\"\"Generate a polynomial trajectory between two poses, with velocity boundary conditions on either end Args: p0 (npt.ArrayLike): Initial position, shape (3,) q0 (npt.ArrayLike): Initial XYZW quaternion, shape (4,) v0 (npt.ArrayLike): Initial linear velocity, shape (3,) w0 (npt.ArrayLike): Initial angular velocity, shape (3,) a0 (npt.ArrayLike): Initial linear acceleration, shape (3,) dw0 (npt.ArrayLike): Initial angular acceleration, shape (3,) pf (npt.ArrayLike): Final position, shape (3,) qf (npt.ArrayLike): Final XYZW quaternion, shape (4,) vf (npt.ArrayLike): Final linear velocity, shape (3,) wf (npt.ArrayLike): Final angular velocity, shape (3,) af (npt.ArrayLike): Final linear acceleration, shape (3,) dwf (npt.ArrayLike): Final angular acceleration, shape (3,) duration (float): Trajectory duration (seconds) dt (float): Sampling period (seconds) Returns: Trajectory: Trajectory with position, orientation, lin/ang velocity, lin/ang acceleration, and time info \"\"\" times = np . arange ( 0 , duration + dt , dt ) n = len ( times ) x0 , y0 , z0 = p0 xf , yf , zf = pf t0 = times [ 0 ] tf = times [ - 1 ] vx0 , vy0 , vz0 = v0 vxf , vyf , vzf = vf ax0 , ay0 , az0 = a0 axf , ayf , azf = af f_x = fifth_order_poly ( t0 , tf , x0 , xf , vx0 , vxf , ax0 , axf ) f_y = fifth_order_poly ( t0 , tf , y0 , yf , vy0 , vyf , ay0 , ayf ) f_z = fifth_order_poly ( t0 , tf , z0 , zf , vz0 , vzf , az0 , azf ) f_vx : Polynomial = f_x . deriv () f_vy : Polynomial = f_y . deriv () f_vz : Polynomial = f_z . deriv () f_ax : Polynomial = f_vx . deriv () f_ay : Polynomial = f_vy . deriv () f_az : Polynomial = f_vz . deriv () q = quaternion_interpolation_with_bcs ( q0 , qf , w0 , wf , dw0 , dwf , duration , n ) omega = quats_to_angular_velocities ( q , dt ) alpha = np . gradient ( omega , dt , axis = 0 ) return Trajectory ( positions = np . column_stack ([ f_x ( times ), f_y ( times ), f_z ( times )]), quats = q , lin_vels = np . column_stack ([ f_vx ( times ), f_vy ( times ), f_vz ( times )]), ang_vels = omega , lin_accels = np . column_stack ([ f_ax ( times ), f_ay ( times ), f_az ( times )]), ang_accels = alpha , times = times , ) def _main (): # TODO add the astrobee following the trajectory?? # Update these values depending on what examples you want to run RUN_NO_BC_EXAMPLE = True RUN_BC_EXAMPLE = True # Example with no boundary conditions if RUN_NO_BC_EXAMPLE : np . random . seed ( 0 ) pose1 = np . array ([ 0 , 0 , 0 , 0 , 0 , 0 , 1 ]) pose2 = np . array ([ 1 , 1 , 1 , * random_quaternion ()]) traj = polynomial_trajectory ( pose1 , pose2 , 5 , 0.1 ) print ( \"Plotting trajectory information\" ) traj . plot () input ( \"Press Enter to visualize the trajectory in pybullet, when ready\" ) traj . visualize () # Example with boundary conditions on the initial/final velocities if RUN_BC_EXAMPLE : p0 = np . array ([ 1 , 2 , 3 ]) q0 = np . array ([ 1 , 2 , 3 , 4 ]) / np . linalg . norm ([ 1 , 2 , 3 , 4 ]) v0 = np . array ([ 1 , 2 , 3 ]) w0 = np . array ([ 0.1 , 0.2 , 0.3 ]) pf = np . array ([ 2 , 3 , 4 ]) qf = np . array ([ 2 , 3 , 4 , 5 ]) / np . linalg . norm ([ 2 , 3 , 4 , 5 ]) vf = np . array ([ 2 , 3 , 4 ]) wf = np . array ([ 0.2 , 0.3 , 0.4 ]) duration = 10 dt = 0.1 # Arbitrary traj = polynomial_traj_with_velocity_bcs ( p0 , q0 , v0 , w0 , pf , qf , vf , wf , duration , dt ) traj . plot () traj . visualize () if __name__ == \"__main__\" : _main ()","title":"Module pyastrobee.trajectories.polynomials"},{"location":"reference/pyastrobee/trajectories/polynomials/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/trajectories/polynomials/#fifth_order_poly","text":"def fifth_order_poly ( t0 : float , tf : float , x0 : float , xf : float , v0 : float , vf : float , a0 : float , af : float ) -> numpy . polynomial . polynomial . Polynomial Generate a fifth-order polynomial over a time domain based on boundary conditions We will refer to the variables in terms of position and velocity, but in general, this can be applied to any variable and its derivative Parameters: Name Type Description Default t0 float Start time None tf float End time None x0 float Initial position None xf float Final position None v0 float Initial velocity None vf float Final velocity None a0 float Initial acceleration None af float Final acceleration None Returns: Type Description Polynomial The polynomial which satisfies the boundary conditions. Evaluate the polynomial by calling it with the evaluation times. e.g. xs = solved_polynomial(times) View Source def fifth_order_poly ( t0 : float , tf : float , x0 : float , xf : float , v0 : float , vf : float , a0 : float , af : float , ) -> Polynomial : \"\"\"Generate a fifth-order polynomial over a time domain based on boundary conditions We will refer to the variables in terms of position and velocity, but in general, this can be applied to any variable and its derivative Args: t0 (float): Start time tf (float): End time x0 (float): Initial position xf (float): Final position v0 (float): Initial velocity vf (float): Final velocity a0 (float): Initial acceleration af (float): Final acceleration Returns: Polynomial: The polynomial which satisfies the boundary conditions. Evaluate the polynomial by calling it with the evaluation times. e.g. xs = solved_polynomial(times) \"\"\" # Form linear system of equations: we have six polynomial coefficients for a fifth-order poly # and have six constraints on the endpoints (initial/final position/velocity/acceleration) A = np . array ( [ [ 1 , t0 , t0 ** 2 , t0 ** 3 , t0 ** 4 , t0 ** 5 ], [ 1 , tf , tf ** 2 , tf ** 3 , tf ** 4 , tf ** 5 ], [ 0 , 1 , 2 * t0 , 3 * t0 ** 2 , 4 * t0 ** 3 , 5 * t0 ** 4 ], [ 0 , 1 , 2 * tf , 3 * tf ** 2 , 4 * tf ** 3 , 5 * tf ** 4 ], [ 0 , 0 , 2 , 6 * t0 , 12 * t0 ** 2 , 20 * t0 ** 3 ], [ 0 , 0 , 2 , 6 * tf , 12 * tf ** 2 , 20 * tf ** 3 ], ] ) b = np . array ([ x0 , xf , v0 , vf , a0 , af ]) coeffs = np . linalg . solve ( A , b ) return Polynomial ( coeffs )","title":"fifth_order_poly"},{"location":"reference/pyastrobee/trajectories/polynomials/#fifth_order_polynomial_traj_with_velocity_bcs","text":"def fifth_order_polynomial_traj_with_velocity_bcs ( p0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], q0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], v0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], w0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], a0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], dw0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], qf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], vf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], wf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], af : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], dwf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], duration : float , dt : float ) -> pyastrobee . trajectories . trajectory . Trajectory Generate a polynomial trajectory between two poses, with velocity boundary conditions on either end Parameters: Name Type Description Default p0 npt.ArrayLike Initial position, shape (3,) None q0 npt.ArrayLike Initial XYZW quaternion, shape (4,) None v0 npt.ArrayLike Initial linear velocity, shape (3,) None w0 npt.ArrayLike Initial angular velocity, shape (3,) None a0 npt.ArrayLike Initial linear acceleration, shape (3,) None dw0 npt.ArrayLike Initial angular acceleration, shape (3,) None pf npt.ArrayLike Final position, shape (3,) None qf npt.ArrayLike Final XYZW quaternion, shape (4,) None vf npt.ArrayLike Final linear velocity, shape (3,) None wf npt.ArrayLike Final angular velocity, shape (3,) None af npt.ArrayLike Final linear acceleration, shape (3,) None dwf npt.ArrayLike Final angular acceleration, shape (3,) None duration float Trajectory duration (seconds) None dt float Sampling period (seconds) None Returns: Type Description Trajectory Trajectory with position, orientation, lin/ang velocity, lin/ang acceleration, and time info View Source def fifth_order_polynomial_traj_with_velocity_bcs ( p0 : npt . ArrayLike , q0 : npt . ArrayLike , v0 : npt . ArrayLike , w0 : npt . ArrayLike , a0 : npt . ArrayLike , dw0 : npt . ArrayLike , pf : npt . ArrayLike , qf : npt . ArrayLike , vf : npt . ArrayLike , wf : npt . ArrayLike , af : npt . ArrayLike , dwf : npt . ArrayLike , duration : float , dt : float , ) -> Trajectory : \"\"\"Generate a polynomial trajectory between two poses, with velocity boundary conditions on either end Args: p0 (npt.ArrayLike): Initial position, shape (3,) q0 (npt.ArrayLike): Initial XYZW quaternion, shape (4,) v0 (npt.ArrayLike): Initial linear velocity, shape (3,) w0 (npt.ArrayLike): Initial angular velocity, shape (3,) a0 (npt.ArrayLike): Initial linear acceleration, shape (3,) dw0 (npt.ArrayLike): Initial angular acceleration, shape (3,) pf (npt.ArrayLike): Final position, shape (3,) qf (npt.ArrayLike): Final XYZW quaternion, shape (4,) vf (npt.ArrayLike): Final linear velocity, shape (3,) wf (npt.ArrayLike): Final angular velocity, shape (3,) af (npt.ArrayLike): Final linear acceleration, shape (3,) dwf (npt.ArrayLike): Final angular acceleration, shape (3,) duration (float): Trajectory duration (seconds) dt (float): Sampling period (seconds) Returns: Trajectory: Trajectory with position, orientation, lin/ang velocity, lin/ang acceleration, and time info \"\"\" times = np . arange ( 0 , duration + dt , dt ) n = len ( times ) x0 , y0 , z0 = p0 xf , yf , zf = pf t0 = times [ 0 ] tf = times [ - 1 ] vx0 , vy0 , vz0 = v0 vxf , vyf , vzf = vf ax0 , ay0 , az0 = a0 axf , ayf , azf = af f_x = fifth_order_poly ( t0 , tf , x0 , xf , vx0 , vxf , ax0 , axf ) f_y = fifth_order_poly ( t0 , tf , y0 , yf , vy0 , vyf , ay0 , ayf ) f_z = fifth_order_poly ( t0 , tf , z0 , zf , vz0 , vzf , az0 , azf ) f_vx : Polynomial = f_x . deriv () f_vy : Polynomial = f_y . deriv () f_vz : Polynomial = f_z . deriv () f_ax : Polynomial = f_vx . deriv () f_ay : Polynomial = f_vy . deriv () f_az : Polynomial = f_vz . deriv () q = quaternion_interpolation_with_bcs ( q0 , qf , w0 , wf , dw0 , dwf , duration , n ) omega = quats_to_angular_velocities ( q , dt ) alpha = np . gradient ( omega , dt , axis = 0 ) return Trajectory ( positions = np . column_stack ([ f_x ( times ), f_y ( times ), f_z ( times )]), quats = q , lin_vels = np . column_stack ([ f_vx ( times ), f_vy ( times ), f_vz ( times )]), ang_vels = omega , lin_accels = np . column_stack ([ f_ax ( times ), f_ay ( times ), f_az ( times )]), ang_accels = alpha , times = times , )","title":"fifth_order_polynomial_traj_with_velocity_bcs"},{"location":"reference/pyastrobee/trajectories/polynomials/#polynomial_slerp","text":"def polynomial_slerp ( q1 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], q2 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], n : int ) -> numpy . ndarray SLERP based on a third-order polynomial discretization This will interpolate quaternions based on a polynomial spacing rather than a linear spacing. The resulting angular velocity vector has a constant direction, but will be quadratic, starting and ending at 0 Parameters: Name Type Description Default q1 npt.ArrayLike Starting XYZW quaternion, shape (4,) None q2 npt.ArrayLike Ending XYZW quaternion, shape (4,) None n int Number of points at which to evaluate the polynomial-based SLERP None Returns: Type Description np.ndarray The interpolated XYZW quaternions, shape = (n, 4) View Source def polynomial_slerp ( q1 : npt . ArrayLike , q2 : npt . ArrayLike , n : int ) -> np . ndarray : \"\"\"SLERP based on a third-order polynomial discretization This will interpolate quaternions based on a polynomial spacing rather than a linear spacing. The resulting angular velocity vector has a constant direction, but will be quadratic, starting and ending at 0 Args: q1 (npt.ArrayLike): Starting XYZW quaternion, shape (4,) q2 (npt.ArrayLike): Ending XYZW quaternion, shape (4,) n (int): Number of points at which to evaluate the polynomial-based SLERP Returns: np.ndarray: The interpolated XYZW quaternions, shape = (n, 4) \"\"\" # Generate our evaluation points for SLERP so that: # - We evaluate over a domain of [0, 1] with n steps # - We want to start at 0 and end at 1 with 0 derivative at either end pcts = third_order_poly ( 0 , 1 , 0 , 1 , 0 , 0 )( np . linspace ( 0 , 1 , n , endpoint = True )) return quaternion_slerp ( q1 , q2 , pcts )","title":"polynomial_slerp"},{"location":"reference/pyastrobee/trajectories/polynomials/#polynomial_traj_with_velocity_bcs","text":"def polynomial_traj_with_velocity_bcs ( p0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], q0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], v0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], w0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], qf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], vf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], wf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], duration : float , dt : float ) -> pyastrobee . trajectories . trajectory . Trajectory Generate a polynomial trajectory between two poses, with velocity boundary conditions on either end Parameters: Name Type Description Default p0 npt.ArrayLike Initial position, shape (3,) None q0 npt.ArrayLike Initial XYZW quaternion, shape (4,) None v0 npt.ArrayLike Initial linear velocity, shape (3,) None w0 npt.ArrayLike Initial angular velocity, shape (3,) None pf npt.ArrayLike Final position, shape (3,) None qf npt.ArrayLike Final XYZW quaternion, shape (4,) None vf npt.ArrayLike Final linear velocity, shape (3,) None wf npt.ArrayLike Final angular velocity, shape (3,) None duration float Trajectory duration (seconds) None dt float Sampling period (seconds) None Returns: Type Description Trajectory Trajectory with position, orientation, lin/ang velocity, lin/ang acceleration, and time info View Source def polynomial_traj_with_velocity_bcs ( p0 : npt . ArrayLike , q0 : npt . ArrayLike , v0 : npt . ArrayLike , w0 : npt . ArrayLike , pf : npt . ArrayLike , qf : npt . ArrayLike , vf : npt . ArrayLike , wf : npt . ArrayLike , duration : float , dt : float , ) -> Trajectory : \"\"\"Generate a polynomial trajectory between two poses, with velocity boundary conditions on either end Args: p0 (npt.ArrayLike): Initial position, shape (3,) q0 (npt.ArrayLike): Initial XYZW quaternion, shape (4,) v0 (npt.ArrayLike): Initial linear velocity, shape (3,) w0 (npt.ArrayLike): Initial angular velocity, shape (3,) pf (npt.ArrayLike): Final position, shape (3,) qf (npt.ArrayLike): Final XYZW quaternion, shape (4,) vf (npt.ArrayLike): Final linear velocity, shape (3,) wf (npt.ArrayLike): Final angular velocity, shape (3,) duration (float): Trajectory duration (seconds) dt (float): Sampling period (seconds) Returns: Trajectory: Trajectory with position, orientation, lin/ang velocity, lin/ang acceleration, and time info \"\"\" times = np . arange ( 0 , duration + dt , dt ) n = len ( times ) x0 , y0 , z0 = p0 xf , yf , zf = pf t0 = times [ 0 ] tf = times [ - 1 ] vx0 , vy0 , vz0 = v0 vxf , vyf , vzf = vf f_x = third_order_poly ( t0 , tf , x0 , xf , vx0 , vxf ) f_y = third_order_poly ( t0 , tf , y0 , yf , vy0 , vyf ) f_z = third_order_poly ( t0 , tf , z0 , zf , vz0 , vzf ) f_vx : Polynomial = f_x . deriv () f_vy : Polynomial = f_y . deriv () f_vz : Polynomial = f_z . deriv () f_ax : Polynomial = f_vx . deriv () f_ay : Polynomial = f_vy . deriv () f_az : Polynomial = f_vz . deriv () # TODO make these an input. It's a bit weird that we don't have the acceleration constraint though # since we're using the third-order poly on the position traj... Figure this out dw0 = np . zeros ( 3 ) dwf = np . zeros ( 3 ) q = quaternion_interpolation_with_bcs ( q0 , qf , w0 , wf , dw0 , dwf , duration , n ) omega = quats_to_angular_velocities ( q , dt ) alpha = np . gradient ( omega , dt , axis = 0 ) return Trajectory ( positions = np . column_stack ([ f_x ( times ), f_y ( times ), f_z ( times )]), quats = q , lin_vels = np . column_stack ([ f_vx ( times ), f_vy ( times ), f_vz ( times )]), ang_vels = omega , lin_accels = np . column_stack ([ f_ax ( times ), f_ay ( times ), f_az ( times )]), ang_accels = alpha , times = times , )","title":"polynomial_traj_with_velocity_bcs"},{"location":"reference/pyastrobee/trajectories/polynomials/#polynomial_trajectory","text":"def polynomial_trajectory ( pose_1 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pose_2 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], duration : float , dt : float ) -> pyastrobee . trajectories . trajectory . Trajectory Generate a third-order polynomial trajectory between two poses Parameters: Name Type Description Default pose_1 npt.ArrayLike Starting position + XYZW quaternion pose, shape (7,) None pose_2 npt.ArrayLike Ending position + XYZW quaternion pose, shape (7,) None duration float Trajectory duration (seconds) None dt float Sampling period (seconds) None Returns: Type Description Trajectory Trajectory with position, orientation, lin/ang velocity, lin/ang acceleration, and time info View Source def polynomial_trajectory ( pose_1 : npt . ArrayLike , pose_2 : npt . ArrayLike , duration : float , dt : float ) -> Trajectory : \"\"\"Generate a third-order polynomial trajectory between two poses Args: pose_1 (npt.ArrayLike): Starting position + XYZW quaternion pose, shape (7,) pose_2 (npt.ArrayLike): Ending position + XYZW quaternion pose, shape (7,) duration (float): Trajectory duration (seconds) dt (float): Sampling period (seconds) Returns: Trajectory: Trajectory with position, orientation, lin/ang velocity, lin/ang acceleration, and time info \"\"\" times = np . arange ( 0 , duration + dt , dt ) n = len ( times ) x0 , y0 , z0 = pose_1 [ : 3 ] q0 = pose_1 [ 3 : ] xf , yf , zf = pose_2 [ : 3 ] qf = pose_2 [ 3 : ] t0 = times [ 0 ] tf = times [ - 1 ] v0 = 0 vf = 0 f_x = third_order_poly ( t0 , tf , x0 , xf , v0 , vf ) f_y = third_order_poly ( t0 , tf , y0 , yf , v0 , vf ) f_z = third_order_poly ( t0 , tf , z0 , zf , v0 , vf ) f_vx : Polynomial = f_x . deriv () f_vy : Polynomial = f_y . deriv () f_vz : Polynomial = f_z . deriv () f_ax : Polynomial = f_vx . deriv () f_ay : Polynomial = f_vy . deriv () f_az : Polynomial = f_vz . deriv () q = polynomial_slerp ( q0 , qf , n ) omega = quats_to_angular_velocities ( q , dt ) alpha = np . gradient ( omega , dt , axis = 0 ) return Trajectory ( positions = np . column_stack ([ f_x ( times ), f_y ( times ), f_z ( times )]), quats = q , lin_vels = np . column_stack ([ f_vx ( times ), f_vy ( times ), f_vz ( times )]), ang_vels = omega , lin_accels = np . column_stack ([ f_ax ( times ), f_ay ( times ), f_az ( times )]), ang_accels = alpha , times = times , )","title":"polynomial_trajectory"},{"location":"reference/pyastrobee/trajectories/polynomials/#third_order_poly","text":"def third_order_poly ( t0 : float , tf : float , x0 : float , xf : float , v0 : float , vf : float ) -> numpy . polynomial . polynomial . Polynomial Generate a third-order polynomial over a time domain based on boundary conditions We will refer to the variables in terms of position and velocity, but in general, this can be applied to any variable and its derivative Parameters: Name Type Description Default t0 float Start time None tf float End time None x0 float Initial position None xf float Final position None v0 float Initial velocity None vf float Final velocity None Returns: Type Description Polynomial The polynomial which satisfies the boundary conditions. Evaluate the polynomial by calling it with the evaluation times. e.g. xs = solved_polynomial(times) View Source def third_order_poly ( t0 : float , tf : float , x0 : float , xf : float , v0 : float , vf : float , ) -> Polynomial : \"\"\"Generate a third-order polynomial over a time domain based on boundary conditions We will refer to the variables in terms of position and velocity, but in general, this can be applied to any variable and its derivative Args: t0 (float): Start time tf (float): End time x0 (float): Initial position xf (float): Final position v0 (float): Initial velocity vf (float): Final velocity Returns: Polynomial: The polynomial which satisfies the boundary conditions. Evaluate the polynomial by calling it with the evaluation times. e.g. xs = solved_polynomial(times) \"\"\" # Form linear system of equations: we have four polynomial coefficients for a third-order poly # and have four constraints on the endpoints (initial/final position/velocity) A = np . array ( [ [ 1 , t0 , t0 ** 2 , t0 ** 3 ], [ 1 , tf , tf ** 2 , tf ** 3 ], [ 0 , 1 , 2 * t0 , 3 * t0 ** 2 ], [ 0 , 1 , 2 * tf , 3 * tf ** 2 ], ] ) b = np . array ([ x0 , xf , v0 , vf ]) coeffs = np . linalg . solve ( A , b ) return Polynomial ( coeffs )","title":"third_order_poly"},{"location":"reference/pyastrobee/trajectories/quaternion_interpolation/","text":"Module pyastrobee.trajectories.quaternion_interpolation Determining an orientation trajectory between two quaternions with angular velocity boundary conditions This is different from SLERP because SLERP will find the shortest path along the unit 4D hypersphere (by traveling along a great circle), but this implies that we cannot dictate the direction of the angular velocity vector during this interpolation This method will instead create a 5th order polynomial to specify the boundary conditions on angular velocity (and technically angular acceleration as well, since we only need a 3rd order polynomial to specify BCs on the first derivatives). There is no guarantee that the quaternions will be normalized, but we can do that after the interpolation process. The interpolation does not result in significant deviations (< 5%) from unit-norm quaternions, so this should not significantly affect the orientation representation See \"Orientation Planning in Task Space using Quaternion Polynomials\" DOI: 10.1109/ROBIO.2017.8324769 for more info Note: this paper uses WXYZ quaternions View Source \"\"\"Determining an orientation trajectory between two quaternions with angular velocity boundary conditions This is different from SLERP because SLERP will find the shortest path along the unit 4D hypersphere (by traveling along a great circle), but this implies that we cannot dictate the direction of the angular velocity vector during this interpolation This method will instead create a 5th order polynomial to specify the boundary conditions on angular velocity (and technically angular acceleration as well, since we only need a 3rd order polynomial to specify BCs on the first derivatives). There is no guarantee that the quaternions will be normalized, but we can do that after the interpolation process. The interpolation does not result in significant deviations (< 5%) from unit-norm quaternions, so this should not significantly affect the orientation representation See \" Orientation Planning in Task Space using Quaternion Polynomials \" DOI: 10.1109/ROBIO.2017.8324769 for more info Note: this paper uses WXYZ quaternions \"\"\" import numpy as np import numpy . typing as npt from pyastrobee . utils . quaternions import ( quats_to_angular_velocities , wxyz_to_xyzw , xyzw_to_wxyz , ) def quaternion_interpolation_with_bcs ( qi : npt . ArrayLike , qf : npt . ArrayLike , wi : npt . ArrayLike , wf : npt . ArrayLike , dwi : npt . ArrayLike , dwf : npt . ArrayLike , duration : float , n : int , ) -> np . ndarray : \"\"\"Generate a sequence of quaternions between two orientations with angular velocity boundary conditions - This implementation is a slightly modified version of \" Orientation Planning in Task Space using Quaternion Polynomials \" DOI: 10.1109/ROBIO.2017.8324769, Algorithm 1 Args: qi (npt.ArrayLike): Initial XYZW quaternion, shape (4,) qf (npt.ArrayLike): Final XYZW quaternion, shape (4,) wi (npt.ArrayLike): Initial inertial-frame angular velocity, shape (3,) wf (npt.ArrayLike): Final inertial-frame angular velocity, shape (3,) dwi (npt.ArrayLike): Initial inertial-frame angular acceleration, shape (3,) dwf (npt.ArrayLike): Final inertial-frame angular acceleration, shape (3,) duration (float): Trajectory duration, seconds n (int): Number of timesteps Returns: np.ndarray: Sequence of XYZW quaternions, shape (n, 4) \"\"\" # NOTE The algorithm in the paper uses WXYZ quaternions , so we 'll need to convert back and forth qi = xyzw_to_wxyz(qi) qf = xyzw_to_wxyz(qf) wi = np.asarray(wi) wf = np.asarray(wf) dwi = np.asarray(dwi) dwf = np.asarray(dwf) # Ensure shortest path interpolation if _dot(qi, qf) < 0: qf = -qf # First and second derivatives of quaternion magnitude should be 0 # (in theory quaternion norms should always be fixed at 1, but this interpolation # does not necessarily guarantee this. But, it generally stays within 5% of norm 1) dNi, ddNi, dNf, ddNf = (0, 0, 0, 0) # Get the first and second derivatives of the quaternion at the starting/ending points dqi = _get_dq(wi, dNi, qi) ddqi = _get_ddq(wi, dwi, dNi, ddNi, qi) dqf = _get_dq(wf, dNf, qf) ddqf = _get_ddq(wf, dwf, dNf, ddNf, qf) # Get the polynomial coefficients p = _fifth_order_quat_poly_coeffs(qi, qf, dqi, dqf, ddqi, ddqf, duration) # Linearly sample along this polynomial to get the interpolated quaternions taus = np.linspace(0, 1, n, endpoint=True) wxyz_quats = _interpolate_along_quat_poly(p, taus) # Convert back to XYZW for compatibility with the rest of the repository quats = wxyz_to_xyzw(wxyz_quats) # Normalize, since this process does not guarantee norm 1 quaternions quats /= np.linalg.norm(quats, axis=1).reshape(-1, 1) return quats # Below are all helper functions based on the equations from the reference paper # These are prefixed by an underscore to imply that they should NOT be imported outside this file # Mainly, this is because the paper deals with WXYZ quaternions and I didn' t want to convert # all of the math for the intermediate steps def _fifth_order_quat_poly_coeffs ( qi : np . ndarray , qf : np . ndarray , dqi : np . ndarray , dqf : np . ndarray , ddqi : np . ndarray , ddqf : np . ndarray , T : float , ) -> np . ndarray : \"\"\"Get the coefficients for a fifth-order polynomial in quaternion space See Equation 13 in the reference paper \"\"\" return np . row_stack ( [ qi, 3 * qi + dqi * T, (ddqi * T**2 + 6 * dqi * T + 12 * qi) / 2, qf, 3 * qf - dqf * T, (ddqf * T**2 - 6 * dqf * T + 12 * qf) / 2, ] ) def _interpolate_along_quat_poly ( p : np . ndarray , taus : np . ndarray ) : \"\"\"Interpolate along a polynomial defined by coefficients p at percents tau See Equation 12 in the reference paper \"\"\" # Convert taus to a column vector for proper broadcasting taus = np . atleast_2d ( taus ) if taus . shape [ 0 ] == 1 : taus = taus . T # Output will be ( n , 4 ) where n is the number of taus to interpolate at return ( 1 - taus ) ** 3 * ( p [ 0 ] + p [ 1 ] * taus + p [ 2 ] * taus ** 2 ) + ( taus ** 3 ) * ( p [ 3 ] + p [ 4 ] * ( 1 - taus ) + p [ 5 ] * ( 1 - taus ) ** 2 ) def _get_dq ( w : np . ndarray , dN : float , q : np . ndarray ) -> np . ndarray : \"\"\"Derivative of WXYZ quaternion (Equation 21) Args: w (np.ndarray): Inertial frame angular velocity, shape (3,) dN (float): Derivative of quaternion norm q (np.ndarray): Current WXYZ quaternion, shape (4,) Returns: np.ndarray: Quaternion derivative, shape (4,) \"\"\" return _multiply ( _pure (( 1 / 2 ) * w + dN ), q ) def _get_ddq ( w : np . ndarray , dw : np . ndarray , dN : float , ddN : float , q : np . ndarray ) -> np . ndarray : \"\"\"Second derivative of WXYZ quaternion (Equation 22) Args: w (np.ndarray): Inertial frame angular velocity, shape (3,) dw (np.ndarray): Derivative of angular velocity, shape (3,) dN (float): Derivative of quaternion norm ddN (float): Second derivative of quaternion norm q (np.ndarray): Current WXYZ quaternion, shape (4,) Returns: np.ndarray: Quaternion derivative, shape (4,) \"\"\" return _multiply ( _pure (( 1 / 2 ) * dw + dN * w - ( 1 / 4 ) * _squared_norm ( w ) + ddN ), q ) def _dot ( q1 , q2 ) : \"\"\"Dot product between two quaternions (Equation 4)\"\"\" return np . dot ( q1 , q2 ) def _conj ( q ) : \"\"\"Conjugate of WXYZ quaternion (Between Eqns. 4/5)\"\"\" return np . array ( [ 1, -1, -1, -1 ] ) * q def _inv ( q ) : \"\"\"Inverse of a WXYZ quaternion (Between Eqns. 4/5)\"\"\" N = np . linalg . norm ( q ) return ( 1 / ( N ** 2 )) * _conj ( q ) def _pure ( v ) : \"\"\"Pure WXYZ quaternion representation from vector component (Between Eqns. 7/8)\"\"\" return np . concatenate ( [ [0 ] , v ] ) def _multiply ( q1 , q2 ) : \"\"\"Multiplication of two WXYZ quaternions (Equation 3)\"\"\" w1 , x1 , y1 , z1 = q1 w2 , x2 , y2 , z2 = q2 return np . array ( [ w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2, w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2, w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2, w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2, ] ) def _squared_norm ( v ) : \"\"\"Squared vector norm\"\"\" return np . dot ( v , v ) # UNUSED functions below # These were based on the equations in the paper or implemented manually ( such as some of the additional derivatives ) # Leaving these juse in case they are helpful in the future def _get_q_from_curve ( p , tau ) : # Equation 12 return ( 1 - tau ) ** 3 * ( p [ 0 ] + p [ 1 ] * tau + p [ 2 ] * tau ** 2 ) + ( tau ** 3 ) * ( p [ 3 ] + p [ 4 ] * ( 1 - tau ) + p [ 5 ] * ( 1 - tau ) ** 2 ) def _get_dq_from_curve ( p , tau ) : # Derivative of equation 12 wrt time return ( - 3 * ( 1 - tau ) ** 2 * ( p [ 0 ] + p [ 1 ] * tau + p [ 2 ] * tau ** 2 ) + ( 1 - tau ) ** 3 * ( p [ 1 ] + 2 * p [ 2 ] * tau ) + 3 * tau ** 2 * ( p [ 3 ] + p [ 4 ] * ( 1 - tau ) + p [ 5 ] * ( 1 - tau ) ** 2 ) + tau ** 3 * ( - p [ 4 ] - 2 * p [ 5 ] * ( 1 - tau )) ) def _get_ddq_from_curve ( p , tau ) : # Second derivative of equation 12 wrt time return ( 6 * ( 1 - tau ) * ( p [ 0 ] + p [ 1 ] * tau + p [ 2 ] * tau ** 2 ) - 6 * ( 1 - tau ) ** 2 * ( p [ 1 ] + 2 * p [ 2 ] * tau ) + ( 1 - tau ) ** 3 * 2 * p [ 2 ] + 6 * tau * ( p [ 3 ] + p [ 4 ] * ( 1 - tau ) + p [ 5 ] * ( 1 - tau ) ** 2 ) + 6 * tau ** 2 * ( - p [ 4 ] - 2 * p [ 5 ] * ( 1 - tau )) + tau ** 3 * 2 * p [ 5 ] ) def _get_N ( q ) : \"\"\"Quaternion norm (should be 1 ideally)\"\"\" return np . linalg . norm ( q ) def _get_w ( q , dq ) : # Equation 6 , part 2 return ( 2 * dq * _inv ( q )) [ 1: ] # Index the vector part of pure quat def _get_dw ( q , dq , ddq ) : # Equation 7 , part 2 q_inv = _inv ( q ) return ( 2 * ddq * q_inv - 2 * ( dq * q_inv ) ** 2 ) [ 1: ] # Index the vector part of pure quat def _main () : import matplotlib . pyplot as plt # pylint : disable = import - outside - toplevel # Calculate and plot an example interpolation ti = 0 # Initial time tf = 5 # Final time T = tf - ti # Duration qi = np . array ( [ 0, 0, 0, 1 ] ) # Initial quaternion wi = 0.1 * np . random . rand ( 3 ) # Initial ang vel dwi = np . zeros ( 3 ) # Initial ang accel qf = np . random . rand ( 4 ) # Final quaternion ( pre - normalization ) qf /= np . linalg . norm ( qf ) # Normalize wf = 0.1 * np . random . rand ( 3 ) # Final angular velocity dwf = np . zeros ( 3 ) # Final angular acceleration dt = 1 / 350 # Timestep ( set to the pybullet physics timestep we ' re using ) n = round ( T / dt ) # Number of timesteps qs = quaternion_interpolation_with_bcs ( qi , qf , wi , wf , dwi , dwf , T , n ) ws = quats_to_angular_velocities ( qs , dt ) dws = np . gradient ( ws , dt , axis = 0 ) # Plot the quaternions , angular velocities , and angular accelerations fig = plt . figure () subfigs = fig . subfigures ( 1 , 3 ) left = subfigs [ 0 ] . subplots ( 1 , 4 ) middle = subfigs [ 1 ] . subplots ( 1 , 3 ) right = subfigs [ 2 ] . subplots ( 1 , 3 ) x_axis = range ( qs . shape [ 0 ] ) q_labels = [ \"qw\", \"qx\", \"qy\", \"qz\" ] w_labels = [ \"wx\", \"wy\", \"wz\" ] dw_labels = [ \"ax\", \"ay\", \"az\" ] x_label = \"Time\" for i , ax in enumerate ( left ) : ax . plot ( x_axis , qs [ :, i ] ) ax . set_title ( q_labels [ i ] ) ax . set_xlabel ( x_label ) for i , ax in enumerate ( middle ) : ax . plot ( x_axis , ws [ :, i ] ) ax . set_title ( w_labels [ i ] ) ax . set_xlabel ( x_label ) for i , ax in enumerate ( right ) : ax . plot ( x_axis , dws [ :, i ] ) ax . set_title ( dw_labels [ i ] ) ax . set_xlabel ( x_label ) plt . show () if __name__ == \"__main__\" : _main () Functions quaternion_interpolation_with_bcs def quaternion_interpolation_with_bcs ( qi : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], qf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], wi : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], wf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], dwi : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], dwf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], duration : float , n : int ) -> numpy . ndarray Generate a sequence of quaternions between two orientations with angular velocity boundary conditions This implementation is a slightly modified version of \"Orientation Planning in Task Space using Quaternion Polynomials\" DOI: 10.1109/ROBIO.2017.8324769, Algorithm 1 Parameters: Name Type Description Default qi npt.ArrayLike Initial XYZW quaternion, shape (4,) None qf npt.ArrayLike Final XYZW quaternion, shape (4,) None wi npt.ArrayLike Initial inertial-frame angular velocity, shape (3,) None wf npt.ArrayLike Final inertial-frame angular velocity, shape (3,) None dwi npt.ArrayLike Initial inertial-frame angular acceleration, shape (3,) None dwf npt.ArrayLike Final inertial-frame angular acceleration, shape (3,) None duration float Trajectory duration, seconds None n int Number of timesteps None Returns: Type Description np.ndarray Sequence of XYZW quaternions, shape (n, 4) View Source def quaternion_interpolation_with_bcs ( qi : npt . ArrayLike , qf : npt . ArrayLike , wi : npt . ArrayLike , wf : npt . ArrayLike , dwi : npt . ArrayLike , dwf : npt . ArrayLike , duration : float , n : int , ) -> np . ndarray : \"\"\"Generate a sequence of quaternions between two orientations with angular velocity boundary conditions - This implementation is a slightly modified version of \" Orientation Planning in Task Space using Quaternion Polynomials \" DOI: 10.1109/ROBIO.2017.8324769, Algorithm 1 Args: qi (npt.ArrayLike): Initial XYZW quaternion, shape (4,) qf (npt.ArrayLike): Final XYZW quaternion, shape (4,) wi (npt.ArrayLike): Initial inertial-frame angular velocity, shape (3,) wf (npt.ArrayLike): Final inertial-frame angular velocity, shape (3,) dwi (npt.ArrayLike): Initial inertial-frame angular acceleration, shape (3,) dwf (npt.ArrayLike): Final inertial-frame angular acceleration, shape (3,) duration (float): Trajectory duration, seconds n (int): Number of timesteps Returns: np.ndarray: Sequence of XYZW quaternions, shape (n, 4) \"\"\" # NOTE The algorithm in the paper uses WXYZ quaternions , so we ' ll need to convert back and forth qi = xyzw_to_wxyz ( qi ) qf = xyzw_to_wxyz ( qf ) wi = np . asarray ( wi ) wf = np . asarray ( wf ) dwi = np . asarray ( dwi ) dwf = np . asarray ( dwf ) # Ensure shortest path interpolation if _dot ( qi , qf ) < 0 : qf = - qf # First and second derivatives of quaternion magnitude should be 0 # ( in theory quaternion norms should always be fixed at 1 , but this interpolation # does not necessarily guarantee this . But , it generally stays within 5 % of norm 1 ) dNi , ddNi , dNf , ddNf = ( 0 , 0 , 0 , 0 ) # Get the first and second derivatives of the quaternion at the starting / ending points dqi = _get_dq ( wi , dNi , qi ) ddqi = _get_ddq ( wi , dwi , dNi , ddNi , qi ) dqf = _get_dq ( wf , dNf , qf ) ddqf = _get_ddq ( wf , dwf , dNf , ddNf , qf ) # Get the polynomial coefficients p = _fifth_order_quat_poly_coeffs ( qi , qf , dqi , dqf , ddqi , ddqf , duration ) # Linearly sample along this polynomial to get the interpolated quaternions taus = np . linspace ( 0 , 1 , n , endpoint = True ) wxyz_quats = _interpolate_along_quat_poly ( p , taus ) # Convert back to XYZW for compatibility with the rest of the repository quats = wxyz_to_xyzw ( wxyz_quats ) # Normalize , since this process does not guarantee norm 1 quaternions quats /= np . linalg . norm ( quats , axis = 1 ). reshape ( - 1 , 1 ) return quats","title":"Quaternion Interpolation"},{"location":"reference/pyastrobee/trajectories/quaternion_interpolation/#module-pyastrobeetrajectoriesquaternion_interpolation","text":"Determining an orientation trajectory between two quaternions with angular velocity boundary conditions This is different from SLERP because SLERP will find the shortest path along the unit 4D hypersphere (by traveling along a great circle), but this implies that we cannot dictate the direction of the angular velocity vector during this interpolation This method will instead create a 5th order polynomial to specify the boundary conditions on angular velocity (and technically angular acceleration as well, since we only need a 3rd order polynomial to specify BCs on the first derivatives). There is no guarantee that the quaternions will be normalized, but we can do that after the interpolation process. The interpolation does not result in significant deviations (< 5%) from unit-norm quaternions, so this should not significantly affect the orientation representation See \"Orientation Planning in Task Space using Quaternion Polynomials\" DOI: 10.1109/ROBIO.2017.8324769 for more info Note: this paper uses WXYZ quaternions View Source \"\"\"Determining an orientation trajectory between two quaternions with angular velocity boundary conditions This is different from SLERP because SLERP will find the shortest path along the unit 4D hypersphere (by traveling along a great circle), but this implies that we cannot dictate the direction of the angular velocity vector during this interpolation This method will instead create a 5th order polynomial to specify the boundary conditions on angular velocity (and technically angular acceleration as well, since we only need a 3rd order polynomial to specify BCs on the first derivatives). There is no guarantee that the quaternions will be normalized, but we can do that after the interpolation process. The interpolation does not result in significant deviations (< 5%) from unit-norm quaternions, so this should not significantly affect the orientation representation See \" Orientation Planning in Task Space using Quaternion Polynomials \" DOI: 10.1109/ROBIO.2017.8324769 for more info Note: this paper uses WXYZ quaternions \"\"\" import numpy as np import numpy . typing as npt from pyastrobee . utils . quaternions import ( quats_to_angular_velocities , wxyz_to_xyzw , xyzw_to_wxyz , ) def quaternion_interpolation_with_bcs ( qi : npt . ArrayLike , qf : npt . ArrayLike , wi : npt . ArrayLike , wf : npt . ArrayLike , dwi : npt . ArrayLike , dwf : npt . ArrayLike , duration : float , n : int , ) -> np . ndarray : \"\"\"Generate a sequence of quaternions between two orientations with angular velocity boundary conditions - This implementation is a slightly modified version of \" Orientation Planning in Task Space using Quaternion Polynomials \" DOI: 10.1109/ROBIO.2017.8324769, Algorithm 1 Args: qi (npt.ArrayLike): Initial XYZW quaternion, shape (4,) qf (npt.ArrayLike): Final XYZW quaternion, shape (4,) wi (npt.ArrayLike): Initial inertial-frame angular velocity, shape (3,) wf (npt.ArrayLike): Final inertial-frame angular velocity, shape (3,) dwi (npt.ArrayLike): Initial inertial-frame angular acceleration, shape (3,) dwf (npt.ArrayLike): Final inertial-frame angular acceleration, shape (3,) duration (float): Trajectory duration, seconds n (int): Number of timesteps Returns: np.ndarray: Sequence of XYZW quaternions, shape (n, 4) \"\"\" # NOTE The algorithm in the paper uses WXYZ quaternions , so we 'll need to convert back and forth qi = xyzw_to_wxyz(qi) qf = xyzw_to_wxyz(qf) wi = np.asarray(wi) wf = np.asarray(wf) dwi = np.asarray(dwi) dwf = np.asarray(dwf) # Ensure shortest path interpolation if _dot(qi, qf) < 0: qf = -qf # First and second derivatives of quaternion magnitude should be 0 # (in theory quaternion norms should always be fixed at 1, but this interpolation # does not necessarily guarantee this. But, it generally stays within 5% of norm 1) dNi, ddNi, dNf, ddNf = (0, 0, 0, 0) # Get the first and second derivatives of the quaternion at the starting/ending points dqi = _get_dq(wi, dNi, qi) ddqi = _get_ddq(wi, dwi, dNi, ddNi, qi) dqf = _get_dq(wf, dNf, qf) ddqf = _get_ddq(wf, dwf, dNf, ddNf, qf) # Get the polynomial coefficients p = _fifth_order_quat_poly_coeffs(qi, qf, dqi, dqf, ddqi, ddqf, duration) # Linearly sample along this polynomial to get the interpolated quaternions taus = np.linspace(0, 1, n, endpoint=True) wxyz_quats = _interpolate_along_quat_poly(p, taus) # Convert back to XYZW for compatibility with the rest of the repository quats = wxyz_to_xyzw(wxyz_quats) # Normalize, since this process does not guarantee norm 1 quaternions quats /= np.linalg.norm(quats, axis=1).reshape(-1, 1) return quats # Below are all helper functions based on the equations from the reference paper # These are prefixed by an underscore to imply that they should NOT be imported outside this file # Mainly, this is because the paper deals with WXYZ quaternions and I didn' t want to convert # all of the math for the intermediate steps def _fifth_order_quat_poly_coeffs ( qi : np . ndarray , qf : np . ndarray , dqi : np . ndarray , dqf : np . ndarray , ddqi : np . ndarray , ddqf : np . ndarray , T : float , ) -> np . ndarray : \"\"\"Get the coefficients for a fifth-order polynomial in quaternion space See Equation 13 in the reference paper \"\"\" return np . row_stack ( [ qi, 3 * qi + dqi * T, (ddqi * T**2 + 6 * dqi * T + 12 * qi) / 2, qf, 3 * qf - dqf * T, (ddqf * T**2 - 6 * dqf * T + 12 * qf) / 2, ] ) def _interpolate_along_quat_poly ( p : np . ndarray , taus : np . ndarray ) : \"\"\"Interpolate along a polynomial defined by coefficients p at percents tau See Equation 12 in the reference paper \"\"\" # Convert taus to a column vector for proper broadcasting taus = np . atleast_2d ( taus ) if taus . shape [ 0 ] == 1 : taus = taus . T # Output will be ( n , 4 ) where n is the number of taus to interpolate at return ( 1 - taus ) ** 3 * ( p [ 0 ] + p [ 1 ] * taus + p [ 2 ] * taus ** 2 ) + ( taus ** 3 ) * ( p [ 3 ] + p [ 4 ] * ( 1 - taus ) + p [ 5 ] * ( 1 - taus ) ** 2 ) def _get_dq ( w : np . ndarray , dN : float , q : np . ndarray ) -> np . ndarray : \"\"\"Derivative of WXYZ quaternion (Equation 21) Args: w (np.ndarray): Inertial frame angular velocity, shape (3,) dN (float): Derivative of quaternion norm q (np.ndarray): Current WXYZ quaternion, shape (4,) Returns: np.ndarray: Quaternion derivative, shape (4,) \"\"\" return _multiply ( _pure (( 1 / 2 ) * w + dN ), q ) def _get_ddq ( w : np . ndarray , dw : np . ndarray , dN : float , ddN : float , q : np . ndarray ) -> np . ndarray : \"\"\"Second derivative of WXYZ quaternion (Equation 22) Args: w (np.ndarray): Inertial frame angular velocity, shape (3,) dw (np.ndarray): Derivative of angular velocity, shape (3,) dN (float): Derivative of quaternion norm ddN (float): Second derivative of quaternion norm q (np.ndarray): Current WXYZ quaternion, shape (4,) Returns: np.ndarray: Quaternion derivative, shape (4,) \"\"\" return _multiply ( _pure (( 1 / 2 ) * dw + dN * w - ( 1 / 4 ) * _squared_norm ( w ) + ddN ), q ) def _dot ( q1 , q2 ) : \"\"\"Dot product between two quaternions (Equation 4)\"\"\" return np . dot ( q1 , q2 ) def _conj ( q ) : \"\"\"Conjugate of WXYZ quaternion (Between Eqns. 4/5)\"\"\" return np . array ( [ 1, -1, -1, -1 ] ) * q def _inv ( q ) : \"\"\"Inverse of a WXYZ quaternion (Between Eqns. 4/5)\"\"\" N = np . linalg . norm ( q ) return ( 1 / ( N ** 2 )) * _conj ( q ) def _pure ( v ) : \"\"\"Pure WXYZ quaternion representation from vector component (Between Eqns. 7/8)\"\"\" return np . concatenate ( [ [0 ] , v ] ) def _multiply ( q1 , q2 ) : \"\"\"Multiplication of two WXYZ quaternions (Equation 3)\"\"\" w1 , x1 , y1 , z1 = q1 w2 , x2 , y2 , z2 = q2 return np . array ( [ w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2, w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2, w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2, w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2, ] ) def _squared_norm ( v ) : \"\"\"Squared vector norm\"\"\" return np . dot ( v , v ) # UNUSED functions below # These were based on the equations in the paper or implemented manually ( such as some of the additional derivatives ) # Leaving these juse in case they are helpful in the future def _get_q_from_curve ( p , tau ) : # Equation 12 return ( 1 - tau ) ** 3 * ( p [ 0 ] + p [ 1 ] * tau + p [ 2 ] * tau ** 2 ) + ( tau ** 3 ) * ( p [ 3 ] + p [ 4 ] * ( 1 - tau ) + p [ 5 ] * ( 1 - tau ) ** 2 ) def _get_dq_from_curve ( p , tau ) : # Derivative of equation 12 wrt time return ( - 3 * ( 1 - tau ) ** 2 * ( p [ 0 ] + p [ 1 ] * tau + p [ 2 ] * tau ** 2 ) + ( 1 - tau ) ** 3 * ( p [ 1 ] + 2 * p [ 2 ] * tau ) + 3 * tau ** 2 * ( p [ 3 ] + p [ 4 ] * ( 1 - tau ) + p [ 5 ] * ( 1 - tau ) ** 2 ) + tau ** 3 * ( - p [ 4 ] - 2 * p [ 5 ] * ( 1 - tau )) ) def _get_ddq_from_curve ( p , tau ) : # Second derivative of equation 12 wrt time return ( 6 * ( 1 - tau ) * ( p [ 0 ] + p [ 1 ] * tau + p [ 2 ] * tau ** 2 ) - 6 * ( 1 - tau ) ** 2 * ( p [ 1 ] + 2 * p [ 2 ] * tau ) + ( 1 - tau ) ** 3 * 2 * p [ 2 ] + 6 * tau * ( p [ 3 ] + p [ 4 ] * ( 1 - tau ) + p [ 5 ] * ( 1 - tau ) ** 2 ) + 6 * tau ** 2 * ( - p [ 4 ] - 2 * p [ 5 ] * ( 1 - tau )) + tau ** 3 * 2 * p [ 5 ] ) def _get_N ( q ) : \"\"\"Quaternion norm (should be 1 ideally)\"\"\" return np . linalg . norm ( q ) def _get_w ( q , dq ) : # Equation 6 , part 2 return ( 2 * dq * _inv ( q )) [ 1: ] # Index the vector part of pure quat def _get_dw ( q , dq , ddq ) : # Equation 7 , part 2 q_inv = _inv ( q ) return ( 2 * ddq * q_inv - 2 * ( dq * q_inv ) ** 2 ) [ 1: ] # Index the vector part of pure quat def _main () : import matplotlib . pyplot as plt # pylint : disable = import - outside - toplevel # Calculate and plot an example interpolation ti = 0 # Initial time tf = 5 # Final time T = tf - ti # Duration qi = np . array ( [ 0, 0, 0, 1 ] ) # Initial quaternion wi = 0.1 * np . random . rand ( 3 ) # Initial ang vel dwi = np . zeros ( 3 ) # Initial ang accel qf = np . random . rand ( 4 ) # Final quaternion ( pre - normalization ) qf /= np . linalg . norm ( qf ) # Normalize wf = 0.1 * np . random . rand ( 3 ) # Final angular velocity dwf = np . zeros ( 3 ) # Final angular acceleration dt = 1 / 350 # Timestep ( set to the pybullet physics timestep we ' re using ) n = round ( T / dt ) # Number of timesteps qs = quaternion_interpolation_with_bcs ( qi , qf , wi , wf , dwi , dwf , T , n ) ws = quats_to_angular_velocities ( qs , dt ) dws = np . gradient ( ws , dt , axis = 0 ) # Plot the quaternions , angular velocities , and angular accelerations fig = plt . figure () subfigs = fig . subfigures ( 1 , 3 ) left = subfigs [ 0 ] . subplots ( 1 , 4 ) middle = subfigs [ 1 ] . subplots ( 1 , 3 ) right = subfigs [ 2 ] . subplots ( 1 , 3 ) x_axis = range ( qs . shape [ 0 ] ) q_labels = [ \"qw\", \"qx\", \"qy\", \"qz\" ] w_labels = [ \"wx\", \"wy\", \"wz\" ] dw_labels = [ \"ax\", \"ay\", \"az\" ] x_label = \"Time\" for i , ax in enumerate ( left ) : ax . plot ( x_axis , qs [ :, i ] ) ax . set_title ( q_labels [ i ] ) ax . set_xlabel ( x_label ) for i , ax in enumerate ( middle ) : ax . plot ( x_axis , ws [ :, i ] ) ax . set_title ( w_labels [ i ] ) ax . set_xlabel ( x_label ) for i , ax in enumerate ( right ) : ax . plot ( x_axis , dws [ :, i ] ) ax . set_title ( dw_labels [ i ] ) ax . set_xlabel ( x_label ) plt . show () if __name__ == \"__main__\" : _main ()","title":"Module pyastrobee.trajectories.quaternion_interpolation"},{"location":"reference/pyastrobee/trajectories/quaternion_interpolation/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/trajectories/quaternion_interpolation/#quaternion_interpolation_with_bcs","text":"def quaternion_interpolation_with_bcs ( qi : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], qf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], wi : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], wf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], dwi : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], dwf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], duration : float , n : int ) -> numpy . ndarray Generate a sequence of quaternions between two orientations with angular velocity boundary conditions This implementation is a slightly modified version of \"Orientation Planning in Task Space using Quaternion Polynomials\" DOI: 10.1109/ROBIO.2017.8324769, Algorithm 1 Parameters: Name Type Description Default qi npt.ArrayLike Initial XYZW quaternion, shape (4,) None qf npt.ArrayLike Final XYZW quaternion, shape (4,) None wi npt.ArrayLike Initial inertial-frame angular velocity, shape (3,) None wf npt.ArrayLike Final inertial-frame angular velocity, shape (3,) None dwi npt.ArrayLike Initial inertial-frame angular acceleration, shape (3,) None dwf npt.ArrayLike Final inertial-frame angular acceleration, shape (3,) None duration float Trajectory duration, seconds None n int Number of timesteps None Returns: Type Description np.ndarray Sequence of XYZW quaternions, shape (n, 4) View Source def quaternion_interpolation_with_bcs ( qi : npt . ArrayLike , qf : npt . ArrayLike , wi : npt . ArrayLike , wf : npt . ArrayLike , dwi : npt . ArrayLike , dwf : npt . ArrayLike , duration : float , n : int , ) -> np . ndarray : \"\"\"Generate a sequence of quaternions between two orientations with angular velocity boundary conditions - This implementation is a slightly modified version of \" Orientation Planning in Task Space using Quaternion Polynomials \" DOI: 10.1109/ROBIO.2017.8324769, Algorithm 1 Args: qi (npt.ArrayLike): Initial XYZW quaternion, shape (4,) qf (npt.ArrayLike): Final XYZW quaternion, shape (4,) wi (npt.ArrayLike): Initial inertial-frame angular velocity, shape (3,) wf (npt.ArrayLike): Final inertial-frame angular velocity, shape (3,) dwi (npt.ArrayLike): Initial inertial-frame angular acceleration, shape (3,) dwf (npt.ArrayLike): Final inertial-frame angular acceleration, shape (3,) duration (float): Trajectory duration, seconds n (int): Number of timesteps Returns: np.ndarray: Sequence of XYZW quaternions, shape (n, 4) \"\"\" # NOTE The algorithm in the paper uses WXYZ quaternions , so we ' ll need to convert back and forth qi = xyzw_to_wxyz ( qi ) qf = xyzw_to_wxyz ( qf ) wi = np . asarray ( wi ) wf = np . asarray ( wf ) dwi = np . asarray ( dwi ) dwf = np . asarray ( dwf ) # Ensure shortest path interpolation if _dot ( qi , qf ) < 0 : qf = - qf # First and second derivatives of quaternion magnitude should be 0 # ( in theory quaternion norms should always be fixed at 1 , but this interpolation # does not necessarily guarantee this . But , it generally stays within 5 % of norm 1 ) dNi , ddNi , dNf , ddNf = ( 0 , 0 , 0 , 0 ) # Get the first and second derivatives of the quaternion at the starting / ending points dqi = _get_dq ( wi , dNi , qi ) ddqi = _get_ddq ( wi , dwi , dNi , ddNi , qi ) dqf = _get_dq ( wf , dNf , qf ) ddqf = _get_ddq ( wf , dwf , dNf , ddNf , qf ) # Get the polynomial coefficients p = _fifth_order_quat_poly_coeffs ( qi , qf , dqi , dqf , ddqi , ddqf , duration ) # Linearly sample along this polynomial to get the interpolated quaternions taus = np . linspace ( 0 , 1 , n , endpoint = True ) wxyz_quats = _interpolate_along_quat_poly ( p , taus ) # Convert back to XYZW for compatibility with the rest of the repository quats = wxyz_to_xyzw ( wxyz_quats ) # Normalize , since this process does not guarantee norm 1 quaternions quats /= np . linalg . norm ( quats , axis = 1 ). reshape ( - 1 , 1 ) return quats","title":"quaternion_interpolation_with_bcs"},{"location":"reference/pyastrobee/trajectories/sampling/","text":"Module pyastrobee.trajectories.sampling Methods for sampling candidate trajectories about a reference state or trajectory View Source \"\"\"Methods for sampling candidate trajectories about a reference state or trajectory\"\"\" # TODO make a method that uses different reward weighting in the trajectory optimization (e.g. different weighting # between minimizing jerk and minimizing pathlength) # TODO make sample_joint_states function # TODO decide if time should be in the sample state function... And does it make sense to call this a \"state\" because # in other places we call things \"dynamics state\" and don't include acceleration info for instance?? import numpy as np import numpy.typing as npt from pyastrobee.utils.math_utils import spherical_vonmises_sampling from pyastrobee.trajectories.trajectory import Trajectory from pyastrobee.trajectories.planner import local_planner def sample_state ( nominal_pos : npt . ArrayLike , nominal_orn : npt . ArrayLike , nominal_vel : npt . ArrayLike , nominal_ang_vel : npt . ArrayLike , nominal_accel : npt . ArrayLike , nominal_alpha : npt . ArrayLike , pos_stdev : float , orn_stdev : float , vel_stdev : float , ang_vel_stdev : float , accel_stdev : float , alpha_stdev : float , ) -> list [ np . ndarray ]: \"\"\"Generate a sample about a nominal state Args: nominal_pos (npt.ArrayLike): Nominal desired position to sample about, shape (3,) nominal_orn (npt.ArrayLike): Nominal desired XYZW quaternion to sample about, shape (4,) nominal_vel (npt.ArrayLike): Nominal desired linear velocity to sample about, shape (3,) nominal_ang_vel (npt.ArrayLike): Nominal desired angular velocity to sample about, shape (3,) nominal_accel (npt.ArrayLike): Nominal desired linear acceleration to sample about, shape (3,) nominal_alpha (npt.ArrayLike): Nominal desired angular acceleration to sample about, shape (3,) pos_stdev (float): Standard deviation of the position sampling distribution orn_stdev (float): Standard deviation of the orientation sampling distribution vel_stdev (float): Standard deviation of the velocity sampling distribution ang_vel_stdev (float): Standard deviation of the angular velocity sampling distribution accel_stdev (float): Standard deviation of the linear acceleration sampling distribution alpha_stdev (float): Standard deviation of the angular acceleration sampling distribution Returns: list[np.ndarray]: Sampled state. Length = 6. Includes position, orientation, velocity, angular velocity, acceleration, and angular acceleration \"\"\" pos = np . random . multivariate_normal ( nominal_pos , pos_stdev ** 2 * np . eye ( 3 )) orn = spherical_vonmises_sampling ( nominal_orn , 1 / ( orn_stdev ** 2 ), 1 )[ 0 ] vel = np . random . multivariate_normal ( nominal_vel , vel_stdev ** 2 * np . eye ( 3 )) ang_vel = np . random . multivariate_normal ( nominal_ang_vel , ang_vel_stdev ** 2 * np . eye ( 3 ) ) accel = np . random . multivariate_normal ( nominal_accel , accel_stdev ** 2 * np . eye ( 3 )) alpha = np . random . multivariate_normal ( nominal_alpha , alpha_stdev ** 2 * np . eye ( 3 )) return [ pos , orn , vel , ang_vel , accel , alpha ] # TODO # - Decide if we should be passing in covariance matrices or arrays instead of scalars # - Decide if the \"orientation stdev\" should be replaced by the von Mises kappa parameter def generate_trajs ( cur_pos : npt . ArrayLike , cur_orn : npt . ArrayLike , cur_vel : npt . ArrayLike , cur_ang_vel : npt . ArrayLike , cur_accel : npt . ArrayLike , # Optional? cur_alpha : npt . ArrayLike , # Optional? nominal_target_pos : npt . ArrayLike , nominal_target_orn : npt . ArrayLike , nominal_target_vel : npt . ArrayLike , nominal_target_ang_vel : npt . ArrayLike , nominal_target_accel : npt . ArrayLike , # Optional? nominal_target_alpha : npt . ArrayLike , # Optional? pos_sampling_stdev : float , orn_sampling_stdev : float , vel_sampling_stdev : float , ang_vel_sampling_stdev : float , accel_sampling_stdev : float , alpha_sampling_stdev : float , n_trajs : int , duration : float , dt : float , include_nominal_traj : bool , ) -> list [ Trajectory ]: \"\"\"Generate a number of trajectories from the current state to a sampled state about a nominal target Args: cur_pos (npt.ArrayLike): Current position, shape (3,) cur_orn (npt.ArrayLike): Current XYZW quaternion orientation, shape (4,) cur_vel (npt.ArrayLike): Current linear velocity, shape (3,) cur_ang_vel (npt.ArrayLike): Current angular velocity, shape (3,) nominal_target_pos (npt.ArrayLike): Nominal desired position to sample about, shape (3,) nominal_target_orn (npt.ArrayLike): Nominal desired XYZW quaternion to sample about, shape (4,) nominal_target_vel (npt.ArrayLike): Nominal desired linear velocity to sample about, shape (3,) nominal_target_ang_vel (npt.ArrayLike): Nominal desired angular velocity to sample about, shape (3,) pos_sampling_stdev (float): Standard deviation of the position sampling distribution orn_sampling_stdev (float): Standard deviation of the orientation sampling distribution vel_sampling_stdev (float): Standard deviation of the velocity sampling distribution ang_vel_sampling_stdev (float): Standard deviation of the angular velocity sampling distribution n_trajs (int): Number of trajectories to generate duration (float): Trajectory duration, in seconds dt (float): Timestep include_nominal_traj (bool): Whether or not to include the nominal (non-sampled) trajectory in the output Returns: list[Trajectory]: Sampled trajectories, length n_trajs \"\"\" trajs = [] if include_nominal_traj : # Let the first generated trajectory use the mean of all of the distributions trajs . append ( local_planner ( cur_pos , cur_orn , cur_vel , cur_ang_vel , cur_accel , cur_alpha , nominal_target_pos , nominal_target_orn , nominal_target_vel , nominal_target_ang_vel , nominal_target_accel , nominal_target_alpha , duration , dt , ) ) # Reduce the number of trajectories to sample since we have added this nominal traj n_samples = n_trajs - 1 else : # Sample all of the trajectories n_samples = n_trajs if n_samples == 0 : return trajs # Sample endpoints for the candidate trajectories about the nominal targets sampled_positions = np . random . multivariate_normal ( nominal_target_pos , pos_sampling_stdev ** 2 * np . eye ( 3 ), n_samples ) sampled_quats = spherical_vonmises_sampling ( nominal_target_orn , 1 / ( orn_sampling_stdev ** 2 ), n_samples ) sampled_vels = np . random . multivariate_normal ( nominal_target_vel , vel_sampling_stdev ** 2 * np . eye ( 3 ), n_samples ) sampled_ang_vels = np . random . multivariate_normal ( nominal_target_ang_vel , ang_vel_sampling_stdev ** 2 * np . eye ( 3 ), n_samples ) sampled_accels = np . random . multivariate_normal ( nominal_target_accel , accel_sampling_stdev ** 2 * np . eye ( 3 ), n_samples ) sampled_alphas = np . random . multivariate_normal ( nominal_target_alpha , alpha_sampling_stdev ** 2 * np . eye ( 3 ), n_samples ) for i in range ( n_samples ): trajs . append ( local_planner ( cur_pos , cur_orn , cur_vel , cur_ang_vel , cur_accel , cur_alpha , sampled_positions [ i ], sampled_quats [ i ], sampled_vels [ i ], sampled_ang_vels [ i ], sampled_accels [ i ], sampled_alphas [ i ], duration , dt , ) ) return trajs Functions generate_trajs def generate_trajs ( cur_pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], cur_orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], cur_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], cur_ang_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], cur_accel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], cur_alpha : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], nominal_target_pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], nominal_target_orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], nominal_target_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], nominal_target_ang_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], nominal_target_accel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], nominal_target_alpha : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pos_sampling_stdev : float , orn_sampling_stdev : float , vel_sampling_stdev : float , ang_vel_sampling_stdev : float , accel_sampling_stdev : float , alpha_sampling_stdev : float , n_trajs : int , duration : float , dt : float , include_nominal_traj : bool ) -> list [ pyastrobee . trajectories . trajectory . Trajectory ] Generate a number of trajectories from the current state to a sampled state about a nominal target Parameters: Name Type Description Default cur_pos npt.ArrayLike Current position, shape (3,) None cur_orn npt.ArrayLike Current XYZW quaternion orientation, shape (4,) None cur_vel npt.ArrayLike Current linear velocity, shape (3,) None cur_ang_vel npt.ArrayLike Current angular velocity, shape (3,) None nominal_target_pos npt.ArrayLike Nominal desired position to sample about, shape (3,) None nominal_target_orn npt.ArrayLike Nominal desired XYZW quaternion to sample about, shape (4,) None nominal_target_vel npt.ArrayLike Nominal desired linear velocity to sample about, shape (3,) None nominal_target_ang_vel npt.ArrayLike Nominal desired angular velocity to sample about, shape (3,) None pos_sampling_stdev float Standard deviation of the position sampling distribution None orn_sampling_stdev float Standard deviation of the orientation sampling distribution None vel_sampling_stdev float Standard deviation of the velocity sampling distribution None ang_vel_sampling_stdev float Standard deviation of the angular velocity sampling distribution None n_trajs int Number of trajectories to generate None duration float Trajectory duration, in seconds None dt float Timestep None include_nominal_traj bool Whether or not to include the nominal (non-sampled) trajectory in the output None Returns: Type Description list[Trajectory] Sampled trajectories, length n_trajs View Source def generate_trajs ( cur_pos : npt . ArrayLike , cur_orn : npt . ArrayLike , cur_vel : npt . ArrayLike , cur_ang_vel : npt . ArrayLike , cur_accel : npt . ArrayLike , # Optional ? cur_alpha : npt . ArrayLike , # Optional ? nominal_target_pos : npt . ArrayLike , nominal_target_orn : npt . ArrayLike , nominal_target_vel : npt . ArrayLike , nominal_target_ang_vel : npt . ArrayLike , nominal_target_accel : npt . ArrayLike , # Optional ? nominal_target_alpha : npt . ArrayLike , # Optional ? pos_sampling_stdev : float , orn_sampling_stdev : float , vel_sampling_stdev : float , ang_vel_sampling_stdev : float , accel_sampling_stdev : float , alpha_sampling_stdev : float , n_trajs : int , duration : float , dt : float , include_nominal_traj : bool , ) -> list [ Trajectory ] : \"\"\"Generate a number of trajectories from the current state to a sampled state about a nominal target Args: cur_pos (npt.ArrayLike): Current position, shape (3,) cur_orn (npt.ArrayLike): Current XYZW quaternion orientation, shape (4,) cur_vel (npt.ArrayLike): Current linear velocity, shape (3,) cur_ang_vel (npt.ArrayLike): Current angular velocity, shape (3,) nominal_target_pos (npt.ArrayLike): Nominal desired position to sample about, shape (3,) nominal_target_orn (npt.ArrayLike): Nominal desired XYZW quaternion to sample about, shape (4,) nominal_target_vel (npt.ArrayLike): Nominal desired linear velocity to sample about, shape (3,) nominal_target_ang_vel (npt.ArrayLike): Nominal desired angular velocity to sample about, shape (3,) pos_sampling_stdev (float): Standard deviation of the position sampling distribution orn_sampling_stdev (float): Standard deviation of the orientation sampling distribution vel_sampling_stdev (float): Standard deviation of the velocity sampling distribution ang_vel_sampling_stdev (float): Standard deviation of the angular velocity sampling distribution n_trajs (int): Number of trajectories to generate duration (float): Trajectory duration, in seconds dt (float): Timestep include_nominal_traj (bool): Whether or not to include the nominal (non-sampled) trajectory in the output Returns: list[Trajectory]: Sampled trajectories, length n_trajs \"\"\" trajs = [] if include_nominal_traj : # Let the first generated trajectory use the mean of all of the distributions trajs . append ( local_planner ( cur_pos , cur_orn , cur_vel , cur_ang_vel , cur_accel , cur_alpha , nominal_target_pos , nominal_target_orn , nominal_target_vel , nominal_target_ang_vel , nominal_target_accel , nominal_target_alpha , duration , dt , ) ) # Reduce the number of trajectories to sample since we have added this nominal traj n_samples = n_trajs - 1 else : # Sample all of the trajectories n_samples = n_trajs if n_samples == 0 : return trajs # Sample endpoints for the candidate trajectories about the nominal targets sampled_positions = np . random . multivariate_normal ( nominal_target_pos , pos_sampling_stdev ** 2 * np . eye ( 3 ), n_samples ) sampled_quats = spherical_vonmises_sampling ( nominal_target_orn , 1 / ( orn_sampling_stdev ** 2 ), n_samples ) sampled_vels = np . random . multivariate_normal ( nominal_target_vel , vel_sampling_stdev ** 2 * np . eye ( 3 ), n_samples ) sampled_ang_vels = np . random . multivariate_normal ( nominal_target_ang_vel , ang_vel_sampling_stdev ** 2 * np . eye ( 3 ), n_samples ) sampled_accels = np . random . multivariate_normal ( nominal_target_accel , accel_sampling_stdev ** 2 * np . eye ( 3 ), n_samples ) sampled_alphas = np . random . multivariate_normal ( nominal_target_alpha , alpha_sampling_stdev ** 2 * np . eye ( 3 ), n_samples ) for i in range ( n_samples ) : trajs . append ( local_planner ( cur_pos , cur_orn , cur_vel , cur_ang_vel , cur_accel , cur_alpha , sampled_positions [ i ] , sampled_quats [ i ] , sampled_vels [ i ] , sampled_ang_vels [ i ] , sampled_accels [ i ] , sampled_alphas [ i ] , duration , dt , ) ) return trajs sample_state def sample_state ( nominal_pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], nominal_orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], nominal_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], nominal_ang_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], nominal_accel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], nominal_alpha : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pos_stdev : float , orn_stdev : float , vel_stdev : float , ang_vel_stdev : float , accel_stdev : float , alpha_stdev : float ) -> list [ numpy . ndarray ] Generate a sample about a nominal state Parameters: Name Type Description Default nominal_pos npt.ArrayLike Nominal desired position to sample about, shape (3,) None nominal_orn npt.ArrayLike Nominal desired XYZW quaternion to sample about, shape (4,) None nominal_vel npt.ArrayLike Nominal desired linear velocity to sample about, shape (3,) None nominal_ang_vel npt.ArrayLike Nominal desired angular velocity to sample about, shape (3,) None nominal_accel npt.ArrayLike Nominal desired linear acceleration to sample about, shape (3,) None nominal_alpha npt.ArrayLike Nominal desired angular acceleration to sample about, shape (3,) None pos_stdev float Standard deviation of the position sampling distribution None orn_stdev float Standard deviation of the orientation sampling distribution None vel_stdev float Standard deviation of the velocity sampling distribution None ang_vel_stdev float Standard deviation of the angular velocity sampling distribution None accel_stdev float Standard deviation of the linear acceleration sampling distribution None alpha_stdev float Standard deviation of the angular acceleration sampling distribution None Returns: Type Description list[np.ndarray] Sampled state. Length = 6. Includes position, orientation, velocity, angular velocity, acceleration, and angular acceleration View Source def sample_state ( nominal_pos : npt . ArrayLike , nominal_orn : npt . ArrayLike , nominal_vel : npt . ArrayLike , nominal_ang_vel : npt . ArrayLike , nominal_accel : npt . ArrayLike , nominal_alpha : npt . ArrayLike , pos_stdev : float , orn_stdev : float , vel_stdev : float , ang_vel_stdev : float , accel_stdev : float , alpha_stdev : float , ) -> list [ np . ndarray ]: \"\"\"Generate a sample about a nominal state Args: nominal_pos (npt.ArrayLike): Nominal desired position to sample about, shape (3,) nominal_orn (npt.ArrayLike): Nominal desired XYZW quaternion to sample about, shape (4,) nominal_vel (npt.ArrayLike): Nominal desired linear velocity to sample about, shape (3,) nominal_ang_vel (npt.ArrayLike): Nominal desired angular velocity to sample about, shape (3,) nominal_accel (npt.ArrayLike): Nominal desired linear acceleration to sample about, shape (3,) nominal_alpha (npt.ArrayLike): Nominal desired angular acceleration to sample about, shape (3,) pos_stdev (float): Standard deviation of the position sampling distribution orn_stdev (float): Standard deviation of the orientation sampling distribution vel_stdev (float): Standard deviation of the velocity sampling distribution ang_vel_stdev (float): Standard deviation of the angular velocity sampling distribution accel_stdev (float): Standard deviation of the linear acceleration sampling distribution alpha_stdev (float): Standard deviation of the angular acceleration sampling distribution Returns: list[np.ndarray]: Sampled state. Length = 6. Includes position, orientation, velocity, angular velocity, acceleration, and angular acceleration \"\"\" pos = np . random . multivariate_normal ( nominal_pos , pos_stdev ** 2 * np . eye ( 3 )) orn = spherical_vonmises_sampling ( nominal_orn , 1 / ( orn_stdev ** 2 ), 1 )[ 0 ] vel = np . random . multivariate_normal ( nominal_vel , vel_stdev ** 2 * np . eye ( 3 )) ang_vel = np . random . multivariate_normal ( nominal_ang_vel , ang_vel_stdev ** 2 * np . eye ( 3 ) ) accel = np . random . multivariate_normal ( nominal_accel , accel_stdev ** 2 * np . eye ( 3 )) alpha = np . random . multivariate_normal ( nominal_alpha , alpha_stdev ** 2 * np . eye ( 3 )) return [ pos , orn , vel , ang_vel , accel , alpha ]","title":"Sampling"},{"location":"reference/pyastrobee/trajectories/sampling/#module-pyastrobeetrajectoriessampling","text":"Methods for sampling candidate trajectories about a reference state or trajectory View Source \"\"\"Methods for sampling candidate trajectories about a reference state or trajectory\"\"\" # TODO make a method that uses different reward weighting in the trajectory optimization (e.g. different weighting # between minimizing jerk and minimizing pathlength) # TODO make sample_joint_states function # TODO decide if time should be in the sample state function... And does it make sense to call this a \"state\" because # in other places we call things \"dynamics state\" and don't include acceleration info for instance?? import numpy as np import numpy.typing as npt from pyastrobee.utils.math_utils import spherical_vonmises_sampling from pyastrobee.trajectories.trajectory import Trajectory from pyastrobee.trajectories.planner import local_planner def sample_state ( nominal_pos : npt . ArrayLike , nominal_orn : npt . ArrayLike , nominal_vel : npt . ArrayLike , nominal_ang_vel : npt . ArrayLike , nominal_accel : npt . ArrayLike , nominal_alpha : npt . ArrayLike , pos_stdev : float , orn_stdev : float , vel_stdev : float , ang_vel_stdev : float , accel_stdev : float , alpha_stdev : float , ) -> list [ np . ndarray ]: \"\"\"Generate a sample about a nominal state Args: nominal_pos (npt.ArrayLike): Nominal desired position to sample about, shape (3,) nominal_orn (npt.ArrayLike): Nominal desired XYZW quaternion to sample about, shape (4,) nominal_vel (npt.ArrayLike): Nominal desired linear velocity to sample about, shape (3,) nominal_ang_vel (npt.ArrayLike): Nominal desired angular velocity to sample about, shape (3,) nominal_accel (npt.ArrayLike): Nominal desired linear acceleration to sample about, shape (3,) nominal_alpha (npt.ArrayLike): Nominal desired angular acceleration to sample about, shape (3,) pos_stdev (float): Standard deviation of the position sampling distribution orn_stdev (float): Standard deviation of the orientation sampling distribution vel_stdev (float): Standard deviation of the velocity sampling distribution ang_vel_stdev (float): Standard deviation of the angular velocity sampling distribution accel_stdev (float): Standard deviation of the linear acceleration sampling distribution alpha_stdev (float): Standard deviation of the angular acceleration sampling distribution Returns: list[np.ndarray]: Sampled state. Length = 6. Includes position, orientation, velocity, angular velocity, acceleration, and angular acceleration \"\"\" pos = np . random . multivariate_normal ( nominal_pos , pos_stdev ** 2 * np . eye ( 3 )) orn = spherical_vonmises_sampling ( nominal_orn , 1 / ( orn_stdev ** 2 ), 1 )[ 0 ] vel = np . random . multivariate_normal ( nominal_vel , vel_stdev ** 2 * np . eye ( 3 )) ang_vel = np . random . multivariate_normal ( nominal_ang_vel , ang_vel_stdev ** 2 * np . eye ( 3 ) ) accel = np . random . multivariate_normal ( nominal_accel , accel_stdev ** 2 * np . eye ( 3 )) alpha = np . random . multivariate_normal ( nominal_alpha , alpha_stdev ** 2 * np . eye ( 3 )) return [ pos , orn , vel , ang_vel , accel , alpha ] # TODO # - Decide if we should be passing in covariance matrices or arrays instead of scalars # - Decide if the \"orientation stdev\" should be replaced by the von Mises kappa parameter def generate_trajs ( cur_pos : npt . ArrayLike , cur_orn : npt . ArrayLike , cur_vel : npt . ArrayLike , cur_ang_vel : npt . ArrayLike , cur_accel : npt . ArrayLike , # Optional? cur_alpha : npt . ArrayLike , # Optional? nominal_target_pos : npt . ArrayLike , nominal_target_orn : npt . ArrayLike , nominal_target_vel : npt . ArrayLike , nominal_target_ang_vel : npt . ArrayLike , nominal_target_accel : npt . ArrayLike , # Optional? nominal_target_alpha : npt . ArrayLike , # Optional? pos_sampling_stdev : float , orn_sampling_stdev : float , vel_sampling_stdev : float , ang_vel_sampling_stdev : float , accel_sampling_stdev : float , alpha_sampling_stdev : float , n_trajs : int , duration : float , dt : float , include_nominal_traj : bool , ) -> list [ Trajectory ]: \"\"\"Generate a number of trajectories from the current state to a sampled state about a nominal target Args: cur_pos (npt.ArrayLike): Current position, shape (3,) cur_orn (npt.ArrayLike): Current XYZW quaternion orientation, shape (4,) cur_vel (npt.ArrayLike): Current linear velocity, shape (3,) cur_ang_vel (npt.ArrayLike): Current angular velocity, shape (3,) nominal_target_pos (npt.ArrayLike): Nominal desired position to sample about, shape (3,) nominal_target_orn (npt.ArrayLike): Nominal desired XYZW quaternion to sample about, shape (4,) nominal_target_vel (npt.ArrayLike): Nominal desired linear velocity to sample about, shape (3,) nominal_target_ang_vel (npt.ArrayLike): Nominal desired angular velocity to sample about, shape (3,) pos_sampling_stdev (float): Standard deviation of the position sampling distribution orn_sampling_stdev (float): Standard deviation of the orientation sampling distribution vel_sampling_stdev (float): Standard deviation of the velocity sampling distribution ang_vel_sampling_stdev (float): Standard deviation of the angular velocity sampling distribution n_trajs (int): Number of trajectories to generate duration (float): Trajectory duration, in seconds dt (float): Timestep include_nominal_traj (bool): Whether or not to include the nominal (non-sampled) trajectory in the output Returns: list[Trajectory]: Sampled trajectories, length n_trajs \"\"\" trajs = [] if include_nominal_traj : # Let the first generated trajectory use the mean of all of the distributions trajs . append ( local_planner ( cur_pos , cur_orn , cur_vel , cur_ang_vel , cur_accel , cur_alpha , nominal_target_pos , nominal_target_orn , nominal_target_vel , nominal_target_ang_vel , nominal_target_accel , nominal_target_alpha , duration , dt , ) ) # Reduce the number of trajectories to sample since we have added this nominal traj n_samples = n_trajs - 1 else : # Sample all of the trajectories n_samples = n_trajs if n_samples == 0 : return trajs # Sample endpoints for the candidate trajectories about the nominal targets sampled_positions = np . random . multivariate_normal ( nominal_target_pos , pos_sampling_stdev ** 2 * np . eye ( 3 ), n_samples ) sampled_quats = spherical_vonmises_sampling ( nominal_target_orn , 1 / ( orn_sampling_stdev ** 2 ), n_samples ) sampled_vels = np . random . multivariate_normal ( nominal_target_vel , vel_sampling_stdev ** 2 * np . eye ( 3 ), n_samples ) sampled_ang_vels = np . random . multivariate_normal ( nominal_target_ang_vel , ang_vel_sampling_stdev ** 2 * np . eye ( 3 ), n_samples ) sampled_accels = np . random . multivariate_normal ( nominal_target_accel , accel_sampling_stdev ** 2 * np . eye ( 3 ), n_samples ) sampled_alphas = np . random . multivariate_normal ( nominal_target_alpha , alpha_sampling_stdev ** 2 * np . eye ( 3 ), n_samples ) for i in range ( n_samples ): trajs . append ( local_planner ( cur_pos , cur_orn , cur_vel , cur_ang_vel , cur_accel , cur_alpha , sampled_positions [ i ], sampled_quats [ i ], sampled_vels [ i ], sampled_ang_vels [ i ], sampled_accels [ i ], sampled_alphas [ i ], duration , dt , ) ) return trajs","title":"Module pyastrobee.trajectories.sampling"},{"location":"reference/pyastrobee/trajectories/sampling/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/trajectories/sampling/#generate_trajs","text":"def generate_trajs ( cur_pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], cur_orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], cur_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], cur_ang_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], cur_accel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], cur_alpha : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], nominal_target_pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], nominal_target_orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], nominal_target_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], nominal_target_ang_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], nominal_target_accel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], nominal_target_alpha : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pos_sampling_stdev : float , orn_sampling_stdev : float , vel_sampling_stdev : float , ang_vel_sampling_stdev : float , accel_sampling_stdev : float , alpha_sampling_stdev : float , n_trajs : int , duration : float , dt : float , include_nominal_traj : bool ) -> list [ pyastrobee . trajectories . trajectory . Trajectory ] Generate a number of trajectories from the current state to a sampled state about a nominal target Parameters: Name Type Description Default cur_pos npt.ArrayLike Current position, shape (3,) None cur_orn npt.ArrayLike Current XYZW quaternion orientation, shape (4,) None cur_vel npt.ArrayLike Current linear velocity, shape (3,) None cur_ang_vel npt.ArrayLike Current angular velocity, shape (3,) None nominal_target_pos npt.ArrayLike Nominal desired position to sample about, shape (3,) None nominal_target_orn npt.ArrayLike Nominal desired XYZW quaternion to sample about, shape (4,) None nominal_target_vel npt.ArrayLike Nominal desired linear velocity to sample about, shape (3,) None nominal_target_ang_vel npt.ArrayLike Nominal desired angular velocity to sample about, shape (3,) None pos_sampling_stdev float Standard deviation of the position sampling distribution None orn_sampling_stdev float Standard deviation of the orientation sampling distribution None vel_sampling_stdev float Standard deviation of the velocity sampling distribution None ang_vel_sampling_stdev float Standard deviation of the angular velocity sampling distribution None n_trajs int Number of trajectories to generate None duration float Trajectory duration, in seconds None dt float Timestep None include_nominal_traj bool Whether or not to include the nominal (non-sampled) trajectory in the output None Returns: Type Description list[Trajectory] Sampled trajectories, length n_trajs View Source def generate_trajs ( cur_pos : npt . ArrayLike , cur_orn : npt . ArrayLike , cur_vel : npt . ArrayLike , cur_ang_vel : npt . ArrayLike , cur_accel : npt . ArrayLike , # Optional ? cur_alpha : npt . ArrayLike , # Optional ? nominal_target_pos : npt . ArrayLike , nominal_target_orn : npt . ArrayLike , nominal_target_vel : npt . ArrayLike , nominal_target_ang_vel : npt . ArrayLike , nominal_target_accel : npt . ArrayLike , # Optional ? nominal_target_alpha : npt . ArrayLike , # Optional ? pos_sampling_stdev : float , orn_sampling_stdev : float , vel_sampling_stdev : float , ang_vel_sampling_stdev : float , accel_sampling_stdev : float , alpha_sampling_stdev : float , n_trajs : int , duration : float , dt : float , include_nominal_traj : bool , ) -> list [ Trajectory ] : \"\"\"Generate a number of trajectories from the current state to a sampled state about a nominal target Args: cur_pos (npt.ArrayLike): Current position, shape (3,) cur_orn (npt.ArrayLike): Current XYZW quaternion orientation, shape (4,) cur_vel (npt.ArrayLike): Current linear velocity, shape (3,) cur_ang_vel (npt.ArrayLike): Current angular velocity, shape (3,) nominal_target_pos (npt.ArrayLike): Nominal desired position to sample about, shape (3,) nominal_target_orn (npt.ArrayLike): Nominal desired XYZW quaternion to sample about, shape (4,) nominal_target_vel (npt.ArrayLike): Nominal desired linear velocity to sample about, shape (3,) nominal_target_ang_vel (npt.ArrayLike): Nominal desired angular velocity to sample about, shape (3,) pos_sampling_stdev (float): Standard deviation of the position sampling distribution orn_sampling_stdev (float): Standard deviation of the orientation sampling distribution vel_sampling_stdev (float): Standard deviation of the velocity sampling distribution ang_vel_sampling_stdev (float): Standard deviation of the angular velocity sampling distribution n_trajs (int): Number of trajectories to generate duration (float): Trajectory duration, in seconds dt (float): Timestep include_nominal_traj (bool): Whether or not to include the nominal (non-sampled) trajectory in the output Returns: list[Trajectory]: Sampled trajectories, length n_trajs \"\"\" trajs = [] if include_nominal_traj : # Let the first generated trajectory use the mean of all of the distributions trajs . append ( local_planner ( cur_pos , cur_orn , cur_vel , cur_ang_vel , cur_accel , cur_alpha , nominal_target_pos , nominal_target_orn , nominal_target_vel , nominal_target_ang_vel , nominal_target_accel , nominal_target_alpha , duration , dt , ) ) # Reduce the number of trajectories to sample since we have added this nominal traj n_samples = n_trajs - 1 else : # Sample all of the trajectories n_samples = n_trajs if n_samples == 0 : return trajs # Sample endpoints for the candidate trajectories about the nominal targets sampled_positions = np . random . multivariate_normal ( nominal_target_pos , pos_sampling_stdev ** 2 * np . eye ( 3 ), n_samples ) sampled_quats = spherical_vonmises_sampling ( nominal_target_orn , 1 / ( orn_sampling_stdev ** 2 ), n_samples ) sampled_vels = np . random . multivariate_normal ( nominal_target_vel , vel_sampling_stdev ** 2 * np . eye ( 3 ), n_samples ) sampled_ang_vels = np . random . multivariate_normal ( nominal_target_ang_vel , ang_vel_sampling_stdev ** 2 * np . eye ( 3 ), n_samples ) sampled_accels = np . random . multivariate_normal ( nominal_target_accel , accel_sampling_stdev ** 2 * np . eye ( 3 ), n_samples ) sampled_alphas = np . random . multivariate_normal ( nominal_target_alpha , alpha_sampling_stdev ** 2 * np . eye ( 3 ), n_samples ) for i in range ( n_samples ) : trajs . append ( local_planner ( cur_pos , cur_orn , cur_vel , cur_ang_vel , cur_accel , cur_alpha , sampled_positions [ i ] , sampled_quats [ i ] , sampled_vels [ i ] , sampled_ang_vels [ i ] , sampled_accels [ i ] , sampled_alphas [ i ] , duration , dt , ) ) return trajs","title":"generate_trajs"},{"location":"reference/pyastrobee/trajectories/sampling/#sample_state","text":"def sample_state ( nominal_pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], nominal_orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], nominal_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], nominal_ang_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], nominal_accel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], nominal_alpha : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pos_stdev : float , orn_stdev : float , vel_stdev : float , ang_vel_stdev : float , accel_stdev : float , alpha_stdev : float ) -> list [ numpy . ndarray ] Generate a sample about a nominal state Parameters: Name Type Description Default nominal_pos npt.ArrayLike Nominal desired position to sample about, shape (3,) None nominal_orn npt.ArrayLike Nominal desired XYZW quaternion to sample about, shape (4,) None nominal_vel npt.ArrayLike Nominal desired linear velocity to sample about, shape (3,) None nominal_ang_vel npt.ArrayLike Nominal desired angular velocity to sample about, shape (3,) None nominal_accel npt.ArrayLike Nominal desired linear acceleration to sample about, shape (3,) None nominal_alpha npt.ArrayLike Nominal desired angular acceleration to sample about, shape (3,) None pos_stdev float Standard deviation of the position sampling distribution None orn_stdev float Standard deviation of the orientation sampling distribution None vel_stdev float Standard deviation of the velocity sampling distribution None ang_vel_stdev float Standard deviation of the angular velocity sampling distribution None accel_stdev float Standard deviation of the linear acceleration sampling distribution None alpha_stdev float Standard deviation of the angular acceleration sampling distribution None Returns: Type Description list[np.ndarray] Sampled state. Length = 6. Includes position, orientation, velocity, angular velocity, acceleration, and angular acceleration View Source def sample_state ( nominal_pos : npt . ArrayLike , nominal_orn : npt . ArrayLike , nominal_vel : npt . ArrayLike , nominal_ang_vel : npt . ArrayLike , nominal_accel : npt . ArrayLike , nominal_alpha : npt . ArrayLike , pos_stdev : float , orn_stdev : float , vel_stdev : float , ang_vel_stdev : float , accel_stdev : float , alpha_stdev : float , ) -> list [ np . ndarray ]: \"\"\"Generate a sample about a nominal state Args: nominal_pos (npt.ArrayLike): Nominal desired position to sample about, shape (3,) nominal_orn (npt.ArrayLike): Nominal desired XYZW quaternion to sample about, shape (4,) nominal_vel (npt.ArrayLike): Nominal desired linear velocity to sample about, shape (3,) nominal_ang_vel (npt.ArrayLike): Nominal desired angular velocity to sample about, shape (3,) nominal_accel (npt.ArrayLike): Nominal desired linear acceleration to sample about, shape (3,) nominal_alpha (npt.ArrayLike): Nominal desired angular acceleration to sample about, shape (3,) pos_stdev (float): Standard deviation of the position sampling distribution orn_stdev (float): Standard deviation of the orientation sampling distribution vel_stdev (float): Standard deviation of the velocity sampling distribution ang_vel_stdev (float): Standard deviation of the angular velocity sampling distribution accel_stdev (float): Standard deviation of the linear acceleration sampling distribution alpha_stdev (float): Standard deviation of the angular acceleration sampling distribution Returns: list[np.ndarray]: Sampled state. Length = 6. Includes position, orientation, velocity, angular velocity, acceleration, and angular acceleration \"\"\" pos = np . random . multivariate_normal ( nominal_pos , pos_stdev ** 2 * np . eye ( 3 )) orn = spherical_vonmises_sampling ( nominal_orn , 1 / ( orn_stdev ** 2 ), 1 )[ 0 ] vel = np . random . multivariate_normal ( nominal_vel , vel_stdev ** 2 * np . eye ( 3 )) ang_vel = np . random . multivariate_normal ( nominal_ang_vel , ang_vel_stdev ** 2 * np . eye ( 3 ) ) accel = np . random . multivariate_normal ( nominal_accel , accel_stdev ** 2 * np . eye ( 3 )) alpha = np . random . multivariate_normal ( nominal_alpha , alpha_stdev ** 2 * np . eye ( 3 )) return [ pos , orn , vel , ang_vel , accel , alpha ]","title":"sample_state"},{"location":"reference/pyastrobee/trajectories/simple_trajectories/","text":"Module pyastrobee.trajectories.simple_trajectories Simple examples of position/orientation trajectories View Source \"\"\"Simple examples of position/orientation trajectories\"\"\" import numpy as np import numpy.typing as npt from pyastrobee.utils.quaternions import ( quaternion_slerp , get_closest_heading_quat , quaternion_dist , ) from pyastrobee.utils.math_utils import normalize def point_and_move_pose_traj ( start_pose : npt . ArrayLike , end_pose : npt . ArrayLike , pos_step : float , orn_step : float , ) -> np . ndarray : \"\"\"Simple pose-only trajectory where the robot points at the goal, moves along a straight line, then aligns with the goal Args: start_pose (npt.ArrayLike): Starting position + xyzw quaternion pose, shape (7,) end_pose (npt.ArrayLike): Ending position + xyzw quaternion pose, shape (7,) pos_step (float): Position stepsize (meters) orn_step (float): Orientation stepsize (quaternion distance) Returns: np.ndarray: Trajectory, shape (n1 + n2 + n3, 7) \"\"\" # Interpolate the orientation, interpolate the position, interpolate the orientation start_position = start_pose [: 3 ] start_quat = start_pose [ 3 :] end_position = end_pose [: 3 ] end_quat = end_pose [ 3 :] # Trajectory part 1: Maintain same pose, turn to point towards the final position # First, need to find the quaternion to point in the right direction heading = normalize ( end_position - start_position ) heading_quat = get_closest_heading_quat ( start_quat , heading ) # Also determine the discretization based on this intermediate orientation n1 = int ( np . ceil ( quaternion_dist ( start_quat , heading_quat ) / orn_step )) traj_1 = fixed_pos_pose_traj ( start_position , start_quat , heading_quat , n1 ) # Trajectory part 2: Maintain the same orientation, move to final position n2 = int ( np . ceil ( np . linalg . norm ( end_position - start_position ) / pos_step )) traj_2 = fixed_orn_pose_traj ( start_position , end_position , heading_quat , n2 ) # Trajectory part 3: Maintain the same final position, turn to goal orientation n3 = int ( np . ceil ( quaternion_dist ( heading_quat , end_quat ) / orn_step )) traj_3 = fixed_pos_pose_traj ( end_position , heading_quat , end_quat , n3 ) # Merge the trajectory components together return np . vstack (( traj_1 , traj_2 , traj_3 )) def fixed_orn_pose_traj ( pos_1 : npt . ArrayLike , pos_2 : npt . ArrayLike , quat : npt . ArrayLike , n : int ) -> np . ndarray : \"\"\"Simple pose-only trajectory interpolated between two positions with a fixed orientation Args: pos_1 (npt.ArrayLike): Starting XYZ position, shape (3,) pos_2 (npt.ArrayLike): Ending XYZ position, shape (3,) quat (npt.ArrayLike): Fixed orientation (XYZW quaternion), shape (4,) n (int): Number of timesteps Returns: np.ndarray: Trajectory, shape (n, 7) \"\"\" positions = np . linspace ( pos_1 , pos_2 , n ) quats = quat * np . ones (( n , 4 )) return np . hstack (( positions , quats )) def fixed_pos_pose_traj ( pos : npt . ArrayLike , q1 : npt . ArrayLike , q2 : npt . ArrayLike , n : int ) -> np . ndarray : \"\"\"Simple pose-only trajectory interpolated between two orientations with a fixed position Args: pos (npt.ArrayLike): Fixed XYZ position, shape (3,) q1 (npt.ArrayLike): Starting orientation (XYZW quaternion), shape (4,) q2 (npt.ArrayLike): Ending orientation (XYZW quaternion), shape (4,) n (int): Number of timesteps Returns: np.ndarray: Trajectory, shape (n, 7) \"\"\" positions = pos * np . ones (( n , 3 )) quats = quaternion_slerp ( q1 , q2 , np . linspace ( 0 , 1 , n )) return np . hstack (( positions , quats )) def interpolation_pose_traj ( start_pose : npt . ArrayLike , end_pose : npt . ArrayLike , n : int ) -> np . ndarray : \"\"\"Simple pose-only trajectory, interpolates between two poses across n timesteps Args: start_pose (npt.ArrayLike): Starting position + xyzw quaternion pose, shape (7,) end_pose (npt.ArrayLike): Ending position + xyzw quaternion pose, shape (7,) n (int): Number of timesteps Returns: np.ndarray: Trajectory, shape (n, 7) \"\"\" start_position = start_pose [: 3 ] start_quat = start_pose [ 3 :] end_position = end_pose [: 3 ] end_quat = end_pose [ 3 :] positions = np . linspace ( start_position , end_position , n ) quats = quaternion_slerp ( start_quat , end_quat , np . linspace ( 0 , 1 , n )) return np . hstack (( positions , quats )) Functions fixed_orn_pose_traj def fixed_orn_pose_traj ( pos_1 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pos_2 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], quat : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], n : int ) -> numpy . ndarray Simple pose-only trajectory interpolated between two positions with a fixed orientation Parameters: Name Type Description Default pos_1 npt.ArrayLike Starting XYZ position, shape (3,) None pos_2 npt.ArrayLike Ending XYZ position, shape (3,) None quat npt.ArrayLike Fixed orientation (XYZW quaternion), shape (4,) None n int Number of timesteps None Returns: Type Description np.ndarray Trajectory, shape (n, 7) View Source def fixed_orn_pose_traj ( pos_1 : npt . ArrayLike , pos_2 : npt . ArrayLike , quat : npt . ArrayLike , n : int ) -> np . ndarray : \"\"\"Simple pose-only trajectory interpolated between two positions with a fixed orientation Args: pos_1 (npt.ArrayLike): Starting XYZ position, shape (3,) pos_2 (npt.ArrayLike): Ending XYZ position, shape (3,) quat (npt.ArrayLike): Fixed orientation (XYZW quaternion), shape (4,) n (int): Number of timesteps Returns: np.ndarray: Trajectory, shape (n, 7) \"\"\" positions = np . linspace ( pos_1 , pos_2 , n ) quats = quat * np . ones (( n , 4 )) return np . hstack (( positions , quats )) fixed_pos_pose_traj def fixed_pos_pose_traj ( pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], q1 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], q2 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], n : int ) -> numpy . ndarray Simple pose-only trajectory interpolated between two orientations with a fixed position Parameters: Name Type Description Default pos npt.ArrayLike Fixed XYZ position, shape (3,) None q1 npt.ArrayLike Starting orientation (XYZW quaternion), shape (4,) None q2 npt.ArrayLike Ending orientation (XYZW quaternion), shape (4,) None n int Number of timesteps None Returns: Type Description np.ndarray Trajectory, shape (n, 7) View Source def fixed_pos_pose_traj ( pos : npt . ArrayLike , q1 : npt . ArrayLike , q2 : npt . ArrayLike , n : int ) -> np . ndarray : \"\"\"Simple pose-only trajectory interpolated between two orientations with a fixed position Args: pos (npt.ArrayLike): Fixed XYZ position, shape (3,) q1 (npt.ArrayLike): Starting orientation (XYZW quaternion), shape (4,) q2 (npt.ArrayLike): Ending orientation (XYZW quaternion), shape (4,) n (int): Number of timesteps Returns: np.ndarray: Trajectory, shape (n, 7) \"\"\" positions = pos * np . ones (( n , 3 )) quats = quaternion_slerp ( q1 , q2 , np . linspace ( 0 , 1 , n )) return np . hstack (( positions , quats )) interpolation_pose_traj def interpolation_pose_traj ( start_pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], end_pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], n : int ) -> numpy . ndarray Simple pose-only trajectory, interpolates between two poses across n timesteps Parameters: Name Type Description Default start_pose npt.ArrayLike Starting position + xyzw quaternion pose, shape (7,) None end_pose npt.ArrayLike Ending position + xyzw quaternion pose, shape (7,) None n int Number of timesteps None Returns: Type Description np.ndarray Trajectory, shape (n, 7) View Source def interpolation_pose_traj ( start_pose : npt . ArrayLike , end_pose : npt . ArrayLike , n : int ) -> np . ndarray : \"\"\"Simple pose-only trajectory, interpolates between two poses across n timesteps Args: start_pose (npt.ArrayLike): Starting position + xyzw quaternion pose, shape (7,) end_pose (npt.ArrayLike): Ending position + xyzw quaternion pose, shape (7,) n (int): Number of timesteps Returns: np.ndarray: Trajectory, shape (n, 7) \"\"\" start_position = start_pose [: 3 ] start_quat = start_pose [ 3 :] end_position = end_pose [: 3 ] end_quat = end_pose [ 3 :] positions = np . linspace ( start_position , end_position , n ) quats = quaternion_slerp ( start_quat , end_quat , np . linspace ( 0 , 1 , n )) return np . hstack (( positions , quats )) point_and_move_pose_traj def point_and_move_pose_traj ( start_pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], end_pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pos_step : float , orn_step : float ) -> numpy . ndarray Simple pose-only trajectory where the robot points at the goal, moves along a straight line, then aligns with the goal Parameters: Name Type Description Default start_pose npt.ArrayLike Starting position + xyzw quaternion pose, shape (7,) None end_pose npt.ArrayLike Ending position + xyzw quaternion pose, shape (7,) None pos_step float Position stepsize (meters) None orn_step float Orientation stepsize (quaternion distance) None Returns: Type Description np.ndarray Trajectory, shape (n1 + n2 + n3, 7) View Source def point_and_move_pose_traj ( start_pose : npt . ArrayLike , end_pose : npt . ArrayLike , pos_step : float , orn_step : float , ) -> np . ndarray : \"\"\"Simple pose-only trajectory where the robot points at the goal, moves along a straight line, then aligns with the goal Args: start_pose (npt.ArrayLike): Starting position + xyzw quaternion pose, shape (7,) end_pose (npt.ArrayLike): Ending position + xyzw quaternion pose, shape (7,) pos_step (float): Position stepsize (meters) orn_step (float): Orientation stepsize (quaternion distance) Returns: np.ndarray: Trajectory, shape (n1 + n2 + n3, 7) \"\"\" # Interpolate the orientation , interpolate the position , interpolate the orientation start_position = start_pose [: 3 ] start_quat = start_pose [ 3 :] end_position = end_pose [: 3 ] end_quat = end_pose [ 3 :] # Trajectory part 1 : Maintain same pose , turn to point towards the final position # First , need to find the quaternion to point in the right direction heading = normalize ( end_position - start_position ) heading_quat = get_closest_heading_quat ( start_quat , heading ) # Also determine the discretization based on this intermediate orientation n1 = int ( np . ceil ( quaternion_dist ( start_quat , heading_quat ) / orn_step )) traj_1 = fixed_pos_pose_traj ( start_position , start_quat , heading_quat , n1 ) # Trajectory part 2 : Maintain the same orientation , move to final position n2 = int ( np . ceil ( np . linalg . norm ( end_position - start_position ) / pos_step )) traj_2 = fixed_orn_pose_traj ( start_position , end_position , heading_quat , n2 ) # Trajectory part 3 : Maintain the same final position , turn to goal orientation n3 = int ( np . ceil ( quaternion_dist ( heading_quat , end_quat ) / orn_step )) traj_3 = fixed_pos_pose_traj ( end_position , heading_quat , end_quat , n3 ) # Merge the trajectory components together return np . vstack (( traj_1 , traj_2 , traj_3 ))","title":"Simple Trajectories"},{"location":"reference/pyastrobee/trajectories/simple_trajectories/#module-pyastrobeetrajectoriessimple_trajectories","text":"Simple examples of position/orientation trajectories View Source \"\"\"Simple examples of position/orientation trajectories\"\"\" import numpy as np import numpy.typing as npt from pyastrobee.utils.quaternions import ( quaternion_slerp , get_closest_heading_quat , quaternion_dist , ) from pyastrobee.utils.math_utils import normalize def point_and_move_pose_traj ( start_pose : npt . ArrayLike , end_pose : npt . ArrayLike , pos_step : float , orn_step : float , ) -> np . ndarray : \"\"\"Simple pose-only trajectory where the robot points at the goal, moves along a straight line, then aligns with the goal Args: start_pose (npt.ArrayLike): Starting position + xyzw quaternion pose, shape (7,) end_pose (npt.ArrayLike): Ending position + xyzw quaternion pose, shape (7,) pos_step (float): Position stepsize (meters) orn_step (float): Orientation stepsize (quaternion distance) Returns: np.ndarray: Trajectory, shape (n1 + n2 + n3, 7) \"\"\" # Interpolate the orientation, interpolate the position, interpolate the orientation start_position = start_pose [: 3 ] start_quat = start_pose [ 3 :] end_position = end_pose [: 3 ] end_quat = end_pose [ 3 :] # Trajectory part 1: Maintain same pose, turn to point towards the final position # First, need to find the quaternion to point in the right direction heading = normalize ( end_position - start_position ) heading_quat = get_closest_heading_quat ( start_quat , heading ) # Also determine the discretization based on this intermediate orientation n1 = int ( np . ceil ( quaternion_dist ( start_quat , heading_quat ) / orn_step )) traj_1 = fixed_pos_pose_traj ( start_position , start_quat , heading_quat , n1 ) # Trajectory part 2: Maintain the same orientation, move to final position n2 = int ( np . ceil ( np . linalg . norm ( end_position - start_position ) / pos_step )) traj_2 = fixed_orn_pose_traj ( start_position , end_position , heading_quat , n2 ) # Trajectory part 3: Maintain the same final position, turn to goal orientation n3 = int ( np . ceil ( quaternion_dist ( heading_quat , end_quat ) / orn_step )) traj_3 = fixed_pos_pose_traj ( end_position , heading_quat , end_quat , n3 ) # Merge the trajectory components together return np . vstack (( traj_1 , traj_2 , traj_3 )) def fixed_orn_pose_traj ( pos_1 : npt . ArrayLike , pos_2 : npt . ArrayLike , quat : npt . ArrayLike , n : int ) -> np . ndarray : \"\"\"Simple pose-only trajectory interpolated between two positions with a fixed orientation Args: pos_1 (npt.ArrayLike): Starting XYZ position, shape (3,) pos_2 (npt.ArrayLike): Ending XYZ position, shape (3,) quat (npt.ArrayLike): Fixed orientation (XYZW quaternion), shape (4,) n (int): Number of timesteps Returns: np.ndarray: Trajectory, shape (n, 7) \"\"\" positions = np . linspace ( pos_1 , pos_2 , n ) quats = quat * np . ones (( n , 4 )) return np . hstack (( positions , quats )) def fixed_pos_pose_traj ( pos : npt . ArrayLike , q1 : npt . ArrayLike , q2 : npt . ArrayLike , n : int ) -> np . ndarray : \"\"\"Simple pose-only trajectory interpolated between two orientations with a fixed position Args: pos (npt.ArrayLike): Fixed XYZ position, shape (3,) q1 (npt.ArrayLike): Starting orientation (XYZW quaternion), shape (4,) q2 (npt.ArrayLike): Ending orientation (XYZW quaternion), shape (4,) n (int): Number of timesteps Returns: np.ndarray: Trajectory, shape (n, 7) \"\"\" positions = pos * np . ones (( n , 3 )) quats = quaternion_slerp ( q1 , q2 , np . linspace ( 0 , 1 , n )) return np . hstack (( positions , quats )) def interpolation_pose_traj ( start_pose : npt . ArrayLike , end_pose : npt . ArrayLike , n : int ) -> np . ndarray : \"\"\"Simple pose-only trajectory, interpolates between two poses across n timesteps Args: start_pose (npt.ArrayLike): Starting position + xyzw quaternion pose, shape (7,) end_pose (npt.ArrayLike): Ending position + xyzw quaternion pose, shape (7,) n (int): Number of timesteps Returns: np.ndarray: Trajectory, shape (n, 7) \"\"\" start_position = start_pose [: 3 ] start_quat = start_pose [ 3 :] end_position = end_pose [: 3 ] end_quat = end_pose [ 3 :] positions = np . linspace ( start_position , end_position , n ) quats = quaternion_slerp ( start_quat , end_quat , np . linspace ( 0 , 1 , n )) return np . hstack (( positions , quats ))","title":"Module pyastrobee.trajectories.simple_trajectories"},{"location":"reference/pyastrobee/trajectories/simple_trajectories/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/trajectories/simple_trajectories/#fixed_orn_pose_traj","text":"def fixed_orn_pose_traj ( pos_1 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pos_2 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], quat : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], n : int ) -> numpy . ndarray Simple pose-only trajectory interpolated between two positions with a fixed orientation Parameters: Name Type Description Default pos_1 npt.ArrayLike Starting XYZ position, shape (3,) None pos_2 npt.ArrayLike Ending XYZ position, shape (3,) None quat npt.ArrayLike Fixed orientation (XYZW quaternion), shape (4,) None n int Number of timesteps None Returns: Type Description np.ndarray Trajectory, shape (n, 7) View Source def fixed_orn_pose_traj ( pos_1 : npt . ArrayLike , pos_2 : npt . ArrayLike , quat : npt . ArrayLike , n : int ) -> np . ndarray : \"\"\"Simple pose-only trajectory interpolated between two positions with a fixed orientation Args: pos_1 (npt.ArrayLike): Starting XYZ position, shape (3,) pos_2 (npt.ArrayLike): Ending XYZ position, shape (3,) quat (npt.ArrayLike): Fixed orientation (XYZW quaternion), shape (4,) n (int): Number of timesteps Returns: np.ndarray: Trajectory, shape (n, 7) \"\"\" positions = np . linspace ( pos_1 , pos_2 , n ) quats = quat * np . ones (( n , 4 )) return np . hstack (( positions , quats ))","title":"fixed_orn_pose_traj"},{"location":"reference/pyastrobee/trajectories/simple_trajectories/#fixed_pos_pose_traj","text":"def fixed_pos_pose_traj ( pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], q1 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], q2 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], n : int ) -> numpy . ndarray Simple pose-only trajectory interpolated between two orientations with a fixed position Parameters: Name Type Description Default pos npt.ArrayLike Fixed XYZ position, shape (3,) None q1 npt.ArrayLike Starting orientation (XYZW quaternion), shape (4,) None q2 npt.ArrayLike Ending orientation (XYZW quaternion), shape (4,) None n int Number of timesteps None Returns: Type Description np.ndarray Trajectory, shape (n, 7) View Source def fixed_pos_pose_traj ( pos : npt . ArrayLike , q1 : npt . ArrayLike , q2 : npt . ArrayLike , n : int ) -> np . ndarray : \"\"\"Simple pose-only trajectory interpolated between two orientations with a fixed position Args: pos (npt.ArrayLike): Fixed XYZ position, shape (3,) q1 (npt.ArrayLike): Starting orientation (XYZW quaternion), shape (4,) q2 (npt.ArrayLike): Ending orientation (XYZW quaternion), shape (4,) n (int): Number of timesteps Returns: np.ndarray: Trajectory, shape (n, 7) \"\"\" positions = pos * np . ones (( n , 3 )) quats = quaternion_slerp ( q1 , q2 , np . linspace ( 0 , 1 , n )) return np . hstack (( positions , quats ))","title":"fixed_pos_pose_traj"},{"location":"reference/pyastrobee/trajectories/simple_trajectories/#interpolation_pose_traj","text":"def interpolation_pose_traj ( start_pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], end_pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], n : int ) -> numpy . ndarray Simple pose-only trajectory, interpolates between two poses across n timesteps Parameters: Name Type Description Default start_pose npt.ArrayLike Starting position + xyzw quaternion pose, shape (7,) None end_pose npt.ArrayLike Ending position + xyzw quaternion pose, shape (7,) None n int Number of timesteps None Returns: Type Description np.ndarray Trajectory, shape (n, 7) View Source def interpolation_pose_traj ( start_pose : npt . ArrayLike , end_pose : npt . ArrayLike , n : int ) -> np . ndarray : \"\"\"Simple pose-only trajectory, interpolates between two poses across n timesteps Args: start_pose (npt.ArrayLike): Starting position + xyzw quaternion pose, shape (7,) end_pose (npt.ArrayLike): Ending position + xyzw quaternion pose, shape (7,) n (int): Number of timesteps Returns: np.ndarray: Trajectory, shape (n, 7) \"\"\" start_position = start_pose [: 3 ] start_quat = start_pose [ 3 :] end_position = end_pose [: 3 ] end_quat = end_pose [ 3 :] positions = np . linspace ( start_position , end_position , n ) quats = quaternion_slerp ( start_quat , end_quat , np . linspace ( 0 , 1 , n )) return np . hstack (( positions , quats ))","title":"interpolation_pose_traj"},{"location":"reference/pyastrobee/trajectories/simple_trajectories/#point_and_move_pose_traj","text":"def point_and_move_pose_traj ( start_pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], end_pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pos_step : float , orn_step : float ) -> numpy . ndarray Simple pose-only trajectory where the robot points at the goal, moves along a straight line, then aligns with the goal Parameters: Name Type Description Default start_pose npt.ArrayLike Starting position + xyzw quaternion pose, shape (7,) None end_pose npt.ArrayLike Ending position + xyzw quaternion pose, shape (7,) None pos_step float Position stepsize (meters) None orn_step float Orientation stepsize (quaternion distance) None Returns: Type Description np.ndarray Trajectory, shape (n1 + n2 + n3, 7) View Source def point_and_move_pose_traj ( start_pose : npt . ArrayLike , end_pose : npt . ArrayLike , pos_step : float , orn_step : float , ) -> np . ndarray : \"\"\"Simple pose-only trajectory where the robot points at the goal, moves along a straight line, then aligns with the goal Args: start_pose (npt.ArrayLike): Starting position + xyzw quaternion pose, shape (7,) end_pose (npt.ArrayLike): Ending position + xyzw quaternion pose, shape (7,) pos_step (float): Position stepsize (meters) orn_step (float): Orientation stepsize (quaternion distance) Returns: np.ndarray: Trajectory, shape (n1 + n2 + n3, 7) \"\"\" # Interpolate the orientation , interpolate the position , interpolate the orientation start_position = start_pose [: 3 ] start_quat = start_pose [ 3 :] end_position = end_pose [: 3 ] end_quat = end_pose [ 3 :] # Trajectory part 1 : Maintain same pose , turn to point towards the final position # First , need to find the quaternion to point in the right direction heading = normalize ( end_position - start_position ) heading_quat = get_closest_heading_quat ( start_quat , heading ) # Also determine the discretization based on this intermediate orientation n1 = int ( np . ceil ( quaternion_dist ( start_quat , heading_quat ) / orn_step )) traj_1 = fixed_pos_pose_traj ( start_position , start_quat , heading_quat , n1 ) # Trajectory part 2 : Maintain the same orientation , move to final position n2 = int ( np . ceil ( np . linalg . norm ( end_position - start_position ) / pos_step )) traj_2 = fixed_orn_pose_traj ( start_position , end_position , heading_quat , n2 ) # Trajectory part 3 : Maintain the same final position , turn to goal orientation n3 = int ( np . ceil ( quaternion_dist ( heading_quat , end_quat ) / orn_step )) traj_3 = fixed_pos_pose_traj ( end_position , heading_quat , end_quat , n3 ) # Merge the trajectory components together return np . vstack (( traj_1 , traj_2 , traj_3 ))","title":"point_and_move_pose_traj"},{"location":"reference/pyastrobee/trajectories/splines/","text":"Module pyastrobee.trajectories.splines Splines / \"composite Bezier curves\" composed of multiple chained Bezier curves Initial boundary conditions are imposed on the start of the first curve, final B.C.s are imposed at the end of the third curve, and we enforce C2 derivative continuity at the knot points Reference: Fast Path Planning Through Large Collections of Safe Boxes https://github.com/cvxgrp/fastpathplanning/blob/main/fastpathplanning/smooth.py https://web.stanford.edu/~boyd/papers/pdf/fpp.pdf View Source \"\"\"Splines / \"composite Bezier curves\" composed of multiple chained Bezier curves Initial boundary conditions are imposed on the start of the first curve, final B.C.s are imposed at the end of the third curve, and we enforce C2 derivative continuity at the knot points Reference: Fast Path Planning Through Large Collections of Safe Boxes https://github.com/cvxgrp/fastpathplanning/blob/main/fastpathplanning/smooth.py https://web.stanford.edu/~boyd/papers/pdf/fpp.pdf \"\"\" from typing import Optional , Union , Any import cvxpy as cp import numpy as np import numpy.typing as npt import pybullet from pyastrobee.trajectories.bezier import BezierCurve from pyastrobee.utils.boxes import Box , visualize_3D_box from pyastrobee.utils.debug_visualizer import visualize_path , visualize_points from pyastrobee.utils.python_utils import print_red from pyastrobee.trajectories.timing import retiming from pyastrobee.utils.errors import OptimizationError class CompositeBezierCurve : \"\"\"Composite Bezier curve class for a continuous chain of connected Bezier curves Args: beziers (list[BezierCurve]): Consecutive Bezier curves composing the composite curve. \"\"\" def __init__ ( self , beziers : list [ BezierCurve ]): for bez1 , bez2 in zip ( beziers [: - 1 ], beziers [ 1 :]): assert bez1 . b == bez2 . a assert bez1 . d == bez2 . d self . beziers = beziers self . N = len ( self . beziers ) self . d = beziers [ 0 ] . d self . a = beziers [ 0 ] . a self . b = beziers [ - 1 ] . b self . duration = self . b - self . a self . transition_times = np . array ([ self . a ] + [ bez . b for bez in beziers ]) self . segment_durations = np . array ([ bez . duration for bez in beziers ]) def find_segment ( self , t ): # return min(bisect(self.transition_times, t) - 1, self.N - 1) # TODO check to see if this will work on a cp variable (probably not...) return np . minimum ( np . searchsorted ( self . transition_times , t , \"right\" ) - 1 , self . N - 1 ) def __call__ ( self , t : Union [ float , np . ndarray ]) -> np . ndarray : \"\"\"Evaluates the composite Bezier curve at specified points, by calling each of the child curves Args: t (Union[float, npt.ArrayLike]): Evaluation points (for instance, trajectory times) Returns: np.ndarray: Points along the composite curve, shape (n_pts, dimension) \"\"\" seg_map = self . find_segment ( t ) evals = [] for i in range ( self . N ): evals . append ( self . beziers [ i ]( t [ seg_map == i ])) return np . row_stack ( evals ) @property def start_point ( self ): \"\"\"Starting point of the composite Bezier curve (the first point of the first curve)\"\"\" return self . beziers [ 0 ] . start_point @property def end_point ( self ): \"\"\"Ending point of the composite Bezier curve (the last point of the last curve)\"\"\" return self . beziers [ - 1 ] . end_point @property def derivative ( self ): \"\"\"Derivative of the composite Bezier curve (a composite Bezier curve of derivative curves)\"\"\" return CompositeBezierCurve ([ b . derivative for b in self . beziers ]) @property def l2_squared_sum ( self ) -> Union [ float , cp . Expression ]: \"\"\"Sum of the squared L2 norm for all curves\"\"\" return sum ( bez . l2_squared for bez in self . beziers ) def spline_trajectory_with_retiming ( p0 : npt . ArrayLike , pf : npt . ArrayLike , t0 : float , tf : float , pts_per_curve : int , boxes : list [ Box ], initial_durations : npt . ArrayLike , v0 : Optional [ npt . ArrayLike ] = None , vf : Optional [ npt . ArrayLike ] = None , a0 : Optional [ npt . ArrayLike ] = None , af : Optional [ npt . ArrayLike ] = None , v_max : Optional [ float ] = None , a_max : Optional [ float ] = None , kappa_min : float = 1e-2 , omega : float = 3 , max_retiming_iters : int = 10 , time_weight : float = 0 , ) -> tuple [ CompositeBezierCurve , float ]: \"\"\"Generate a min-jerk trajectory based on chained Bezier curves through a set of safe boxes, for a set time interval. Use an iterative retiming method to refine the durations for each segment of the trajectory We enforce continuity between curves up to the second derivative Note: if position is unconstrained (no need for safe boxes), you should instead use a single Bezier curve Args: p0 (npt.ArrayLike): Initial position, shape (3,) pf (npt.ArrayLike): Final position, shape (3,) t0 (float): Starting time tf (float): Ending time pts_per_curve (int): Number of control points per Bezier curve. Generally, should be around 6-10 boxes (list[Box]): Sequential list of safe box regions pass through initial_durations (npt.ArrayLike): Initial estimate of the durations for each segment of the trajectory. These will be refined during the retiming process. Shape (num_boxes,) v0 (Optional[npt.ArrayLike]): Initial velocity, shape (3,). Defaults to None (unconstrained) vf (Optional[npt.ArrayLike]): Final velocity, shape (3,). Defaults to None (unconstrained) a0 (Optional[npt.ArrayLike]): Initial acceleration, shape (3,). Defaults to None (unconstrained) af (Optional[npt.ArrayLike]): Final acceleration, shape (3,). Defaults to None (unconstrained) v_max (Optional[float]): Maximum L2 norm of the velocity. Defaults to None (unconstrained) a_max (Optional[float]): Maximum L2 norm of the acceleration. Defaults to None (unconstrained) kappa_min (float, optional): Retiming trust region parameter: Defines the maximum change in adjacent scaling factors. Defaults to 1e-2. omega (float, optional): Retiming parameter: Defines the rate at which kappa decays after each iteration. Must be > 1. Small values (~2) work well when transition time estimates are poor, but larger values (~5) are more effective otherwise. Defaults to 3. max_retiming_iters (int, optional): Maximum number of iterations for the retiming process. Defaults to 10. time_weight (float, optional): Objective function weight corresponding to a linear penalty on the duration. Defaults to 0 (minimize jerk only). Note: this should be > 0 if evaluating the free-final-time case Returns: tuple[CompositeBezierCurve, float]: CompositeBezierCurve: The optimal curve for the position component of the trajectory. Note: derivatives can be evaluated using the curve.derivative property float: The optimal cost of the objective function \"\"\" # Handle inputs if tf <= t0 : raise ValueError ( f \"Invalid time interval: ( { t0 } , { tf } )\" ) if omega <= 1 : raise ValueError ( \"The retiming parameter omega must be > 1\" ) if pts_per_curve < 6 : print_red ( \"WARNING: Curves with less than 6 control points may lead to infeasible constraints\" ) # Store the curve parameters so that we can reuse these in the repeated calls to the spline function curve_kwargs = dict ( p0 = p0 , pf = pf , t0 = t0 , tf = tf , pts_per_curve = pts_per_curve , boxes = boxes , v0 = v0 , vf = vf , a0 = a0 , af = af , v_max = v_max , a_max = a_max , time_weight = time_weight , ) # Solve a preliminary trajectory for this initial guess at the durations durations = initial_durations curve_kwargs [ \"durations\" ] = durations best_curve , best_info = _fixed_timing_spline ( ** curve_kwargs ) kappa = 1 # Initialize the trust region parameter for _ in range ( max_retiming_iters ): # Retime. try : new_durations , kappa_max = retiming ( kappa , best_info [ \"cost_breakdown\" ], durations , best_info [ \"retiming_weights\" ], ) except OptimizationError : print_red ( \"Spline trajectory generation terminated due to failure to solve the retiming problem. \\n \" + \"This can sometimes be due to a poor initialization of the curve durations, \" + \"or having a time horizon that is too short\" ) break # Improve Bezier curves based on the retiming curve_kwargs [ \"durations\" ] = new_durations new_curve , new_info = _fixed_timing_spline ( ** curve_kwargs ) print ( \"Retiming cost: \" , new_info [ \"cost\" ]) if new_info [ \"cost\" ] < best_info [ \"cost\" ]: # Accept trajectory with new durations durations = new_durations best_info = new_info best_curve = new_curve # Update trust region if kappa < kappa_min : break kappa = kappa_max / omega else : print_red ( \"Spline trajectory generation terminated due to reaching the maximum number of iterations\" ) return best_curve , best_info [ \"cost\" ] def _fixed_timing_spline ( p0 : npt . ArrayLike , pf : npt . ArrayLike , t0 : float , tf : float , pts_per_curve : int , boxes : list [ Box ], durations : npt . ArrayLike , v0 : Optional [ npt . ArrayLike ] = None , vf : Optional [ npt . ArrayLike ] = None , a0 : Optional [ npt . ArrayLike ] = None , af : Optional [ npt . ArrayLike ] = None , v_max : Optional [ float ] = None , a_max : Optional [ float ] = None , time_weight : float = 0 , ) -> tuple [ CompositeBezierCurve , dict [ str , Any ]]: \"\"\"Generate a min-jerk spline based on chained Bezier curves through a set of safe boxes, for a fixed time interval and fixed durations within each box NOTE: This is NOT globally optimal if we don't use the retiming process to refine the time breakdown, which is why this is a helper function that gets called within the trajectory-with-retiming function Args: p0 (npt.ArrayLike): Initial position, shape (3,) pf (npt.ArrayLike): Final position, shape (3,) t0 (float): Starting time tf (float): Ending time pts_per_curve (int): Number of control points per Bezier curve. Generally, should be around 6-10 boxes (list[Box]): Sequential list of safe box regions pass through durations (npt.ArrayLike): Durations for each segment of the trajectory, shape (num_boxes,) v0 (Optional[npt.ArrayLike]): Initial velocity, shape (3,). Defaults to None (unconstrained) vf (Optional[npt.ArrayLike]): Final velocity, shape (3,). Defaults to None (unconstrained) a0 (Optional[npt.ArrayLike]): Initial acceleration, shape (3,). Defaults to None (unconstrained) af (Optional[npt.ArrayLike]): Final acceleration, shape (3,). Defaults to None (unconstrained) v_max (Optional[float]): Maximum L2 norm of the velocity. Defaults to None (unconstrained) a_max (Optional[float]): Maximum L2 norm of the acceleration. Defaults to None (unconstrained) time_weight (float, optional): Objective function weight corresponding to a linear penalty on the duration. Defaults to 0 (minimize jerk only). Note: this should be > 0 if evaluating the free-final-time case Returns: tuple[CompositeBezierCurve, dict[str, Any]]: CompositeBezierCurve: The solved position curve dict[str, Any]: Solution info to use for retiming optimization \"\"\" dim = len ( p0 ) n_curves = len ( boxes ) # Construct our main optimization variable all_control_points = cp . Variable (( n_curves * pts_per_curve , dim )) # Determine the knot times between trajectory segments # Includes start/end times as knots too, for ease of indexing knot_times = np . concatenate ([[ t0 ], np . cumsum ( durations )]) knot_times [ - 1 ] = tf # Fix floating pt issue with cumsum # Indexing from the main cvxpy variable containing all of the control points pos_pt_sets = [ all_control_points [ pts_per_curve * i : pts_per_curve * ( i + 1 )] for i in range ( n_curves ) ] pos_curves = [ BezierCurve ( pos_pt_sets [ i ], knot_times [ i ], knot_times [ i + 1 ]) for i in range ( n_curves ) ] # Set up derivative curves and the points associated with them vel_curves = [ pc . derivative for pc in pos_curves ] accel_curves = [ vc . derivative for vc in vel_curves ] jerk_curves = [ ac . derivative for ac in accel_curves ] vel_pt_sets = [ vc . points for vc in vel_curves ] accel_pt_sets = [ ac . points for ac in accel_curves ] # Set up constraints pos_continuity = [ pos_pt_sets [ i ][ - 1 ] == pos_pt_sets [ i + 1 ][ 0 ] for i in range ( n_curves - 1 ) ] vel_continuity = [ vel_pt_sets [ i ][ - 1 ] == vel_pt_sets [ i + 1 ][ 0 ] for i in range ( n_curves - 1 ) ] accel_continuity = [ accel_pt_sets [ i ][ - 1 ] == accel_pt_sets [ i + 1 ][ 0 ] for i in range ( n_curves - 1 ) ] continuity_constraints = pos_continuity + vel_continuity + accel_continuity bc_constraints = [ pos_pt_sets [ 0 ][ 0 ] == p0 , pos_pt_sets [ - 1 ][ - 1 ] == pf ] if v0 is not None : bc_constraints . append ( vel_pt_sets [ 0 ][ 0 ] == v0 ) if a0 is not None : bc_constraints . append ( accel_pt_sets [ 0 ][ 0 ] == a0 ) if vf is not None : bc_constraints . append ( vel_pt_sets [ - 1 ][ - 1 ] == vf ) if af is not None : bc_constraints . append ( accel_pt_sets [ - 1 ][ - 1 ] == af ) box_constraints = [] for i , box in enumerate ( boxes ): lower , upper = box n = pos_pt_sets [ i ] . shape [ 0 ] # Number of control points in ith curve box_constraints . append ( pos_pt_sets [ i ] >= np . tile ( lower , ( n , 1 ))) box_constraints . append ( pos_pt_sets [ i ] <= np . tile ( upper , ( n , 1 ))) dyn_constraints = [] if v_max is not None : for i in range ( n_curves ): dyn_constraints . append ( cp . norm2 ( vel_pt_sets [ i ], axis = 1 ) <= v_max ) if a_max is not None : for i in range ( n_curves ): dyn_constraints . append ( cp . norm2 ( accel_pt_sets [ i ], axis = 1 ) <= a_max ) # Merge the lists of constraints together constraints = ( continuity_constraints + bc_constraints + box_constraints + dyn_constraints ) # Complete the problem formulation and solve it jerk = sum ( jc . l2_squared for jc in jerk_curves ) objective = cp . Minimize ( jerk + time_weight * ( tf - t0 )) prob = cp . Problem ( objective , constraints ) try : prob . solve ( solver = cp . CLARABEL ) except cp . error . SolverError as e : raise OptimizationError ( \"Cannot generate the trajectory - Solver error!\" ) from e if prob . status != cp . OPTIMAL : raise OptimizationError ( f \"Unable to generate the trajectory (solver status: { prob . status } ). \\n \" + \"Check on the feasibility of the constraints\" ) # Form info about the solution to match the methodology from FPP, so we can use this for retiming # For more details on this, refer to the FPP source code and paper cost_breakdown = {} for k in range ( n_curves ): cost_breakdown [ k ] = {} cost_breakdown [ k ][ 3 ] = jerk_curves [ k ] . l2_squared . value retiming_weights = {} for k in range ( n_curves - 1 ): retiming_weights [ k ] = {} vel_primal = vel_curves [ k ] . points [ - 1 ] . value vel_dual = vel_continuity [ k ] . dual_value retiming_weights [ k ][ 1 ] = vel_primal . dot ( vel_dual ) accel_primal = accel_curves [ k ] . points [ - 1 ] . value accel_dual = accel_continuity [ k ] . dual_value retiming_weights [ k ][ 2 ] = accel_primal . dot ( accel_dual ) info = { \"cost\" : prob . value , \"retiming_weights\" : retiming_weights , \"cost_breakdown\" : cost_breakdown , } # Construct the Bezier curves from the solved control points, solved_pos_curves = [ BezierCurve ( pos_pt_sets [ i ] . value , knot_times [ i ], knot_times [ i + 1 ]) for i in range ( n_curves ) ] solved_pos_spline = CompositeBezierCurve ( solved_pos_curves ) return solved_pos_spline , info def _test_spline_trajectory (): \"\"\"Construct and visualize an optimal trajectory composed of three curves between safe sets\"\"\" p0 = [ 0.1 , 0.2 , 0.3 ] pf = [ 1.5 , 5 , 1.7 ] t0 = 0 tf = 5 pts_per_curve = 8 v0 = np . zeros ( 3 ) vf = np . zeros ( 3 ) a0 = np . zeros ( 3 ) af = np . zeros ( 3 ) boxes = [ Box (( 0 , 0 , 0 ), ( 1 , 1 , 1 )), Box (( 0.5 , 0.5 , 0.5 ), ( 1.5 , 5 , 1.5 )), Box (( 1 , 4.5 , 1 ), ( 2 , 5.5 , 2 )), ] n_curves = len ( boxes ) durations = np . ones ( n_curves ) * ( tf - t0 ) / n_curves n_timesteps = 50 times = np . linspace ( t0 , tf , n_timesteps , endpoint = True ) pos_curve , * _ = _fixed_timing_spline ( p0 , pf , t0 , tf , pts_per_curve , boxes , durations , v0 , vf , a0 , af ) pos_pts = pos_curve ( times ) pos_curve_retimed , cost = spline_trajectory_with_retiming ( p0 , pf , t0 , tf , pts_per_curve , boxes , durations , v0 , vf , a0 , af ) pos = pos_curve_retimed ( np . linspace ( t0 , tf , n_timesteps )) pybullet . connect ( pybullet . GUI ) visualize_points ( np . vstack ([ p0 , pf ]), ( 0 , 0 , 1 )) for box in boxes : visualize_3D_box ( box ) simple_traj_color = ( 0 , 0 , 1 ) retimed_traj_color = ( 0 , 1 , 0 ) visualize_path ( pos_pts , 10 , simple_traj_color ) visualize_path ( pos , 10 , retimed_traj_color ) pybullet . addUserDebugText ( \"Original curve\" , [ 0 , 0 , - 0.2 ], simple_traj_color ) pybullet . addUserDebugText ( \"Retimed curve\" , [ 0 , 0 , - 0.4 ], retimed_traj_color ) input () if __name__ == \"__main__\" : # _test_plotting_spline() _test_spline_trajectory () Functions spline_trajectory_with_retiming def spline_trajectory_with_retiming ( p0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], t0 : float , tf : float , pts_per_curve : int , boxes : list [ pyastrobee . utils . boxes . Box ], initial_durations : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], v0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , vf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , a0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , af : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , v_max : Optional [ float ] = None , a_max : Optional [ float ] = None , kappa_min : float = 0.01 , omega : float = 3 , max_retiming_iters : int = 10 , time_weight : float = 0 ) -> tuple [ pyastrobee . trajectories . splines . CompositeBezierCurve , float ] Generate a min-jerk trajectory based on chained Bezier curves through a set of safe boxes, for a set time interval. Use an iterative retiming method to refine the durations for each segment of the trajectory We enforce continuity between curves up to the second derivative Note: if position is unconstrained (no need for safe boxes), you should instead use a single Bezier curve Parameters: Name Type Description Default p0 npt.ArrayLike Initial position, shape (3,) None pf npt.ArrayLike Final position, shape (3,) None t0 float Starting time None tf float Ending time None pts_per_curve int Number of control points per Bezier curve. Generally, should be around 6-10 None boxes list[Box] Sequential list of safe box regions pass through None initial_durations npt.ArrayLike Initial estimate of the durations for each segment of the trajectory. These will be refined during the retiming process. Shape (num_boxes,) None v0 Optional[npt.ArrayLike] Initial velocity, shape (3,). Defaults to None (unconstrained) None vf Optional[npt.ArrayLike] Final velocity, shape (3,). Defaults to None (unconstrained) None a0 Optional[npt.ArrayLike] Initial acceleration, shape (3,). Defaults to None (unconstrained) None af Optional[npt.ArrayLike] Final acceleration, shape (3,). Defaults to None (unconstrained) None v_max Optional[float] Maximum L2 norm of the velocity. Defaults to None (unconstrained) None a_max Optional[float] Maximum L2 norm of the acceleration. Defaults to None (unconstrained) None kappa_min float Retiming trust region parameter: Defines the maximum change in adjacent scaling factors. Defaults to 1e-2. None omega float Retiming parameter: Defines the rate at which kappa decays after each iteration. Must be > 1. Small values (~2) work well when transition time estimates are poor, but larger values (~5) are more effective otherwise. Defaults to 3. None max_retiming_iters int Maximum number of iterations for the retiming process. Defaults to 10. 10 time_weight float Objective function weight corresponding to a linear penalty on the duration. Defaults to 0 (minimize jerk only). Note: this should be > 0 if evaluating the free-final-time case None Returns: Type Description tuple[CompositeBezierCurve, float] CompositeBezierCurve: The optimal curve for the position component of the trajectory. Note: derivatives can be evaluated using the curve.derivative property float: The optimal cost of the objective function View Source def spline_trajectory_with_retiming ( p0 : npt . ArrayLike , pf : npt . ArrayLike , t0 : float , tf : float , pts_per_curve : int , boxes : list [ Box ] , initial_durations : npt . ArrayLike , v0 : Optional [ npt.ArrayLike ] = None , vf : Optional [ npt.ArrayLike ] = None , a0 : Optional [ npt.ArrayLike ] = None , af : Optional [ npt.ArrayLike ] = None , v_max : Optional [ float ] = None , a_max : Optional [ float ] = None , kappa_min : float = 1e-2 , omega : float = 3 , max_retiming_iters : int = 10 , time_weight : float = 0 , ) -> tuple [ CompositeBezierCurve, float ] : \"\"\"Generate a min-jerk trajectory based on chained Bezier curves through a set of safe boxes, for a set time interval. Use an iterative retiming method to refine the durations for each segment of the trajectory We enforce continuity between curves up to the second derivative Note: if position is unconstrained (no need for safe boxes), you should instead use a single Bezier curve Args: p0 (npt.ArrayLike): Initial position, shape (3,) pf (npt.ArrayLike): Final position, shape (3,) t0 (float): Starting time tf (float): Ending time pts_per_curve (int): Number of control points per Bezier curve. Generally, should be around 6-10 boxes (list[Box]): Sequential list of safe box regions pass through initial_durations (npt.ArrayLike): Initial estimate of the durations for each segment of the trajectory. These will be refined during the retiming process. Shape (num_boxes,) v0 (Optional[npt.ArrayLike]): Initial velocity, shape (3,). Defaults to None (unconstrained) vf (Optional[npt.ArrayLike]): Final velocity, shape (3,). Defaults to None (unconstrained) a0 (Optional[npt.ArrayLike]): Initial acceleration, shape (3,). Defaults to None (unconstrained) af (Optional[npt.ArrayLike]): Final acceleration, shape (3,). Defaults to None (unconstrained) v_max (Optional[float]): Maximum L2 norm of the velocity. Defaults to None (unconstrained) a_max (Optional[float]): Maximum L2 norm of the acceleration. Defaults to None (unconstrained) kappa_min (float, optional): Retiming trust region parameter: Defines the maximum change in adjacent scaling factors. Defaults to 1e-2. omega (float, optional): Retiming parameter: Defines the rate at which kappa decays after each iteration. Must be > 1. Small values (~2) work well when transition time estimates are poor, but larger values (~5) are more effective otherwise. Defaults to 3. max_retiming_iters (int, optional): Maximum number of iterations for the retiming process. Defaults to 10. time_weight (float, optional): Objective function weight corresponding to a linear penalty on the duration. Defaults to 0 (minimize jerk only). Note: this should be > 0 if evaluating the free-final-time case Returns: tuple[CompositeBezierCurve, float]: CompositeBezierCurve: The optimal curve for the position component of the trajectory. Note: derivatives can be evaluated using the curve.derivative property float: The optimal cost of the objective function \"\"\" # Handle inputs if tf <= t0 : raise ValueError ( f \"Invalid time interval: ({t0}, {tf})\" ) if omega <= 1 : raise ValueError ( \"The retiming parameter omega must be > 1\" ) if pts_per_curve < 6 : print_red ( \"WARNING: Curves with less than 6 control points may lead to infeasible constraints\" ) # Store the curve parameters so that we can reuse these in the repeated calls to the spline function curve_kwargs = dict ( p0 = p0 , pf = pf , t0 = t0 , tf = tf , pts_per_curve = pts_per_curve , boxes = boxes , v0 = v0 , vf = vf , a0 = a0 , af = af , v_max = v_max , a_max = a_max , time_weight = time_weight , ) # Solve a preliminary trajectory for this initial guess at the durations durations = initial_durations curve_kwargs [ \"durations\" ] = durations best_curve , best_info = _fixed_timing_spline ( ** curve_kwargs ) kappa = 1 # Initialize the trust region parameter for _ in range ( max_retiming_iters ) : # Retime . try : new_durations , kappa_max = retiming ( kappa , best_info [ \"cost_breakdown\" ] , durations , best_info [ \"retiming_weights\" ] , ) except OptimizationError : print_red ( \"Spline trajectory generation terminated due to failure to solve the retiming problem.\\n\" + \"This can sometimes be due to a poor initialization of the curve durations, \" + \"or having a time horizon that is too short\" ) break # Improve Bezier curves based on the retiming curve_kwargs [ \"durations\" ] = new_durations new_curve , new_info = _fixed_timing_spline ( ** curve_kwargs ) print ( \"Retiming cost: \" , new_info [ \"cost\" ] ) if new_info [ \"cost\" ] < best_info [ \"cost\" ] : # Accept trajectory with new durations durations = new_durations best_info = new_info best_curve = new_curve # Update trust region if kappa < kappa_min : break kappa = kappa_max / omega else : print_red ( \"Spline trajectory generation terminated due to reaching the maximum number of iterations\" ) return best_curve , best_info [ \"cost\" ] Classes CompositeBezierCurve class CompositeBezierCurve ( beziers : list [ pyastrobee . trajectories . bezier . BezierCurve ] ) Composite Bezier curve class for a continuous chain of connected Bezier curves Attributes Name Type Description Default beziers list[BezierCurve] Consecutive Bezier curves composing the composite curve. None View Source class CompositeBezierCurve : \"\"\"Composite Bezier curve class for a continuous chain of connected Bezier curves Args: beziers (list[BezierCurve]): Consecutive Bezier curves composing the composite curve. \"\"\" def __init__ ( self , beziers : list [ BezierCurve ] ) : for bez1 , bez2 in zip ( beziers [ :-1 ] , beziers [ 1: ] ) : assert bez1 . b == bez2 . a assert bez1 . d == bez2 . d self . beziers = beziers self . N = len ( self . beziers ) self . d = beziers [ 0 ] . d self . a = beziers [ 0 ] . a self . b = beziers [ -1 ] . b self . duration = self . b - self . a self . transition_times = np . array ( [ self.a ] + [ bez.b for bez in beziers ] ) self . segment_durations = np . array ( [ bez.duration for bez in beziers ] ) def find_segment ( self , t ) : # return min ( bisect ( self . transition_times , t ) - 1 , self . N - 1 ) # TODO check to see if this will work on a cp variable ( probably not ...) return np . minimum ( np . searchsorted ( self . transition_times , t , \"right\" ) - 1 , self . N - 1 ) def __call__ ( self , t : Union [ float, np.ndarray ] ) -> np . ndarray : \"\"\"Evaluates the composite Bezier curve at specified points, by calling each of the child curves Args: t (Union[float, npt.ArrayLike]): Evaluation points (for instance, trajectory times) Returns: np.ndarray: Points along the composite curve, shape (n_pts, dimension) \"\"\" seg_map = self . find_segment ( t ) evals = [] for i in range ( self . N ) : evals . append ( self . beziers [ i ] ( t [ seg_map == i ] )) return np . row_stack ( evals ) @property def start_point ( self ) : \"\"\"Starting point of the composite Bezier curve (the first point of the first curve)\"\"\" return self . beziers [ 0 ] . start_point @property def end_point ( self ) : \"\"\"Ending point of the composite Bezier curve (the last point of the last curve)\"\"\" return self . beziers [ -1 ] . end_point @property def derivative ( self ) : \"\"\"Derivative of the composite Bezier curve (a composite Bezier curve of derivative curves)\"\"\" return CompositeBezierCurve ( [ b.derivative for b in self.beziers ] ) @property def l2_squared_sum ( self ) -> Union [ float, cp.Expression ] : \"\"\"Sum of the squared L2 norm for all curves\"\"\" return sum ( bez . l2_squared for bez in self . beziers ) Instance variables derivative Derivative of the composite Bezier curve (a composite Bezier curve of derivative curves) end_point Ending point of the composite Bezier curve (the last point of the last curve) l2_squared_sum Sum of the squared L2 norm for all curves start_point Starting point of the composite Bezier curve (the first point of the first curve) Methods find_segment def find_segment ( self , t ) View Source def find_segment ( self , t ): # return min(bisect(self.transition_times, t) - 1, self.N - 1) # TODO check to see if this will work on a cp variable (probably not...) return np . minimum ( np . searchsorted ( self . transition_times , t , \"right\" ) - 1 , self . N - 1 )","title":"Splines"},{"location":"reference/pyastrobee/trajectories/splines/#module-pyastrobeetrajectoriessplines","text":"Splines / \"composite Bezier curves\" composed of multiple chained Bezier curves Initial boundary conditions are imposed on the start of the first curve, final B.C.s are imposed at the end of the third curve, and we enforce C2 derivative continuity at the knot points Reference: Fast Path Planning Through Large Collections of Safe Boxes https://github.com/cvxgrp/fastpathplanning/blob/main/fastpathplanning/smooth.py https://web.stanford.edu/~boyd/papers/pdf/fpp.pdf View Source \"\"\"Splines / \"composite Bezier curves\" composed of multiple chained Bezier curves Initial boundary conditions are imposed on the start of the first curve, final B.C.s are imposed at the end of the third curve, and we enforce C2 derivative continuity at the knot points Reference: Fast Path Planning Through Large Collections of Safe Boxes https://github.com/cvxgrp/fastpathplanning/blob/main/fastpathplanning/smooth.py https://web.stanford.edu/~boyd/papers/pdf/fpp.pdf \"\"\" from typing import Optional , Union , Any import cvxpy as cp import numpy as np import numpy.typing as npt import pybullet from pyastrobee.trajectories.bezier import BezierCurve from pyastrobee.utils.boxes import Box , visualize_3D_box from pyastrobee.utils.debug_visualizer import visualize_path , visualize_points from pyastrobee.utils.python_utils import print_red from pyastrobee.trajectories.timing import retiming from pyastrobee.utils.errors import OptimizationError class CompositeBezierCurve : \"\"\"Composite Bezier curve class for a continuous chain of connected Bezier curves Args: beziers (list[BezierCurve]): Consecutive Bezier curves composing the composite curve. \"\"\" def __init__ ( self , beziers : list [ BezierCurve ]): for bez1 , bez2 in zip ( beziers [: - 1 ], beziers [ 1 :]): assert bez1 . b == bez2 . a assert bez1 . d == bez2 . d self . beziers = beziers self . N = len ( self . beziers ) self . d = beziers [ 0 ] . d self . a = beziers [ 0 ] . a self . b = beziers [ - 1 ] . b self . duration = self . b - self . a self . transition_times = np . array ([ self . a ] + [ bez . b for bez in beziers ]) self . segment_durations = np . array ([ bez . duration for bez in beziers ]) def find_segment ( self , t ): # return min(bisect(self.transition_times, t) - 1, self.N - 1) # TODO check to see if this will work on a cp variable (probably not...) return np . minimum ( np . searchsorted ( self . transition_times , t , \"right\" ) - 1 , self . N - 1 ) def __call__ ( self , t : Union [ float , np . ndarray ]) -> np . ndarray : \"\"\"Evaluates the composite Bezier curve at specified points, by calling each of the child curves Args: t (Union[float, npt.ArrayLike]): Evaluation points (for instance, trajectory times) Returns: np.ndarray: Points along the composite curve, shape (n_pts, dimension) \"\"\" seg_map = self . find_segment ( t ) evals = [] for i in range ( self . N ): evals . append ( self . beziers [ i ]( t [ seg_map == i ])) return np . row_stack ( evals ) @property def start_point ( self ): \"\"\"Starting point of the composite Bezier curve (the first point of the first curve)\"\"\" return self . beziers [ 0 ] . start_point @property def end_point ( self ): \"\"\"Ending point of the composite Bezier curve (the last point of the last curve)\"\"\" return self . beziers [ - 1 ] . end_point @property def derivative ( self ): \"\"\"Derivative of the composite Bezier curve (a composite Bezier curve of derivative curves)\"\"\" return CompositeBezierCurve ([ b . derivative for b in self . beziers ]) @property def l2_squared_sum ( self ) -> Union [ float , cp . Expression ]: \"\"\"Sum of the squared L2 norm for all curves\"\"\" return sum ( bez . l2_squared for bez in self . beziers ) def spline_trajectory_with_retiming ( p0 : npt . ArrayLike , pf : npt . ArrayLike , t0 : float , tf : float , pts_per_curve : int , boxes : list [ Box ], initial_durations : npt . ArrayLike , v0 : Optional [ npt . ArrayLike ] = None , vf : Optional [ npt . ArrayLike ] = None , a0 : Optional [ npt . ArrayLike ] = None , af : Optional [ npt . ArrayLike ] = None , v_max : Optional [ float ] = None , a_max : Optional [ float ] = None , kappa_min : float = 1e-2 , omega : float = 3 , max_retiming_iters : int = 10 , time_weight : float = 0 , ) -> tuple [ CompositeBezierCurve , float ]: \"\"\"Generate a min-jerk trajectory based on chained Bezier curves through a set of safe boxes, for a set time interval. Use an iterative retiming method to refine the durations for each segment of the trajectory We enforce continuity between curves up to the second derivative Note: if position is unconstrained (no need for safe boxes), you should instead use a single Bezier curve Args: p0 (npt.ArrayLike): Initial position, shape (3,) pf (npt.ArrayLike): Final position, shape (3,) t0 (float): Starting time tf (float): Ending time pts_per_curve (int): Number of control points per Bezier curve. Generally, should be around 6-10 boxes (list[Box]): Sequential list of safe box regions pass through initial_durations (npt.ArrayLike): Initial estimate of the durations for each segment of the trajectory. These will be refined during the retiming process. Shape (num_boxes,) v0 (Optional[npt.ArrayLike]): Initial velocity, shape (3,). Defaults to None (unconstrained) vf (Optional[npt.ArrayLike]): Final velocity, shape (3,). Defaults to None (unconstrained) a0 (Optional[npt.ArrayLike]): Initial acceleration, shape (3,). Defaults to None (unconstrained) af (Optional[npt.ArrayLike]): Final acceleration, shape (3,). Defaults to None (unconstrained) v_max (Optional[float]): Maximum L2 norm of the velocity. Defaults to None (unconstrained) a_max (Optional[float]): Maximum L2 norm of the acceleration. Defaults to None (unconstrained) kappa_min (float, optional): Retiming trust region parameter: Defines the maximum change in adjacent scaling factors. Defaults to 1e-2. omega (float, optional): Retiming parameter: Defines the rate at which kappa decays after each iteration. Must be > 1. Small values (~2) work well when transition time estimates are poor, but larger values (~5) are more effective otherwise. Defaults to 3. max_retiming_iters (int, optional): Maximum number of iterations for the retiming process. Defaults to 10. time_weight (float, optional): Objective function weight corresponding to a linear penalty on the duration. Defaults to 0 (minimize jerk only). Note: this should be > 0 if evaluating the free-final-time case Returns: tuple[CompositeBezierCurve, float]: CompositeBezierCurve: The optimal curve for the position component of the trajectory. Note: derivatives can be evaluated using the curve.derivative property float: The optimal cost of the objective function \"\"\" # Handle inputs if tf <= t0 : raise ValueError ( f \"Invalid time interval: ( { t0 } , { tf } )\" ) if omega <= 1 : raise ValueError ( \"The retiming parameter omega must be > 1\" ) if pts_per_curve < 6 : print_red ( \"WARNING: Curves with less than 6 control points may lead to infeasible constraints\" ) # Store the curve parameters so that we can reuse these in the repeated calls to the spline function curve_kwargs = dict ( p0 = p0 , pf = pf , t0 = t0 , tf = tf , pts_per_curve = pts_per_curve , boxes = boxes , v0 = v0 , vf = vf , a0 = a0 , af = af , v_max = v_max , a_max = a_max , time_weight = time_weight , ) # Solve a preliminary trajectory for this initial guess at the durations durations = initial_durations curve_kwargs [ \"durations\" ] = durations best_curve , best_info = _fixed_timing_spline ( ** curve_kwargs ) kappa = 1 # Initialize the trust region parameter for _ in range ( max_retiming_iters ): # Retime. try : new_durations , kappa_max = retiming ( kappa , best_info [ \"cost_breakdown\" ], durations , best_info [ \"retiming_weights\" ], ) except OptimizationError : print_red ( \"Spline trajectory generation terminated due to failure to solve the retiming problem. \\n \" + \"This can sometimes be due to a poor initialization of the curve durations, \" + \"or having a time horizon that is too short\" ) break # Improve Bezier curves based on the retiming curve_kwargs [ \"durations\" ] = new_durations new_curve , new_info = _fixed_timing_spline ( ** curve_kwargs ) print ( \"Retiming cost: \" , new_info [ \"cost\" ]) if new_info [ \"cost\" ] < best_info [ \"cost\" ]: # Accept trajectory with new durations durations = new_durations best_info = new_info best_curve = new_curve # Update trust region if kappa < kappa_min : break kappa = kappa_max / omega else : print_red ( \"Spline trajectory generation terminated due to reaching the maximum number of iterations\" ) return best_curve , best_info [ \"cost\" ] def _fixed_timing_spline ( p0 : npt . ArrayLike , pf : npt . ArrayLike , t0 : float , tf : float , pts_per_curve : int , boxes : list [ Box ], durations : npt . ArrayLike , v0 : Optional [ npt . ArrayLike ] = None , vf : Optional [ npt . ArrayLike ] = None , a0 : Optional [ npt . ArrayLike ] = None , af : Optional [ npt . ArrayLike ] = None , v_max : Optional [ float ] = None , a_max : Optional [ float ] = None , time_weight : float = 0 , ) -> tuple [ CompositeBezierCurve , dict [ str , Any ]]: \"\"\"Generate a min-jerk spline based on chained Bezier curves through a set of safe boxes, for a fixed time interval and fixed durations within each box NOTE: This is NOT globally optimal if we don't use the retiming process to refine the time breakdown, which is why this is a helper function that gets called within the trajectory-with-retiming function Args: p0 (npt.ArrayLike): Initial position, shape (3,) pf (npt.ArrayLike): Final position, shape (3,) t0 (float): Starting time tf (float): Ending time pts_per_curve (int): Number of control points per Bezier curve. Generally, should be around 6-10 boxes (list[Box]): Sequential list of safe box regions pass through durations (npt.ArrayLike): Durations for each segment of the trajectory, shape (num_boxes,) v0 (Optional[npt.ArrayLike]): Initial velocity, shape (3,). Defaults to None (unconstrained) vf (Optional[npt.ArrayLike]): Final velocity, shape (3,). Defaults to None (unconstrained) a0 (Optional[npt.ArrayLike]): Initial acceleration, shape (3,). Defaults to None (unconstrained) af (Optional[npt.ArrayLike]): Final acceleration, shape (3,). Defaults to None (unconstrained) v_max (Optional[float]): Maximum L2 norm of the velocity. Defaults to None (unconstrained) a_max (Optional[float]): Maximum L2 norm of the acceleration. Defaults to None (unconstrained) time_weight (float, optional): Objective function weight corresponding to a linear penalty on the duration. Defaults to 0 (minimize jerk only). Note: this should be > 0 if evaluating the free-final-time case Returns: tuple[CompositeBezierCurve, dict[str, Any]]: CompositeBezierCurve: The solved position curve dict[str, Any]: Solution info to use for retiming optimization \"\"\" dim = len ( p0 ) n_curves = len ( boxes ) # Construct our main optimization variable all_control_points = cp . Variable (( n_curves * pts_per_curve , dim )) # Determine the knot times between trajectory segments # Includes start/end times as knots too, for ease of indexing knot_times = np . concatenate ([[ t0 ], np . cumsum ( durations )]) knot_times [ - 1 ] = tf # Fix floating pt issue with cumsum # Indexing from the main cvxpy variable containing all of the control points pos_pt_sets = [ all_control_points [ pts_per_curve * i : pts_per_curve * ( i + 1 )] for i in range ( n_curves ) ] pos_curves = [ BezierCurve ( pos_pt_sets [ i ], knot_times [ i ], knot_times [ i + 1 ]) for i in range ( n_curves ) ] # Set up derivative curves and the points associated with them vel_curves = [ pc . derivative for pc in pos_curves ] accel_curves = [ vc . derivative for vc in vel_curves ] jerk_curves = [ ac . derivative for ac in accel_curves ] vel_pt_sets = [ vc . points for vc in vel_curves ] accel_pt_sets = [ ac . points for ac in accel_curves ] # Set up constraints pos_continuity = [ pos_pt_sets [ i ][ - 1 ] == pos_pt_sets [ i + 1 ][ 0 ] for i in range ( n_curves - 1 ) ] vel_continuity = [ vel_pt_sets [ i ][ - 1 ] == vel_pt_sets [ i + 1 ][ 0 ] for i in range ( n_curves - 1 ) ] accel_continuity = [ accel_pt_sets [ i ][ - 1 ] == accel_pt_sets [ i + 1 ][ 0 ] for i in range ( n_curves - 1 ) ] continuity_constraints = pos_continuity + vel_continuity + accel_continuity bc_constraints = [ pos_pt_sets [ 0 ][ 0 ] == p0 , pos_pt_sets [ - 1 ][ - 1 ] == pf ] if v0 is not None : bc_constraints . append ( vel_pt_sets [ 0 ][ 0 ] == v0 ) if a0 is not None : bc_constraints . append ( accel_pt_sets [ 0 ][ 0 ] == a0 ) if vf is not None : bc_constraints . append ( vel_pt_sets [ - 1 ][ - 1 ] == vf ) if af is not None : bc_constraints . append ( accel_pt_sets [ - 1 ][ - 1 ] == af ) box_constraints = [] for i , box in enumerate ( boxes ): lower , upper = box n = pos_pt_sets [ i ] . shape [ 0 ] # Number of control points in ith curve box_constraints . append ( pos_pt_sets [ i ] >= np . tile ( lower , ( n , 1 ))) box_constraints . append ( pos_pt_sets [ i ] <= np . tile ( upper , ( n , 1 ))) dyn_constraints = [] if v_max is not None : for i in range ( n_curves ): dyn_constraints . append ( cp . norm2 ( vel_pt_sets [ i ], axis = 1 ) <= v_max ) if a_max is not None : for i in range ( n_curves ): dyn_constraints . append ( cp . norm2 ( accel_pt_sets [ i ], axis = 1 ) <= a_max ) # Merge the lists of constraints together constraints = ( continuity_constraints + bc_constraints + box_constraints + dyn_constraints ) # Complete the problem formulation and solve it jerk = sum ( jc . l2_squared for jc in jerk_curves ) objective = cp . Minimize ( jerk + time_weight * ( tf - t0 )) prob = cp . Problem ( objective , constraints ) try : prob . solve ( solver = cp . CLARABEL ) except cp . error . SolverError as e : raise OptimizationError ( \"Cannot generate the trajectory - Solver error!\" ) from e if prob . status != cp . OPTIMAL : raise OptimizationError ( f \"Unable to generate the trajectory (solver status: { prob . status } ). \\n \" + \"Check on the feasibility of the constraints\" ) # Form info about the solution to match the methodology from FPP, so we can use this for retiming # For more details on this, refer to the FPP source code and paper cost_breakdown = {} for k in range ( n_curves ): cost_breakdown [ k ] = {} cost_breakdown [ k ][ 3 ] = jerk_curves [ k ] . l2_squared . value retiming_weights = {} for k in range ( n_curves - 1 ): retiming_weights [ k ] = {} vel_primal = vel_curves [ k ] . points [ - 1 ] . value vel_dual = vel_continuity [ k ] . dual_value retiming_weights [ k ][ 1 ] = vel_primal . dot ( vel_dual ) accel_primal = accel_curves [ k ] . points [ - 1 ] . value accel_dual = accel_continuity [ k ] . dual_value retiming_weights [ k ][ 2 ] = accel_primal . dot ( accel_dual ) info = { \"cost\" : prob . value , \"retiming_weights\" : retiming_weights , \"cost_breakdown\" : cost_breakdown , } # Construct the Bezier curves from the solved control points, solved_pos_curves = [ BezierCurve ( pos_pt_sets [ i ] . value , knot_times [ i ], knot_times [ i + 1 ]) for i in range ( n_curves ) ] solved_pos_spline = CompositeBezierCurve ( solved_pos_curves ) return solved_pos_spline , info def _test_spline_trajectory (): \"\"\"Construct and visualize an optimal trajectory composed of three curves between safe sets\"\"\" p0 = [ 0.1 , 0.2 , 0.3 ] pf = [ 1.5 , 5 , 1.7 ] t0 = 0 tf = 5 pts_per_curve = 8 v0 = np . zeros ( 3 ) vf = np . zeros ( 3 ) a0 = np . zeros ( 3 ) af = np . zeros ( 3 ) boxes = [ Box (( 0 , 0 , 0 ), ( 1 , 1 , 1 )), Box (( 0.5 , 0.5 , 0.5 ), ( 1.5 , 5 , 1.5 )), Box (( 1 , 4.5 , 1 ), ( 2 , 5.5 , 2 )), ] n_curves = len ( boxes ) durations = np . ones ( n_curves ) * ( tf - t0 ) / n_curves n_timesteps = 50 times = np . linspace ( t0 , tf , n_timesteps , endpoint = True ) pos_curve , * _ = _fixed_timing_spline ( p0 , pf , t0 , tf , pts_per_curve , boxes , durations , v0 , vf , a0 , af ) pos_pts = pos_curve ( times ) pos_curve_retimed , cost = spline_trajectory_with_retiming ( p0 , pf , t0 , tf , pts_per_curve , boxes , durations , v0 , vf , a0 , af ) pos = pos_curve_retimed ( np . linspace ( t0 , tf , n_timesteps )) pybullet . connect ( pybullet . GUI ) visualize_points ( np . vstack ([ p0 , pf ]), ( 0 , 0 , 1 )) for box in boxes : visualize_3D_box ( box ) simple_traj_color = ( 0 , 0 , 1 ) retimed_traj_color = ( 0 , 1 , 0 ) visualize_path ( pos_pts , 10 , simple_traj_color ) visualize_path ( pos , 10 , retimed_traj_color ) pybullet . addUserDebugText ( \"Original curve\" , [ 0 , 0 , - 0.2 ], simple_traj_color ) pybullet . addUserDebugText ( \"Retimed curve\" , [ 0 , 0 , - 0.4 ], retimed_traj_color ) input () if __name__ == \"__main__\" : # _test_plotting_spline() _test_spline_trajectory ()","title":"Module pyastrobee.trajectories.splines"},{"location":"reference/pyastrobee/trajectories/splines/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/trajectories/splines/#spline_trajectory_with_retiming","text":"def spline_trajectory_with_retiming ( p0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], t0 : float , tf : float , pts_per_curve : int , boxes : list [ pyastrobee . utils . boxes . Box ], initial_durations : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], v0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , vf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , a0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , af : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , v_max : Optional [ float ] = None , a_max : Optional [ float ] = None , kappa_min : float = 0.01 , omega : float = 3 , max_retiming_iters : int = 10 , time_weight : float = 0 ) -> tuple [ pyastrobee . trajectories . splines . CompositeBezierCurve , float ] Generate a min-jerk trajectory based on chained Bezier curves through a set of safe boxes, for a set time interval. Use an iterative retiming method to refine the durations for each segment of the trajectory We enforce continuity between curves up to the second derivative Note: if position is unconstrained (no need for safe boxes), you should instead use a single Bezier curve Parameters: Name Type Description Default p0 npt.ArrayLike Initial position, shape (3,) None pf npt.ArrayLike Final position, shape (3,) None t0 float Starting time None tf float Ending time None pts_per_curve int Number of control points per Bezier curve. Generally, should be around 6-10 None boxes list[Box] Sequential list of safe box regions pass through None initial_durations npt.ArrayLike Initial estimate of the durations for each segment of the trajectory. These will be refined during the retiming process. Shape (num_boxes,) None v0 Optional[npt.ArrayLike] Initial velocity, shape (3,). Defaults to None (unconstrained) None vf Optional[npt.ArrayLike] Final velocity, shape (3,). Defaults to None (unconstrained) None a0 Optional[npt.ArrayLike] Initial acceleration, shape (3,). Defaults to None (unconstrained) None af Optional[npt.ArrayLike] Final acceleration, shape (3,). Defaults to None (unconstrained) None v_max Optional[float] Maximum L2 norm of the velocity. Defaults to None (unconstrained) None a_max Optional[float] Maximum L2 norm of the acceleration. Defaults to None (unconstrained) None kappa_min float Retiming trust region parameter: Defines the maximum change in adjacent scaling factors. Defaults to 1e-2. None omega float Retiming parameter: Defines the rate at which kappa decays after each iteration. Must be > 1. Small values (~2) work well when transition time estimates are poor, but larger values (~5) are more effective otherwise. Defaults to 3. None max_retiming_iters int Maximum number of iterations for the retiming process. Defaults to 10. 10 time_weight float Objective function weight corresponding to a linear penalty on the duration. Defaults to 0 (minimize jerk only). Note: this should be > 0 if evaluating the free-final-time case None Returns: Type Description tuple[CompositeBezierCurve, float] CompositeBezierCurve: The optimal curve for the position component of the trajectory. Note: derivatives can be evaluated using the curve.derivative property float: The optimal cost of the objective function View Source def spline_trajectory_with_retiming ( p0 : npt . ArrayLike , pf : npt . ArrayLike , t0 : float , tf : float , pts_per_curve : int , boxes : list [ Box ] , initial_durations : npt . ArrayLike , v0 : Optional [ npt.ArrayLike ] = None , vf : Optional [ npt.ArrayLike ] = None , a0 : Optional [ npt.ArrayLike ] = None , af : Optional [ npt.ArrayLike ] = None , v_max : Optional [ float ] = None , a_max : Optional [ float ] = None , kappa_min : float = 1e-2 , omega : float = 3 , max_retiming_iters : int = 10 , time_weight : float = 0 , ) -> tuple [ CompositeBezierCurve, float ] : \"\"\"Generate a min-jerk trajectory based on chained Bezier curves through a set of safe boxes, for a set time interval. Use an iterative retiming method to refine the durations for each segment of the trajectory We enforce continuity between curves up to the second derivative Note: if position is unconstrained (no need for safe boxes), you should instead use a single Bezier curve Args: p0 (npt.ArrayLike): Initial position, shape (3,) pf (npt.ArrayLike): Final position, shape (3,) t0 (float): Starting time tf (float): Ending time pts_per_curve (int): Number of control points per Bezier curve. Generally, should be around 6-10 boxes (list[Box]): Sequential list of safe box regions pass through initial_durations (npt.ArrayLike): Initial estimate of the durations for each segment of the trajectory. These will be refined during the retiming process. Shape (num_boxes,) v0 (Optional[npt.ArrayLike]): Initial velocity, shape (3,). Defaults to None (unconstrained) vf (Optional[npt.ArrayLike]): Final velocity, shape (3,). Defaults to None (unconstrained) a0 (Optional[npt.ArrayLike]): Initial acceleration, shape (3,). Defaults to None (unconstrained) af (Optional[npt.ArrayLike]): Final acceleration, shape (3,). Defaults to None (unconstrained) v_max (Optional[float]): Maximum L2 norm of the velocity. Defaults to None (unconstrained) a_max (Optional[float]): Maximum L2 norm of the acceleration. Defaults to None (unconstrained) kappa_min (float, optional): Retiming trust region parameter: Defines the maximum change in adjacent scaling factors. Defaults to 1e-2. omega (float, optional): Retiming parameter: Defines the rate at which kappa decays after each iteration. Must be > 1. Small values (~2) work well when transition time estimates are poor, but larger values (~5) are more effective otherwise. Defaults to 3. max_retiming_iters (int, optional): Maximum number of iterations for the retiming process. Defaults to 10. time_weight (float, optional): Objective function weight corresponding to a linear penalty on the duration. Defaults to 0 (minimize jerk only). Note: this should be > 0 if evaluating the free-final-time case Returns: tuple[CompositeBezierCurve, float]: CompositeBezierCurve: The optimal curve for the position component of the trajectory. Note: derivatives can be evaluated using the curve.derivative property float: The optimal cost of the objective function \"\"\" # Handle inputs if tf <= t0 : raise ValueError ( f \"Invalid time interval: ({t0}, {tf})\" ) if omega <= 1 : raise ValueError ( \"The retiming parameter omega must be > 1\" ) if pts_per_curve < 6 : print_red ( \"WARNING: Curves with less than 6 control points may lead to infeasible constraints\" ) # Store the curve parameters so that we can reuse these in the repeated calls to the spline function curve_kwargs = dict ( p0 = p0 , pf = pf , t0 = t0 , tf = tf , pts_per_curve = pts_per_curve , boxes = boxes , v0 = v0 , vf = vf , a0 = a0 , af = af , v_max = v_max , a_max = a_max , time_weight = time_weight , ) # Solve a preliminary trajectory for this initial guess at the durations durations = initial_durations curve_kwargs [ \"durations\" ] = durations best_curve , best_info = _fixed_timing_spline ( ** curve_kwargs ) kappa = 1 # Initialize the trust region parameter for _ in range ( max_retiming_iters ) : # Retime . try : new_durations , kappa_max = retiming ( kappa , best_info [ \"cost_breakdown\" ] , durations , best_info [ \"retiming_weights\" ] , ) except OptimizationError : print_red ( \"Spline trajectory generation terminated due to failure to solve the retiming problem.\\n\" + \"This can sometimes be due to a poor initialization of the curve durations, \" + \"or having a time horizon that is too short\" ) break # Improve Bezier curves based on the retiming curve_kwargs [ \"durations\" ] = new_durations new_curve , new_info = _fixed_timing_spline ( ** curve_kwargs ) print ( \"Retiming cost: \" , new_info [ \"cost\" ] ) if new_info [ \"cost\" ] < best_info [ \"cost\" ] : # Accept trajectory with new durations durations = new_durations best_info = new_info best_curve = new_curve # Update trust region if kappa < kappa_min : break kappa = kappa_max / omega else : print_red ( \"Spline trajectory generation terminated due to reaching the maximum number of iterations\" ) return best_curve , best_info [ \"cost\" ]","title":"spline_trajectory_with_retiming"},{"location":"reference/pyastrobee/trajectories/splines/#classes","text":"","title":"Classes"},{"location":"reference/pyastrobee/trajectories/splines/#compositebeziercurve","text":"class CompositeBezierCurve ( beziers : list [ pyastrobee . trajectories . bezier . BezierCurve ] ) Composite Bezier curve class for a continuous chain of connected Bezier curves","title":"CompositeBezierCurve"},{"location":"reference/pyastrobee/trajectories/splines/#attributes","text":"Name Type Description Default beziers list[BezierCurve] Consecutive Bezier curves composing the composite curve. None View Source class CompositeBezierCurve : \"\"\"Composite Bezier curve class for a continuous chain of connected Bezier curves Args: beziers (list[BezierCurve]): Consecutive Bezier curves composing the composite curve. \"\"\" def __init__ ( self , beziers : list [ BezierCurve ] ) : for bez1 , bez2 in zip ( beziers [ :-1 ] , beziers [ 1: ] ) : assert bez1 . b == bez2 . a assert bez1 . d == bez2 . d self . beziers = beziers self . N = len ( self . beziers ) self . d = beziers [ 0 ] . d self . a = beziers [ 0 ] . a self . b = beziers [ -1 ] . b self . duration = self . b - self . a self . transition_times = np . array ( [ self.a ] + [ bez.b for bez in beziers ] ) self . segment_durations = np . array ( [ bez.duration for bez in beziers ] ) def find_segment ( self , t ) : # return min ( bisect ( self . transition_times , t ) - 1 , self . N - 1 ) # TODO check to see if this will work on a cp variable ( probably not ...) return np . minimum ( np . searchsorted ( self . transition_times , t , \"right\" ) - 1 , self . N - 1 ) def __call__ ( self , t : Union [ float, np.ndarray ] ) -> np . ndarray : \"\"\"Evaluates the composite Bezier curve at specified points, by calling each of the child curves Args: t (Union[float, npt.ArrayLike]): Evaluation points (for instance, trajectory times) Returns: np.ndarray: Points along the composite curve, shape (n_pts, dimension) \"\"\" seg_map = self . find_segment ( t ) evals = [] for i in range ( self . N ) : evals . append ( self . beziers [ i ] ( t [ seg_map == i ] )) return np . row_stack ( evals ) @property def start_point ( self ) : \"\"\"Starting point of the composite Bezier curve (the first point of the first curve)\"\"\" return self . beziers [ 0 ] . start_point @property def end_point ( self ) : \"\"\"Ending point of the composite Bezier curve (the last point of the last curve)\"\"\" return self . beziers [ -1 ] . end_point @property def derivative ( self ) : \"\"\"Derivative of the composite Bezier curve (a composite Bezier curve of derivative curves)\"\"\" return CompositeBezierCurve ( [ b.derivative for b in self.beziers ] ) @property def l2_squared_sum ( self ) -> Union [ float, cp.Expression ] : \"\"\"Sum of the squared L2 norm for all curves\"\"\" return sum ( bez . l2_squared for bez in self . beziers )","title":"Attributes"},{"location":"reference/pyastrobee/trajectories/splines/#instance-variables","text":"derivative Derivative of the composite Bezier curve (a composite Bezier curve of derivative curves) end_point Ending point of the composite Bezier curve (the last point of the last curve) l2_squared_sum Sum of the squared L2 norm for all curves start_point Starting point of the composite Bezier curve (the first point of the first curve)","title":"Instance variables"},{"location":"reference/pyastrobee/trajectories/splines/#methods","text":"","title":"Methods"},{"location":"reference/pyastrobee/trajectories/splines/#find_segment","text":"def find_segment ( self , t ) View Source def find_segment ( self , t ): # return min(bisect(self.transition_times, t) - 1, self.N - 1) # TODO check to see if this will work on a cp variable (probably not...) return np . minimum ( np . searchsorted ( self . transition_times , t , \"right\" ) - 1 , self . N - 1 )","title":"find_segment"},{"location":"reference/pyastrobee/trajectories/timing/","text":"Module pyastrobee.trajectories.timing Functions associated with determining timing parameters for trajectories Timing heuristics help us estimate the amount of time allocated to trajectories Note: These heuristics are astrobee-specific The retiming optimization refines transition timing of spline trajectories View Source \"\"\"Functions associated with determining timing parameters for trajectories - Timing heuristics help us estimate the amount of time allocated to trajectories - Note: These heuristics are astrobee-specific - The retiming optimization refines transition timing of spline trajectories \"\"\" # TODO # - Some of these heuristics will be relatively poor. Try to figure out better estimates that are # not too computationally intensive to solve import numpy as np import numpy.typing as npt import cvxpy as cp from pyastrobee.utils.boxes import Box from pyastrobee.trajectories.box_paths import intersection_path from pyastrobee.config.astrobee_motion import LINEAR_SPEED_LIMIT , ANGULAR_SPEED_LIMIT from pyastrobee.utils.quaternions import quaternion_angular_error from pyastrobee.utils.errors import OptimizationError def bezier_duration_heuristic ( start_pt : npt . ArrayLike , end_pt : npt . ArrayLike ) -> float : \"\"\"Estimate the total duration of a trajectory comprised of a single Bezier curve Args: start_pt (npt.ArrayLike): Starting XYZ position, shape (3,) end_pt (npt.ArrayLike): Ending XYZ position, shape (3,) Returns: float: Estimated duration \"\"\" dist = np . linalg . norm ( end_pt - start_pt ) return dist / ( 0.5 * LINEAR_SPEED_LIMIT ) def spline_duration_heuristic ( start_pt : npt . ArrayLike , end_pt : npt . ArrayLike , boxes : list [ Box ] ) -> tuple [ float , np . ndarray ]: \"\"\"Calculate a preliminary estimate for the time allocated to each curve in a spline Empirically, this seems to give a decent weighting and improves the solver reliability for retiming Args: start_pt (npt.ArrayLike): Starting XYZ position, shape (3,) end_pt (npt.ArrayLike): Ending XYZ position, shape (3,) boxes (list[Box]): Sequence of safe boxes that will be traveled through (Not the entire free space) Returns: tuple[float, np.ndarray]: float: Total duration estimate for the entire curve np.ndarray: Fractions of the total duration allocated to each box, shape (num_boxes,) \"\"\" # Approximate the lengths of each path segment path_points = intersection_path ( start_pt , end_pt , boxes ) path_lengths = np . linalg . norm ( np . diff ( path_points , axis = 0 ), axis = 1 ) total_length = np . sum ( path_lengths ) fractional_lengths = path_lengths / total_length # Allocate a little extra time to the start and end to account for accel/decel fractional_lengths [ 0 ] *= 1.5 fractional_lengths [ - 1 ] *= 1.5 # Re-ensure the fractional lengths sum to one fractional_lengths /= np . sum ( fractional_lengths ) # Assume constant speed along each segment of half of the speed limit constant_speed = 0.5 * LINEAR_SPEED_LIMIT total_time = total_length / constant_speed return total_time , fractional_lengths def rotation_duration_heuristic ( q0 : npt . ArrayLike , qf : npt . ArrayLike ) -> float : \"\"\"Calculate an estimate of how long a rotation will take Args: q0 (npt.ArrayLike): Initial XYZW quaternion, shape (4,) qf (npt.ArrayLike): Final XYZW quaternion, shape (4,) Returns: float: Time estimate, seconds \"\"\" err = quaternion_angular_error ( q0 , qf ) err_mag = np . linalg . norm ( err ) return err_mag / ( 0.5 * ANGULAR_SPEED_LIMIT ) def retiming ( kappa : float , costs : dict [ int , dict [ int , float ]], durations : npt . ArrayLike , retiming_weights : dict [ int , dict [ int , float ]], ) -> tuple [ np . ndarray , float ]: \"\"\"Run the retiming trust-region-based optimization to generate an improved set of curve durations This code is essentially straight from Fast Path Planning with minimal modification since the retiming method is a bit complex, and we know that this works Args: kappa (float): Trust region parameter: Defines the maximum change in adjacent scaling factors costs (dict[int, dict[int, float]]): Breakdown of costs per curve and per derivative. Costs[i] gives the info for curve i, and costs[i][j] gives the cost associated with the jth derivative curve. Since we deal only with min-jerk, we only evaluate the j=3 case. The cost is the squared L2 norm of the jerk durations (npt.ArrayLike): Current best known value of the curve durations, shape (n_curves,) retiming_weights (dict[int, dict[int, float]]): A combination of Lagrangian multipliers and the last solved path. Weights[i] gives the weights associated with the ith differentiability (continuity) constraint, and weights[i][j] gives the weight associated with the jth derivative curve continuity. We enforce continuity up to the second derivative (j = 1 and 2) Returns: tuple[np.ndarray, float]: np.ndarray: The updated curve durations float: The new trust region parameter \"\"\" # Decision variables. n_boxes = max ( costs ) + 1 eta = cp . Variable ( n_boxes ) eta . value = np . ones ( n_boxes ) constr = [ durations @ eta == sum ( durations )] # Scale costs from previous trajectory. cost = 0 for i , ci in costs . items (): for j , cij in ci . items (): cost += cij * cp . power ( eta [ i ], 1 - 2 * j ) # Retiming weights. for k in range ( n_boxes - 1 ): for i , w in retiming_weights [ k ] . items (): cost += i * retiming_weights [ k ][ i ] * ( eta [ k + 1 ] - eta [ k ]) # Trust region. if not np . isinf ( kappa ): constr . append ( eta [ 1 :] - eta [: - 1 ] <= kappa ) constr . append ( eta [: - 1 ] - eta [ 1 :] <= kappa ) # Solve SOCP and get new durarations. prob = cp . Problem ( cp . Minimize ( cost ), constr ) prob . solve ( solver = cp . CLARABEL ) if prob . status != cp . OPTIMAL : print ( \"Clarabel failed to solve the retiming problem. Retrying with MOSEK\" ) prob . solve ( solver = cp . MOSEK ) if prob . status != cp . OPTIMAL : raise OptimizationError ( \"Unable to solve the retiming problem\" ) new_durations = np . multiply ( eta . value , durations ) # New candidate for kappa. kappa_max = max ( np . abs ( eta . value [ 1 :] - eta . value [: - 1 ])) return new_durations , kappa_max def _test_timing_estimate (): p0 = [ 0.1 , 0.2 , 0.3 ] pf = [ 1.5 , 5 , 1.7 ] safe_boxes = [ Box (( 0 , 0 , 0 ), ( 1 , 1 , 1 )), Box (( 0.5 , 0.5 , 0.5 ), ( 1.5 , 5 , 1.5 )), Box (( 1 , 4.5 , 1 ), ( 2 , 5.5 , 2 )), ] total_time , time_fractions = spline_duration_heuristic ( p0 , pf , safe_boxes ) print ( \"Time estimate: \" , total_time ) print ( \"Fractional breakdown per box: \" , time_fractions ) print ( \"Time per box: \" , total_time * time_fractions ) if __name__ == \"__main__\" : _test_timing_estimate () Variables ANGULAR_SPEED_LIMIT LINEAR_SPEED_LIMIT Functions bezier_duration_heuristic def bezier_duration_heuristic ( start_pt : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], end_pt : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> float Estimate the total duration of a trajectory comprised of a single Bezier curve Parameters: Name Type Description Default start_pt npt.ArrayLike Starting XYZ position, shape (3,) None end_pt npt.ArrayLike Ending XYZ position, shape (3,) None Returns: Type Description float Estimated duration View Source def bezier_duration_heuristic(start_pt: npt.ArrayLike, end_pt: npt.ArrayLike) -> float: \"\"\"Estimate the total duration of a trajectory comprised of a single Bezier curve Args: start_pt (npt.ArrayLike): Starting XYZ position, shape (3,) end_pt (npt.ArrayLike): Ending XYZ position, shape (3,) Returns: float: Estimated duration \"\"\" dist = np.linalg.norm(end_pt - start_pt) return dist / (0.5 * LINEAR_SPEED_LIMIT) retiming def retiming ( kappa : float , costs : dict [ int , dict [ int , float ]], durations : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], retiming_weights : dict [ int , dict [ int , float ]] ) -> tuple [ numpy . ndarray , float ] Run the retiming trust-region-based optimization to generate an improved set of curve durations This code is essentially straight from Fast Path Planning with minimal modification since the retiming method is a bit complex, and we know that this works Parameters: Name Type Description Default kappa float Trust region parameter: Defines the maximum change in adjacent scaling factors None costs dict[int, dict[int, float]] Breakdown of costs per curve and per derivative. Costs[i] gives the info for curve i, and costs[i][j] gives the cost associated with the jth derivative curve. Since we deal only with min-jerk, we only evaluate the j=3 case. The cost is the squared L2 norm of the jerk None durations npt.ArrayLike Current best known value of the curve durations, shape (n_curves,) None retiming_weights dict[int, dict[int, float]] A combination of Lagrangian multipliers and the last solved path. Weights[i] gives the weights associated with the ith differentiability (continuity) constraint, and weights[i][j] gives the weight associated with the jth derivative curve continuity. We enforce continuity up to the second derivative (j = 1 and 2) None Returns: Type Description tuple[np.ndarray, float] np.ndarray: The updated curve durations float: The new trust region parameter View Source def retiming ( kappa : float , costs : dict [ int , dict [ int , float ]], durations : npt . ArrayLike , retiming_weights : dict [ int , dict [ int , float ]], ) -> tuple [ np . ndarray , float ] : \"\"\"Run the retiming trust-region-based optimization to generate an improved set of curve durations This code is essentially straight from Fast Path Planning with minimal modification since the retiming method is a bit complex, and we know that this works Args: kappa (float): Trust region parameter: Defines the maximum change in adjacent scaling factors costs (dict[int, dict[int, float]]): Breakdown of costs per curve and per derivative. Costs[i] gives the info for curve i, and costs[i][j] gives the cost associated with the jth derivative curve. Since we deal only with min-jerk, we only evaluate the j=3 case. The cost is the squared L2 norm of the jerk durations (npt.ArrayLike): Current best known value of the curve durations, shape (n_curves,) retiming_weights (dict[int, dict[int, float]]): A combination of Lagrangian multipliers and the last solved path. Weights[i] gives the weights associated with the ith differentiability (continuity) constraint, and weights[i][j] gives the weight associated with the jth derivative curve continuity. We enforce continuity up to the second derivative (j = 1 and 2) Returns: tuple[np.ndarray, float]: np.ndarray: The updated curve durations float: The new trust region parameter \"\"\" # Decision variables . n_boxes = max ( costs ) + 1 eta = cp . Variable ( n_boxes ) eta . val ue = np . ones ( n_boxes ) constr = [ durations @ eta == sum ( durations )] # Scale costs from previous trajectory . cost = 0 for i , ci in costs . items () : for j , cij in ci . items () : cost += cij * cp . power ( eta [ i ], 1 - 2 * j ) # Retiming weights . for k in range ( n_boxes - 1 ) : for i , w in retiming_weights [ k ]. items () : cost += i * retiming_weights [ k ][ i ] * ( eta [ k + 1 ] - eta [ k ]) # Trust region . if not np . isinf ( kappa ) : constr . append ( eta [ 1 : ] - eta [ :- 1 ] <= kappa ) constr . append ( eta [ :- 1 ] - eta [ 1 : ] <= kappa ) # Solve SOCP and get new durarations . prob = cp . Problem ( cp . Minimize ( cost ), constr ) prob . solve ( solver = cp . CLARABEL ) if prob . status ! = cp . OPTIMAL : print ( \"Clarabel failed to solve the retiming problem. Retrying with MOSEK\" ) prob . solve ( solver = cp . MOSEK ) if prob . status ! = cp . OPTIMAL : raise OptimizationError ( \"Unable to solve the retiming problem\" ) new_durations = np . multiply ( eta . val ue , durations ) # New candidate for kappa . kappa_max = max ( np . abs ( eta . val ue [ 1 : ] - eta . val ue [ :- 1 ])) return new_durations , kappa_max rotation_duration_heuristic def rotation_duration_heuristic ( q0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], qf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> float Calculate an estimate of how long a rotation will take Parameters: Name Type Description Default q0 npt.ArrayLike Initial XYZW quaternion, shape (4,) None qf npt.ArrayLike Final XYZW quaternion, shape (4,) None Returns: Type Description float Time estimate, seconds View Source def rotation_duration_heuristic(q0: npt.ArrayLike, qf: npt.ArrayLike) -> float: \"\"\"Calculate an estimate of how long a rotation will take Args: q0 (npt.ArrayLike): Initial XYZW quaternion, shape (4,) qf (npt.ArrayLike): Final XYZW quaternion, shape (4,) Returns: float: Time estimate, seconds \"\"\" err = quaternion_angular_error(q0, qf) err_mag = np.linalg.norm(err) return err_mag / (0.5 * ANGULAR_SPEED_LIMIT) spline_duration_heuristic def spline_duration_heuristic ( start_pt : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], end_pt : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], boxes : list [ pyastrobee . utils . boxes . Box ] ) -> tuple [ float , numpy . ndarray ] Calculate a preliminary estimate for the time allocated to each curve in a spline Empirically, this seems to give a decent weighting and improves the solver reliability for retiming Parameters: Name Type Description Default start_pt npt.ArrayLike Starting XYZ position, shape (3,) None end_pt npt.ArrayLike Ending XYZ position, shape (3,) None boxes list[Box] Sequence of safe boxes that will be traveled through (Not the entire free space) None Returns: Type Description tuple[float, np.ndarray] float: Total duration estimate for the entire curve np.ndarray: Fractions of the total duration allocated to each box, shape (num_boxes,) View Source def spline_duration_heuristic ( start_pt : npt . ArrayLike , end_pt : npt . ArrayLike , boxes : list [ Box ] ) -> tuple [ float, np.ndarray ] : \"\"\"Calculate a preliminary estimate for the time allocated to each curve in a spline Empirically, this seems to give a decent weighting and improves the solver reliability for retiming Args: start_pt (npt.ArrayLike): Starting XYZ position, shape (3,) end_pt (npt.ArrayLike): Ending XYZ position, shape (3,) boxes (list[Box]): Sequence of safe boxes that will be traveled through (Not the entire free space) Returns: tuple[float, np.ndarray]: float: Total duration estimate for the entire curve np.ndarray: Fractions of the total duration allocated to each box, shape (num_boxes,) \"\"\" # Approximate the lengths of each path segment path_points = intersection_path ( start_pt , end_pt , boxes ) path_lengths = np . linalg . norm ( np . diff ( path_points , axis = 0 ), axis = 1 ) total_length = np . sum ( path_lengths ) fractional_lengths = path_lengths / total_length # Allocate a little extra time to the start and end to account for accel / decel fractional_lengths [ 0 ] *= 1.5 fractional_lengths [ -1 ] *= 1.5 # Re - ensure the fractional lengths sum to one fractional_lengths /= np . sum ( fractional_lengths ) # Assume constant speed along each segment of half of the speed limit constant_speed = 0.5 * LINEAR_SPEED_LIMIT total_time = total_length / constant_speed return total_time , fractional_lengths","title":"Timing"},{"location":"reference/pyastrobee/trajectories/timing/#module-pyastrobeetrajectoriestiming","text":"Functions associated with determining timing parameters for trajectories Timing heuristics help us estimate the amount of time allocated to trajectories Note: These heuristics are astrobee-specific The retiming optimization refines transition timing of spline trajectories View Source \"\"\"Functions associated with determining timing parameters for trajectories - Timing heuristics help us estimate the amount of time allocated to trajectories - Note: These heuristics are astrobee-specific - The retiming optimization refines transition timing of spline trajectories \"\"\" # TODO # - Some of these heuristics will be relatively poor. Try to figure out better estimates that are # not too computationally intensive to solve import numpy as np import numpy.typing as npt import cvxpy as cp from pyastrobee.utils.boxes import Box from pyastrobee.trajectories.box_paths import intersection_path from pyastrobee.config.astrobee_motion import LINEAR_SPEED_LIMIT , ANGULAR_SPEED_LIMIT from pyastrobee.utils.quaternions import quaternion_angular_error from pyastrobee.utils.errors import OptimizationError def bezier_duration_heuristic ( start_pt : npt . ArrayLike , end_pt : npt . ArrayLike ) -> float : \"\"\"Estimate the total duration of a trajectory comprised of a single Bezier curve Args: start_pt (npt.ArrayLike): Starting XYZ position, shape (3,) end_pt (npt.ArrayLike): Ending XYZ position, shape (3,) Returns: float: Estimated duration \"\"\" dist = np . linalg . norm ( end_pt - start_pt ) return dist / ( 0.5 * LINEAR_SPEED_LIMIT ) def spline_duration_heuristic ( start_pt : npt . ArrayLike , end_pt : npt . ArrayLike , boxes : list [ Box ] ) -> tuple [ float , np . ndarray ]: \"\"\"Calculate a preliminary estimate for the time allocated to each curve in a spline Empirically, this seems to give a decent weighting and improves the solver reliability for retiming Args: start_pt (npt.ArrayLike): Starting XYZ position, shape (3,) end_pt (npt.ArrayLike): Ending XYZ position, shape (3,) boxes (list[Box]): Sequence of safe boxes that will be traveled through (Not the entire free space) Returns: tuple[float, np.ndarray]: float: Total duration estimate for the entire curve np.ndarray: Fractions of the total duration allocated to each box, shape (num_boxes,) \"\"\" # Approximate the lengths of each path segment path_points = intersection_path ( start_pt , end_pt , boxes ) path_lengths = np . linalg . norm ( np . diff ( path_points , axis = 0 ), axis = 1 ) total_length = np . sum ( path_lengths ) fractional_lengths = path_lengths / total_length # Allocate a little extra time to the start and end to account for accel/decel fractional_lengths [ 0 ] *= 1.5 fractional_lengths [ - 1 ] *= 1.5 # Re-ensure the fractional lengths sum to one fractional_lengths /= np . sum ( fractional_lengths ) # Assume constant speed along each segment of half of the speed limit constant_speed = 0.5 * LINEAR_SPEED_LIMIT total_time = total_length / constant_speed return total_time , fractional_lengths def rotation_duration_heuristic ( q0 : npt . ArrayLike , qf : npt . ArrayLike ) -> float : \"\"\"Calculate an estimate of how long a rotation will take Args: q0 (npt.ArrayLike): Initial XYZW quaternion, shape (4,) qf (npt.ArrayLike): Final XYZW quaternion, shape (4,) Returns: float: Time estimate, seconds \"\"\" err = quaternion_angular_error ( q0 , qf ) err_mag = np . linalg . norm ( err ) return err_mag / ( 0.5 * ANGULAR_SPEED_LIMIT ) def retiming ( kappa : float , costs : dict [ int , dict [ int , float ]], durations : npt . ArrayLike , retiming_weights : dict [ int , dict [ int , float ]], ) -> tuple [ np . ndarray , float ]: \"\"\"Run the retiming trust-region-based optimization to generate an improved set of curve durations This code is essentially straight from Fast Path Planning with minimal modification since the retiming method is a bit complex, and we know that this works Args: kappa (float): Trust region parameter: Defines the maximum change in adjacent scaling factors costs (dict[int, dict[int, float]]): Breakdown of costs per curve and per derivative. Costs[i] gives the info for curve i, and costs[i][j] gives the cost associated with the jth derivative curve. Since we deal only with min-jerk, we only evaluate the j=3 case. The cost is the squared L2 norm of the jerk durations (npt.ArrayLike): Current best known value of the curve durations, shape (n_curves,) retiming_weights (dict[int, dict[int, float]]): A combination of Lagrangian multipliers and the last solved path. Weights[i] gives the weights associated with the ith differentiability (continuity) constraint, and weights[i][j] gives the weight associated with the jth derivative curve continuity. We enforce continuity up to the second derivative (j = 1 and 2) Returns: tuple[np.ndarray, float]: np.ndarray: The updated curve durations float: The new trust region parameter \"\"\" # Decision variables. n_boxes = max ( costs ) + 1 eta = cp . Variable ( n_boxes ) eta . value = np . ones ( n_boxes ) constr = [ durations @ eta == sum ( durations )] # Scale costs from previous trajectory. cost = 0 for i , ci in costs . items (): for j , cij in ci . items (): cost += cij * cp . power ( eta [ i ], 1 - 2 * j ) # Retiming weights. for k in range ( n_boxes - 1 ): for i , w in retiming_weights [ k ] . items (): cost += i * retiming_weights [ k ][ i ] * ( eta [ k + 1 ] - eta [ k ]) # Trust region. if not np . isinf ( kappa ): constr . append ( eta [ 1 :] - eta [: - 1 ] <= kappa ) constr . append ( eta [: - 1 ] - eta [ 1 :] <= kappa ) # Solve SOCP and get new durarations. prob = cp . Problem ( cp . Minimize ( cost ), constr ) prob . solve ( solver = cp . CLARABEL ) if prob . status != cp . OPTIMAL : print ( \"Clarabel failed to solve the retiming problem. Retrying with MOSEK\" ) prob . solve ( solver = cp . MOSEK ) if prob . status != cp . OPTIMAL : raise OptimizationError ( \"Unable to solve the retiming problem\" ) new_durations = np . multiply ( eta . value , durations ) # New candidate for kappa. kappa_max = max ( np . abs ( eta . value [ 1 :] - eta . value [: - 1 ])) return new_durations , kappa_max def _test_timing_estimate (): p0 = [ 0.1 , 0.2 , 0.3 ] pf = [ 1.5 , 5 , 1.7 ] safe_boxes = [ Box (( 0 , 0 , 0 ), ( 1 , 1 , 1 )), Box (( 0.5 , 0.5 , 0.5 ), ( 1.5 , 5 , 1.5 )), Box (( 1 , 4.5 , 1 ), ( 2 , 5.5 , 2 )), ] total_time , time_fractions = spline_duration_heuristic ( p0 , pf , safe_boxes ) print ( \"Time estimate: \" , total_time ) print ( \"Fractional breakdown per box: \" , time_fractions ) print ( \"Time per box: \" , total_time * time_fractions ) if __name__ == \"__main__\" : _test_timing_estimate ()","title":"Module pyastrobee.trajectories.timing"},{"location":"reference/pyastrobee/trajectories/timing/#variables","text":"ANGULAR_SPEED_LIMIT LINEAR_SPEED_LIMIT","title":"Variables"},{"location":"reference/pyastrobee/trajectories/timing/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/trajectories/timing/#bezier_duration_heuristic","text":"def bezier_duration_heuristic ( start_pt : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], end_pt : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> float Estimate the total duration of a trajectory comprised of a single Bezier curve Parameters: Name Type Description Default start_pt npt.ArrayLike Starting XYZ position, shape (3,) None end_pt npt.ArrayLike Ending XYZ position, shape (3,) None Returns: Type Description float Estimated duration View Source def bezier_duration_heuristic(start_pt: npt.ArrayLike, end_pt: npt.ArrayLike) -> float: \"\"\"Estimate the total duration of a trajectory comprised of a single Bezier curve Args: start_pt (npt.ArrayLike): Starting XYZ position, shape (3,) end_pt (npt.ArrayLike): Ending XYZ position, shape (3,) Returns: float: Estimated duration \"\"\" dist = np.linalg.norm(end_pt - start_pt) return dist / (0.5 * LINEAR_SPEED_LIMIT)","title":"bezier_duration_heuristic"},{"location":"reference/pyastrobee/trajectories/timing/#retiming","text":"def retiming ( kappa : float , costs : dict [ int , dict [ int , float ]], durations : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], retiming_weights : dict [ int , dict [ int , float ]] ) -> tuple [ numpy . ndarray , float ] Run the retiming trust-region-based optimization to generate an improved set of curve durations This code is essentially straight from Fast Path Planning with minimal modification since the retiming method is a bit complex, and we know that this works Parameters: Name Type Description Default kappa float Trust region parameter: Defines the maximum change in adjacent scaling factors None costs dict[int, dict[int, float]] Breakdown of costs per curve and per derivative. Costs[i] gives the info for curve i, and costs[i][j] gives the cost associated with the jth derivative curve. Since we deal only with min-jerk, we only evaluate the j=3 case. The cost is the squared L2 norm of the jerk None durations npt.ArrayLike Current best known value of the curve durations, shape (n_curves,) None retiming_weights dict[int, dict[int, float]] A combination of Lagrangian multipliers and the last solved path. Weights[i] gives the weights associated with the ith differentiability (continuity) constraint, and weights[i][j] gives the weight associated with the jth derivative curve continuity. We enforce continuity up to the second derivative (j = 1 and 2) None Returns: Type Description tuple[np.ndarray, float] np.ndarray: The updated curve durations float: The new trust region parameter View Source def retiming ( kappa : float , costs : dict [ int , dict [ int , float ]], durations : npt . ArrayLike , retiming_weights : dict [ int , dict [ int , float ]], ) -> tuple [ np . ndarray , float ] : \"\"\"Run the retiming trust-region-based optimization to generate an improved set of curve durations This code is essentially straight from Fast Path Planning with minimal modification since the retiming method is a bit complex, and we know that this works Args: kappa (float): Trust region parameter: Defines the maximum change in adjacent scaling factors costs (dict[int, dict[int, float]]): Breakdown of costs per curve and per derivative. Costs[i] gives the info for curve i, and costs[i][j] gives the cost associated with the jth derivative curve. Since we deal only with min-jerk, we only evaluate the j=3 case. The cost is the squared L2 norm of the jerk durations (npt.ArrayLike): Current best known value of the curve durations, shape (n_curves,) retiming_weights (dict[int, dict[int, float]]): A combination of Lagrangian multipliers and the last solved path. Weights[i] gives the weights associated with the ith differentiability (continuity) constraint, and weights[i][j] gives the weight associated with the jth derivative curve continuity. We enforce continuity up to the second derivative (j = 1 and 2) Returns: tuple[np.ndarray, float]: np.ndarray: The updated curve durations float: The new trust region parameter \"\"\" # Decision variables . n_boxes = max ( costs ) + 1 eta = cp . Variable ( n_boxes ) eta . val ue = np . ones ( n_boxes ) constr = [ durations @ eta == sum ( durations )] # Scale costs from previous trajectory . cost = 0 for i , ci in costs . items () : for j , cij in ci . items () : cost += cij * cp . power ( eta [ i ], 1 - 2 * j ) # Retiming weights . for k in range ( n_boxes - 1 ) : for i , w in retiming_weights [ k ]. items () : cost += i * retiming_weights [ k ][ i ] * ( eta [ k + 1 ] - eta [ k ]) # Trust region . if not np . isinf ( kappa ) : constr . append ( eta [ 1 : ] - eta [ :- 1 ] <= kappa ) constr . append ( eta [ :- 1 ] - eta [ 1 : ] <= kappa ) # Solve SOCP and get new durarations . prob = cp . Problem ( cp . Minimize ( cost ), constr ) prob . solve ( solver = cp . CLARABEL ) if prob . status ! = cp . OPTIMAL : print ( \"Clarabel failed to solve the retiming problem. Retrying with MOSEK\" ) prob . solve ( solver = cp . MOSEK ) if prob . status ! = cp . OPTIMAL : raise OptimizationError ( \"Unable to solve the retiming problem\" ) new_durations = np . multiply ( eta . val ue , durations ) # New candidate for kappa . kappa_max = max ( np . abs ( eta . val ue [ 1 : ] - eta . val ue [ :- 1 ])) return new_durations , kappa_max","title":"retiming"},{"location":"reference/pyastrobee/trajectories/timing/#rotation_duration_heuristic","text":"def rotation_duration_heuristic ( q0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], qf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> float Calculate an estimate of how long a rotation will take Parameters: Name Type Description Default q0 npt.ArrayLike Initial XYZW quaternion, shape (4,) None qf npt.ArrayLike Final XYZW quaternion, shape (4,) None Returns: Type Description float Time estimate, seconds View Source def rotation_duration_heuristic(q0: npt.ArrayLike, qf: npt.ArrayLike) -> float: \"\"\"Calculate an estimate of how long a rotation will take Args: q0 (npt.ArrayLike): Initial XYZW quaternion, shape (4,) qf (npt.ArrayLike): Final XYZW quaternion, shape (4,) Returns: float: Time estimate, seconds \"\"\" err = quaternion_angular_error(q0, qf) err_mag = np.linalg.norm(err) return err_mag / (0.5 * ANGULAR_SPEED_LIMIT)","title":"rotation_duration_heuristic"},{"location":"reference/pyastrobee/trajectories/timing/#spline_duration_heuristic","text":"def spline_duration_heuristic ( start_pt : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], end_pt : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], boxes : list [ pyastrobee . utils . boxes . Box ] ) -> tuple [ float , numpy . ndarray ] Calculate a preliminary estimate for the time allocated to each curve in a spline Empirically, this seems to give a decent weighting and improves the solver reliability for retiming Parameters: Name Type Description Default start_pt npt.ArrayLike Starting XYZ position, shape (3,) None end_pt npt.ArrayLike Ending XYZ position, shape (3,) None boxes list[Box] Sequence of safe boxes that will be traveled through (Not the entire free space) None Returns: Type Description tuple[float, np.ndarray] float: Total duration estimate for the entire curve np.ndarray: Fractions of the total duration allocated to each box, shape (num_boxes,) View Source def spline_duration_heuristic ( start_pt : npt . ArrayLike , end_pt : npt . ArrayLike , boxes : list [ Box ] ) -> tuple [ float, np.ndarray ] : \"\"\"Calculate a preliminary estimate for the time allocated to each curve in a spline Empirically, this seems to give a decent weighting and improves the solver reliability for retiming Args: start_pt (npt.ArrayLike): Starting XYZ position, shape (3,) end_pt (npt.ArrayLike): Ending XYZ position, shape (3,) boxes (list[Box]): Sequence of safe boxes that will be traveled through (Not the entire free space) Returns: tuple[float, np.ndarray]: float: Total duration estimate for the entire curve np.ndarray: Fractions of the total duration allocated to each box, shape (num_boxes,) \"\"\" # Approximate the lengths of each path segment path_points = intersection_path ( start_pt , end_pt , boxes ) path_lengths = np . linalg . norm ( np . diff ( path_points , axis = 0 ), axis = 1 ) total_length = np . sum ( path_lengths ) fractional_lengths = path_lengths / total_length # Allocate a little extra time to the start and end to account for accel / decel fractional_lengths [ 0 ] *= 1.5 fractional_lengths [ -1 ] *= 1.5 # Re - ensure the fractional lengths sum to one fractional_lengths /= np . sum ( fractional_lengths ) # Assume constant speed along each segment of half of the speed limit constant_speed = 0.5 * LINEAR_SPEED_LIMIT total_time = total_length / constant_speed return total_time , fractional_lengths","title":"spline_duration_heuristic"},{"location":"reference/pyastrobee/trajectories/trajectory/","text":"Module pyastrobee.trajectories.trajectory Trajectory class for Astrobee control, and trajectory-associated helpers View Source \"\"\"Trajectory class for Astrobee control, and trajectory-associated helpers\"\"\" # TODO decide if trajectory attributes should be read-only? (properties) # TODO make a subclass of Trajectory with the log() method # TODO make it clearer what happens if some of the traj components are None # (Numerically calculate the gradient? Remove the option to set these as None?) # TODO add max vel/accel lines into the plots? # TODO remove the ability to not give time information... this makes no sense. from typing import Optional , Union import pybullet from pybullet_utils.bullet_client import BulletClient import numpy as np import numpy.typing as npt import matplotlib.pyplot as plt from matplotlib.figure import Figure from pyastrobee.utils.poses import batched_pos_quats_to_tmats from pyastrobee.utils.debug_visualizer import visualize_frame , visualize_path from pyastrobee.utils.quaternions import quaternion_dist , quats_to_angular_velocities from pyastrobee.utils.boxes import Box class Trajectory : \"\"\"Trajectory class: Keeps track of a sequence of poses/velocities/accels over a period of time - All arguments can be omitted as needed (for instance, a pose-only trajectory without velocities, or a trajectory without time information) - All positions/orientations/velocities... are assumed to be defined in world frame Args: positions (Optional[npt.ArrayLike]): Sequence of XYZ positions, shape (n, 3) quats (Optional[npt.ArrayLike]): Sequence of XYZW quaternions, shape (n, 4) lin_vels (Optional[npt.ArrayLike]): Sequence of (vx, vy, vz) linear velocities, shape (n, 3) ang_vels (Optional[npt.ArrayLike]): Sequence of (wx, wy, wz) angular velocities, shape (n, 3) lin_accels (Optional[npt.ArrayLike]): Sequence of (ax, ay, az) linear accelerations, shape (n, 3) ang_accels (Optional[npt.ArrayLike]): Sequence of (al_x, al_y, al_z) angular accelerations, shape (n, 3) times (Optional[npt.ArrayLike]): Times corresponding to each trajectory entry, shape (n) \"\"\" def __init__ ( self , positions : Optional [ npt . ArrayLike ] = None , quats : Optional [ npt . ArrayLike ] = None , lin_vels : Optional [ npt . ArrayLike ] = None , ang_vels : Optional [ npt . ArrayLike ] = None , lin_accels : Optional [ npt . ArrayLike ] = None , ang_accels : Optional [ npt . ArrayLike ] = None , times : Optional [ npt . ArrayLike ] = None , ): self . _positions = positions if positions is not None else [] self . _quats = quats if quats is not None else [] self . _lin_vels = lin_vels if lin_vels is not None else [] self . _ang_vels = ang_vels if ang_vels is not None else [] self . _lin_accels = lin_accels if lin_accels is not None else [] self . _ang_accels = ang_accels if ang_accels is not None else [] self . _times = times if times is not None else [] self . _poses = None # Init self . _tmats = None # Init self . _num_timesteps = None # Init @property def positions ( self ) -> np . ndarray : return np . atleast_2d ( self . _positions ) @property def quaternions ( self ) -> np . ndarray : return np . atleast_2d ( self . _quats ) @property def linear_velocities ( self ) -> np . ndarray : return np . atleast_2d ( self . _lin_vels ) @property def angular_velocities ( self ) -> np . ndarray : return np . atleast_2d ( self . _ang_vels ) @property def linear_accels ( self ) -> np . ndarray : return np . atleast_2d ( self . _lin_accels ) @property def angular_accels ( self ) -> np . ndarray : return np . atleast_2d ( self . _ang_accels ) @property def times ( self ) -> np . ndarray : return np . asarray ( self . _times ) @property def timestep ( self ) -> float | None : if np . size ( self . _times ) == 0 : return None return self . _times [ 1 ] - self . _times [ 0 ] @property def num_timesteps ( self ) -> int : if self . _num_timesteps is None : if np . size ( self . positions ) > 0 : self . _num_timesteps = self . positions . shape [ 0 ] elif np . size ( self . quaternions ) > 0 : self . _num_timesteps = self . quaternions . shape [ 0 ] # If there is no position or orientation info, trajectory is empty (None) return self . _num_timesteps @property def duration ( self ) -> float : return self . _times [ - 1 ] - self . _times [ 0 ] @property def poses ( self ) -> np . ndarray : \"\"\"Pose array (position + xyzw quaternion), shape (n, 7)\"\"\" # if self._poses is not None: # return self._poses # Only calculate this once if self . positions . size == 0 : raise ValueError ( \"No position information available\" ) if self . quaternions . size == 0 : raise ValueError ( \"No orientation information available\" ) self . _poses = np . column_stack ([ self . positions , self . quaternions ]) return self . _poses @property def tmats ( self ) -> np . ndarray : \"\"\"Poses expressed as transformation matrices, shape (n, 4, 4)\"\"\" # if self._tmats is not None: # return self._tmats # Only calculate this once self . _tmats = batched_pos_quats_to_tmats ( self . poses ) return self . _tmats @property def contains_pos_only ( self ) -> bool : \"\"\"Whether the trajectory contains only position info\"\"\" return self . positions . size > 0 and self . quaternions . size == 0 @property def contains_orn_only ( self ) -> bool : \"\"\"Whether the trajectory contains only orientation info\"\"\" return self . positions . size == 0 and self . quaternions . size > 0 @property def contains_pos_and_orn ( self ) -> bool : \"\"\"Whether the trajectory contains both position and orientation info\"\"\" return self . positions . size > 0 and self . quaternions . size > 0 @property def is_empty ( self ) -> bool : \"\"\"Whether the trajectory contains no position/orientation info\"\"\" return self . positions . size == 0 and self . quaternions . size == 0 def visualize ( self , n : Optional [ int ] = None , size : float = 0.5 , client : Optional [ BulletClient ] = None , ) -> list [ int ]: \"\"\"View the trajectory in Pybullet Args: n (Optional[int]): Number of frames to plot, if plotting all of the frames is not desired. Defaults to None (plot all frames) size (float, optional): Length of the lines to plot for each frame. Defaults to 0.5 (this gives a good scale with respect to the dimensions of the Astrobee) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: list[int]: Pybullet IDs for the lines drawn onto the GUI \"\"\" client : pybullet = pybullet if client is None else client connection_status = client . isConnected () # Bring up the Pybullet GUI if needed if not connection_status : client . connect ( pybullet . GUI ) if self . contains_pos_and_orn : ids = visualize_traj ( self , n , size , client = client ) elif self . contains_pos_only : print ( \"Trajectory only contains position info. Showing path instead\" ) ids = visualize_path ( self . positions , n , client = client ) elif self . contains_orn_only : raise NotImplementedError ( \"Visualizing a sequence of purely orientations is not implemented yet\" ) else : # Empty trajectory raise ValueError ( \"No trajectory information to visualize\" ) # Disconnect Pybullet if we originally weren't connected if not connection_status : input ( \"Press Enter to disconnect Pybullet\" ) client . disconnect () return ids def plot ( self , show : bool = True ) -> Figure : \"\"\"Plot the trajectory components over time Args: show (bool, optional): Whether or not to display the plot. Defaults to True. Returns: Figure: Matplotlib figure containing the plots \"\"\" return plot_traj ( self , show = show ) def get_segment ( self , start_index : int , end_index : int , reset_time : bool = True ) -> \"Trajectory\" : \"\"\"Construct a trajectory segment from a larger trajectory Args: start_index (int): Starting index of the larger trajectory to extract the segment end_index (int): Ending index of the larger trajectory to extract the segment reset_time (bool): Whether to maintain the time association with the original trajectory, or reset the start time back to 0. Defaults to True (reset start time back to 0) Returns: Trajectory: A new trajectory representing a segment of the original trajectory \"\"\" # TODO: add check for invalid slicing indices? Or just leave it up to numpy # Time needs to get handled differently because the trajectory may or may not have time info if np . size ( self . times ) == 0 : # No time info new_times = None else : new_times = self . times [ start_index : end_index ] if reset_time : new_times -= new_times [ 0 ] return Trajectory ( self . positions [ start_index : end_index ], self . quaternions [ start_index : end_index ], self . linear_velocities [ start_index : end_index ], self . angular_velocities [ start_index : end_index ], self . linear_accels [ start_index : end_index ], self . angular_accels [ start_index : end_index ], new_times , ) def get_segment_between_times ( self , start_time , end_time , reset_time : bool = True ): # start_index = np.searchsorted(self.times, start_time) # end_index = np.searchsorted(self.times, end_time) raise NotImplementedError ( \"TODO\" ) class TrajectoryLogger ( Trajectory ): \"\"\"Class for maintaining a history of a robot's state over time\"\"\" def __init__ ( self ): # Create an empty Trajectory which we will iteratively append to super () . __init__ ( None , None , None , None , None , None , None ) def log_state ( self , pos : npt . ArrayLike , quat : npt . ArrayLike , lin_vel : Optional [ npt . ArrayLike ] = None , ang_vel : Optional [ npt . ArrayLike ] = None , dt : Optional [ float ] = None , ): \"\"\"Record the robot state at a given timestep If velocity information is not available (for instance, with a softbody), we can log just the position + orientation information Args: pos (npt.ArrayLike): Current position, shape (3,) quat (npt.ArrayLike): Current orientation (XYZW quaternion), shape (4,) lin_vel (Optional[npt.ArrayLike]): Current linear velocity, shape (3,). Defaults to None. ang_vel (Optional[npt.ArrayLike]): Current angular velocity, shape (3,). Defaults to None. dt (Optional[float]): Time elapsed since the previous step. Defaults to None. \"\"\" # TODO refine this functionality # Can log position/orientation info without velocity if needed # These values can be None because matplotlib will just not plot them # Most importantly, we want to make sure that things correspond in time # (There shouldn't be an instance where we have histories of different lengths) self . _positions . append ( pos ) self . _quats . append ( quat ) self . _lin_vels . append ( lin_vel ) self . _ang_vels . append ( ang_vel ) if dt is not None and len ( self . _times ) == 0 : self . _times . append ( 0.0 ) elif dt is not None : self . _times . append ( self . _times [ - 1 ] + dt ) def clear_log ( self ) -> None : \"\"\"Clears the log of all trajectory data\"\"\" self . _positions = [] self . _quats = [] self . _lin_vels = [] self . _ang_vels = [] self . _times = [] # TODO improve this... make it match up with the normal class # TODO velocity/force control? # TODO use a dictionary for the angles instead? map joint indices => their angles over time # TODO should we always define the trajectory for all of the joints? class ArmTrajectory : \"\"\"Maintains information on the positions of the arm's joint angles over time Currently this assumes we are working with position control Args: angles (np.ndarray): Joint angles over time, shape (n_timesteps, n_controlled_joints) joint_ids (npt.ArrayLike): Indices of the joints being controlled with position control. Unspecified joints will be left at their default control value (Either manually set or defined at robot initialization) times (Optional[npt.ArrayLike]): Time information for the trajectory, shape (n_timesteps). Defaults to None. key_times (Optional[dict[str, float]]): Information about when key transitions occur in the trajectory, for instance, when we start/stop an arm deployment motion. Defaults to None. Raises: ValueError: If the shape of the angles input does not match the expected number of joints being controlled, or the number of timesteps in the time input KeyError: If the key_times dictionary contains unexpected keys. Currently supported: \"begin_drag_motion\", \"end_drag_motion\", \"begin_grasp_motion\", \"end_grasp_motion\" \"\"\" def __init__ ( self , angles : np . ndarray , joint_ids : npt . ArrayLike , times : Optional [ npt . ArrayLike ] = None , key_times : Optional [ dict [ str , float ]] = None , ): if np . ndim ( angles ) == 1 : angles = angles . reshape ( - 1 , 1 ) joint_ids = np . atleast_1d ( joint_ids ) n_steps , n_joints = angles . shape if n_joints != len ( joint_ids ): raise ValueError ( \"Mismatched inputs: The second dimension of the angles must match the number of joints. \\n \" + f \"Got shape: { angles . shape } for { len ( joint_ids ) } joint indices: { joint_ids } \" ) if times is not None and len ( times ) != n_steps : raise ValueError ( \"Mismatched input dimensions: Time info is not the same length as the angles\" ) self . angles = angles self . joint_ids = joint_ids self . times = times if times is not None else [] self . num_timesteps = n_steps # Hacky way to store information on the times/indices when the arm moves back or forward # This somewhat assumes that we're going to move the arm to \"drag\" and then back to \"grasp\" # TODO make this more general # TODO improve how we handle the keys that we'd expect to see self . key_times = key_times expected_keys = { \"begin_drag_motion\" , \"end_drag_motion\" , \"begin_grasp_motion\" , \"end_grasp_motion\" , } for key in self . key_times . keys (): if key not in expected_keys : raise KeyError ( \"Unexpected key time name: \" , key ) def plot ( self ): if self . times is None or np . size ( self . times ) == 0 : x_axis = range ( self . num_timesteps ) x_label = \"Timesteps\" else : x_axis = self . times x_label = \"Time, s\" n_subplots = len ( self . joint_ids ) subplot_shape = num_subplots_to_shape ( n_subplots ) fig = plt . figure () for j , index in enumerate ( self . joint_ids ): plt . subplot ( * subplot_shape , j + 1 ) plt . plot ( x_axis , self . angles [:, j ]) plt . title ( f \"Joint { index } \" ) plt . xlabel ( x_label ) plt . ylabel ( \"Angle\" ) plt . show () # TODO!! USE NEW CONCATENATE AND EXTRAPOLATE METHODS def get_segment ( self , start_index : int , end_index : int , reset_time : bool = True ) -> \"ArmTrajectory\" : \"\"\"Construct an arm trajectory segment from a larger trajectory Args: start_index (int): Starting index of the larger trajectory to extract the segment end_index (int): Ending index of the larger trajectory to extract the segment reset_time (bool): Whether to maintain the time association with the original trajectory, or reset the start time back to 0. Defaults to True (reset start time back to 0) Returns: ArmTrajectory: A new trajectory representing a segment of the original trajectory \"\"\" # TODO: add check for invalid slicing indices? Or just leave it up to numpy # HACK HACK HACK !!!!!!!!!!!!!!!!!!!!!! n_steps = len ( self . times ) # print(f\"GETTING ARM SEGMENT: Start: {start_index}, End: {end_index}\") if start_index < n_steps and end_index < n_steps : # NORMAL # Time needs to get handled differently because the trajectory may or may not have time info if np . size ( self . times ) == 0 : # No time info new_times = None else : new_times = self . times [ start_index : end_index ] new_key_times = {} for name , time in self . key_times . items (): if new_times [ 0 ] <= time <= new_times [ - 1 ]: new_key_times [ name ] = time if reset_time and new_times is not None : new_times -= new_times [ 0 ] for name , time in new_key_times . items (): new_key_times [ name ] -= new_times [ 0 ] return ArmTrajectory ( self . angles [ start_index : end_index , :], self . joint_ids , new_times , new_key_times , ) elif start_index < n_steps and end_index >= n_steps : angles = np . vstack ( [ self . angles [ start_index :, :], np . ones (( end_index - n_steps , len ( self . joint_ids ))) * self . angles [ - 1 ], ] ) dt = self . times [ 1 ] - self . times [ 0 ] new_times = ( self . times [ start_index ] + np . arange ( end_index - start_index ) * dt ) new_key_times = {} for name , time in self . key_times . items (): if new_times [ 0 ] <= time <= new_times [ - 1 ]: new_key_times [ name ] = time if reset_time : new_times -= new_times [ 0 ] for name , time in new_key_times . items (): new_key_times [ name ] -= new_times [ 0 ] return ArmTrajectory ( angles , self . joint_ids , new_times , new_key_times ) else : # Both over the limit angles = self . angles [ - 1 ] * np . ones ( ( end_index - start_index , len ( self . joint_ids )) ) dt = self . times [ 1 ] - self . times [ 0 ] new_times = self . times [ - 1 ] + np . arange ( end_index - start_index ) * dt new_key_times = {} for name , time in self . key_times . items (): if new_times [ 0 ] <= time <= new_times [ - 1 ]: new_key_times [ name ] = time if reset_time : new_times -= new_times [ 0 ] for name , time in new_key_times . items (): new_key_times [ name ] -= new_times [ 0 ] return ArmTrajectory ( angles , self . joint_ids , new_times , new_key_times ) def get_segment_from_times ( self , start_time : float , end_time : float , reset_time : bool = True ) -> \"ArmTrajectory\" : \"\"\"Construct an arm trajectory segment from a larger trajectory Args: start_time (float): Starting time of the segment end_time (float): Ending time of the segment reset_time (bool): Whether to maintain the time association with the original trajectory, or reset the start time back to 0. Defaults to True (reset start time back to 0) Returns: ArmTrajectory: A new trajectory representing a segment of the original trajectory \"\"\" start_index = np . searchsorted ( self . times , start_time ) end_index = np . searchsorted ( self . times , end_time ) if end_index == len ( self . times ): # Past the max time... somewhat of a HACK dt = self . times [ - 1 ] - self . times [ - 2 ] time_after = end_time - self . times [ - 1 ] end_index = len ( self . times ) - 1 + round ( time_after / dt ) return self . get_segment ( start_index , end_index , reset_time ) # TODO see if we can incorporate a sequence of Boxes for the position constraints # on a spline trajectory (rather than just a single Box constraint for a single curve) def plot_traj_constraints ( traj : Trajectory , pos_lims : Optional [ Union [ Box , npt . ArrayLike ]] = None , max_vel : Optional [ float ] = None , max_accel : Optional [ float ] = None , max_omega : Optional [ float ] = None , max_alpha : Optional [ float ] = None , show : bool = True , ) -> Figure : \"\"\"Plot trajectory info to visualize how it satisfies constraints Args: traj (Trajectory): Trajectory to plot pos_lims (Optional[Union[Box, npt.ArrayLike]]): Lower and upper limits on the XYZ position. Defaults to None. max_vel (Optional[float]): Maximum velocity magnitude. Defaults to None. max_accel (Optional[float]): Maximum acceleration magnitude. Defaults to None. max_omega (Optional[float]): Maximum angular velocity magnitude. Defaults to None. max_alpha (Optional[float]): Maximum angular acceleration magnitude. Defaults to None. show (bool, optional): Whether or not to display the plot. Defaults to True. Returns: Figure: The plot \"\"\" fig = plt . figure () if traj . times is None or np . size ( traj . times ) == 0 : x_axis = range ( traj . num_timesteps ) x_label = \"Timesteps\" else : x_axis = traj . times x_label = \"Time, s\" fmt = \"k-\" lim_fmt = \"r--\" # Top row is position info, bottom row is orientation info # Columns give derivative info subfigs = fig . subfigures ( 2 , 3 ) # Position top_left = subfigs [ 0 , 0 ] . subplots ( 1 , 3 ) if traj . positions . size > 0 : for i , ax in enumerate ( top_left ): ax . plot ( x_axis , traj . positions [:, i ], fmt ) ax . set_title ([ \"x\" , \"y\" , \"z\" ][ i ]) ax . set_xlabel ( x_label ) if pos_lims is not None : lower_pos_lim , upper_pos_lim = pos_lims for i , ax in enumerate ( top_left ): ax . plot ( x_axis , lower_pos_lim [ i ] * np . ones_like ( x_axis ), lim_fmt ) ax . plot ( x_axis , upper_pos_lim [ i ] * np . ones_like ( x_axis ), lim_fmt ) # Linear velocity if traj . linear_velocities . size > 0 : top_middle = subfigs [ 0 , 1 ] . subplots ( 1 , 1 ) top_middle . plot ( x_axis , np . linalg . norm ( traj . linear_velocities , axis = 1 ), fmt ) top_middle . set_title ( \"||vel||\" ) top_middle . set_xlabel ( x_label ) if max_vel is not None : top_middle . plot ( x_axis , max_vel * np . ones_like ( x_axis ), lim_fmt ) # Linear acceleration if traj . linear_accels . size > 0 : top_right = subfigs [ 0 , 2 ] . subplots ( 1 , 1 ) top_right . plot ( x_axis , np . linalg . norm ( traj . linear_accels , axis = 1 ), fmt ) top_right . set_title ( \"||accel||\" ) top_right . set_xlabel ( x_label ) if max_accel is not None : top_right . plot ( x_axis , max_accel * np . ones_like ( x_axis ), lim_fmt ) # Quaternions # These are unconstrained so it's the same plotting method as in the standard plot traj function bot_left = subfigs [ 1 , 0 ] . subplots ( 1 , 4 ) if traj . quaternions . size > 0 : _plot ( bot_left , traj . quaternions , [ \"qx\" , \"qy\" , \"qz\" , \"qw\" ], x_axis , x_label , fmt ) # Angular velocity bot_middle = subfigs [ 1 , 1 ] . subplots ( 1 , 1 ) if traj . angular_velocities . size > 0 : bot_middle . plot ( x_axis , np . linalg . norm ( traj . angular_velocities , axis = 1 ), fmt ) bot_middle . set_title ( \"||omega||\" ) bot_middle . set_xlabel ( x_label ) if max_omega is not None : bot_middle . plot ( x_axis , max_omega * np . ones_like ( x_axis ), lim_fmt ) # Angular acceleration bot_right = subfigs [ 1 , 2 ] . subplots ( 1 , 1 ) if traj . angular_accels . size > 0 : bot_right . plot ( x_axis , np . linalg . norm ( traj . angular_accels , axis = 1 ), fmt ) bot_right . set_title ( \"||alpha||\" ) bot_right . set_xlabel ( x_label ) if max_alpha is not None : bot_right . plot ( x_axis , max_alpha * np . ones_like ( x_axis ), lim_fmt ) if show : plt . show () return fig def plot_traj ( traj : Trajectory , show : bool = True , fmt : str = \"k-\" ) -> Figure : \"\"\"Plot the trajectory components over time Args: traj (Trajectory): The Trajectory object to plot show (bool, optional): Whether or not to display the plot. Defaults to True. fmt (str, optional): Matplotlib line specification. Defaults to \"k-\" Returns: Figure: Matplotlib figure containing the plots \"\"\" # Indexing helper variables POS = 0 ORN = 1 LIN_VEL = 2 ANG_VEL = 3 LIN_ACCEL = 4 ANG_ACCEL = 5 labels = { POS : [ \"x\" , \"y\" , \"z\" ], ORN : [ \"qx\" , \"qy\" , \"qz\" , \"qw\" ], LIN_VEL : [ \"vx\" , \"vy\" , \"vz\" ], ANG_VEL : [ \"wx\" , \"wy\" , \"wz\" ], LIN_ACCEL : [ \"ax\" , \"ay\" , \"az\" ], ANG_ACCEL : [ \"al_x\" , \"al_y\" , \"al_z\" ], } fig = plt . figure () if traj . times is None or np . size ( traj . times ) == 0 : x_axis = range ( traj . num_timesteps ) x_label = \"Timesteps\" else : x_axis = traj . times x_label = \"Time, s\" # Top row is position info, bottom row is orientation info # Columns give derivative info subfigs = fig . subfigures ( 2 , 3 ) top_left = subfigs [ 0 , 0 ] . subplots ( 1 , 3 ) _plot ( top_left , traj . positions , labels [ POS ], x_axis , x_label , fmt ) top_middle = subfigs [ 0 , 1 ] . subplots ( 1 , 3 ) _plot ( top_middle , traj . linear_velocities , labels [ LIN_VEL ], x_axis , x_label , fmt ) top_right = subfigs [ 0 , 2 ] . subplots ( 1 , 3 ) _plot ( top_right , traj . linear_accels , labels [ LIN_ACCEL ], x_axis , x_label , fmt ) bot_left = subfigs [ 1 , 0 ] . subplots ( 1 , 4 ) _plot ( bot_left , traj . quaternions , labels [ ORN ], x_axis , x_label , fmt ) bot_middle = subfigs [ 1 , 1 ] . subplots ( 1 , 3 ) _plot ( bot_middle , traj . angular_velocities , labels [ ANG_VEL ], x_axis , x_label , fmt ) bot_right = subfigs [ 1 , 2 ] . subplots ( 1 , 3 ) _plot ( bot_right , traj . angular_accels , labels [ ANG_ACCEL ], x_axis , x_label , fmt ) if show : plt . show () return fig def _plot ( axes : np . ndarray [ plt . Axes ], data : np . ndarray , labels : list [ str ], x_axis : np . ndarray , x_label : str , * args , ** kwargs , ): \"\"\"Helper function for plotting trajectory components Args: axes (np.ndarray[plt.Axes]): Matplotlib axes for subplots within a subfigure, length = n data (np.ndarray): Trajectory information to plot, shape (m, n) where m is the number of timesteps and n refers to the number of components of that trajectory info (for instance, position has data for x, y, and z, so n = 3) labels (list[str]): Labels for each of the components of the trajectory data, length = n x_axis (np.ndarray): X-axis data to plot the trajectory against, length = m x_label (str): Label for the x-axis (for instance, \"Time\" or \"Steps\") \"\"\" # If the trajectory doesn't contain the info, don't plot it if np . size ( data ) == 0 or data is None : return # Number of components to plot (for instance, position: n = 3: x, y, z) n = data . shape [ 1 ] assert n == len ( labels ) assert n == len ( axes ) # Plot each component of the trajectory information on a separate axis for i , ax in enumerate ( axes ): ax . plot ( x_axis , data [:, i ], * args , ** kwargs ) ax . set_title ( labels [ i ]) ax . set_xlabel ( x_label ) # TODO all of the plotting logic here is extremely similar to the single-plot method # Figure out a way to simplify the code def compare_trajs ( traj_1 : Trajectory , traj_2 : Trajectory , show : bool = True , fmt_1 : str = \"k-\" , fmt_2 : str = \"b-\" , ) -> Figure : \"\"\"Compares two trajectories by plotting them on the same axes Args: traj_1 (Trajectory): First trajectory to plot traj_2 (Trajectory): Second trajectory to plot show (bool, optional): . Defaults to True. fmt_1 (str, optional): Matplotlib line specification for the first traj. Defaults to \"k-\". fmt_2 (str, optional): Matplotlib line specification for the second traj. Defaults to \"b-\". Returns: Figure: Matplotlib figure containing the plots \"\"\" # Indexing helper variables POS = 0 ORN = 1 LIN_VEL = 2 ANG_VEL = 3 LIN_ACCEL = 4 ANG_ACCEL = 5 labels = { POS : [ \"x\" , \"y\" , \"z\" ], ORN : [ \"qx\" , \"qy\" , \"qz\" , \"qw\" ], LIN_VEL : [ \"vx\" , \"vy\" , \"vz\" ], ANG_VEL : [ \"wx\" , \"wy\" , \"wz\" ], LIN_ACCEL : [ \"ax\" , \"ay\" , \"az\" ], ANG_ACCEL : [ \"al_x\" , \"al_y\" , \"al_z\" ], } fig = plt . figure () # TODO this check is kinda weird right now # what happens if one has time info and the other doesn't?? if traj_1 . times is None or np . size ( traj_1 . times ) == 0 : x_axis_1 = range ( traj_1 . num_timesteps ) x_label = \"Timesteps\" else : x_axis_1 = traj_1 . times x_label = \"Time, s\" if traj_2 . times is None or np . size ( traj_2 . times ) == 0 : x_axis_2 = range ( traj_2 . num_timesteps ) else : x_axis_2 = traj_2 . times # Top row is position info, bottom row is orientation info # Columns give derivative info # fmt: off subfigs = fig . subfigures ( 2 , 3 ) top_left = subfigs [ 0 , 0 ] . subplots ( 1 , 3 ) _plot ( top_left , traj_1 . positions , labels [ POS ], x_axis_1 , x_label , fmt_1 ) _plot ( top_left , traj_2 . positions , labels [ POS ], x_axis_2 , x_label , fmt_2 ) top_middle = subfigs [ 0 , 1 ] . subplots ( 1 , 3 ) _plot ( top_middle , traj_1 . linear_velocities , labels [ LIN_VEL ], x_axis_1 , x_label , fmt_1 ) _plot ( top_middle , traj_2 . linear_velocities , labels [ LIN_VEL ], x_axis_2 , x_label , fmt_2 ) top_right = subfigs [ 0 , 2 ] . subplots ( 1 , 3 ) _plot ( top_right , traj_1 . linear_accels , labels [ LIN_ACCEL ], x_axis_1 , x_label , fmt_1 ) _plot ( top_right , traj_2 . linear_accels , labels [ LIN_ACCEL ], x_axis_2 , x_label , fmt_2 ) bot_left = subfigs [ 1 , 0 ] . subplots ( 1 , 4 ) _plot ( bot_left , traj_1 . quaternions , labels [ ORN ], x_axis_1 , x_label , fmt_1 ) _plot ( bot_left , traj_2 . quaternions , labels [ ORN ], x_axis_2 , x_label , fmt_2 ) bot_mid = subfigs [ 1 , 1 ] . subplots ( 1 , 3 ) _plot ( bot_mid , traj_1 . angular_velocities , labels [ ANG_VEL ], x_axis_1 , x_label , fmt_1 ) _plot ( bot_mid , traj_2 . angular_velocities , labels [ ANG_VEL ], x_axis_2 , x_label , fmt_2 ) bot_right = subfigs [ 1 , 2 ] . subplots ( 1 , 3 ) _plot ( bot_right , traj_1 . angular_accels , labels [ ANG_ACCEL ], x_axis_1 , x_label , fmt_1 ) _plot ( bot_right , traj_2 . angular_accels , labels [ ANG_ACCEL ], x_axis_2 , x_label , fmt_2 ) # fmt: on if show : plt . show () return fig def visualize_traj ( traj : Union [ Trajectory , npt . ArrayLike ], n : Optional [ int ] = None , size : float = 0.5 , client : Optional [ BulletClient ] = None , ) -> list [ int ]: \"\"\"Visualizes a trajectory's sequence of poses on the Pybullet GUI Args: traj (Union[Trajectory, npt.ArrayLike]): Trajectory to visualize (must contain at least position + orientation info), or an array of position + quaternion poses, shape (n, 7) n (Optional[int]): Number of frames to plot, if plotting all of the frames is not desired. Defaults to None (plot all frames) size (float, optional): Length of the lines to plot for each frame. Defaults to 0.5 (this gives a good scale with respect to the dimensions of the Astrobee) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: list[int]: Pybullet IDs for the lines drawn onto the GUI \"\"\" client : pybullet = pybullet if client is None else client if isinstance ( traj , Trajectory ): traj = traj . poses else : # If there is more information (velocity, time) in our array, only use the pose info traj = np . atleast_2d ( traj )[:, : 7 ] n_frames = traj . shape [ 0 ] # If desired, sample frames evenly across the trajectory to plot a subset if n is not None and n < n_frames : # This indexing ensures that the first and last frames are plotted idx = np . round ( np . linspace ( 0 , n_frames - 1 , n , endpoint = True )) . astype ( int ) traj = traj [ idx , :] tmats = batched_pos_quats_to_tmats ( traj ) ids = [] for i in range ( tmats . shape [ 0 ]): ids += visualize_frame ( tmats [ i , :, :], size , client = client ) return ids # TODO Move this to a more dynamics-relevant location? def stopping_criteria ( pos : npt . ArrayLike , quat : npt . ArrayLike , lin_vel : npt . ArrayLike , ang_vel : npt . ArrayLike , pos_des : npt . ArrayLike , quat_des : npt . ArrayLike , dp : float = 1e-2 , dq : float = 1e-2 , dv : float = 1e-2 , dw : float = 5e-3 , ) -> bool : \"\"\"Determine if the Astrobee has fully stopped, based on its current dynamics state Args: pos (npt.ArrayLike): Current position, shape (3,) quat (npt.ArrayLike): Current XYZW quaternion orientation, shape (4,) lin_vel (npt.ArrayLike): Current linear velocity, shape (3,) ang_vel (npt.ArrayLike): Current angular velocity, shape (3,) pos_des (npt.ArrayLike): Desired position, shape (3,) quat_des (npt.ArrayLike): Desired XYZW quaternion orientation, shape (4,) dp (float, optional): Tolerance on position error magnitude. Defaults to 1e-2. dq (float, optional): Tolerance on quaternion distance between cur/des. Defaults to 1e-2. dv (float, optional): Tolerance on linear velocity error magnitude. Defaults to 1e-2. dw (float, optional): Tolerance on angular velocity error magnitude. Defaults to 5e-3. Returns: bool: If the Astrobee have successfully stopped at its desired goal pose \"\"\" p_check = np . linalg . norm ( pos - pos_des ) <= dp q_check = quaternion_dist ( quat , quat_des ) <= dq v_check = np . linalg . norm ( lin_vel ) <= dv w_check = np . linalg . norm ( ang_vel ) <= dw checks = [ p_check , q_check , v_check , w_check ] return np . all ( checks ) def merge_trajs ( pos_traj : Trajectory , orn_traj : Trajectory ) -> Trajectory : \"\"\"Merge the position component from one trajectory with the orientation component from another Args: pos_traj (Trajectory): Trajectory with desired position component orn_traj (Trajectory): Trajectory with desired orientation component Returns: Trajectory: Merged trajectory with both position + orientation info \"\"\" assert np . size ( pos_traj . positions ) > 0 assert np . size ( orn_traj . quaternions ) > 0 positions = pos_traj . positions quaternions = pos_traj . quaternions # Time # If both trajectories have time info, make sure they match up if np . size ( pos_traj . times ) > 0 : if np . size ( orn_traj . times ) > 0 : if not np . allclose ( pos_traj . times , orn_traj . times ): raise ValueError ( \"Mismatched time information\" ) times = pos_traj . times dt = pos_traj . timestep elif np . size ( orn_traj . times ) > 0 : times = orn_traj . times dt = orn_traj . timestep else : times = None dt = None # If either trajectory is missing derivative info, compute it if we can # Position if np . size ( pos_traj . linear_velocities ) == 0 and dt is not None : lin_vels = np . gradient ( pos_traj . positions , dt , axis = 0 ) else : lin_vels = pos_traj . linear_velocities if np . size ( pos_traj . linear_accels ) == 0 and dt is not None : lin_accels = np . gradient ( lin_vels , dt , axis = 0 ) else : lin_accels = pos_traj . linear_accels # Orientation if np . size ( orn_traj . angular_velocities ) == 0 and dt is not None : ang_vels = quats_to_angular_velocities ( orn_traj . quaternions , dt ) else : ang_vels = orn_traj . angular_velocities if np . size ( orn_traj . angular_accels ) == 0 and dt is not None : ang_accels = np . gradient ( ang_vels , dt , axis = 0 ) else : ang_accels = orn_traj . angular_accels return Trajectory ( positions , quaternions , lin_vels , ang_vels , lin_accels , ang_accels , times ) def concatenate_trajs ( traj_1 : Trajectory , traj_2 : Trajectory ) -> Trajectory : \"\"\"Combine two trajectories one after the other This will follow the first trajectory until its end, then follow the second one until it ends Args: traj_1 (Trajectory): First trajectory traj_2 (Trajectory): Second trajectory Returns: Trajectory: Combined trajectory \"\"\" # Ensure continuity in time # TODO check for continuity in all other components? # TODO this assumes that both have time information dt = traj_1 . times [ - 1 ] - traj_1 . times [ - 2 ] if np . isclose ( traj_2 . times [ 0 ], 0 ): times = np . concatenate ([ traj_1 . times , traj_2 . times + traj_1 . times [ - 1 ] + dt ]) elif np . isclose ( traj_2 . times [ 0 ], traj_1 . times [ - 1 ] + dt ): times = np . concatenate ([ traj_1 . times , traj_2 . times ]) return Trajectory ( np . vstack ([ traj_1 . positions , traj_2 . positions ]), np . vstack ( [ traj_1 . quaternions , traj_2 . quaternions ], ), np . vstack ([ traj_1 . linear_velocities , traj_2 . linear_velocities ]), np . vstack ([ traj_1 . angular_velocities , traj_2 . angular_velocities ]), np . vstack ([ traj_1 . linear_accels , traj_2 . linear_accels ]), np . vstack ([ traj_1 . angular_accels , traj_2 . angular_accels ]), times , ) def concatenate_arm_trajs ( traj_1 : ArmTrajectory , traj_2 : ArmTrajectory ) -> ArmTrajectory : \"\"\"Combine two arm trajectories one after the other This will follow the first trajectory until its end, then follow the second one until it ends Args: traj_1 (ArmTrajectory): First trajectory traj_2 (ArmTrajectory): Second trajectory Returns: ArmTrajectory: Combined trajectory \"\"\" if traj_1 . joint_ids != traj_2 . joint_ids : raise NotImplementedError ( \"Controlled joint indices must match between the two trajectories (for now)\" ) # Ensure continuity in time, and merge the key time information # TODO check for continuity in all other components? # TODO this assumes that both have time information dt = traj_1 . times [ - 1 ] - traj_1 . times [ - 2 ] new_key_times = traj_1 . key_times if np . isclose ( traj_2 . times [ 0 ], 0 ): times = np . concatenate ([ traj_1 . times , traj_2 . times + traj_1 . times [ - 1 ] + dt ]) for name , time in traj_2 . key_times . items (): new_key_times [ name ] = time + traj_1 . times [ - 1 ] + dt elif np . isclose ( traj_2 . times [ 0 ], traj_1 . times [ - 1 ] + dt ): times = np . concatenate ([ traj_1 . times , traj_2 . times ]) new_key_times |= traj_2 . key_times return ArmTrajectory ( np . vstack ([ traj_1 . angles , traj_2 . angles ]), traj_1 . joint_ids , times , new_key_times , ) def extrapolate_traj ( traj : Trajectory , duration : Optional [ float ] = None , n_steps : Optional [ int ] = None ) -> Trajectory : \"\"\"Extrapolates a trajectory by an amount of time This assumes that the (pre-extrapolation) trajectory comes to a rest at the end Either the extrapolation duration or number of timesteps must be specified. Not both, not neither Args: traj (Trajectory): Original trajectory duration (Optional[float], optional): Amount of time to extrapolate by. Defaults to None (n_steps input must be provided) n_steps (Optional[int], optional): Number of timesteps to extrapolate by. Defaults to None (duration input must be provided) Returns: Trajectory: Extrapolated trajectory \"\"\" dt = traj . times [ - 1 ] - traj . times [ - 2 ] if duration is None and n_steps is None : raise ValueError ( \"Must provide either a duration to extrapolate by, or a fixed number of timesteps\" ) elif duration is not None and n_steps is not None : raise ValueError ( \"Provide either a duration or a number of timesteps, not both\" ) elif duration is not None : n_steps = round ( duration / dt ) assert n_steps is not None if not np . isclose ( np . linalg . norm ( traj . linear_velocities [ - 1 ]), 0 ) or not np . isclose ( np . linalg . norm ( traj . angular_velocities [ - 1 ]), 0 ): raise NotImplementedError ( \"Cannot extrapolate the trajectory: Only implemented for trajectories that end at a stopped pose\" ) return Trajectory ( np . vstack ([ traj . positions , traj . positions [ - 1 ] * np . ones (( n_steps , 1 ))]), np . vstack ([ traj . quaternions , traj . quaternions [ - 1 ] * np . ones (( n_steps , 1 ))]), np . vstack ([ traj . linear_velocities , np . zeros (( n_steps , 3 ))]), np . vstack ([ traj . angular_velocities , np . zeros (( n_steps , 3 ))]), np . vstack ([ traj . linear_accels , np . zeros (( n_steps , 3 ))]), np . vstack ([ traj . angular_accels , np . zeros (( n_steps , 3 ))]), np . concatenate ([ traj . times , traj . times [ - 1 ] + dt + np . arange ( n_steps ) * dt ]), ) def extrapolate_arm_traj ( traj : ArmTrajectory , duration : Optional [ float ] = None , n_steps : Optional [ int ] = None ) -> ArmTrajectory : \"\"\"Extrapolates an arm trajectory by an amount of time This assumes that the (pre-extrapolation) trajectory comes to a rest at the end Either the extrapolation duration or number of timesteps must be specified. Not both, not neither Args: traj (ArmTrajectory): Original arm trajectory duration (Optional[float], optional): Amount of time to extrapolate by. Defaults to None (n_steps input must be provided) n_steps (Optional[int], optional): Number of timesteps to extrapolate by. Defaults to None (duration input must be provided) Returns: ArmTrajectory: Extrapolated arm trajectory \"\"\" dt = traj . times [ - 1 ] - traj . times [ - 2 ] if duration is None and n_steps is None : raise ValueError ( \"Must provide either a duration to extrapolate by, or a fixed number of timesteps\" ) elif duration is not None and n_steps is not None : raise ValueError ( \"Provide either a duration or a number of timesteps, not both\" ) elif duration is not None : n_steps = round ( duration / dt ) assert n_steps is not None return ArmTrajectory ( np . vstack ([ traj . angles , traj . angles [ - 1 ] * np . ones (( n_steps , 1 ))]), traj . joint_ids , np . concatenate ([ traj . times , traj . times [ - 1 ] + dt + np . arange ( n_steps ) * dt ]), traj . key_times , ) def num_subplots_to_shape ( n : int ) -> tuple [ int , int ]: \"\"\"Determines the best layout of a number of subplots within a larger figure Args: n (int): Number of subplots Returns: tuple[int, int]: Number of rows and columns for the subplot divisions \"\"\" n_rows = int ( np . sqrt ( n )) n_cols = n // n_rows + ( n % n_rows > 0 ) assert n_rows * n_cols >= n return ( n_rows , n_cols ) Functions compare_trajs def compare_trajs ( traj_1 : pyastrobee . trajectories . trajectory . Trajectory , traj_2 : pyastrobee . trajectories . trajectory . Trajectory , show : bool = True , fmt_1 : str = 'k-' , fmt_2 : str = 'b-' ) -> matplotlib . figure . Figure Compares two trajectories by plotting them on the same axes Parameters: Name Type Description Default traj_1 Trajectory First trajectory to plot None traj_2 Trajectory Second trajectory to plot None show bool . Defaults to True. True fmt_1 str Matplotlib line specification for the first traj. Defaults to \"k-\". \"k-\" fmt_2 str Matplotlib line specification for the second traj. Defaults to \"b-\". \"b-\" Returns: Type Description Figure Matplotlib figure containing the plots View Source def compare_trajs ( traj_1 : Trajectory , traj_2 : Trajectory , show : bool = True , fmt_1 : str = \"k-\" , fmt_2 : str = \"b-\" , ) -> Figure : \"\"\"Compares two trajectories by plotting them on the same axes Args: traj_1 (Trajectory): First trajectory to plot traj_2 (Trajectory): Second trajectory to plot show (bool, optional): . Defaults to True. fmt_1 (str, optional): Matplotlib line specification for the first traj. Defaults to \" k - \". fmt_2 (str, optional): Matplotlib line specification for the second traj. Defaults to \" b - \". Returns: Figure: Matplotlib figure containing the plots \"\"\" # Indexing helper variables POS = 0 ORN = 1 LIN_VEL = 2 ANG_VEL = 3 LIN_ACCEL = 4 ANG_ACCEL = 5 labels = { POS : [ \"x\", \"y\", \"z\" ] , ORN : [ \"qx\", \"qy\", \"qz\", \"qw\" ] , LIN_VEL : [ \"vx\", \"vy\", \"vz\" ] , ANG_VEL : [ \"wx\", \"wy\", \"wz\" ] , LIN_ACCEL : [ \"ax\", \"ay\", \"az\" ] , ANG_ACCEL : [ \"al_x\", \"al_y\", \"al_z\" ] , } fig = plt . figure () # TODO this check is kinda weird right now # what happens if one has time info and the other doesn ' t ?? if traj_1 . times is None or np . size ( traj_1 . times ) == 0 : x_axis_1 = range ( traj_1 . num_timesteps ) x_label = \"Timesteps\" else : x_axis_1 = traj_1 . times x_label = \"Time, s\" if traj_2 . times is None or np . size ( traj_2 . times ) == 0 : x_axis_2 = range ( traj_2 . num_timesteps ) else : x_axis_2 = traj_2 . times # Top row is position info , bottom row is orientation info # Columns give derivative info # fmt : off subfigs = fig . subfigures ( 2 , 3 ) top_left = subfigs [ 0, 0 ] . subplots ( 1 , 3 ) _plot ( top_left , traj_1 . positions , labels [ POS ] , x_axis_1 , x_label , fmt_1 ) _plot ( top_left , traj_2 . positions , labels [ POS ] , x_axis_2 , x_label , fmt_2 ) top_middle = subfigs [ 0, 1 ] . subplots ( 1 , 3 ) _plot ( top_middle , traj_1 . linear_velocities , labels [ LIN_VEL ] , x_axis_1 , x_label , fmt_1 ) _plot ( top_middle , traj_2 . linear_velocities , labels [ LIN_VEL ] , x_axis_2 , x_label , fmt_2 ) top_right = subfigs [ 0, 2 ] . subplots ( 1 , 3 ) _plot ( top_right , traj_1 . linear_accels , labels [ LIN_ACCEL ] , x_axis_1 , x_label , fmt_1 ) _plot ( top_right , traj_2 . linear_accels , labels [ LIN_ACCEL ] , x_axis_2 , x_label , fmt_2 ) bot_left = subfigs [ 1, 0 ] . subplots ( 1 , 4 ) _plot ( bot_left , traj_1 . quaternions , labels [ ORN ] , x_axis_1 , x_label , fmt_1 ) _plot ( bot_left , traj_2 . quaternions , labels [ ORN ] , x_axis_2 , x_label , fmt_2 ) bot_mid = subfigs [ 1, 1 ] . subplots ( 1 , 3 ) _plot ( bot_mid , traj_1 . angular_velocities , labels [ ANG_VEL ] , x_axis_1 , x_label , fmt_1 ) _plot ( bot_mid , traj_2 . angular_velocities , labels [ ANG_VEL ] , x_axis_2 , x_label , fmt_2 ) bot_right = subfigs [ 1, 2 ] . subplots ( 1 , 3 ) _plot ( bot_right , traj_1 . angular_accels , labels [ ANG_ACCEL ] , x_axis_1 , x_label , fmt_1 ) _plot ( bot_right , traj_2 . angular_accels , labels [ ANG_ACCEL ] , x_axis_2 , x_label , fmt_2 ) # fmt : on if show : plt . show () return fig concatenate_arm_trajs def concatenate_arm_trajs ( traj_1 : pyastrobee . trajectories . trajectory . ArmTrajectory , traj_2 : pyastrobee . trajectories . trajectory . ArmTrajectory ) -> pyastrobee . trajectories . trajectory . ArmTrajectory Combine two arm trajectories one after the other This will follow the first trajectory until its end, then follow the second one until it ends Parameters: Name Type Description Default traj_1 ArmTrajectory First trajectory None traj_2 ArmTrajectory Second trajectory None Returns: Type Description ArmTrajectory Combined trajectory View Source def concatenate_arm_trajs ( traj_1 : ArmTrajectory , traj_2 : ArmTrajectory ) -> ArmTrajectory : \"\"\"Combine two arm trajectories one after the other This will follow the first trajectory until its end, then follow the second one until it ends Args: traj_1 (ArmTrajectory): First trajectory traj_2 (ArmTrajectory): Second trajectory Returns: ArmTrajectory: Combined trajectory \"\"\" if traj_1 . joint_ids != traj_2 . joint_ids : raise NotImplementedError ( \"Controlled joint indices must match between the two trajectories (for now)\" ) # Ensure continuity in time , and merge the key time information # TODO check for continuity in all other components ? # TODO this assumes that both have time information dt = traj_1 . times [ -1 ] - traj_1 . times [ -2 ] new_key_times = traj_1 . key_times if np . isclose ( traj_2 . times [ 0 ] , 0 ) : times = np . concatenate ( [ traj_1.times, traj_2.times + traj_1.times[-1 ] + dt ] ) for name , time in traj_2 . key_times . items () : new_key_times [ name ] = time + traj_1 . times [ -1 ] + dt elif np . isclose ( traj_2 . times [ 0 ] , traj_1 . times [ -1 ] + dt ) : times = np . concatenate ( [ traj_1.times, traj_2.times ] ) new_key_times |= traj_2 . key_times return ArmTrajectory ( np . vstack ( [ traj_1.angles, traj_2.angles ] ), traj_1 . joint_ids , times , new_key_times , ) concatenate_trajs def concatenate_trajs ( traj_1 : pyastrobee . trajectories . trajectory . Trajectory , traj_2 : pyastrobee . trajectories . trajectory . Trajectory ) -> pyastrobee . trajectories . trajectory . Trajectory Combine two trajectories one after the other This will follow the first trajectory until its end, then follow the second one until it ends Parameters: Name Type Description Default traj_1 Trajectory First trajectory None traj_2 Trajectory Second trajectory None Returns: Type Description Trajectory Combined trajectory View Source def concatenate_trajs ( traj_1 : Trajectory , traj_2 : Trajectory ) -> Trajectory : \"\"\"Combine two trajectories one after the other This will follow the first trajectory until its end, then follow the second one until it ends Args: traj_1 (Trajectory): First trajectory traj_2 (Trajectory): Second trajectory Returns: Trajectory: Combined trajectory \"\"\" # Ensure continuity in time # TODO check for continuity in all other components ? # TODO this assumes that both have time information dt = traj_1 . times [ - 1 ] - traj_1 . times [ - 2 ] if np . isclose ( traj_2 . times [ 0 ], 0 ) : times = np . concatenate ([ traj_1 . times , traj_2 . times + traj_1 . times [ - 1 ] + dt ]) elif np . isclose ( traj_2 . times [ 0 ], traj_1 . times [ - 1 ] + dt ) : times = np . concatenate ([ traj_1 . times , traj_2 . times ]) return Trajectory ( np . vstack ([ traj_1 . positions , traj_2 . positions ]), np . vstack ( [ traj_1 . quaternions , traj_2 . quaternions ], ), np . vstack ([ traj_1 . linear_velocities , traj_2 . linear_velocities ]), np . vstack ([ traj_1 . angular_velocities , traj_2 . angular_velocities ]), np . vstack ([ traj_1 . linear_accels , traj_2 . linear_accels ]), np . vstack ([ traj_1 . angular_accels , traj_2 . angular_accels ]), times , ) extrapolate_arm_traj def extrapolate_arm_traj ( traj : pyastrobee . trajectories . trajectory . ArmTrajectory , duration : Optional [ float ] = None , n_steps : Optional [ int ] = None ) -> pyastrobee . trajectories . trajectory . ArmTrajectory Extrapolates an arm trajectory by an amount of time This assumes that the (pre-extrapolation) trajectory comes to a rest at the end Either the extrapolation duration or number of timesteps must be specified. Not both, not neither Parameters: Name Type Description Default traj ArmTrajectory Original arm trajectory None duration Optional[float] Amount of time to extrapolate by. Defaults to None (n_steps input must be provided) None n_steps Optional[int] Number of timesteps to extrapolate by. Defaults to None (duration input must be provided) None Returns: Type Description ArmTrajectory Extrapolated arm trajectory View Source def extrapolate_arm_traj ( traj : ArmTrajectory , duration : Optional [ float ] = None , n_steps : Optional [ int ] = None ) -> ArmTrajectory : \"\"\"Extrapolates an arm trajectory by an amount of time This assumes that the (pre-extrapolation) trajectory comes to a rest at the end Either the extrapolation duration or number of timesteps must be specified. Not both, not neither Args: traj (ArmTrajectory): Original arm trajectory duration (Optional[float], optional): Amount of time to extrapolate by. Defaults to None (n_steps input must be provided) n_steps (Optional[int], optional): Number of timesteps to extrapolate by. Defaults to None (duration input must be provided) Returns: ArmTrajectory: Extrapolated arm trajectory \"\"\" dt = traj . times [ -1 ] - traj . times [ -2 ] if duration is None and n_steps is None : raise ValueError ( \"Must provide either a duration to extrapolate by, or a fixed number of timesteps\" ) elif duration is not None and n_steps is not None : raise ValueError ( \"Provide either a duration or a number of timesteps, not both\" ) elif duration is not None : n_steps = round ( duration / dt ) assert n_steps is not None return ArmTrajectory ( np . vstack ( [ traj.angles, traj.angles[-1 ] * np . ones (( n_steps , 1 )) ] ), traj . joint_ids , np . concatenate ( [ traj.times, traj.times[-1 ] + dt + np . arange ( n_steps ) * dt ] ), traj . key_times , ) extrapolate_traj def extrapolate_traj ( traj : pyastrobee . trajectories . trajectory . Trajectory , duration : Optional [ float ] = None , n_steps : Optional [ int ] = None ) -> pyastrobee . trajectories . trajectory . Trajectory Extrapolates a trajectory by an amount of time This assumes that the (pre-extrapolation) trajectory comes to a rest at the end Either the extrapolation duration or number of timesteps must be specified. Not both, not neither Parameters: Name Type Description Default traj Trajectory Original trajectory None duration Optional[float] Amount of time to extrapolate by. Defaults to None (n_steps input must be provided) None n_steps Optional[int] Number of timesteps to extrapolate by. Defaults to None (duration input must be provided) None Returns: Type Description Trajectory Extrapolated trajectory View Source def extrapolate_traj ( traj : Trajectory , duration : Optional [ float ] = None , n_steps : Optional [ int ] = None ) -> Trajectory : \"\"\"Extrapolates a trajectory by an amount of time This assumes that the (pre-extrapolation) trajectory comes to a rest at the end Either the extrapolation duration or number of timesteps must be specified. Not both, not neither Args: traj (Trajectory): Original trajectory duration (Optional[float], optional): Amount of time to extrapolate by. Defaults to None (n_steps input must be provided) n_steps (Optional[int], optional): Number of timesteps to extrapolate by. Defaults to None (duration input must be provided) Returns: Trajectory: Extrapolated trajectory \"\"\" dt = traj . times [ -1 ] - traj . times [ -2 ] if duration is None and n_steps is None : raise ValueError ( \"Must provide either a duration to extrapolate by, or a fixed number of timesteps\" ) elif duration is not None and n_steps is not None : raise ValueError ( \"Provide either a duration or a number of timesteps, not both\" ) elif duration is not None : n_steps = round ( duration / dt ) assert n_steps is not None if not np . isclose ( np . linalg . norm ( traj . linear_velocities [ -1 ] ), 0 ) or not np . isclose ( np . linalg . norm ( traj . angular_velocities [ -1 ] ), 0 ) : raise NotImplementedError ( \"Cannot extrapolate the trajectory: Only implemented for trajectories that end at a stopped pose\" ) return Trajectory ( np . vstack ( [ traj.positions, traj.positions[-1 ] * np . ones (( n_steps , 1 )) ] ), np . vstack ( [ traj.quaternions, traj.quaternions[-1 ] * np . ones (( n_steps , 1 )) ] ), np . vstack ( [ traj.linear_velocities, np.zeros((n_steps, 3)) ] ), np . vstack ( [ traj.angular_velocities, np.zeros((n_steps, 3)) ] ), np . vstack ( [ traj.linear_accels, np.zeros((n_steps, 3)) ] ), np . vstack ( [ traj.angular_accels, np.zeros((n_steps, 3)) ] ), np . concatenate ( [ traj.times, traj.times[-1 ] + dt + np . arange ( n_steps ) * dt ] ), ) merge_trajs def merge_trajs ( pos_traj : pyastrobee . trajectories . trajectory . Trajectory , orn_traj : pyastrobee . trajectories . trajectory . Trajectory ) -> pyastrobee . trajectories . trajectory . Trajectory Merge the position component from one trajectory with the orientation component from another Parameters: Name Type Description Default pos_traj Trajectory Trajectory with desired position component None orn_traj Trajectory Trajectory with desired orientation component None Returns: Type Description Trajectory Merged trajectory with both position + orientation info View Source def merge_trajs ( pos_traj : Trajectory , orn_traj : Trajectory ) -> Trajectory : \"\"\"Merge the position component from one trajectory with the orientation component from another Args: pos_traj (Trajectory): Trajectory with desired position component orn_traj (Trajectory): Trajectory with desired orientation component Returns: Trajectory: Merged trajectory with both position + orientation info \"\"\" assert np . size ( pos_traj . positions ) > 0 assert np . size ( orn_traj . quaternions ) > 0 positions = pos_traj . positions quaternions = pos_traj . quaternions # Time # If both trajectories have time info , make sure they match up if np . size ( pos_traj . times ) > 0 : if np . size ( orn_traj . times ) > 0 : if not np . allclose ( pos_traj . times , orn_traj . times ) : raise ValueError ( \"Mismatched time information\" ) times = pos_traj . times dt = pos_traj . timestep elif np . size ( orn_traj . times ) > 0 : times = orn_traj . times dt = orn_traj . timestep else : times = None dt = None # If either trajectory is missing derivative info , compute it if we can # Position if np . size ( pos_traj . linear_velocities ) == 0 and dt is not None : lin_vels = np . gradient ( pos_traj . positions , dt , axis = 0 ) else : lin_vels = pos_traj . linear_velocities if np . size ( pos_traj . linear_accels ) == 0 and dt is not None : lin_accels = np . gradient ( lin_vels , dt , axis = 0 ) else : lin_accels = pos_traj . linear_accels # Orientation if np . size ( orn_traj . angular_velocities ) == 0 and dt is not None : ang_vels = quats_to_angular_velocities ( orn_traj . quaternions , dt ) else : ang_vels = orn_traj . angular_velocities if np . size ( orn_traj . angular_accels ) == 0 and dt is not None : ang_accels = np . gradient ( ang_vels , dt , axis = 0 ) else : ang_accels = orn_traj . angular_accels return Trajectory ( positions , quaternions , lin_vels , ang_vels , lin_accels , ang_accels , times ) num_subplots_to_shape def num_subplots_to_shape ( n : int ) -> tuple [ int , int ] Determines the best layout of a number of subplots within a larger figure Parameters: Name Type Description Default n int Number of subplots None Returns: Type Description tuple[int, int] Number of rows and columns for the subplot divisions View Source def num_subplots_to_shape(n: int) -> tuple[int, int]: \"\"\"Determines the best layout of a number of subplots within a larger figure Args: n (int): Number of subplots Returns: tuple[int, int]: Number of rows and columns for the subplot divisions \"\"\" n_rows = int(np.sqrt(n)) n_cols = n // n_rows + (n % n_rows > 0) assert n_rows * n_cols >= n return (n_rows, n_cols) plot_traj def plot_traj ( traj : pyastrobee . trajectories . trajectory . Trajectory , show : bool = True , fmt : str = 'k-' ) -> matplotlib . figure . Figure Plot the trajectory components over time Parameters: Name Type Description Default traj Trajectory The Trajectory object to plot None show bool Whether or not to display the plot. Defaults to True. True fmt str Matplotlib line specification. Defaults to \"k-\" None Returns: Type Description Figure Matplotlib figure containing the plots View Source def plot_traj ( traj : Trajectory , show : bool = True , fmt : str = \"k-\" ) -> Figure : \"\"\"Plot the trajectory components over time Args: traj (Trajectory): The Trajectory object to plot show (bool, optional): Whether or not to display the plot. Defaults to True. fmt (str, optional): Matplotlib line specification. Defaults to \" k - \" Returns: Figure: Matplotlib figure containing the plots \"\"\" # Indexing helper variables POS = 0 ORN = 1 LIN_VEL = 2 ANG_VEL = 3 LIN_ACCEL = 4 ANG_ACCEL = 5 labels = { POS : [ \"x\", \"y\", \"z\" ] , ORN : [ \"qx\", \"qy\", \"qz\", \"qw\" ] , LIN_VEL : [ \"vx\", \"vy\", \"vz\" ] , ANG_VEL : [ \"wx\", \"wy\", \"wz\" ] , LIN_ACCEL : [ \"ax\", \"ay\", \"az\" ] , ANG_ACCEL : [ \"al_x\", \"al_y\", \"al_z\" ] , } fig = plt . figure () if traj . times is None or np . size ( traj . times ) == 0 : x_axis = range ( traj . num_timesteps ) x_label = \"Timesteps\" else : x_axis = traj . times x_label = \"Time, s\" # Top row is position info , bottom row is orientation info # Columns give derivative info subfigs = fig . subfigures ( 2 , 3 ) top_left = subfigs [ 0, 0 ] . subplots ( 1 , 3 ) _plot ( top_left , traj . positions , labels [ POS ] , x_axis , x_label , fmt ) top_middle = subfigs [ 0, 1 ] . subplots ( 1 , 3 ) _plot ( top_middle , traj . linear_velocities , labels [ LIN_VEL ] , x_axis , x_label , fmt ) top_right = subfigs [ 0, 2 ] . subplots ( 1 , 3 ) _plot ( top_right , traj . linear_accels , labels [ LIN_ACCEL ] , x_axis , x_label , fmt ) bot_left = subfigs [ 1, 0 ] . subplots ( 1 , 4 ) _plot ( bot_left , traj . quaternions , labels [ ORN ] , x_axis , x_label , fmt ) bot_middle = subfigs [ 1, 1 ] . subplots ( 1 , 3 ) _plot ( bot_middle , traj . angular_velocities , labels [ ANG_VEL ] , x_axis , x_label , fmt ) bot_right = subfigs [ 1, 2 ] . subplots ( 1 , 3 ) _plot ( bot_right , traj . angular_accels , labels [ ANG_ACCEL ] , x_axis , x_label , fmt ) if show : plt . show () return fig plot_traj_constraints def plot_traj_constraints ( traj : pyastrobee . trajectories . trajectory . Trajectory , pos_lims : Union [ pyastrobee . utils . boxes . Box , numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , max_vel : Optional [ float ] = None , max_accel : Optional [ float ] = None , max_omega : Optional [ float ] = None , max_alpha : Optional [ float ] = None , show : bool = True ) -> matplotlib . figure . Figure Plot trajectory info to visualize how it satisfies constraints Parameters: Name Type Description Default traj Trajectory Trajectory to plot None pos_lims Optional[Union[Box, npt.ArrayLike]] Lower and upper limits on the XYZ position. Defaults to None. None max_vel Optional[float] Maximum velocity magnitude. Defaults to None. None max_accel Optional[float] Maximum acceleration magnitude. Defaults to None. None max_omega Optional[float] Maximum angular velocity magnitude. Defaults to None. None max_alpha Optional[float] Maximum angular acceleration magnitude. Defaults to None. None show bool Whether or not to display the plot. Defaults to True. True Returns: Type Description Figure The plot View Source def plot_traj_constraints ( traj : Trajectory , pos_lims : Optional [ Union[Box, npt.ArrayLike ] ] = None , max_vel : Optional [ float ] = None , max_accel : Optional [ float ] = None , max_omega : Optional [ float ] = None , max_alpha : Optional [ float ] = None , show : bool = True , ) -> Figure : \"\"\"Plot trajectory info to visualize how it satisfies constraints Args: traj (Trajectory): Trajectory to plot pos_lims (Optional[Union[Box, npt.ArrayLike]]): Lower and upper limits on the XYZ position. Defaults to None. max_vel (Optional[float]): Maximum velocity magnitude. Defaults to None. max_accel (Optional[float]): Maximum acceleration magnitude. Defaults to None. max_omega (Optional[float]): Maximum angular velocity magnitude. Defaults to None. max_alpha (Optional[float]): Maximum angular acceleration magnitude. Defaults to None. show (bool, optional): Whether or not to display the plot. Defaults to True. Returns: Figure: The plot \"\"\" fig = plt . figure () if traj . times is None or np . size ( traj . times ) == 0 : x_axis = range ( traj . num_timesteps ) x_label = \"Timesteps\" else : x_axis = traj . times x_label = \"Time, s\" fmt = \"k-\" lim_fmt = \"r--\" # Top row is position info , bottom row is orientation info # Columns give derivative info subfigs = fig . subfigures ( 2 , 3 ) # Position top_left = subfigs [ 0, 0 ] . subplots ( 1 , 3 ) if traj . positions . size > 0 : for i , ax in enumerate ( top_left ) : ax . plot ( x_axis , traj . positions [ :, i ] , fmt ) ax . set_title ( [ \"x\", \"y\", \"z\" ][ i ] ) ax . set_xlabel ( x_label ) if pos_lims is not None : lower_pos_lim , upper_pos_lim = pos_lims for i , ax in enumerate ( top_left ) : ax . plot ( x_axis , lower_pos_lim [ i ] * np . ones_like ( x_axis ), lim_fmt ) ax . plot ( x_axis , upper_pos_lim [ i ] * np . ones_like ( x_axis ), lim_fmt ) # Linear velocity if traj . linear_velocities . size > 0 : top_middle = subfigs [ 0, 1 ] . subplots ( 1 , 1 ) top_middle . plot ( x_axis , np . linalg . norm ( traj . linear_velocities , axis = 1 ), fmt ) top_middle . set_title ( \"||vel||\" ) top_middle . set_xlabel ( x_label ) if max_vel is not None : top_middle . plot ( x_axis , max_vel * np . ones_like ( x_axis ), lim_fmt ) # Linear acceleration if traj . linear_accels . size > 0 : top_right = subfigs [ 0, 2 ] . subplots ( 1 , 1 ) top_right . plot ( x_axis , np . linalg . norm ( traj . linear_accels , axis = 1 ), fmt ) top_right . set_title ( \"||accel||\" ) top_right . set_xlabel ( x_label ) if max_accel is not None : top_right . plot ( x_axis , max_accel * np . ones_like ( x_axis ), lim_fmt ) # Quaternions # These are unconstrained so it ' s the same plotting method as in the standard plot traj function bot_left = subfigs [ 1, 0 ] . subplots ( 1 , 4 ) if traj . quaternions . size > 0 : _plot ( bot_left , traj . quaternions , [ \"qx\", \"qy\", \"qz\", \"qw\" ] , x_axis , x_label , fmt ) # Angular velocity bot_middle = subfigs [ 1, 1 ] . subplots ( 1 , 1 ) if traj . angular_velocities . size > 0 : bot_middle . plot ( x_axis , np . linalg . norm ( traj . angular_velocities , axis = 1 ), fmt ) bot_middle . set_title ( \"||omega||\" ) bot_middle . set_xlabel ( x_label ) if max_omega is not None : bot_middle . plot ( x_axis , max_omega * np . ones_like ( x_axis ), lim_fmt ) # Angular acceleration bot_right = subfigs [ 1, 2 ] . subplots ( 1 , 1 ) if traj . angular_accels . size > 0 : bot_right . plot ( x_axis , np . linalg . norm ( traj . angular_accels , axis = 1 ), fmt ) bot_right . set_title ( \"||alpha||\" ) bot_right . set_xlabel ( x_label ) if max_alpha is not None : bot_right . plot ( x_axis , max_alpha * np . ones_like ( x_axis ), lim_fmt ) if show : plt . show () return fig stopping_criteria def stopping_criteria ( pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], quat : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], lin_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], ang_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pos_des : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], quat_des : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], dp : float = 0.01 , dq : float = 0.01 , dv : float = 0.01 , dw : float = 0.005 ) -> bool Determine if the Astrobee has fully stopped, based on its current dynamics state Parameters: Name Type Description Default pos npt.ArrayLike Current position, shape (3,) None quat npt.ArrayLike Current XYZW quaternion orientation, shape (4,) None lin_vel npt.ArrayLike Current linear velocity, shape (3,) None ang_vel npt.ArrayLike Current angular velocity, shape (3,) None pos_des npt.ArrayLike Desired position, shape (3,) None quat_des npt.ArrayLike Desired XYZW quaternion orientation, shape (4,) None dp float Tolerance on position error magnitude. Defaults to 1e-2. 1e-2 dq float Tolerance on quaternion distance between cur/des. Defaults to 1e-2. 1e-2 dv float Tolerance on linear velocity error magnitude. Defaults to 1e-2. 1e-2 dw float Tolerance on angular velocity error magnitude. Defaults to 5e-3. 5e-3 Returns: Type Description bool If the Astrobee have successfully stopped at its desired goal pose View Source def stopping_criteria ( pos : npt . ArrayLike , quat : npt . ArrayLike , lin_vel : npt . ArrayLike , ang_vel : npt . ArrayLike , pos_des : npt . ArrayLike , quat_des : npt . ArrayLike , dp : float = 1e-2 , dq : float = 1e-2 , dv : float = 1e-2 , dw : float = 5e-3 , ) -> bool : \"\"\"Determine if the Astrobee has fully stopped, based on its current dynamics state Args: pos (npt.ArrayLike): Current position, shape (3,) quat (npt.ArrayLike): Current XYZW quaternion orientation, shape (4,) lin_vel (npt.ArrayLike): Current linear velocity, shape (3,) ang_vel (npt.ArrayLike): Current angular velocity, shape (3,) pos_des (npt.ArrayLike): Desired position, shape (3,) quat_des (npt.ArrayLike): Desired XYZW quaternion orientation, shape (4,) dp (float, optional): Tolerance on position error magnitude. Defaults to 1e-2. dq (float, optional): Tolerance on quaternion distance between cur/des. Defaults to 1e-2. dv (float, optional): Tolerance on linear velocity error magnitude. Defaults to 1e-2. dw (float, optional): Tolerance on angular velocity error magnitude. Defaults to 5e-3. Returns: bool: If the Astrobee have successfully stopped at its desired goal pose \"\"\" p_check = np . linalg . norm ( pos - pos_des ) <= dp q_check = quaternion_dist ( quat , quat_des ) <= dq v_check = np . linalg . norm ( lin_vel ) <= dv w_check = np . linalg . norm ( ang_vel ) <= dw checks = [ p_check , q_check , v_check , w_check ] return np . all ( checks ) visualize_traj def visualize_traj ( traj : Union [ pyastrobee . trajectories . trajectory . Trajectory , numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], n : Optional [ int ] = None , size : float = 0.5 , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> list [ int ] Visualizes a trajectory's sequence of poses on the Pybullet GUI Parameters: Name Type Description Default traj Union[Trajectory, npt.ArrayLike] Trajectory to visualize (must contain at least position + orientation info), or an array of position + quaternion poses, shape (n, 7) None n Optional[int] Number of frames to plot, if plotting all of the frames is not desired. Defaults to None (plot all frames) None size float Length of the lines to plot for each frame. Defaults to 0.5 (this gives a good scale with respect to the dimensions of the Astrobee) 0 client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Returns: Type Description list[int] Pybullet IDs for the lines drawn onto the GUI View Source def visualize_traj ( traj : Union [ Trajectory, npt.ArrayLike ] , n : Optional [ int ] = None , size : float = 0.5 , client : Optional [ BulletClient ] = None , ) -> list [ int ] : \"\"\"Visualizes a trajectory's sequence of poses on the Pybullet GUI Args: traj (Union[Trajectory, npt.ArrayLike]): Trajectory to visualize (must contain at least position + orientation info), or an array of position + quaternion poses, shape (n, 7) n (Optional[int]): Number of frames to plot, if plotting all of the frames is not desired. Defaults to None (plot all frames) size (float, optional): Length of the lines to plot for each frame. Defaults to 0.5 (this gives a good scale with respect to the dimensions of the Astrobee) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: list[int]: Pybullet IDs for the lines drawn onto the GUI \"\"\" client : pybullet = pybullet if client is None else client if isinstance ( traj , Trajectory ) : traj = traj . poses else : # If there is more information ( velocity , time ) in our array , only use the pose info traj = np . atleast_2d ( traj ) [ :, :7 ] n_frames = traj . shape [ 0 ] # If desired , sample frames evenly across the trajectory to plot a subset if n is not None and n < n_frames : # This indexing ensures that the first and last frames are plotted idx = np . round ( np . linspace ( 0 , n_frames - 1 , n , endpoint = True )). astype ( int ) traj = traj [ idx, : ] tmats = batched_pos_quats_to_tmats ( traj ) ids = [] for i in range ( tmats . shape [ 0 ] ) : ids += visualize_frame ( tmats [ i, :, : ] , size , client = client ) return ids Classes ArmTrajectory class ArmTrajectory ( angles : numpy . ndarray , joint_ids : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], times : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , key_times : Optional [ dict [ str , float ]] = None ) Maintains information on the positions of the arm's joint angles over time Currently this assumes we are working with position control Attributes Name Type Description Default angles np.ndarray Joint angles over time, shape (n_timesteps, n_controlled_joints) None joint_ids npt.ArrayLike Indices of the joints being controlled with position control. Unspecified joints will be left at their default control value (Either manually set or defined at robot initialization) None times Optional[npt.ArrayLike] Time information for the trajectory, shape (n_timesteps). Defaults to None. None key_times Optional[dict[str, float]] Information about when key transitions occur in the trajectory, for instance, when we start/stop an arm deployment motion. Defaults to None. None View Source class ArmTrajectory : \"\"\"Maintains information on the positions of the arm's joint angles over time Currently this assumes we are working with position control Args: angles (np.ndarray): Joint angles over time, shape (n_timesteps, n_controlled_joints) joint_ids (npt.ArrayLike): Indices of the joints being controlled with position control. Unspecified joints will be left at their default control value (Either manually set or defined at robot initialization) times (Optional[npt.ArrayLike]): Time information for the trajectory, shape (n_timesteps). Defaults to None. key_times (Optional[dict[str, float]]): Information about when key transitions occur in the trajectory, for instance, when we start/stop an arm deployment motion. Defaults to None. Raises: ValueError: If the shape of the angles input does not match the expected number of joints being controlled, or the number of timesteps in the time input KeyError: If the key_times dictionary contains unexpected keys. Currently supported: \" begin_drag_motion \", \" end_drag_motion \", \" begin_grasp_motion \", \" end_grasp_motion \" \"\"\" def __init__ ( self , angles : np . ndarray , joint_ids : npt . ArrayLike , times : Optional [ npt.ArrayLike ] = None , key_times : Optional [ dict[str, float ] ] = None , ) : if np . ndim ( angles ) == 1 : angles = angles . reshape ( - 1 , 1 ) joint_ids = np . atleast_1d ( joint_ids ) n_steps , n_joints = angles . shape if n_joints != len ( joint_ids ) : raise ValueError ( \"Mismatched inputs: The second dimension of the angles must match the number of joints.\\n\" + f \"Got shape: {angles.shape} for {len(joint_ids)} joint indices: {joint_ids}\" ) if times is not None and len ( times ) != n_steps : raise ValueError ( \"Mismatched input dimensions: Time info is not the same length as the angles\" ) self . angles = angles self . joint_ids = joint_ids self . times = times if times is not None else [] self . num_timesteps = n_steps # Hacky way to store information on the times / indices when the arm moves back or forward # This somewhat assumes that we 're going to move the arm to \"drag\" and then back to \"grasp\" # TODO make this more general # TODO improve how we handle the keys that we' d expect to see self . key_times = key_times expected_keys = { \"begin_drag_motion\" , \"end_drag_motion\" , \"begin_grasp_motion\" , \"end_grasp_motion\" , } for key in self . key_times . keys () : if key not in expected_keys : raise KeyError ( \"Unexpected key time name: \" , key ) def plot ( self ) : if self . times is None or np . size ( self . times ) == 0 : x_axis = range ( self . num_timesteps ) x_label = \"Timesteps\" else : x_axis = self . times x_label = \"Time, s\" n_subplots = len ( self . joint_ids ) subplot_shape = num_subplots_to_shape ( n_subplots ) fig = plt . figure () for j , index in enumerate ( self . joint_ids ) : plt . subplot ( * subplot_shape , j + 1 ) plt . plot ( x_axis , self . angles [ :, j ] ) plt . title ( f \"Joint {index}\" ) plt . xlabel ( x_label ) plt . ylabel ( \"Angle\" ) plt . show () # TODO !! USE NEW CONCATENATE AND EXTRAPOLATE METHODS def get_segment ( self , start_index : int , end_index : int , reset_time : bool = True ) -> \"ArmTrajectory\" : \"\"\"Construct an arm trajectory segment from a larger trajectory Args: start_index (int): Starting index of the larger trajectory to extract the segment end_index (int): Ending index of the larger trajectory to extract the segment reset_time (bool): Whether to maintain the time association with the original trajectory, or reset the start time back to 0. Defaults to True (reset start time back to 0) Returns: ArmTrajectory: A new trajectory representing a segment of the original trajectory \"\"\" # TODO : add check for invalid slicing indices ? Or just leave it up to numpy # HACK HACK HACK !!!!!!!!!!!!!!!!!!!!!! n_steps = len ( self . times ) # print ( f \"GETTING ARM SEGMENT: Start: {start_index}, End: {end_index}\" ) if start_index < n_steps and end_index < n_steps : # NORMAL # Time needs to get handled differently because the trajectory may or may not have time info if np . size ( self . times ) == 0 : # No time info new_times = None else : new_times = self . times [ start_index:end_index ] new_key_times = {} for name , time in self . key_times . items () : if new_times [ 0 ] <= time <= new_times [ -1 ] : new_key_times [ name ] = time if reset_time and new_times is not None : new_times -= new_times [ 0 ] for name , time in new_key_times . items () : new_key_times [ name ] -= new_times [ 0 ] return ArmTrajectory ( self . angles [ start_index:end_index, : ] , self . joint_ids , new_times , new_key_times , ) elif start_index < n_steps and end_index >= n_steps : angles = np . vstack ( [ self.angles[start_index:, : ] , np . ones (( end_index - n_steps , len ( self . joint_ids ))) * self . angles [ -1 ] , ] ) dt = self . times [ 1 ] - self . times [ 0 ] new_times = ( self . times [ start_index ] + np . arange ( end_index - start_index ) * dt ) new_key_times = {} for name , time in self . key_times . items () : if new_times [ 0 ] <= time <= new_times [ -1 ] : new_key_times [ name ] = time if reset_time : new_times -= new_times [ 0 ] for name , time in new_key_times . items () : new_key_times [ name ] -= new_times [ 0 ] return ArmTrajectory ( angles , self . joint_ids , new_times , new_key_times ) else : # Both over the limit angles = self . angles [ -1 ] * np . ones ( ( end_index - start_index , len ( self . joint_ids )) ) dt = self . times [ 1 ] - self . times [ 0 ] new_times = self . times [ -1 ] + np . arange ( end_index - start_index ) * dt new_key_times = {} for name , time in self . key_times . items () : if new_times [ 0 ] <= time <= new_times [ -1 ] : new_key_times [ name ] = time if reset_time : new_times -= new_times [ 0 ] for name , time in new_key_times . items () : new_key_times [ name ] -= new_times [ 0 ] return ArmTrajectory ( angles , self . joint_ids , new_times , new_key_times ) def get_segment_from_times ( self , start_time : float , end_time : float , reset_time : bool = True ) -> \"ArmTrajectory\" : \"\"\"Construct an arm trajectory segment from a larger trajectory Args: start_time (float): Starting time of the segment end_time (float): Ending time of the segment reset_time (bool): Whether to maintain the time association with the original trajectory, or reset the start time back to 0. Defaults to True (reset start time back to 0) Returns: ArmTrajectory: A new trajectory representing a segment of the original trajectory \"\"\" start_index = np . searchsorted ( self . times , start_time ) end_index = np . searchsorted ( self . times , end_time ) if end_index == len ( self . times ) : # Past the max time ... somewhat of a HACK dt = self . times [ -1 ] - self . times [ -2 ] time_after = end_time - self . times [ -1 ] end_index = len ( self . times ) - 1 + round ( time_after / dt ) return self . get_segment ( start_index , end_index , reset_time ) Methods get_segment def get_segment ( self , start_index : int , end_index : int , reset_time : bool = True ) -> 'ArmTrajectory' Construct an arm trajectory segment from a larger trajectory Parameters: Name Type Description Default start_index int Starting index of the larger trajectory to extract the segment None end_index int Ending index of the larger trajectory to extract the segment None reset_time bool Whether to maintain the time association with the original trajectory, or reset the start time back to 0. Defaults to True (reset start time back to 0) None Returns: Type Description ArmTrajectory A new trajectory representing a segment of the original trajectory View Source def get_segment ( self , start_index : int , end_index : int , reset_time : bool = True ) -> \"ArmTrajectory\" : \"\"\"Construct an arm trajectory segment from a larger trajectory Args: start_index (int): Starting index of the larger trajectory to extract the segment end_index (int): Ending index of the larger trajectory to extract the segment reset_time (bool): Whether to maintain the time association with the original trajectory, or reset the start time back to 0. Defaults to True (reset start time back to 0) Returns: ArmTrajectory: A new trajectory representing a segment of the original trajectory \"\"\" # TODO : add check for invalid slicing indices ? Or just leave it up to numpy # HACK HACK HACK !!!!!!!!!!!!!!!!!!!!!! n_steps = len ( self . times ) # print ( f \"GETTING ARM SEGMENT: Start: {start_index}, End: {end_index}\" ) if start_index < n_steps and end_index < n_steps : # NORMAL # Time needs to get handled differently because the trajectory may or may not have time info if np . size ( self . times ) == 0 : # No time info new_times = None else : new_times = self . times [ start_index:end_index ] new_key_times = {} for name , time in self . key_times . items () : if new_times [ 0 ] <= time <= new_times [ -1 ] : new_key_times [ name ] = time if reset_time and new_times is not None : new_times -= new_times [ 0 ] for name , time in new_key_times . items () : new_key_times [ name ] -= new_times [ 0 ] return ArmTrajectory ( self . angles [ start_index:end_index, : ] , self . joint_ids , new_times , new_key_times , ) elif start_index < n_steps and end_index >= n_steps : angles = np . vstack ( [ self.angles[start_index:, : ] , np . ones (( end_index - n_steps , len ( self . joint_ids ))) * self . angles [ -1 ] , ] ) dt = self . times [ 1 ] - self . times [ 0 ] new_times = ( self . times [ start_index ] + np . arange ( end_index - start_index ) * dt ) new_key_times = {} for name , time in self . key_times . items () : if new_times [ 0 ] <= time <= new_times [ -1 ] : new_key_times [ name ] = time if reset_time : new_times -= new_times [ 0 ] for name , time in new_key_times . items () : new_key_times [ name ] -= new_times [ 0 ] return ArmTrajectory ( angles , self . joint_ids , new_times , new_key_times ) else : # Both over the limit angles = self . angles [ -1 ] * np . ones ( ( end_index - start_index , len ( self . joint_ids )) ) dt = self . times [ 1 ] - self . times [ 0 ] new_times = self . times [ -1 ] + np . arange ( end_index - start_index ) * dt new_key_times = {} for name , time in self . key_times . items () : if new_times [ 0 ] <= time <= new_times [ -1 ] : new_key_times [ name ] = time if reset_time : new_times -= new_times [ 0 ] for name , time in new_key_times . items () : new_key_times [ name ] -= new_times [ 0 ] return ArmTrajectory ( angles , self . joint_ids , new_times , new_key_times ) get_segment_from_times def get_segment_from_times ( self , start_time : float , end_time : float , reset_time : bool = True ) -> 'ArmTrajectory' Construct an arm trajectory segment from a larger trajectory Parameters: Name Type Description Default start_time float Starting time of the segment None end_time float Ending time of the segment None reset_time bool Whether to maintain the time association with the original trajectory, or reset the start time back to 0. Defaults to True (reset start time back to 0) None Returns: Type Description ArmTrajectory A new trajectory representing a segment of the original trajectory View Source def get_segment_from_times ( self , start_time : float , end_ time : float , reset_time : bool = True ) -> \"ArmTrajectory\" : \"\"\"Construct an arm trajectory segment from a larger trajectory Args: start_time (float): Starting time of the segment end_time (float): Ending time of the segment reset_time (bool): Whether to maintain the time association with the original trajectory, or reset the start time back to 0. Defaults to True (reset start time back to 0) Returns: ArmTrajectory: A new trajectory representing a segment of the original trajectory \"\"\" start_index = np . searchsorted ( self . times , start_time ) end_ index = np . searchsorted ( self . times , end_ time ) if end_ index == len ( self . times ) : # Past the max time ... somewhat of a HACK dt = self . times [ - 1 ] - self . times [ - 2 ] time_after = end_ time - self . times [ - 1 ] end_ index = len ( self . times ) - 1 + round ( time_after / dt ) return self . get_segment ( start_index , end_ index , reset_time ) plot def plot ( self ) View Source def plot ( self ): if self . times is None or np . size ( self . times ) == 0 : x_axis = range ( self . num_timesteps ) x_label = \"Timesteps\" else : x_axis = self . times x_label = \"Time, s\" n_subplots = len ( self . joint_ids ) subplot_shape = num_subplots_to_shape ( n_subplots ) fig = plt . figure () for j , index in enumerate ( self . joint_ids ): plt . subplot ( * subplot_shape , j + 1 ) plt . plot ( x_axis , self . angles [:, j ]) plt . title ( f \"Joint {index}\" ) plt . xlabel ( x_label ) plt . ylabel ( \"Angle\" ) plt . show () Trajectory class Trajectory ( positions : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , quats : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , lin_vels : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , ang_vels : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , lin_accels : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , ang_accels : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , times : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None ) Trajectory class: Keeps track of a sequence of poses/velocities/accels over a period of time All arguments can be omitted as needed (for instance, a pose-only trajectory without velocities, or a trajectory without time information) All positions/orientations/velocities... are assumed to be defined in world frame Attributes Name Type Description Default positions Optional[npt.ArrayLike] Sequence of XYZ positions, shape (n, 3) None quats Optional[npt.ArrayLike] Sequence of XYZW quaternions, shape (n, 4) None lin_vels Optional[npt.ArrayLike] Sequence of (vx, vy, vz) linear velocities, shape (n, 3) None ang_vels Optional[npt.ArrayLike] Sequence of (wx, wy, wz) angular velocities, shape (n, 3) None lin_accels Optional[npt.ArrayLike] Sequence of (ax, ay, az) linear accelerations, shape (n, 3) None ang_accels Optional[npt.ArrayLike] Sequence of (al_x, al_y, al_z) angular accelerations, shape (n, 3) None times Optional[npt.ArrayLike] Times corresponding to each trajectory entry, shape (n) None View Source class Trajectory : \"\"\"Trajectory class: Keeps track of a sequence of poses/velocities/accels over a period of time - All arguments can be omitted as needed (for instance, a pose-only trajectory without velocities, or a trajectory without time information) - All positions/orientations/velocities... are assumed to be defined in world frame Args: positions (Optional[npt.ArrayLike]): Sequence of XYZ positions, shape (n, 3) quats (Optional[npt.ArrayLike]): Sequence of XYZW quaternions, shape (n, 4) lin_vels (Optional[npt.ArrayLike]): Sequence of (vx, vy, vz) linear velocities, shape (n, 3) ang_vels (Optional[npt.ArrayLike]): Sequence of (wx, wy, wz) angular velocities, shape (n, 3) lin_accels (Optional[npt.ArrayLike]): Sequence of (ax, ay, az) linear accelerations, shape (n, 3) ang_accels (Optional[npt.ArrayLike]): Sequence of (al_x, al_y, al_z) angular accelerations, shape (n, 3) times (Optional[npt.ArrayLike]): Times corresponding to each trajectory entry, shape (n) \"\"\" def __init__ ( self , positions : Optional [ npt.ArrayLike ] = None , quats : Optional [ npt.ArrayLike ] = None , lin_vels : Optional [ npt.ArrayLike ] = None , ang_vels : Optional [ npt.ArrayLike ] = None , lin_accels : Optional [ npt.ArrayLike ] = None , ang_accels : Optional [ npt.ArrayLike ] = None , times : Optional [ npt.ArrayLike ] = None , ) : self . _positions = positions if positions is not None else [] self . _quats = quats if quats is not None else [] self . _lin_vels = lin_vels if lin_vels is not None else [] self . _ang_vels = ang_vels if ang_vels is not None else [] self . _lin_accels = lin_accels if lin_accels is not None else [] self . _ang_accels = ang_accels if ang_accels is not None else [] self . _times = times if times is not None else [] self . _poses = None # Init self . _tmats = None # Init self . _num_timesteps = None # Init @property def positions ( self ) -> np . ndarray : return np . atleast_2d ( self . _positions ) @property def quaternions ( self ) -> np . ndarray : return np . atleast_2d ( self . _quats ) @property def linear_velocities ( self ) -> np . ndarray : return np . atleast_2d ( self . _lin_vels ) @property def angular_velocities ( self ) -> np . ndarray : return np . atleast_2d ( self . _ang_vels ) @property def linear_accels ( self ) -> np . ndarray : return np . atleast_2d ( self . _lin_accels ) @property def angular_accels ( self ) -> np . ndarray : return np . atleast_2d ( self . _ang_accels ) @property def times ( self ) -> np . ndarray : return np . asarray ( self . _times ) @property def timestep ( self ) -> float | None : if np . size ( self . _times ) == 0 : return None return self . _times [ 1 ] - self . _times [ 0 ] @property def num_timesteps ( self ) -> int : if self . _num_timesteps is None : if np . size ( self . positions ) > 0 : self . _num_timesteps = self . positions . shape [ 0 ] elif np . size ( self . quaternions ) > 0 : self . _num_timesteps = self . quaternions . shape [ 0 ] # If there is no position or orientation info , trajectory is empty ( None ) return self . _num_timesteps @property def duration ( self ) -> float : return self . _times [ -1 ] - self . _times [ 0 ] @property def poses ( self ) -> np . ndarray : \"\"\"Pose array (position + xyzw quaternion), shape (n, 7)\"\"\" # if self . _poses is not None : # return self . _poses # Only calculate this once if self . positions . size == 0 : raise ValueError ( \"No position information available\" ) if self . quaternions . size == 0 : raise ValueError ( \"No orientation information available\" ) self . _poses = np . column_stack ( [ self.positions, self.quaternions ] ) return self . _poses @property def tmats ( self ) -> np . ndarray : \"\"\"Poses expressed as transformation matrices, shape (n, 4, 4)\"\"\" # if self . _tmats is not None : # return self . _tmats # Only calculate this once self . _tmats = batched_pos_quats_to_tmats ( self . poses ) return self . _tmats @property def contains_pos_only ( self ) -> bool : \"\"\"Whether the trajectory contains only position info\"\"\" return self . positions . size > 0 and self . quaternions . size == 0 @property def contains_orn_only ( self ) -> bool : \"\"\"Whether the trajectory contains only orientation info\"\"\" return self . positions . size == 0 and self . quaternions . size > 0 @property def contains_pos_and_orn ( self ) -> bool : \"\"\"Whether the trajectory contains both position and orientation info\"\"\" return self . positions . size > 0 and self . quaternions . size > 0 @property def is_empty ( self ) -> bool : \"\"\"Whether the trajectory contains no position/orientation info\"\"\" return self . positions . size == 0 and self . quaternions . size == 0 def visualize ( self , n : Optional [ int ] = None , size : float = 0.5 , client : Optional [ BulletClient ] = None , ) -> list [ int ] : \"\"\"View the trajectory in Pybullet Args: n (Optional[int]): Number of frames to plot, if plotting all of the frames is not desired. Defaults to None (plot all frames) size (float, optional): Length of the lines to plot for each frame. Defaults to 0.5 (this gives a good scale with respect to the dimensions of the Astrobee) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: list[int]: Pybullet IDs for the lines drawn onto the GUI \"\"\" client : pybullet = pybullet if client is None else client connection_status = client . isConnected () # Bring up the Pybullet GUI if needed if not connection_status : client . connect ( pybullet . GUI ) if self . contains_pos_and_orn : ids = visualize_traj ( self , n , size , client = client ) elif self . contains_pos_only : print ( \"Trajectory only contains position info. Showing path instead\" ) ids = visualize_path ( self . positions , n , client = client ) elif self . contains_orn_only : raise NotImplementedError ( \"Visualizing a sequence of purely orientations is not implemented yet\" ) else : # Empty trajectory raise ValueError ( \"No trajectory information to visualize\" ) # Disconnect Pybullet if we originally weren ' t connected if not connection_status : input ( \"Press Enter to disconnect Pybullet\" ) client . disconnect () return ids def plot ( self , show : bool = True ) -> Figure : \"\"\"Plot the trajectory components over time Args: show (bool, optional): Whether or not to display the plot. Defaults to True. Returns: Figure: Matplotlib figure containing the plots \"\"\" return plot_traj ( self , show = show ) def get_segment ( self , start_index : int , end_index : int , reset_time : bool = True ) -> \"Trajectory\" : \"\"\"Construct a trajectory segment from a larger trajectory Args: start_index (int): Starting index of the larger trajectory to extract the segment end_index (int): Ending index of the larger trajectory to extract the segment reset_time (bool): Whether to maintain the time association with the original trajectory, or reset the start time back to 0. Defaults to True (reset start time back to 0) Returns: Trajectory: A new trajectory representing a segment of the original trajectory \"\"\" # TODO : add check for invalid slicing indices ? Or just leave it up to numpy # Time needs to get handled differently because the trajectory may or may not have time info if np . size ( self . times ) == 0 : # No time info new_times = None else : new_times = self . times [ start_index:end_index ] if reset_time : new_times -= new_times [ 0 ] return Trajectory ( self . positions [ start_index:end_index ] , self . quaternions [ start_index:end_index ] , self . linear_velocities [ start_index:end_index ] , self . angular_velocities [ start_index:end_index ] , self . linear_accels [ start_index:end_index ] , self . angular_accels [ start_index:end_index ] , new_times , ) def get_segment_between_times ( self , start_time , end_time , reset_time : bool = True ) : # start_index = np . searchsorted ( self . times , start_time ) # end_index = np . searchsorted ( self . times , end_time ) raise NotImplementedError ( \"TODO\" ) Descendants pyastrobee.trajectories.trajectory.TrajectoryLogger Instance variables angular_accels angular_velocities contains_orn_only Whether the trajectory contains only orientation info contains_pos_and_orn Whether the trajectory contains both position and orientation info contains_pos_only Whether the trajectory contains only position info duration is_empty Whether the trajectory contains no position/orientation info linear_accels linear_velocities num_timesteps poses Pose array (position + xyzw quaternion), shape (n, 7) positions quaternions times timestep tmats Poses expressed as transformation matrices, shape (n, 4, 4) Methods get_segment def get_segment ( self , start_index : int , end_index : int , reset_time : bool = True ) -> 'Trajectory' Construct a trajectory segment from a larger trajectory Parameters: Name Type Description Default start_index int Starting index of the larger trajectory to extract the segment None end_index int Ending index of the larger trajectory to extract the segment None reset_time bool Whether to maintain the time association with the original trajectory, or reset the start time back to 0. Defaults to True (reset start time back to 0) None Returns: Type Description Trajectory A new trajectory representing a segment of the original trajectory View Source def get_segment ( self , start_index : int , end_ index : int , reset_time : bool = True ) -> \"Trajectory\" : \"\"\"Construct a trajectory segment from a larger trajectory Args: start_index (int): Starting index of the larger trajectory to extract the segment end_index (int): Ending index of the larger trajectory to extract the segment reset_time (bool): Whether to maintain the time association with the original trajectory, or reset the start time back to 0. Defaults to True (reset start time back to 0) Returns: Trajectory: A new trajectory representing a segment of the original trajectory \"\"\" # TODO : add check for invalid slicing indices ? Or just leave it up to numpy # Time needs to get handled differently because the trajectory may or may not have time info if np . size ( self . times ) == 0 : # No time info new_times = None else : new_times = self . times [ start_index : end_ index ] if reset_time : new_times -= new_times [ 0 ] return Trajectory ( self . positions [ start_index : end_ index ], self . quaternions [ start_index : end_ index ], self . linear_velocities [ start_index : end_ index ], self . angular_velocities [ start_index : end_ index ], self . linear_accels [ start_index : end_ index ], self . angular_accels [ start_index : end_ index ], new_times , ) get_segment_between_times def get_segment_between_times ( self , start_time , end_time , reset_time : bool = True ) View Source def get_segment_between_times(self, start_time, end_time, reset_time: bool = True): # start_index = np.searchsorted(self.times, start_time) # end_index = np.searchsorted(self.times, end_time) raise NotImplementedError(\"TODO\") plot def plot ( self , show : bool = True ) -> matplotlib . figure . Figure Plot the trajectory components over time Parameters: Name Type Description Default show bool Whether or not to display the plot. Defaults to True. True Returns: Type Description Figure Matplotlib figure containing the plots View Source def plot ( self , show : bool = True ) -> Figure : \"\"\"Plot the trajectory components over time Args: show (bool, optional): Whether or not to display the plot. Defaults to True. Returns: Figure: Matplotlib figure containing the plots \"\"\" return plot_traj ( self , show = show ) visualize def visualize ( self , n : Optional [ int ] = None , size : float = 0.5 , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> list [ int ] View the trajectory in Pybullet Parameters: Name Type Description Default n Optional[int] Number of frames to plot, if plotting all of the frames is not desired. Defaults to None (plot all frames) None size float Length of the lines to plot for each frame. Defaults to 0.5 (this gives a good scale with respect to the dimensions of the Astrobee) 0 client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Returns: Type Description list[int] Pybullet IDs for the lines drawn onto the GUI View Source def visualize ( self , n : Optional [ int ] = None , size : float = 0.5 , client : Optional [ BulletClient ] = None , ) -> list [ int ] : \"\"\"View the trajectory in Pybullet Args: n (Optional[int]): Number of frames to plot, if plotting all of the frames is not desired. Defaults to None (plot all frames) size (float, optional): Length of the lines to plot for each frame. Defaults to 0.5 (this gives a good scale with respect to the dimensions of the Astrobee) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: list[int]: Pybullet IDs for the lines drawn onto the GUI \"\"\" client : pybullet = pybullet if client is None else client connection_status = client . isConnected () # Bring up the Pybullet GUI if needed if not connection_status : client . connect ( pybullet . GUI ) if self . contains_pos_and_orn : ids = visualize_traj ( self , n , size , client = client ) elif self . contains_pos_only : print ( \"Trajectory only contains position info. Showing path instead\" ) ids = visualize_path ( self . positions , n , client = client ) elif self . contains_orn_only : raise NotImplementedError ( \"Visualizing a sequence of purely orientations is not implemented yet\" ) else : # Empty trajectory raise ValueError ( \"No trajectory information to visualize\" ) # Disconnect Pybullet if we originally weren ' t connected if not connection_status : input ( \"Press Enter to disconnect Pybullet\" ) client . disconnect () return ids TrajectoryLogger class TrajectoryLogger ( ) Class for maintaining a history of a robot's state over time View Source class TrajectoryLogger ( Trajectory ) : \"\"\"Class for maintaining a history of a robot's state over time\"\"\" def __init__ ( self ) : # Create an empty Trajectory which we will iteratively append to super (). __init__ ( None , None , None , None , None , None , None ) def log_state ( self , pos : npt . ArrayLike , quat : npt . ArrayLike , lin_vel : Optional [ npt.ArrayLike ] = None , ang_vel : Optional [ npt.ArrayLike ] = None , dt : Optional [ float ] = None , ) : \"\"\"Record the robot state at a given timestep If velocity information is not available (for instance, with a softbody), we can log just the position + orientation information Args: pos (npt.ArrayLike): Current position, shape (3,) quat (npt.ArrayLike): Current orientation (XYZW quaternion), shape (4,) lin_vel (Optional[npt.ArrayLike]): Current linear velocity, shape (3,). Defaults to None. ang_vel (Optional[npt.ArrayLike]): Current angular velocity, shape (3,). Defaults to None. dt (Optional[float]): Time elapsed since the previous step. Defaults to None. \"\"\" # TODO refine this functionality # Can log position / orientation info without velocity if needed # These values can be None because matplotlib will just not plot them # Most importantly , we want to make sure that things correspond in time # ( There shouldn ' t be an instance where we have histories of different lengths ) self . _positions . append ( pos ) self . _quats . append ( quat ) self . _lin_vels . append ( lin_vel ) self . _ang_vels . append ( ang_vel ) if dt is not None and len ( self . _times ) == 0 : self . _times . append ( 0.0 ) elif dt is not None : self . _times . append ( self . _times [ -1 ] + dt ) def clear_log ( self ) -> None : \"\"\"Clears the log of all trajectory data\"\"\" self . _positions = [] self . _quats = [] self . _lin_vels = [] self . _ang_vels = [] self . _times = [] Ancestors (in MRO) pyastrobee.trajectories.trajectory.Trajectory Instance variables angular_accels angular_velocities contains_orn_only Whether the trajectory contains only orientation info contains_pos_and_orn Whether the trajectory contains both position and orientation info contains_pos_only Whether the trajectory contains only position info duration is_empty Whether the trajectory contains no position/orientation info linear_accels linear_velocities num_timesteps poses Pose array (position + xyzw quaternion), shape (n, 7) positions quaternions times timestep tmats Poses expressed as transformation matrices, shape (n, 4, 4) Methods clear_log def clear_log ( self ) -> None Clears the log of all trajectory data View Source def clear_log ( self ) -> None : \"\"\"Clears the log of all trajectory data\"\"\" self . _positions = [] self . _quats = [] self . _lin_vels = [] self . _ang_vels = [] self . _times = [] get_segment def get_segment ( self , start_index : int , end_index : int , reset_time : bool = True ) -> 'Trajectory' Construct a trajectory segment from a larger trajectory Parameters: Name Type Description Default start_index int Starting index of the larger trajectory to extract the segment None end_index int Ending index of the larger trajectory to extract the segment None reset_time bool Whether to maintain the time association with the original trajectory, or reset the start time back to 0. Defaults to True (reset start time back to 0) None Returns: Type Description Trajectory A new trajectory representing a segment of the original trajectory View Source def get_segment ( self , start_index : int , end_ index : int , reset_time : bool = True ) -> \"Trajectory\" : \"\"\"Construct a trajectory segment from a larger trajectory Args: start_index (int): Starting index of the larger trajectory to extract the segment end_index (int): Ending index of the larger trajectory to extract the segment reset_time (bool): Whether to maintain the time association with the original trajectory, or reset the start time back to 0. Defaults to True (reset start time back to 0) Returns: Trajectory: A new trajectory representing a segment of the original trajectory \"\"\" # TODO : add check for invalid slicing indices ? Or just leave it up to numpy # Time needs to get handled differently because the trajectory may or may not have time info if np . size ( self . times ) == 0 : # No time info new_times = None else : new_times = self . times [ start_index : end_ index ] if reset_time : new_times -= new_times [ 0 ] return Trajectory ( self . positions [ start_index : end_ index ], self . quaternions [ start_index : end_ index ], self . linear_velocities [ start_index : end_ index ], self . angular_velocities [ start_index : end_ index ], self . linear_accels [ start_index : end_ index ], self . angular_accels [ start_index : end_ index ], new_times , ) get_segment_between_times def get_segment_between_times ( self , start_time , end_time , reset_time : bool = True ) View Source def get_segment_between_times(self, start_time, end_time, reset_time: bool = True): # start_index = np.searchsorted(self.times, start_time) # end_index = np.searchsorted(self.times, end_time) raise NotImplementedError(\"TODO\") log_state def log_state ( self , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], quat : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], lin_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , ang_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , dt : Optional [ float ] = None ) Record the robot state at a given timestep If velocity information is not available (for instance, with a softbody), we can log just the position + orientation information Parameters: Name Type Description Default pos npt.ArrayLike Current position, shape (3,) None quat npt.ArrayLike Current orientation (XYZW quaternion), shape (4,) None lin_vel Optional[npt.ArrayLike] Current linear velocity, shape (3,). Defaults to None. None ang_vel Optional[npt.ArrayLike] Current angular velocity, shape (3,). Defaults to None. None dt Optional[float] Time elapsed since the previous step. Defaults to None. None View Source def log_state ( self , pos : npt . ArrayLike , quat : npt . ArrayLike , lin_vel : Optional [ npt.ArrayLike ] = None , ang_vel : Optional [ npt.ArrayLike ] = None , dt : Optional [ float ] = None , ) : \"\"\"Record the robot state at a given timestep If velocity information is not available (for instance, with a softbody), we can log just the position + orientation information Args: pos (npt.ArrayLike): Current position, shape (3,) quat (npt.ArrayLike): Current orientation (XYZW quaternion), shape (4,) lin_vel (Optional[npt.ArrayLike]): Current linear velocity, shape (3,). Defaults to None. ang_vel (Optional[npt.ArrayLike]): Current angular velocity, shape (3,). Defaults to None. dt (Optional[float]): Time elapsed since the previous step. Defaults to None. \"\"\" # TODO refine this functionality # Can log position / orientation info without velocity if needed # These values can be None because matplotlib will just not plot them # Most importantly , we want to make sure that things correspond in time # ( There shouldn ' t be an instance where we have histories of different lengths ) self . _positions . append ( pos ) self . _quats . append ( quat ) self . _lin_vels . append ( lin_vel ) self . _ang_vels . append ( ang_vel ) if dt is not None and len ( self . _times ) == 0 : self . _times . append ( 0.0 ) elif dt is not None : self . _times . append ( self . _times [ -1 ] + dt ) plot def plot ( self , show : bool = True ) -> matplotlib . figure . Figure Plot the trajectory components over time Parameters: Name Type Description Default show bool Whether or not to display the plot. Defaults to True. True Returns: Type Description Figure Matplotlib figure containing the plots View Source def plot ( self , show : bool = True ) -> Figure : \"\"\"Plot the trajectory components over time Args: show (bool, optional): Whether or not to display the plot. Defaults to True. Returns: Figure: Matplotlib figure containing the plots \"\"\" return plot_traj ( self , show = show ) visualize def visualize ( self , n : Optional [ int ] = None , size : float = 0.5 , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> list [ int ] View the trajectory in Pybullet Parameters: Name Type Description Default n Optional[int] Number of frames to plot, if plotting all of the frames is not desired. Defaults to None (plot all frames) None size float Length of the lines to plot for each frame. Defaults to 0.5 (this gives a good scale with respect to the dimensions of the Astrobee) 0 client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Returns: Type Description list[int] Pybullet IDs for the lines drawn onto the GUI View Source def visualize ( self , n : Optional [ int ] = None , size : float = 0.5 , client : Optional [ BulletClient ] = None , ) -> list [ int ] : \"\"\"View the trajectory in Pybullet Args: n (Optional[int]): Number of frames to plot, if plotting all of the frames is not desired. Defaults to None (plot all frames) size (float, optional): Length of the lines to plot for each frame. Defaults to 0.5 (this gives a good scale with respect to the dimensions of the Astrobee) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: list[int]: Pybullet IDs for the lines drawn onto the GUI \"\"\" client : pybullet = pybullet if client is None else client connection_status = client . isConnected () # Bring up the Pybullet GUI if needed if not connection_status : client . connect ( pybullet . GUI ) if self . contains_pos_and_orn : ids = visualize_traj ( self , n , size , client = client ) elif self . contains_pos_only : print ( \"Trajectory only contains position info. Showing path instead\" ) ids = visualize_path ( self . positions , n , client = client ) elif self . contains_orn_only : raise NotImplementedError ( \"Visualizing a sequence of purely orientations is not implemented yet\" ) else : # Empty trajectory raise ValueError ( \"No trajectory information to visualize\" ) # Disconnect Pybullet if we originally weren ' t connected if not connection_status : input ( \"Press Enter to disconnect Pybullet\" ) client . disconnect () return ids","title":"Trajectory"},{"location":"reference/pyastrobee/trajectories/trajectory/#module-pyastrobeetrajectoriestrajectory","text":"Trajectory class for Astrobee control, and trajectory-associated helpers View Source \"\"\"Trajectory class for Astrobee control, and trajectory-associated helpers\"\"\" # TODO decide if trajectory attributes should be read-only? (properties) # TODO make a subclass of Trajectory with the log() method # TODO make it clearer what happens if some of the traj components are None # (Numerically calculate the gradient? Remove the option to set these as None?) # TODO add max vel/accel lines into the plots? # TODO remove the ability to not give time information... this makes no sense. from typing import Optional , Union import pybullet from pybullet_utils.bullet_client import BulletClient import numpy as np import numpy.typing as npt import matplotlib.pyplot as plt from matplotlib.figure import Figure from pyastrobee.utils.poses import batched_pos_quats_to_tmats from pyastrobee.utils.debug_visualizer import visualize_frame , visualize_path from pyastrobee.utils.quaternions import quaternion_dist , quats_to_angular_velocities from pyastrobee.utils.boxes import Box class Trajectory : \"\"\"Trajectory class: Keeps track of a sequence of poses/velocities/accels over a period of time - All arguments can be omitted as needed (for instance, a pose-only trajectory without velocities, or a trajectory without time information) - All positions/orientations/velocities... are assumed to be defined in world frame Args: positions (Optional[npt.ArrayLike]): Sequence of XYZ positions, shape (n, 3) quats (Optional[npt.ArrayLike]): Sequence of XYZW quaternions, shape (n, 4) lin_vels (Optional[npt.ArrayLike]): Sequence of (vx, vy, vz) linear velocities, shape (n, 3) ang_vels (Optional[npt.ArrayLike]): Sequence of (wx, wy, wz) angular velocities, shape (n, 3) lin_accels (Optional[npt.ArrayLike]): Sequence of (ax, ay, az) linear accelerations, shape (n, 3) ang_accels (Optional[npt.ArrayLike]): Sequence of (al_x, al_y, al_z) angular accelerations, shape (n, 3) times (Optional[npt.ArrayLike]): Times corresponding to each trajectory entry, shape (n) \"\"\" def __init__ ( self , positions : Optional [ npt . ArrayLike ] = None , quats : Optional [ npt . ArrayLike ] = None , lin_vels : Optional [ npt . ArrayLike ] = None , ang_vels : Optional [ npt . ArrayLike ] = None , lin_accels : Optional [ npt . ArrayLike ] = None , ang_accels : Optional [ npt . ArrayLike ] = None , times : Optional [ npt . ArrayLike ] = None , ): self . _positions = positions if positions is not None else [] self . _quats = quats if quats is not None else [] self . _lin_vels = lin_vels if lin_vels is not None else [] self . _ang_vels = ang_vels if ang_vels is not None else [] self . _lin_accels = lin_accels if lin_accels is not None else [] self . _ang_accels = ang_accels if ang_accels is not None else [] self . _times = times if times is not None else [] self . _poses = None # Init self . _tmats = None # Init self . _num_timesteps = None # Init @property def positions ( self ) -> np . ndarray : return np . atleast_2d ( self . _positions ) @property def quaternions ( self ) -> np . ndarray : return np . atleast_2d ( self . _quats ) @property def linear_velocities ( self ) -> np . ndarray : return np . atleast_2d ( self . _lin_vels ) @property def angular_velocities ( self ) -> np . ndarray : return np . atleast_2d ( self . _ang_vels ) @property def linear_accels ( self ) -> np . ndarray : return np . atleast_2d ( self . _lin_accels ) @property def angular_accels ( self ) -> np . ndarray : return np . atleast_2d ( self . _ang_accels ) @property def times ( self ) -> np . ndarray : return np . asarray ( self . _times ) @property def timestep ( self ) -> float | None : if np . size ( self . _times ) == 0 : return None return self . _times [ 1 ] - self . _times [ 0 ] @property def num_timesteps ( self ) -> int : if self . _num_timesteps is None : if np . size ( self . positions ) > 0 : self . _num_timesteps = self . positions . shape [ 0 ] elif np . size ( self . quaternions ) > 0 : self . _num_timesteps = self . quaternions . shape [ 0 ] # If there is no position or orientation info, trajectory is empty (None) return self . _num_timesteps @property def duration ( self ) -> float : return self . _times [ - 1 ] - self . _times [ 0 ] @property def poses ( self ) -> np . ndarray : \"\"\"Pose array (position + xyzw quaternion), shape (n, 7)\"\"\" # if self._poses is not None: # return self._poses # Only calculate this once if self . positions . size == 0 : raise ValueError ( \"No position information available\" ) if self . quaternions . size == 0 : raise ValueError ( \"No orientation information available\" ) self . _poses = np . column_stack ([ self . positions , self . quaternions ]) return self . _poses @property def tmats ( self ) -> np . ndarray : \"\"\"Poses expressed as transformation matrices, shape (n, 4, 4)\"\"\" # if self._tmats is not None: # return self._tmats # Only calculate this once self . _tmats = batched_pos_quats_to_tmats ( self . poses ) return self . _tmats @property def contains_pos_only ( self ) -> bool : \"\"\"Whether the trajectory contains only position info\"\"\" return self . positions . size > 0 and self . quaternions . size == 0 @property def contains_orn_only ( self ) -> bool : \"\"\"Whether the trajectory contains only orientation info\"\"\" return self . positions . size == 0 and self . quaternions . size > 0 @property def contains_pos_and_orn ( self ) -> bool : \"\"\"Whether the trajectory contains both position and orientation info\"\"\" return self . positions . size > 0 and self . quaternions . size > 0 @property def is_empty ( self ) -> bool : \"\"\"Whether the trajectory contains no position/orientation info\"\"\" return self . positions . size == 0 and self . quaternions . size == 0 def visualize ( self , n : Optional [ int ] = None , size : float = 0.5 , client : Optional [ BulletClient ] = None , ) -> list [ int ]: \"\"\"View the trajectory in Pybullet Args: n (Optional[int]): Number of frames to plot, if plotting all of the frames is not desired. Defaults to None (plot all frames) size (float, optional): Length of the lines to plot for each frame. Defaults to 0.5 (this gives a good scale with respect to the dimensions of the Astrobee) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: list[int]: Pybullet IDs for the lines drawn onto the GUI \"\"\" client : pybullet = pybullet if client is None else client connection_status = client . isConnected () # Bring up the Pybullet GUI if needed if not connection_status : client . connect ( pybullet . GUI ) if self . contains_pos_and_orn : ids = visualize_traj ( self , n , size , client = client ) elif self . contains_pos_only : print ( \"Trajectory only contains position info. Showing path instead\" ) ids = visualize_path ( self . positions , n , client = client ) elif self . contains_orn_only : raise NotImplementedError ( \"Visualizing a sequence of purely orientations is not implemented yet\" ) else : # Empty trajectory raise ValueError ( \"No trajectory information to visualize\" ) # Disconnect Pybullet if we originally weren't connected if not connection_status : input ( \"Press Enter to disconnect Pybullet\" ) client . disconnect () return ids def plot ( self , show : bool = True ) -> Figure : \"\"\"Plot the trajectory components over time Args: show (bool, optional): Whether or not to display the plot. Defaults to True. Returns: Figure: Matplotlib figure containing the plots \"\"\" return plot_traj ( self , show = show ) def get_segment ( self , start_index : int , end_index : int , reset_time : bool = True ) -> \"Trajectory\" : \"\"\"Construct a trajectory segment from a larger trajectory Args: start_index (int): Starting index of the larger trajectory to extract the segment end_index (int): Ending index of the larger trajectory to extract the segment reset_time (bool): Whether to maintain the time association with the original trajectory, or reset the start time back to 0. Defaults to True (reset start time back to 0) Returns: Trajectory: A new trajectory representing a segment of the original trajectory \"\"\" # TODO: add check for invalid slicing indices? Or just leave it up to numpy # Time needs to get handled differently because the trajectory may or may not have time info if np . size ( self . times ) == 0 : # No time info new_times = None else : new_times = self . times [ start_index : end_index ] if reset_time : new_times -= new_times [ 0 ] return Trajectory ( self . positions [ start_index : end_index ], self . quaternions [ start_index : end_index ], self . linear_velocities [ start_index : end_index ], self . angular_velocities [ start_index : end_index ], self . linear_accels [ start_index : end_index ], self . angular_accels [ start_index : end_index ], new_times , ) def get_segment_between_times ( self , start_time , end_time , reset_time : bool = True ): # start_index = np.searchsorted(self.times, start_time) # end_index = np.searchsorted(self.times, end_time) raise NotImplementedError ( \"TODO\" ) class TrajectoryLogger ( Trajectory ): \"\"\"Class for maintaining a history of a robot's state over time\"\"\" def __init__ ( self ): # Create an empty Trajectory which we will iteratively append to super () . __init__ ( None , None , None , None , None , None , None ) def log_state ( self , pos : npt . ArrayLike , quat : npt . ArrayLike , lin_vel : Optional [ npt . ArrayLike ] = None , ang_vel : Optional [ npt . ArrayLike ] = None , dt : Optional [ float ] = None , ): \"\"\"Record the robot state at a given timestep If velocity information is not available (for instance, with a softbody), we can log just the position + orientation information Args: pos (npt.ArrayLike): Current position, shape (3,) quat (npt.ArrayLike): Current orientation (XYZW quaternion), shape (4,) lin_vel (Optional[npt.ArrayLike]): Current linear velocity, shape (3,). Defaults to None. ang_vel (Optional[npt.ArrayLike]): Current angular velocity, shape (3,). Defaults to None. dt (Optional[float]): Time elapsed since the previous step. Defaults to None. \"\"\" # TODO refine this functionality # Can log position/orientation info without velocity if needed # These values can be None because matplotlib will just not plot them # Most importantly, we want to make sure that things correspond in time # (There shouldn't be an instance where we have histories of different lengths) self . _positions . append ( pos ) self . _quats . append ( quat ) self . _lin_vels . append ( lin_vel ) self . _ang_vels . append ( ang_vel ) if dt is not None and len ( self . _times ) == 0 : self . _times . append ( 0.0 ) elif dt is not None : self . _times . append ( self . _times [ - 1 ] + dt ) def clear_log ( self ) -> None : \"\"\"Clears the log of all trajectory data\"\"\" self . _positions = [] self . _quats = [] self . _lin_vels = [] self . _ang_vels = [] self . _times = [] # TODO improve this... make it match up with the normal class # TODO velocity/force control? # TODO use a dictionary for the angles instead? map joint indices => their angles over time # TODO should we always define the trajectory for all of the joints? class ArmTrajectory : \"\"\"Maintains information on the positions of the arm's joint angles over time Currently this assumes we are working with position control Args: angles (np.ndarray): Joint angles over time, shape (n_timesteps, n_controlled_joints) joint_ids (npt.ArrayLike): Indices of the joints being controlled with position control. Unspecified joints will be left at their default control value (Either manually set or defined at robot initialization) times (Optional[npt.ArrayLike]): Time information for the trajectory, shape (n_timesteps). Defaults to None. key_times (Optional[dict[str, float]]): Information about when key transitions occur in the trajectory, for instance, when we start/stop an arm deployment motion. Defaults to None. Raises: ValueError: If the shape of the angles input does not match the expected number of joints being controlled, or the number of timesteps in the time input KeyError: If the key_times dictionary contains unexpected keys. Currently supported: \"begin_drag_motion\", \"end_drag_motion\", \"begin_grasp_motion\", \"end_grasp_motion\" \"\"\" def __init__ ( self , angles : np . ndarray , joint_ids : npt . ArrayLike , times : Optional [ npt . ArrayLike ] = None , key_times : Optional [ dict [ str , float ]] = None , ): if np . ndim ( angles ) == 1 : angles = angles . reshape ( - 1 , 1 ) joint_ids = np . atleast_1d ( joint_ids ) n_steps , n_joints = angles . shape if n_joints != len ( joint_ids ): raise ValueError ( \"Mismatched inputs: The second dimension of the angles must match the number of joints. \\n \" + f \"Got shape: { angles . shape } for { len ( joint_ids ) } joint indices: { joint_ids } \" ) if times is not None and len ( times ) != n_steps : raise ValueError ( \"Mismatched input dimensions: Time info is not the same length as the angles\" ) self . angles = angles self . joint_ids = joint_ids self . times = times if times is not None else [] self . num_timesteps = n_steps # Hacky way to store information on the times/indices when the arm moves back or forward # This somewhat assumes that we're going to move the arm to \"drag\" and then back to \"grasp\" # TODO make this more general # TODO improve how we handle the keys that we'd expect to see self . key_times = key_times expected_keys = { \"begin_drag_motion\" , \"end_drag_motion\" , \"begin_grasp_motion\" , \"end_grasp_motion\" , } for key in self . key_times . keys (): if key not in expected_keys : raise KeyError ( \"Unexpected key time name: \" , key ) def plot ( self ): if self . times is None or np . size ( self . times ) == 0 : x_axis = range ( self . num_timesteps ) x_label = \"Timesteps\" else : x_axis = self . times x_label = \"Time, s\" n_subplots = len ( self . joint_ids ) subplot_shape = num_subplots_to_shape ( n_subplots ) fig = plt . figure () for j , index in enumerate ( self . joint_ids ): plt . subplot ( * subplot_shape , j + 1 ) plt . plot ( x_axis , self . angles [:, j ]) plt . title ( f \"Joint { index } \" ) plt . xlabel ( x_label ) plt . ylabel ( \"Angle\" ) plt . show () # TODO!! USE NEW CONCATENATE AND EXTRAPOLATE METHODS def get_segment ( self , start_index : int , end_index : int , reset_time : bool = True ) -> \"ArmTrajectory\" : \"\"\"Construct an arm trajectory segment from a larger trajectory Args: start_index (int): Starting index of the larger trajectory to extract the segment end_index (int): Ending index of the larger trajectory to extract the segment reset_time (bool): Whether to maintain the time association with the original trajectory, or reset the start time back to 0. Defaults to True (reset start time back to 0) Returns: ArmTrajectory: A new trajectory representing a segment of the original trajectory \"\"\" # TODO: add check for invalid slicing indices? Or just leave it up to numpy # HACK HACK HACK !!!!!!!!!!!!!!!!!!!!!! n_steps = len ( self . times ) # print(f\"GETTING ARM SEGMENT: Start: {start_index}, End: {end_index}\") if start_index < n_steps and end_index < n_steps : # NORMAL # Time needs to get handled differently because the trajectory may or may not have time info if np . size ( self . times ) == 0 : # No time info new_times = None else : new_times = self . times [ start_index : end_index ] new_key_times = {} for name , time in self . key_times . items (): if new_times [ 0 ] <= time <= new_times [ - 1 ]: new_key_times [ name ] = time if reset_time and new_times is not None : new_times -= new_times [ 0 ] for name , time in new_key_times . items (): new_key_times [ name ] -= new_times [ 0 ] return ArmTrajectory ( self . angles [ start_index : end_index , :], self . joint_ids , new_times , new_key_times , ) elif start_index < n_steps and end_index >= n_steps : angles = np . vstack ( [ self . angles [ start_index :, :], np . ones (( end_index - n_steps , len ( self . joint_ids ))) * self . angles [ - 1 ], ] ) dt = self . times [ 1 ] - self . times [ 0 ] new_times = ( self . times [ start_index ] + np . arange ( end_index - start_index ) * dt ) new_key_times = {} for name , time in self . key_times . items (): if new_times [ 0 ] <= time <= new_times [ - 1 ]: new_key_times [ name ] = time if reset_time : new_times -= new_times [ 0 ] for name , time in new_key_times . items (): new_key_times [ name ] -= new_times [ 0 ] return ArmTrajectory ( angles , self . joint_ids , new_times , new_key_times ) else : # Both over the limit angles = self . angles [ - 1 ] * np . ones ( ( end_index - start_index , len ( self . joint_ids )) ) dt = self . times [ 1 ] - self . times [ 0 ] new_times = self . times [ - 1 ] + np . arange ( end_index - start_index ) * dt new_key_times = {} for name , time in self . key_times . items (): if new_times [ 0 ] <= time <= new_times [ - 1 ]: new_key_times [ name ] = time if reset_time : new_times -= new_times [ 0 ] for name , time in new_key_times . items (): new_key_times [ name ] -= new_times [ 0 ] return ArmTrajectory ( angles , self . joint_ids , new_times , new_key_times ) def get_segment_from_times ( self , start_time : float , end_time : float , reset_time : bool = True ) -> \"ArmTrajectory\" : \"\"\"Construct an arm trajectory segment from a larger trajectory Args: start_time (float): Starting time of the segment end_time (float): Ending time of the segment reset_time (bool): Whether to maintain the time association with the original trajectory, or reset the start time back to 0. Defaults to True (reset start time back to 0) Returns: ArmTrajectory: A new trajectory representing a segment of the original trajectory \"\"\" start_index = np . searchsorted ( self . times , start_time ) end_index = np . searchsorted ( self . times , end_time ) if end_index == len ( self . times ): # Past the max time... somewhat of a HACK dt = self . times [ - 1 ] - self . times [ - 2 ] time_after = end_time - self . times [ - 1 ] end_index = len ( self . times ) - 1 + round ( time_after / dt ) return self . get_segment ( start_index , end_index , reset_time ) # TODO see if we can incorporate a sequence of Boxes for the position constraints # on a spline trajectory (rather than just a single Box constraint for a single curve) def plot_traj_constraints ( traj : Trajectory , pos_lims : Optional [ Union [ Box , npt . ArrayLike ]] = None , max_vel : Optional [ float ] = None , max_accel : Optional [ float ] = None , max_omega : Optional [ float ] = None , max_alpha : Optional [ float ] = None , show : bool = True , ) -> Figure : \"\"\"Plot trajectory info to visualize how it satisfies constraints Args: traj (Trajectory): Trajectory to plot pos_lims (Optional[Union[Box, npt.ArrayLike]]): Lower and upper limits on the XYZ position. Defaults to None. max_vel (Optional[float]): Maximum velocity magnitude. Defaults to None. max_accel (Optional[float]): Maximum acceleration magnitude. Defaults to None. max_omega (Optional[float]): Maximum angular velocity magnitude. Defaults to None. max_alpha (Optional[float]): Maximum angular acceleration magnitude. Defaults to None. show (bool, optional): Whether or not to display the plot. Defaults to True. Returns: Figure: The plot \"\"\" fig = plt . figure () if traj . times is None or np . size ( traj . times ) == 0 : x_axis = range ( traj . num_timesteps ) x_label = \"Timesteps\" else : x_axis = traj . times x_label = \"Time, s\" fmt = \"k-\" lim_fmt = \"r--\" # Top row is position info, bottom row is orientation info # Columns give derivative info subfigs = fig . subfigures ( 2 , 3 ) # Position top_left = subfigs [ 0 , 0 ] . subplots ( 1 , 3 ) if traj . positions . size > 0 : for i , ax in enumerate ( top_left ): ax . plot ( x_axis , traj . positions [:, i ], fmt ) ax . set_title ([ \"x\" , \"y\" , \"z\" ][ i ]) ax . set_xlabel ( x_label ) if pos_lims is not None : lower_pos_lim , upper_pos_lim = pos_lims for i , ax in enumerate ( top_left ): ax . plot ( x_axis , lower_pos_lim [ i ] * np . ones_like ( x_axis ), lim_fmt ) ax . plot ( x_axis , upper_pos_lim [ i ] * np . ones_like ( x_axis ), lim_fmt ) # Linear velocity if traj . linear_velocities . size > 0 : top_middle = subfigs [ 0 , 1 ] . subplots ( 1 , 1 ) top_middle . plot ( x_axis , np . linalg . norm ( traj . linear_velocities , axis = 1 ), fmt ) top_middle . set_title ( \"||vel||\" ) top_middle . set_xlabel ( x_label ) if max_vel is not None : top_middle . plot ( x_axis , max_vel * np . ones_like ( x_axis ), lim_fmt ) # Linear acceleration if traj . linear_accels . size > 0 : top_right = subfigs [ 0 , 2 ] . subplots ( 1 , 1 ) top_right . plot ( x_axis , np . linalg . norm ( traj . linear_accels , axis = 1 ), fmt ) top_right . set_title ( \"||accel||\" ) top_right . set_xlabel ( x_label ) if max_accel is not None : top_right . plot ( x_axis , max_accel * np . ones_like ( x_axis ), lim_fmt ) # Quaternions # These are unconstrained so it's the same plotting method as in the standard plot traj function bot_left = subfigs [ 1 , 0 ] . subplots ( 1 , 4 ) if traj . quaternions . size > 0 : _plot ( bot_left , traj . quaternions , [ \"qx\" , \"qy\" , \"qz\" , \"qw\" ], x_axis , x_label , fmt ) # Angular velocity bot_middle = subfigs [ 1 , 1 ] . subplots ( 1 , 1 ) if traj . angular_velocities . size > 0 : bot_middle . plot ( x_axis , np . linalg . norm ( traj . angular_velocities , axis = 1 ), fmt ) bot_middle . set_title ( \"||omega||\" ) bot_middle . set_xlabel ( x_label ) if max_omega is not None : bot_middle . plot ( x_axis , max_omega * np . ones_like ( x_axis ), lim_fmt ) # Angular acceleration bot_right = subfigs [ 1 , 2 ] . subplots ( 1 , 1 ) if traj . angular_accels . size > 0 : bot_right . plot ( x_axis , np . linalg . norm ( traj . angular_accels , axis = 1 ), fmt ) bot_right . set_title ( \"||alpha||\" ) bot_right . set_xlabel ( x_label ) if max_alpha is not None : bot_right . plot ( x_axis , max_alpha * np . ones_like ( x_axis ), lim_fmt ) if show : plt . show () return fig def plot_traj ( traj : Trajectory , show : bool = True , fmt : str = \"k-\" ) -> Figure : \"\"\"Plot the trajectory components over time Args: traj (Trajectory): The Trajectory object to plot show (bool, optional): Whether or not to display the plot. Defaults to True. fmt (str, optional): Matplotlib line specification. Defaults to \"k-\" Returns: Figure: Matplotlib figure containing the plots \"\"\" # Indexing helper variables POS = 0 ORN = 1 LIN_VEL = 2 ANG_VEL = 3 LIN_ACCEL = 4 ANG_ACCEL = 5 labels = { POS : [ \"x\" , \"y\" , \"z\" ], ORN : [ \"qx\" , \"qy\" , \"qz\" , \"qw\" ], LIN_VEL : [ \"vx\" , \"vy\" , \"vz\" ], ANG_VEL : [ \"wx\" , \"wy\" , \"wz\" ], LIN_ACCEL : [ \"ax\" , \"ay\" , \"az\" ], ANG_ACCEL : [ \"al_x\" , \"al_y\" , \"al_z\" ], } fig = plt . figure () if traj . times is None or np . size ( traj . times ) == 0 : x_axis = range ( traj . num_timesteps ) x_label = \"Timesteps\" else : x_axis = traj . times x_label = \"Time, s\" # Top row is position info, bottom row is orientation info # Columns give derivative info subfigs = fig . subfigures ( 2 , 3 ) top_left = subfigs [ 0 , 0 ] . subplots ( 1 , 3 ) _plot ( top_left , traj . positions , labels [ POS ], x_axis , x_label , fmt ) top_middle = subfigs [ 0 , 1 ] . subplots ( 1 , 3 ) _plot ( top_middle , traj . linear_velocities , labels [ LIN_VEL ], x_axis , x_label , fmt ) top_right = subfigs [ 0 , 2 ] . subplots ( 1 , 3 ) _plot ( top_right , traj . linear_accels , labels [ LIN_ACCEL ], x_axis , x_label , fmt ) bot_left = subfigs [ 1 , 0 ] . subplots ( 1 , 4 ) _plot ( bot_left , traj . quaternions , labels [ ORN ], x_axis , x_label , fmt ) bot_middle = subfigs [ 1 , 1 ] . subplots ( 1 , 3 ) _plot ( bot_middle , traj . angular_velocities , labels [ ANG_VEL ], x_axis , x_label , fmt ) bot_right = subfigs [ 1 , 2 ] . subplots ( 1 , 3 ) _plot ( bot_right , traj . angular_accels , labels [ ANG_ACCEL ], x_axis , x_label , fmt ) if show : plt . show () return fig def _plot ( axes : np . ndarray [ plt . Axes ], data : np . ndarray , labels : list [ str ], x_axis : np . ndarray , x_label : str , * args , ** kwargs , ): \"\"\"Helper function for plotting trajectory components Args: axes (np.ndarray[plt.Axes]): Matplotlib axes for subplots within a subfigure, length = n data (np.ndarray): Trajectory information to plot, shape (m, n) where m is the number of timesteps and n refers to the number of components of that trajectory info (for instance, position has data for x, y, and z, so n = 3) labels (list[str]): Labels for each of the components of the trajectory data, length = n x_axis (np.ndarray): X-axis data to plot the trajectory against, length = m x_label (str): Label for the x-axis (for instance, \"Time\" or \"Steps\") \"\"\" # If the trajectory doesn't contain the info, don't plot it if np . size ( data ) == 0 or data is None : return # Number of components to plot (for instance, position: n = 3: x, y, z) n = data . shape [ 1 ] assert n == len ( labels ) assert n == len ( axes ) # Plot each component of the trajectory information on a separate axis for i , ax in enumerate ( axes ): ax . plot ( x_axis , data [:, i ], * args , ** kwargs ) ax . set_title ( labels [ i ]) ax . set_xlabel ( x_label ) # TODO all of the plotting logic here is extremely similar to the single-plot method # Figure out a way to simplify the code def compare_trajs ( traj_1 : Trajectory , traj_2 : Trajectory , show : bool = True , fmt_1 : str = \"k-\" , fmt_2 : str = \"b-\" , ) -> Figure : \"\"\"Compares two trajectories by plotting them on the same axes Args: traj_1 (Trajectory): First trajectory to plot traj_2 (Trajectory): Second trajectory to plot show (bool, optional): . Defaults to True. fmt_1 (str, optional): Matplotlib line specification for the first traj. Defaults to \"k-\". fmt_2 (str, optional): Matplotlib line specification for the second traj. Defaults to \"b-\". Returns: Figure: Matplotlib figure containing the plots \"\"\" # Indexing helper variables POS = 0 ORN = 1 LIN_VEL = 2 ANG_VEL = 3 LIN_ACCEL = 4 ANG_ACCEL = 5 labels = { POS : [ \"x\" , \"y\" , \"z\" ], ORN : [ \"qx\" , \"qy\" , \"qz\" , \"qw\" ], LIN_VEL : [ \"vx\" , \"vy\" , \"vz\" ], ANG_VEL : [ \"wx\" , \"wy\" , \"wz\" ], LIN_ACCEL : [ \"ax\" , \"ay\" , \"az\" ], ANG_ACCEL : [ \"al_x\" , \"al_y\" , \"al_z\" ], } fig = plt . figure () # TODO this check is kinda weird right now # what happens if one has time info and the other doesn't?? if traj_1 . times is None or np . size ( traj_1 . times ) == 0 : x_axis_1 = range ( traj_1 . num_timesteps ) x_label = \"Timesteps\" else : x_axis_1 = traj_1 . times x_label = \"Time, s\" if traj_2 . times is None or np . size ( traj_2 . times ) == 0 : x_axis_2 = range ( traj_2 . num_timesteps ) else : x_axis_2 = traj_2 . times # Top row is position info, bottom row is orientation info # Columns give derivative info # fmt: off subfigs = fig . subfigures ( 2 , 3 ) top_left = subfigs [ 0 , 0 ] . subplots ( 1 , 3 ) _plot ( top_left , traj_1 . positions , labels [ POS ], x_axis_1 , x_label , fmt_1 ) _plot ( top_left , traj_2 . positions , labels [ POS ], x_axis_2 , x_label , fmt_2 ) top_middle = subfigs [ 0 , 1 ] . subplots ( 1 , 3 ) _plot ( top_middle , traj_1 . linear_velocities , labels [ LIN_VEL ], x_axis_1 , x_label , fmt_1 ) _plot ( top_middle , traj_2 . linear_velocities , labels [ LIN_VEL ], x_axis_2 , x_label , fmt_2 ) top_right = subfigs [ 0 , 2 ] . subplots ( 1 , 3 ) _plot ( top_right , traj_1 . linear_accels , labels [ LIN_ACCEL ], x_axis_1 , x_label , fmt_1 ) _plot ( top_right , traj_2 . linear_accels , labels [ LIN_ACCEL ], x_axis_2 , x_label , fmt_2 ) bot_left = subfigs [ 1 , 0 ] . subplots ( 1 , 4 ) _plot ( bot_left , traj_1 . quaternions , labels [ ORN ], x_axis_1 , x_label , fmt_1 ) _plot ( bot_left , traj_2 . quaternions , labels [ ORN ], x_axis_2 , x_label , fmt_2 ) bot_mid = subfigs [ 1 , 1 ] . subplots ( 1 , 3 ) _plot ( bot_mid , traj_1 . angular_velocities , labels [ ANG_VEL ], x_axis_1 , x_label , fmt_1 ) _plot ( bot_mid , traj_2 . angular_velocities , labels [ ANG_VEL ], x_axis_2 , x_label , fmt_2 ) bot_right = subfigs [ 1 , 2 ] . subplots ( 1 , 3 ) _plot ( bot_right , traj_1 . angular_accels , labels [ ANG_ACCEL ], x_axis_1 , x_label , fmt_1 ) _plot ( bot_right , traj_2 . angular_accels , labels [ ANG_ACCEL ], x_axis_2 , x_label , fmt_2 ) # fmt: on if show : plt . show () return fig def visualize_traj ( traj : Union [ Trajectory , npt . ArrayLike ], n : Optional [ int ] = None , size : float = 0.5 , client : Optional [ BulletClient ] = None , ) -> list [ int ]: \"\"\"Visualizes a trajectory's sequence of poses on the Pybullet GUI Args: traj (Union[Trajectory, npt.ArrayLike]): Trajectory to visualize (must contain at least position + orientation info), or an array of position + quaternion poses, shape (n, 7) n (Optional[int]): Number of frames to plot, if plotting all of the frames is not desired. Defaults to None (plot all frames) size (float, optional): Length of the lines to plot for each frame. Defaults to 0.5 (this gives a good scale with respect to the dimensions of the Astrobee) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: list[int]: Pybullet IDs for the lines drawn onto the GUI \"\"\" client : pybullet = pybullet if client is None else client if isinstance ( traj , Trajectory ): traj = traj . poses else : # If there is more information (velocity, time) in our array, only use the pose info traj = np . atleast_2d ( traj )[:, : 7 ] n_frames = traj . shape [ 0 ] # If desired, sample frames evenly across the trajectory to plot a subset if n is not None and n < n_frames : # This indexing ensures that the first and last frames are plotted idx = np . round ( np . linspace ( 0 , n_frames - 1 , n , endpoint = True )) . astype ( int ) traj = traj [ idx , :] tmats = batched_pos_quats_to_tmats ( traj ) ids = [] for i in range ( tmats . shape [ 0 ]): ids += visualize_frame ( tmats [ i , :, :], size , client = client ) return ids # TODO Move this to a more dynamics-relevant location? def stopping_criteria ( pos : npt . ArrayLike , quat : npt . ArrayLike , lin_vel : npt . ArrayLike , ang_vel : npt . ArrayLike , pos_des : npt . ArrayLike , quat_des : npt . ArrayLike , dp : float = 1e-2 , dq : float = 1e-2 , dv : float = 1e-2 , dw : float = 5e-3 , ) -> bool : \"\"\"Determine if the Astrobee has fully stopped, based on its current dynamics state Args: pos (npt.ArrayLike): Current position, shape (3,) quat (npt.ArrayLike): Current XYZW quaternion orientation, shape (4,) lin_vel (npt.ArrayLike): Current linear velocity, shape (3,) ang_vel (npt.ArrayLike): Current angular velocity, shape (3,) pos_des (npt.ArrayLike): Desired position, shape (3,) quat_des (npt.ArrayLike): Desired XYZW quaternion orientation, shape (4,) dp (float, optional): Tolerance on position error magnitude. Defaults to 1e-2. dq (float, optional): Tolerance on quaternion distance between cur/des. Defaults to 1e-2. dv (float, optional): Tolerance on linear velocity error magnitude. Defaults to 1e-2. dw (float, optional): Tolerance on angular velocity error magnitude. Defaults to 5e-3. Returns: bool: If the Astrobee have successfully stopped at its desired goal pose \"\"\" p_check = np . linalg . norm ( pos - pos_des ) <= dp q_check = quaternion_dist ( quat , quat_des ) <= dq v_check = np . linalg . norm ( lin_vel ) <= dv w_check = np . linalg . norm ( ang_vel ) <= dw checks = [ p_check , q_check , v_check , w_check ] return np . all ( checks ) def merge_trajs ( pos_traj : Trajectory , orn_traj : Trajectory ) -> Trajectory : \"\"\"Merge the position component from one trajectory with the orientation component from another Args: pos_traj (Trajectory): Trajectory with desired position component orn_traj (Trajectory): Trajectory with desired orientation component Returns: Trajectory: Merged trajectory with both position + orientation info \"\"\" assert np . size ( pos_traj . positions ) > 0 assert np . size ( orn_traj . quaternions ) > 0 positions = pos_traj . positions quaternions = pos_traj . quaternions # Time # If both trajectories have time info, make sure they match up if np . size ( pos_traj . times ) > 0 : if np . size ( orn_traj . times ) > 0 : if not np . allclose ( pos_traj . times , orn_traj . times ): raise ValueError ( \"Mismatched time information\" ) times = pos_traj . times dt = pos_traj . timestep elif np . size ( orn_traj . times ) > 0 : times = orn_traj . times dt = orn_traj . timestep else : times = None dt = None # If either trajectory is missing derivative info, compute it if we can # Position if np . size ( pos_traj . linear_velocities ) == 0 and dt is not None : lin_vels = np . gradient ( pos_traj . positions , dt , axis = 0 ) else : lin_vels = pos_traj . linear_velocities if np . size ( pos_traj . linear_accels ) == 0 and dt is not None : lin_accels = np . gradient ( lin_vels , dt , axis = 0 ) else : lin_accels = pos_traj . linear_accels # Orientation if np . size ( orn_traj . angular_velocities ) == 0 and dt is not None : ang_vels = quats_to_angular_velocities ( orn_traj . quaternions , dt ) else : ang_vels = orn_traj . angular_velocities if np . size ( orn_traj . angular_accels ) == 0 and dt is not None : ang_accels = np . gradient ( ang_vels , dt , axis = 0 ) else : ang_accels = orn_traj . angular_accels return Trajectory ( positions , quaternions , lin_vels , ang_vels , lin_accels , ang_accels , times ) def concatenate_trajs ( traj_1 : Trajectory , traj_2 : Trajectory ) -> Trajectory : \"\"\"Combine two trajectories one after the other This will follow the first trajectory until its end, then follow the second one until it ends Args: traj_1 (Trajectory): First trajectory traj_2 (Trajectory): Second trajectory Returns: Trajectory: Combined trajectory \"\"\" # Ensure continuity in time # TODO check for continuity in all other components? # TODO this assumes that both have time information dt = traj_1 . times [ - 1 ] - traj_1 . times [ - 2 ] if np . isclose ( traj_2 . times [ 0 ], 0 ): times = np . concatenate ([ traj_1 . times , traj_2 . times + traj_1 . times [ - 1 ] + dt ]) elif np . isclose ( traj_2 . times [ 0 ], traj_1 . times [ - 1 ] + dt ): times = np . concatenate ([ traj_1 . times , traj_2 . times ]) return Trajectory ( np . vstack ([ traj_1 . positions , traj_2 . positions ]), np . vstack ( [ traj_1 . quaternions , traj_2 . quaternions ], ), np . vstack ([ traj_1 . linear_velocities , traj_2 . linear_velocities ]), np . vstack ([ traj_1 . angular_velocities , traj_2 . angular_velocities ]), np . vstack ([ traj_1 . linear_accels , traj_2 . linear_accels ]), np . vstack ([ traj_1 . angular_accels , traj_2 . angular_accels ]), times , ) def concatenate_arm_trajs ( traj_1 : ArmTrajectory , traj_2 : ArmTrajectory ) -> ArmTrajectory : \"\"\"Combine two arm trajectories one after the other This will follow the first trajectory until its end, then follow the second one until it ends Args: traj_1 (ArmTrajectory): First trajectory traj_2 (ArmTrajectory): Second trajectory Returns: ArmTrajectory: Combined trajectory \"\"\" if traj_1 . joint_ids != traj_2 . joint_ids : raise NotImplementedError ( \"Controlled joint indices must match between the two trajectories (for now)\" ) # Ensure continuity in time, and merge the key time information # TODO check for continuity in all other components? # TODO this assumes that both have time information dt = traj_1 . times [ - 1 ] - traj_1 . times [ - 2 ] new_key_times = traj_1 . key_times if np . isclose ( traj_2 . times [ 0 ], 0 ): times = np . concatenate ([ traj_1 . times , traj_2 . times + traj_1 . times [ - 1 ] + dt ]) for name , time in traj_2 . key_times . items (): new_key_times [ name ] = time + traj_1 . times [ - 1 ] + dt elif np . isclose ( traj_2 . times [ 0 ], traj_1 . times [ - 1 ] + dt ): times = np . concatenate ([ traj_1 . times , traj_2 . times ]) new_key_times |= traj_2 . key_times return ArmTrajectory ( np . vstack ([ traj_1 . angles , traj_2 . angles ]), traj_1 . joint_ids , times , new_key_times , ) def extrapolate_traj ( traj : Trajectory , duration : Optional [ float ] = None , n_steps : Optional [ int ] = None ) -> Trajectory : \"\"\"Extrapolates a trajectory by an amount of time This assumes that the (pre-extrapolation) trajectory comes to a rest at the end Either the extrapolation duration or number of timesteps must be specified. Not both, not neither Args: traj (Trajectory): Original trajectory duration (Optional[float], optional): Amount of time to extrapolate by. Defaults to None (n_steps input must be provided) n_steps (Optional[int], optional): Number of timesteps to extrapolate by. Defaults to None (duration input must be provided) Returns: Trajectory: Extrapolated trajectory \"\"\" dt = traj . times [ - 1 ] - traj . times [ - 2 ] if duration is None and n_steps is None : raise ValueError ( \"Must provide either a duration to extrapolate by, or a fixed number of timesteps\" ) elif duration is not None and n_steps is not None : raise ValueError ( \"Provide either a duration or a number of timesteps, not both\" ) elif duration is not None : n_steps = round ( duration / dt ) assert n_steps is not None if not np . isclose ( np . linalg . norm ( traj . linear_velocities [ - 1 ]), 0 ) or not np . isclose ( np . linalg . norm ( traj . angular_velocities [ - 1 ]), 0 ): raise NotImplementedError ( \"Cannot extrapolate the trajectory: Only implemented for trajectories that end at a stopped pose\" ) return Trajectory ( np . vstack ([ traj . positions , traj . positions [ - 1 ] * np . ones (( n_steps , 1 ))]), np . vstack ([ traj . quaternions , traj . quaternions [ - 1 ] * np . ones (( n_steps , 1 ))]), np . vstack ([ traj . linear_velocities , np . zeros (( n_steps , 3 ))]), np . vstack ([ traj . angular_velocities , np . zeros (( n_steps , 3 ))]), np . vstack ([ traj . linear_accels , np . zeros (( n_steps , 3 ))]), np . vstack ([ traj . angular_accels , np . zeros (( n_steps , 3 ))]), np . concatenate ([ traj . times , traj . times [ - 1 ] + dt + np . arange ( n_steps ) * dt ]), ) def extrapolate_arm_traj ( traj : ArmTrajectory , duration : Optional [ float ] = None , n_steps : Optional [ int ] = None ) -> ArmTrajectory : \"\"\"Extrapolates an arm trajectory by an amount of time This assumes that the (pre-extrapolation) trajectory comes to a rest at the end Either the extrapolation duration or number of timesteps must be specified. Not both, not neither Args: traj (ArmTrajectory): Original arm trajectory duration (Optional[float], optional): Amount of time to extrapolate by. Defaults to None (n_steps input must be provided) n_steps (Optional[int], optional): Number of timesteps to extrapolate by. Defaults to None (duration input must be provided) Returns: ArmTrajectory: Extrapolated arm trajectory \"\"\" dt = traj . times [ - 1 ] - traj . times [ - 2 ] if duration is None and n_steps is None : raise ValueError ( \"Must provide either a duration to extrapolate by, or a fixed number of timesteps\" ) elif duration is not None and n_steps is not None : raise ValueError ( \"Provide either a duration or a number of timesteps, not both\" ) elif duration is not None : n_steps = round ( duration / dt ) assert n_steps is not None return ArmTrajectory ( np . vstack ([ traj . angles , traj . angles [ - 1 ] * np . ones (( n_steps , 1 ))]), traj . joint_ids , np . concatenate ([ traj . times , traj . times [ - 1 ] + dt + np . arange ( n_steps ) * dt ]), traj . key_times , ) def num_subplots_to_shape ( n : int ) -> tuple [ int , int ]: \"\"\"Determines the best layout of a number of subplots within a larger figure Args: n (int): Number of subplots Returns: tuple[int, int]: Number of rows and columns for the subplot divisions \"\"\" n_rows = int ( np . sqrt ( n )) n_cols = n // n_rows + ( n % n_rows > 0 ) assert n_rows * n_cols >= n return ( n_rows , n_cols )","title":"Module pyastrobee.trajectories.trajectory"},{"location":"reference/pyastrobee/trajectories/trajectory/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/trajectories/trajectory/#compare_trajs","text":"def compare_trajs ( traj_1 : pyastrobee . trajectories . trajectory . Trajectory , traj_2 : pyastrobee . trajectories . trajectory . Trajectory , show : bool = True , fmt_1 : str = 'k-' , fmt_2 : str = 'b-' ) -> matplotlib . figure . Figure Compares two trajectories by plotting them on the same axes Parameters: Name Type Description Default traj_1 Trajectory First trajectory to plot None traj_2 Trajectory Second trajectory to plot None show bool . Defaults to True. True fmt_1 str Matplotlib line specification for the first traj. Defaults to \"k-\". \"k-\" fmt_2 str Matplotlib line specification for the second traj. Defaults to \"b-\". \"b-\" Returns: Type Description Figure Matplotlib figure containing the plots View Source def compare_trajs ( traj_1 : Trajectory , traj_2 : Trajectory , show : bool = True , fmt_1 : str = \"k-\" , fmt_2 : str = \"b-\" , ) -> Figure : \"\"\"Compares two trajectories by plotting them on the same axes Args: traj_1 (Trajectory): First trajectory to plot traj_2 (Trajectory): Second trajectory to plot show (bool, optional): . Defaults to True. fmt_1 (str, optional): Matplotlib line specification for the first traj. Defaults to \" k - \". fmt_2 (str, optional): Matplotlib line specification for the second traj. Defaults to \" b - \". Returns: Figure: Matplotlib figure containing the plots \"\"\" # Indexing helper variables POS = 0 ORN = 1 LIN_VEL = 2 ANG_VEL = 3 LIN_ACCEL = 4 ANG_ACCEL = 5 labels = { POS : [ \"x\", \"y\", \"z\" ] , ORN : [ \"qx\", \"qy\", \"qz\", \"qw\" ] , LIN_VEL : [ \"vx\", \"vy\", \"vz\" ] , ANG_VEL : [ \"wx\", \"wy\", \"wz\" ] , LIN_ACCEL : [ \"ax\", \"ay\", \"az\" ] , ANG_ACCEL : [ \"al_x\", \"al_y\", \"al_z\" ] , } fig = plt . figure () # TODO this check is kinda weird right now # what happens if one has time info and the other doesn ' t ?? if traj_1 . times is None or np . size ( traj_1 . times ) == 0 : x_axis_1 = range ( traj_1 . num_timesteps ) x_label = \"Timesteps\" else : x_axis_1 = traj_1 . times x_label = \"Time, s\" if traj_2 . times is None or np . size ( traj_2 . times ) == 0 : x_axis_2 = range ( traj_2 . num_timesteps ) else : x_axis_2 = traj_2 . times # Top row is position info , bottom row is orientation info # Columns give derivative info # fmt : off subfigs = fig . subfigures ( 2 , 3 ) top_left = subfigs [ 0, 0 ] . subplots ( 1 , 3 ) _plot ( top_left , traj_1 . positions , labels [ POS ] , x_axis_1 , x_label , fmt_1 ) _plot ( top_left , traj_2 . positions , labels [ POS ] , x_axis_2 , x_label , fmt_2 ) top_middle = subfigs [ 0, 1 ] . subplots ( 1 , 3 ) _plot ( top_middle , traj_1 . linear_velocities , labels [ LIN_VEL ] , x_axis_1 , x_label , fmt_1 ) _plot ( top_middle , traj_2 . linear_velocities , labels [ LIN_VEL ] , x_axis_2 , x_label , fmt_2 ) top_right = subfigs [ 0, 2 ] . subplots ( 1 , 3 ) _plot ( top_right , traj_1 . linear_accels , labels [ LIN_ACCEL ] , x_axis_1 , x_label , fmt_1 ) _plot ( top_right , traj_2 . linear_accels , labels [ LIN_ACCEL ] , x_axis_2 , x_label , fmt_2 ) bot_left = subfigs [ 1, 0 ] . subplots ( 1 , 4 ) _plot ( bot_left , traj_1 . quaternions , labels [ ORN ] , x_axis_1 , x_label , fmt_1 ) _plot ( bot_left , traj_2 . quaternions , labels [ ORN ] , x_axis_2 , x_label , fmt_2 ) bot_mid = subfigs [ 1, 1 ] . subplots ( 1 , 3 ) _plot ( bot_mid , traj_1 . angular_velocities , labels [ ANG_VEL ] , x_axis_1 , x_label , fmt_1 ) _plot ( bot_mid , traj_2 . angular_velocities , labels [ ANG_VEL ] , x_axis_2 , x_label , fmt_2 ) bot_right = subfigs [ 1, 2 ] . subplots ( 1 , 3 ) _plot ( bot_right , traj_1 . angular_accels , labels [ ANG_ACCEL ] , x_axis_1 , x_label , fmt_1 ) _plot ( bot_right , traj_2 . angular_accels , labels [ ANG_ACCEL ] , x_axis_2 , x_label , fmt_2 ) # fmt : on if show : plt . show () return fig","title":"compare_trajs"},{"location":"reference/pyastrobee/trajectories/trajectory/#concatenate_arm_trajs","text":"def concatenate_arm_trajs ( traj_1 : pyastrobee . trajectories . trajectory . ArmTrajectory , traj_2 : pyastrobee . trajectories . trajectory . ArmTrajectory ) -> pyastrobee . trajectories . trajectory . ArmTrajectory Combine two arm trajectories one after the other This will follow the first trajectory until its end, then follow the second one until it ends Parameters: Name Type Description Default traj_1 ArmTrajectory First trajectory None traj_2 ArmTrajectory Second trajectory None Returns: Type Description ArmTrajectory Combined trajectory View Source def concatenate_arm_trajs ( traj_1 : ArmTrajectory , traj_2 : ArmTrajectory ) -> ArmTrajectory : \"\"\"Combine two arm trajectories one after the other This will follow the first trajectory until its end, then follow the second one until it ends Args: traj_1 (ArmTrajectory): First trajectory traj_2 (ArmTrajectory): Second trajectory Returns: ArmTrajectory: Combined trajectory \"\"\" if traj_1 . joint_ids != traj_2 . joint_ids : raise NotImplementedError ( \"Controlled joint indices must match between the two trajectories (for now)\" ) # Ensure continuity in time , and merge the key time information # TODO check for continuity in all other components ? # TODO this assumes that both have time information dt = traj_1 . times [ -1 ] - traj_1 . times [ -2 ] new_key_times = traj_1 . key_times if np . isclose ( traj_2 . times [ 0 ] , 0 ) : times = np . concatenate ( [ traj_1.times, traj_2.times + traj_1.times[-1 ] + dt ] ) for name , time in traj_2 . key_times . items () : new_key_times [ name ] = time + traj_1 . times [ -1 ] + dt elif np . isclose ( traj_2 . times [ 0 ] , traj_1 . times [ -1 ] + dt ) : times = np . concatenate ( [ traj_1.times, traj_2.times ] ) new_key_times |= traj_2 . key_times return ArmTrajectory ( np . vstack ( [ traj_1.angles, traj_2.angles ] ), traj_1 . joint_ids , times , new_key_times , )","title":"concatenate_arm_trajs"},{"location":"reference/pyastrobee/trajectories/trajectory/#concatenate_trajs","text":"def concatenate_trajs ( traj_1 : pyastrobee . trajectories . trajectory . Trajectory , traj_2 : pyastrobee . trajectories . trajectory . Trajectory ) -> pyastrobee . trajectories . trajectory . Trajectory Combine two trajectories one after the other This will follow the first trajectory until its end, then follow the second one until it ends Parameters: Name Type Description Default traj_1 Trajectory First trajectory None traj_2 Trajectory Second trajectory None Returns: Type Description Trajectory Combined trajectory View Source def concatenate_trajs ( traj_1 : Trajectory , traj_2 : Trajectory ) -> Trajectory : \"\"\"Combine two trajectories one after the other This will follow the first trajectory until its end, then follow the second one until it ends Args: traj_1 (Trajectory): First trajectory traj_2 (Trajectory): Second trajectory Returns: Trajectory: Combined trajectory \"\"\" # Ensure continuity in time # TODO check for continuity in all other components ? # TODO this assumes that both have time information dt = traj_1 . times [ - 1 ] - traj_1 . times [ - 2 ] if np . isclose ( traj_2 . times [ 0 ], 0 ) : times = np . concatenate ([ traj_1 . times , traj_2 . times + traj_1 . times [ - 1 ] + dt ]) elif np . isclose ( traj_2 . times [ 0 ], traj_1 . times [ - 1 ] + dt ) : times = np . concatenate ([ traj_1 . times , traj_2 . times ]) return Trajectory ( np . vstack ([ traj_1 . positions , traj_2 . positions ]), np . vstack ( [ traj_1 . quaternions , traj_2 . quaternions ], ), np . vstack ([ traj_1 . linear_velocities , traj_2 . linear_velocities ]), np . vstack ([ traj_1 . angular_velocities , traj_2 . angular_velocities ]), np . vstack ([ traj_1 . linear_accels , traj_2 . linear_accels ]), np . vstack ([ traj_1 . angular_accels , traj_2 . angular_accels ]), times , )","title":"concatenate_trajs"},{"location":"reference/pyastrobee/trajectories/trajectory/#extrapolate_arm_traj","text":"def extrapolate_arm_traj ( traj : pyastrobee . trajectories . trajectory . ArmTrajectory , duration : Optional [ float ] = None , n_steps : Optional [ int ] = None ) -> pyastrobee . trajectories . trajectory . ArmTrajectory Extrapolates an arm trajectory by an amount of time This assumes that the (pre-extrapolation) trajectory comes to a rest at the end Either the extrapolation duration or number of timesteps must be specified. Not both, not neither Parameters: Name Type Description Default traj ArmTrajectory Original arm trajectory None duration Optional[float] Amount of time to extrapolate by. Defaults to None (n_steps input must be provided) None n_steps Optional[int] Number of timesteps to extrapolate by. Defaults to None (duration input must be provided) None Returns: Type Description ArmTrajectory Extrapolated arm trajectory View Source def extrapolate_arm_traj ( traj : ArmTrajectory , duration : Optional [ float ] = None , n_steps : Optional [ int ] = None ) -> ArmTrajectory : \"\"\"Extrapolates an arm trajectory by an amount of time This assumes that the (pre-extrapolation) trajectory comes to a rest at the end Either the extrapolation duration or number of timesteps must be specified. Not both, not neither Args: traj (ArmTrajectory): Original arm trajectory duration (Optional[float], optional): Amount of time to extrapolate by. Defaults to None (n_steps input must be provided) n_steps (Optional[int], optional): Number of timesteps to extrapolate by. Defaults to None (duration input must be provided) Returns: ArmTrajectory: Extrapolated arm trajectory \"\"\" dt = traj . times [ -1 ] - traj . times [ -2 ] if duration is None and n_steps is None : raise ValueError ( \"Must provide either a duration to extrapolate by, or a fixed number of timesteps\" ) elif duration is not None and n_steps is not None : raise ValueError ( \"Provide either a duration or a number of timesteps, not both\" ) elif duration is not None : n_steps = round ( duration / dt ) assert n_steps is not None return ArmTrajectory ( np . vstack ( [ traj.angles, traj.angles[-1 ] * np . ones (( n_steps , 1 )) ] ), traj . joint_ids , np . concatenate ( [ traj.times, traj.times[-1 ] + dt + np . arange ( n_steps ) * dt ] ), traj . key_times , )","title":"extrapolate_arm_traj"},{"location":"reference/pyastrobee/trajectories/trajectory/#extrapolate_traj","text":"def extrapolate_traj ( traj : pyastrobee . trajectories . trajectory . Trajectory , duration : Optional [ float ] = None , n_steps : Optional [ int ] = None ) -> pyastrobee . trajectories . trajectory . Trajectory Extrapolates a trajectory by an amount of time This assumes that the (pre-extrapolation) trajectory comes to a rest at the end Either the extrapolation duration or number of timesteps must be specified. Not both, not neither Parameters: Name Type Description Default traj Trajectory Original trajectory None duration Optional[float] Amount of time to extrapolate by. Defaults to None (n_steps input must be provided) None n_steps Optional[int] Number of timesteps to extrapolate by. Defaults to None (duration input must be provided) None Returns: Type Description Trajectory Extrapolated trajectory View Source def extrapolate_traj ( traj : Trajectory , duration : Optional [ float ] = None , n_steps : Optional [ int ] = None ) -> Trajectory : \"\"\"Extrapolates a trajectory by an amount of time This assumes that the (pre-extrapolation) trajectory comes to a rest at the end Either the extrapolation duration or number of timesteps must be specified. Not both, not neither Args: traj (Trajectory): Original trajectory duration (Optional[float], optional): Amount of time to extrapolate by. Defaults to None (n_steps input must be provided) n_steps (Optional[int], optional): Number of timesteps to extrapolate by. Defaults to None (duration input must be provided) Returns: Trajectory: Extrapolated trajectory \"\"\" dt = traj . times [ -1 ] - traj . times [ -2 ] if duration is None and n_steps is None : raise ValueError ( \"Must provide either a duration to extrapolate by, or a fixed number of timesteps\" ) elif duration is not None and n_steps is not None : raise ValueError ( \"Provide either a duration or a number of timesteps, not both\" ) elif duration is not None : n_steps = round ( duration / dt ) assert n_steps is not None if not np . isclose ( np . linalg . norm ( traj . linear_velocities [ -1 ] ), 0 ) or not np . isclose ( np . linalg . norm ( traj . angular_velocities [ -1 ] ), 0 ) : raise NotImplementedError ( \"Cannot extrapolate the trajectory: Only implemented for trajectories that end at a stopped pose\" ) return Trajectory ( np . vstack ( [ traj.positions, traj.positions[-1 ] * np . ones (( n_steps , 1 )) ] ), np . vstack ( [ traj.quaternions, traj.quaternions[-1 ] * np . ones (( n_steps , 1 )) ] ), np . vstack ( [ traj.linear_velocities, np.zeros((n_steps, 3)) ] ), np . vstack ( [ traj.angular_velocities, np.zeros((n_steps, 3)) ] ), np . vstack ( [ traj.linear_accels, np.zeros((n_steps, 3)) ] ), np . vstack ( [ traj.angular_accels, np.zeros((n_steps, 3)) ] ), np . concatenate ( [ traj.times, traj.times[-1 ] + dt + np . arange ( n_steps ) * dt ] ), )","title":"extrapolate_traj"},{"location":"reference/pyastrobee/trajectories/trajectory/#merge_trajs","text":"def merge_trajs ( pos_traj : pyastrobee . trajectories . trajectory . Trajectory , orn_traj : pyastrobee . trajectories . trajectory . Trajectory ) -> pyastrobee . trajectories . trajectory . Trajectory Merge the position component from one trajectory with the orientation component from another Parameters: Name Type Description Default pos_traj Trajectory Trajectory with desired position component None orn_traj Trajectory Trajectory with desired orientation component None Returns: Type Description Trajectory Merged trajectory with both position + orientation info View Source def merge_trajs ( pos_traj : Trajectory , orn_traj : Trajectory ) -> Trajectory : \"\"\"Merge the position component from one trajectory with the orientation component from another Args: pos_traj (Trajectory): Trajectory with desired position component orn_traj (Trajectory): Trajectory with desired orientation component Returns: Trajectory: Merged trajectory with both position + orientation info \"\"\" assert np . size ( pos_traj . positions ) > 0 assert np . size ( orn_traj . quaternions ) > 0 positions = pos_traj . positions quaternions = pos_traj . quaternions # Time # If both trajectories have time info , make sure they match up if np . size ( pos_traj . times ) > 0 : if np . size ( orn_traj . times ) > 0 : if not np . allclose ( pos_traj . times , orn_traj . times ) : raise ValueError ( \"Mismatched time information\" ) times = pos_traj . times dt = pos_traj . timestep elif np . size ( orn_traj . times ) > 0 : times = orn_traj . times dt = orn_traj . timestep else : times = None dt = None # If either trajectory is missing derivative info , compute it if we can # Position if np . size ( pos_traj . linear_velocities ) == 0 and dt is not None : lin_vels = np . gradient ( pos_traj . positions , dt , axis = 0 ) else : lin_vels = pos_traj . linear_velocities if np . size ( pos_traj . linear_accels ) == 0 and dt is not None : lin_accels = np . gradient ( lin_vels , dt , axis = 0 ) else : lin_accels = pos_traj . linear_accels # Orientation if np . size ( orn_traj . angular_velocities ) == 0 and dt is not None : ang_vels = quats_to_angular_velocities ( orn_traj . quaternions , dt ) else : ang_vels = orn_traj . angular_velocities if np . size ( orn_traj . angular_accels ) == 0 and dt is not None : ang_accels = np . gradient ( ang_vels , dt , axis = 0 ) else : ang_accels = orn_traj . angular_accels return Trajectory ( positions , quaternions , lin_vels , ang_vels , lin_accels , ang_accels , times )","title":"merge_trajs"},{"location":"reference/pyastrobee/trajectories/trajectory/#num_subplots_to_shape","text":"def num_subplots_to_shape ( n : int ) -> tuple [ int , int ] Determines the best layout of a number of subplots within a larger figure Parameters: Name Type Description Default n int Number of subplots None Returns: Type Description tuple[int, int] Number of rows and columns for the subplot divisions View Source def num_subplots_to_shape(n: int) -> tuple[int, int]: \"\"\"Determines the best layout of a number of subplots within a larger figure Args: n (int): Number of subplots Returns: tuple[int, int]: Number of rows and columns for the subplot divisions \"\"\" n_rows = int(np.sqrt(n)) n_cols = n // n_rows + (n % n_rows > 0) assert n_rows * n_cols >= n return (n_rows, n_cols)","title":"num_subplots_to_shape"},{"location":"reference/pyastrobee/trajectories/trajectory/#plot_traj","text":"def plot_traj ( traj : pyastrobee . trajectories . trajectory . Trajectory , show : bool = True , fmt : str = 'k-' ) -> matplotlib . figure . Figure Plot the trajectory components over time Parameters: Name Type Description Default traj Trajectory The Trajectory object to plot None show bool Whether or not to display the plot. Defaults to True. True fmt str Matplotlib line specification. Defaults to \"k-\" None Returns: Type Description Figure Matplotlib figure containing the plots View Source def plot_traj ( traj : Trajectory , show : bool = True , fmt : str = \"k-\" ) -> Figure : \"\"\"Plot the trajectory components over time Args: traj (Trajectory): The Trajectory object to plot show (bool, optional): Whether or not to display the plot. Defaults to True. fmt (str, optional): Matplotlib line specification. Defaults to \" k - \" Returns: Figure: Matplotlib figure containing the plots \"\"\" # Indexing helper variables POS = 0 ORN = 1 LIN_VEL = 2 ANG_VEL = 3 LIN_ACCEL = 4 ANG_ACCEL = 5 labels = { POS : [ \"x\", \"y\", \"z\" ] , ORN : [ \"qx\", \"qy\", \"qz\", \"qw\" ] , LIN_VEL : [ \"vx\", \"vy\", \"vz\" ] , ANG_VEL : [ \"wx\", \"wy\", \"wz\" ] , LIN_ACCEL : [ \"ax\", \"ay\", \"az\" ] , ANG_ACCEL : [ \"al_x\", \"al_y\", \"al_z\" ] , } fig = plt . figure () if traj . times is None or np . size ( traj . times ) == 0 : x_axis = range ( traj . num_timesteps ) x_label = \"Timesteps\" else : x_axis = traj . times x_label = \"Time, s\" # Top row is position info , bottom row is orientation info # Columns give derivative info subfigs = fig . subfigures ( 2 , 3 ) top_left = subfigs [ 0, 0 ] . subplots ( 1 , 3 ) _plot ( top_left , traj . positions , labels [ POS ] , x_axis , x_label , fmt ) top_middle = subfigs [ 0, 1 ] . subplots ( 1 , 3 ) _plot ( top_middle , traj . linear_velocities , labels [ LIN_VEL ] , x_axis , x_label , fmt ) top_right = subfigs [ 0, 2 ] . subplots ( 1 , 3 ) _plot ( top_right , traj . linear_accels , labels [ LIN_ACCEL ] , x_axis , x_label , fmt ) bot_left = subfigs [ 1, 0 ] . subplots ( 1 , 4 ) _plot ( bot_left , traj . quaternions , labels [ ORN ] , x_axis , x_label , fmt ) bot_middle = subfigs [ 1, 1 ] . subplots ( 1 , 3 ) _plot ( bot_middle , traj . angular_velocities , labels [ ANG_VEL ] , x_axis , x_label , fmt ) bot_right = subfigs [ 1, 2 ] . subplots ( 1 , 3 ) _plot ( bot_right , traj . angular_accels , labels [ ANG_ACCEL ] , x_axis , x_label , fmt ) if show : plt . show () return fig","title":"plot_traj"},{"location":"reference/pyastrobee/trajectories/trajectory/#plot_traj_constraints","text":"def plot_traj_constraints ( traj : pyastrobee . trajectories . trajectory . Trajectory , pos_lims : Union [ pyastrobee . utils . boxes . Box , numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , max_vel : Optional [ float ] = None , max_accel : Optional [ float ] = None , max_omega : Optional [ float ] = None , max_alpha : Optional [ float ] = None , show : bool = True ) -> matplotlib . figure . Figure Plot trajectory info to visualize how it satisfies constraints Parameters: Name Type Description Default traj Trajectory Trajectory to plot None pos_lims Optional[Union[Box, npt.ArrayLike]] Lower and upper limits on the XYZ position. Defaults to None. None max_vel Optional[float] Maximum velocity magnitude. Defaults to None. None max_accel Optional[float] Maximum acceleration magnitude. Defaults to None. None max_omega Optional[float] Maximum angular velocity magnitude. Defaults to None. None max_alpha Optional[float] Maximum angular acceleration magnitude. Defaults to None. None show bool Whether or not to display the plot. Defaults to True. True Returns: Type Description Figure The plot View Source def plot_traj_constraints ( traj : Trajectory , pos_lims : Optional [ Union[Box, npt.ArrayLike ] ] = None , max_vel : Optional [ float ] = None , max_accel : Optional [ float ] = None , max_omega : Optional [ float ] = None , max_alpha : Optional [ float ] = None , show : bool = True , ) -> Figure : \"\"\"Plot trajectory info to visualize how it satisfies constraints Args: traj (Trajectory): Trajectory to plot pos_lims (Optional[Union[Box, npt.ArrayLike]]): Lower and upper limits on the XYZ position. Defaults to None. max_vel (Optional[float]): Maximum velocity magnitude. Defaults to None. max_accel (Optional[float]): Maximum acceleration magnitude. Defaults to None. max_omega (Optional[float]): Maximum angular velocity magnitude. Defaults to None. max_alpha (Optional[float]): Maximum angular acceleration magnitude. Defaults to None. show (bool, optional): Whether or not to display the plot. Defaults to True. Returns: Figure: The plot \"\"\" fig = plt . figure () if traj . times is None or np . size ( traj . times ) == 0 : x_axis = range ( traj . num_timesteps ) x_label = \"Timesteps\" else : x_axis = traj . times x_label = \"Time, s\" fmt = \"k-\" lim_fmt = \"r--\" # Top row is position info , bottom row is orientation info # Columns give derivative info subfigs = fig . subfigures ( 2 , 3 ) # Position top_left = subfigs [ 0, 0 ] . subplots ( 1 , 3 ) if traj . positions . size > 0 : for i , ax in enumerate ( top_left ) : ax . plot ( x_axis , traj . positions [ :, i ] , fmt ) ax . set_title ( [ \"x\", \"y\", \"z\" ][ i ] ) ax . set_xlabel ( x_label ) if pos_lims is not None : lower_pos_lim , upper_pos_lim = pos_lims for i , ax in enumerate ( top_left ) : ax . plot ( x_axis , lower_pos_lim [ i ] * np . ones_like ( x_axis ), lim_fmt ) ax . plot ( x_axis , upper_pos_lim [ i ] * np . ones_like ( x_axis ), lim_fmt ) # Linear velocity if traj . linear_velocities . size > 0 : top_middle = subfigs [ 0, 1 ] . subplots ( 1 , 1 ) top_middle . plot ( x_axis , np . linalg . norm ( traj . linear_velocities , axis = 1 ), fmt ) top_middle . set_title ( \"||vel||\" ) top_middle . set_xlabel ( x_label ) if max_vel is not None : top_middle . plot ( x_axis , max_vel * np . ones_like ( x_axis ), lim_fmt ) # Linear acceleration if traj . linear_accels . size > 0 : top_right = subfigs [ 0, 2 ] . subplots ( 1 , 1 ) top_right . plot ( x_axis , np . linalg . norm ( traj . linear_accels , axis = 1 ), fmt ) top_right . set_title ( \"||accel||\" ) top_right . set_xlabel ( x_label ) if max_accel is not None : top_right . plot ( x_axis , max_accel * np . ones_like ( x_axis ), lim_fmt ) # Quaternions # These are unconstrained so it ' s the same plotting method as in the standard plot traj function bot_left = subfigs [ 1, 0 ] . subplots ( 1 , 4 ) if traj . quaternions . size > 0 : _plot ( bot_left , traj . quaternions , [ \"qx\", \"qy\", \"qz\", \"qw\" ] , x_axis , x_label , fmt ) # Angular velocity bot_middle = subfigs [ 1, 1 ] . subplots ( 1 , 1 ) if traj . angular_velocities . size > 0 : bot_middle . plot ( x_axis , np . linalg . norm ( traj . angular_velocities , axis = 1 ), fmt ) bot_middle . set_title ( \"||omega||\" ) bot_middle . set_xlabel ( x_label ) if max_omega is not None : bot_middle . plot ( x_axis , max_omega * np . ones_like ( x_axis ), lim_fmt ) # Angular acceleration bot_right = subfigs [ 1, 2 ] . subplots ( 1 , 1 ) if traj . angular_accels . size > 0 : bot_right . plot ( x_axis , np . linalg . norm ( traj . angular_accels , axis = 1 ), fmt ) bot_right . set_title ( \"||alpha||\" ) bot_right . set_xlabel ( x_label ) if max_alpha is not None : bot_right . plot ( x_axis , max_alpha * np . ones_like ( x_axis ), lim_fmt ) if show : plt . show () return fig","title":"plot_traj_constraints"},{"location":"reference/pyastrobee/trajectories/trajectory/#stopping_criteria","text":"def stopping_criteria ( pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], quat : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], lin_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], ang_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pos_des : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], quat_des : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], dp : float = 0.01 , dq : float = 0.01 , dv : float = 0.01 , dw : float = 0.005 ) -> bool Determine if the Astrobee has fully stopped, based on its current dynamics state Parameters: Name Type Description Default pos npt.ArrayLike Current position, shape (3,) None quat npt.ArrayLike Current XYZW quaternion orientation, shape (4,) None lin_vel npt.ArrayLike Current linear velocity, shape (3,) None ang_vel npt.ArrayLike Current angular velocity, shape (3,) None pos_des npt.ArrayLike Desired position, shape (3,) None quat_des npt.ArrayLike Desired XYZW quaternion orientation, shape (4,) None dp float Tolerance on position error magnitude. Defaults to 1e-2. 1e-2 dq float Tolerance on quaternion distance between cur/des. Defaults to 1e-2. 1e-2 dv float Tolerance on linear velocity error magnitude. Defaults to 1e-2. 1e-2 dw float Tolerance on angular velocity error magnitude. Defaults to 5e-3. 5e-3 Returns: Type Description bool If the Astrobee have successfully stopped at its desired goal pose View Source def stopping_criteria ( pos : npt . ArrayLike , quat : npt . ArrayLike , lin_vel : npt . ArrayLike , ang_vel : npt . ArrayLike , pos_des : npt . ArrayLike , quat_des : npt . ArrayLike , dp : float = 1e-2 , dq : float = 1e-2 , dv : float = 1e-2 , dw : float = 5e-3 , ) -> bool : \"\"\"Determine if the Astrobee has fully stopped, based on its current dynamics state Args: pos (npt.ArrayLike): Current position, shape (3,) quat (npt.ArrayLike): Current XYZW quaternion orientation, shape (4,) lin_vel (npt.ArrayLike): Current linear velocity, shape (3,) ang_vel (npt.ArrayLike): Current angular velocity, shape (3,) pos_des (npt.ArrayLike): Desired position, shape (3,) quat_des (npt.ArrayLike): Desired XYZW quaternion orientation, shape (4,) dp (float, optional): Tolerance on position error magnitude. Defaults to 1e-2. dq (float, optional): Tolerance on quaternion distance between cur/des. Defaults to 1e-2. dv (float, optional): Tolerance on linear velocity error magnitude. Defaults to 1e-2. dw (float, optional): Tolerance on angular velocity error magnitude. Defaults to 5e-3. Returns: bool: If the Astrobee have successfully stopped at its desired goal pose \"\"\" p_check = np . linalg . norm ( pos - pos_des ) <= dp q_check = quaternion_dist ( quat , quat_des ) <= dq v_check = np . linalg . norm ( lin_vel ) <= dv w_check = np . linalg . norm ( ang_vel ) <= dw checks = [ p_check , q_check , v_check , w_check ] return np . all ( checks )","title":"stopping_criteria"},{"location":"reference/pyastrobee/trajectories/trajectory/#visualize_traj","text":"def visualize_traj ( traj : Union [ pyastrobee . trajectories . trajectory . Trajectory , numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], n : Optional [ int ] = None , size : float = 0.5 , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> list [ int ] Visualizes a trajectory's sequence of poses on the Pybullet GUI Parameters: Name Type Description Default traj Union[Trajectory, npt.ArrayLike] Trajectory to visualize (must contain at least position + orientation info), or an array of position + quaternion poses, shape (n, 7) None n Optional[int] Number of frames to plot, if plotting all of the frames is not desired. Defaults to None (plot all frames) None size float Length of the lines to plot for each frame. Defaults to 0.5 (this gives a good scale with respect to the dimensions of the Astrobee) 0 client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Returns: Type Description list[int] Pybullet IDs for the lines drawn onto the GUI View Source def visualize_traj ( traj : Union [ Trajectory, npt.ArrayLike ] , n : Optional [ int ] = None , size : float = 0.5 , client : Optional [ BulletClient ] = None , ) -> list [ int ] : \"\"\"Visualizes a trajectory's sequence of poses on the Pybullet GUI Args: traj (Union[Trajectory, npt.ArrayLike]): Trajectory to visualize (must contain at least position + orientation info), or an array of position + quaternion poses, shape (n, 7) n (Optional[int]): Number of frames to plot, if plotting all of the frames is not desired. Defaults to None (plot all frames) size (float, optional): Length of the lines to plot for each frame. Defaults to 0.5 (this gives a good scale with respect to the dimensions of the Astrobee) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: list[int]: Pybullet IDs for the lines drawn onto the GUI \"\"\" client : pybullet = pybullet if client is None else client if isinstance ( traj , Trajectory ) : traj = traj . poses else : # If there is more information ( velocity , time ) in our array , only use the pose info traj = np . atleast_2d ( traj ) [ :, :7 ] n_frames = traj . shape [ 0 ] # If desired , sample frames evenly across the trajectory to plot a subset if n is not None and n < n_frames : # This indexing ensures that the first and last frames are plotted idx = np . round ( np . linspace ( 0 , n_frames - 1 , n , endpoint = True )). astype ( int ) traj = traj [ idx, : ] tmats = batched_pos_quats_to_tmats ( traj ) ids = [] for i in range ( tmats . shape [ 0 ] ) : ids += visualize_frame ( tmats [ i, :, : ] , size , client = client ) return ids","title":"visualize_traj"},{"location":"reference/pyastrobee/trajectories/trajectory/#classes","text":"","title":"Classes"},{"location":"reference/pyastrobee/trajectories/trajectory/#armtrajectory","text":"class ArmTrajectory ( angles : numpy . ndarray , joint_ids : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], times : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , key_times : Optional [ dict [ str , float ]] = None ) Maintains information on the positions of the arm's joint angles over time Currently this assumes we are working with position control","title":"ArmTrajectory"},{"location":"reference/pyastrobee/trajectories/trajectory/#attributes","text":"Name Type Description Default angles np.ndarray Joint angles over time, shape (n_timesteps, n_controlled_joints) None joint_ids npt.ArrayLike Indices of the joints being controlled with position control. Unspecified joints will be left at their default control value (Either manually set or defined at robot initialization) None times Optional[npt.ArrayLike] Time information for the trajectory, shape (n_timesteps). Defaults to None. None key_times Optional[dict[str, float]] Information about when key transitions occur in the trajectory, for instance, when we start/stop an arm deployment motion. Defaults to None. None View Source class ArmTrajectory : \"\"\"Maintains information on the positions of the arm's joint angles over time Currently this assumes we are working with position control Args: angles (np.ndarray): Joint angles over time, shape (n_timesteps, n_controlled_joints) joint_ids (npt.ArrayLike): Indices of the joints being controlled with position control. Unspecified joints will be left at their default control value (Either manually set or defined at robot initialization) times (Optional[npt.ArrayLike]): Time information for the trajectory, shape (n_timesteps). Defaults to None. key_times (Optional[dict[str, float]]): Information about when key transitions occur in the trajectory, for instance, when we start/stop an arm deployment motion. Defaults to None. Raises: ValueError: If the shape of the angles input does not match the expected number of joints being controlled, or the number of timesteps in the time input KeyError: If the key_times dictionary contains unexpected keys. Currently supported: \" begin_drag_motion \", \" end_drag_motion \", \" begin_grasp_motion \", \" end_grasp_motion \" \"\"\" def __init__ ( self , angles : np . ndarray , joint_ids : npt . ArrayLike , times : Optional [ npt.ArrayLike ] = None , key_times : Optional [ dict[str, float ] ] = None , ) : if np . ndim ( angles ) == 1 : angles = angles . reshape ( - 1 , 1 ) joint_ids = np . atleast_1d ( joint_ids ) n_steps , n_joints = angles . shape if n_joints != len ( joint_ids ) : raise ValueError ( \"Mismatched inputs: The second dimension of the angles must match the number of joints.\\n\" + f \"Got shape: {angles.shape} for {len(joint_ids)} joint indices: {joint_ids}\" ) if times is not None and len ( times ) != n_steps : raise ValueError ( \"Mismatched input dimensions: Time info is not the same length as the angles\" ) self . angles = angles self . joint_ids = joint_ids self . times = times if times is not None else [] self . num_timesteps = n_steps # Hacky way to store information on the times / indices when the arm moves back or forward # This somewhat assumes that we 're going to move the arm to \"drag\" and then back to \"grasp\" # TODO make this more general # TODO improve how we handle the keys that we' d expect to see self . key_times = key_times expected_keys = { \"begin_drag_motion\" , \"end_drag_motion\" , \"begin_grasp_motion\" , \"end_grasp_motion\" , } for key in self . key_times . keys () : if key not in expected_keys : raise KeyError ( \"Unexpected key time name: \" , key ) def plot ( self ) : if self . times is None or np . size ( self . times ) == 0 : x_axis = range ( self . num_timesteps ) x_label = \"Timesteps\" else : x_axis = self . times x_label = \"Time, s\" n_subplots = len ( self . joint_ids ) subplot_shape = num_subplots_to_shape ( n_subplots ) fig = plt . figure () for j , index in enumerate ( self . joint_ids ) : plt . subplot ( * subplot_shape , j + 1 ) plt . plot ( x_axis , self . angles [ :, j ] ) plt . title ( f \"Joint {index}\" ) plt . xlabel ( x_label ) plt . ylabel ( \"Angle\" ) plt . show () # TODO !! USE NEW CONCATENATE AND EXTRAPOLATE METHODS def get_segment ( self , start_index : int , end_index : int , reset_time : bool = True ) -> \"ArmTrajectory\" : \"\"\"Construct an arm trajectory segment from a larger trajectory Args: start_index (int): Starting index of the larger trajectory to extract the segment end_index (int): Ending index of the larger trajectory to extract the segment reset_time (bool): Whether to maintain the time association with the original trajectory, or reset the start time back to 0. Defaults to True (reset start time back to 0) Returns: ArmTrajectory: A new trajectory representing a segment of the original trajectory \"\"\" # TODO : add check for invalid slicing indices ? Or just leave it up to numpy # HACK HACK HACK !!!!!!!!!!!!!!!!!!!!!! n_steps = len ( self . times ) # print ( f \"GETTING ARM SEGMENT: Start: {start_index}, End: {end_index}\" ) if start_index < n_steps and end_index < n_steps : # NORMAL # Time needs to get handled differently because the trajectory may or may not have time info if np . size ( self . times ) == 0 : # No time info new_times = None else : new_times = self . times [ start_index:end_index ] new_key_times = {} for name , time in self . key_times . items () : if new_times [ 0 ] <= time <= new_times [ -1 ] : new_key_times [ name ] = time if reset_time and new_times is not None : new_times -= new_times [ 0 ] for name , time in new_key_times . items () : new_key_times [ name ] -= new_times [ 0 ] return ArmTrajectory ( self . angles [ start_index:end_index, : ] , self . joint_ids , new_times , new_key_times , ) elif start_index < n_steps and end_index >= n_steps : angles = np . vstack ( [ self.angles[start_index:, : ] , np . ones (( end_index - n_steps , len ( self . joint_ids ))) * self . angles [ -1 ] , ] ) dt = self . times [ 1 ] - self . times [ 0 ] new_times = ( self . times [ start_index ] + np . arange ( end_index - start_index ) * dt ) new_key_times = {} for name , time in self . key_times . items () : if new_times [ 0 ] <= time <= new_times [ -1 ] : new_key_times [ name ] = time if reset_time : new_times -= new_times [ 0 ] for name , time in new_key_times . items () : new_key_times [ name ] -= new_times [ 0 ] return ArmTrajectory ( angles , self . joint_ids , new_times , new_key_times ) else : # Both over the limit angles = self . angles [ -1 ] * np . ones ( ( end_index - start_index , len ( self . joint_ids )) ) dt = self . times [ 1 ] - self . times [ 0 ] new_times = self . times [ -1 ] + np . arange ( end_index - start_index ) * dt new_key_times = {} for name , time in self . key_times . items () : if new_times [ 0 ] <= time <= new_times [ -1 ] : new_key_times [ name ] = time if reset_time : new_times -= new_times [ 0 ] for name , time in new_key_times . items () : new_key_times [ name ] -= new_times [ 0 ] return ArmTrajectory ( angles , self . joint_ids , new_times , new_key_times ) def get_segment_from_times ( self , start_time : float , end_time : float , reset_time : bool = True ) -> \"ArmTrajectory\" : \"\"\"Construct an arm trajectory segment from a larger trajectory Args: start_time (float): Starting time of the segment end_time (float): Ending time of the segment reset_time (bool): Whether to maintain the time association with the original trajectory, or reset the start time back to 0. Defaults to True (reset start time back to 0) Returns: ArmTrajectory: A new trajectory representing a segment of the original trajectory \"\"\" start_index = np . searchsorted ( self . times , start_time ) end_index = np . searchsorted ( self . times , end_time ) if end_index == len ( self . times ) : # Past the max time ... somewhat of a HACK dt = self . times [ -1 ] - self . times [ -2 ] time_after = end_time - self . times [ -1 ] end_index = len ( self . times ) - 1 + round ( time_after / dt ) return self . get_segment ( start_index , end_index , reset_time )","title":"Attributes"},{"location":"reference/pyastrobee/trajectories/trajectory/#methods","text":"","title":"Methods"},{"location":"reference/pyastrobee/trajectories/trajectory/#get_segment","text":"def get_segment ( self , start_index : int , end_index : int , reset_time : bool = True ) -> 'ArmTrajectory' Construct an arm trajectory segment from a larger trajectory Parameters: Name Type Description Default start_index int Starting index of the larger trajectory to extract the segment None end_index int Ending index of the larger trajectory to extract the segment None reset_time bool Whether to maintain the time association with the original trajectory, or reset the start time back to 0. Defaults to True (reset start time back to 0) None Returns: Type Description ArmTrajectory A new trajectory representing a segment of the original trajectory View Source def get_segment ( self , start_index : int , end_index : int , reset_time : bool = True ) -> \"ArmTrajectory\" : \"\"\"Construct an arm trajectory segment from a larger trajectory Args: start_index (int): Starting index of the larger trajectory to extract the segment end_index (int): Ending index of the larger trajectory to extract the segment reset_time (bool): Whether to maintain the time association with the original trajectory, or reset the start time back to 0. Defaults to True (reset start time back to 0) Returns: ArmTrajectory: A new trajectory representing a segment of the original trajectory \"\"\" # TODO : add check for invalid slicing indices ? Or just leave it up to numpy # HACK HACK HACK !!!!!!!!!!!!!!!!!!!!!! n_steps = len ( self . times ) # print ( f \"GETTING ARM SEGMENT: Start: {start_index}, End: {end_index}\" ) if start_index < n_steps and end_index < n_steps : # NORMAL # Time needs to get handled differently because the trajectory may or may not have time info if np . size ( self . times ) == 0 : # No time info new_times = None else : new_times = self . times [ start_index:end_index ] new_key_times = {} for name , time in self . key_times . items () : if new_times [ 0 ] <= time <= new_times [ -1 ] : new_key_times [ name ] = time if reset_time and new_times is not None : new_times -= new_times [ 0 ] for name , time in new_key_times . items () : new_key_times [ name ] -= new_times [ 0 ] return ArmTrajectory ( self . angles [ start_index:end_index, : ] , self . joint_ids , new_times , new_key_times , ) elif start_index < n_steps and end_index >= n_steps : angles = np . vstack ( [ self.angles[start_index:, : ] , np . ones (( end_index - n_steps , len ( self . joint_ids ))) * self . angles [ -1 ] , ] ) dt = self . times [ 1 ] - self . times [ 0 ] new_times = ( self . times [ start_index ] + np . arange ( end_index - start_index ) * dt ) new_key_times = {} for name , time in self . key_times . items () : if new_times [ 0 ] <= time <= new_times [ -1 ] : new_key_times [ name ] = time if reset_time : new_times -= new_times [ 0 ] for name , time in new_key_times . items () : new_key_times [ name ] -= new_times [ 0 ] return ArmTrajectory ( angles , self . joint_ids , new_times , new_key_times ) else : # Both over the limit angles = self . angles [ -1 ] * np . ones ( ( end_index - start_index , len ( self . joint_ids )) ) dt = self . times [ 1 ] - self . times [ 0 ] new_times = self . times [ -1 ] + np . arange ( end_index - start_index ) * dt new_key_times = {} for name , time in self . key_times . items () : if new_times [ 0 ] <= time <= new_times [ -1 ] : new_key_times [ name ] = time if reset_time : new_times -= new_times [ 0 ] for name , time in new_key_times . items () : new_key_times [ name ] -= new_times [ 0 ] return ArmTrajectory ( angles , self . joint_ids , new_times , new_key_times )","title":"get_segment"},{"location":"reference/pyastrobee/trajectories/trajectory/#get_segment_from_times","text":"def get_segment_from_times ( self , start_time : float , end_time : float , reset_time : bool = True ) -> 'ArmTrajectory' Construct an arm trajectory segment from a larger trajectory Parameters: Name Type Description Default start_time float Starting time of the segment None end_time float Ending time of the segment None reset_time bool Whether to maintain the time association with the original trajectory, or reset the start time back to 0. Defaults to True (reset start time back to 0) None Returns: Type Description ArmTrajectory A new trajectory representing a segment of the original trajectory View Source def get_segment_from_times ( self , start_time : float , end_ time : float , reset_time : bool = True ) -> \"ArmTrajectory\" : \"\"\"Construct an arm trajectory segment from a larger trajectory Args: start_time (float): Starting time of the segment end_time (float): Ending time of the segment reset_time (bool): Whether to maintain the time association with the original trajectory, or reset the start time back to 0. Defaults to True (reset start time back to 0) Returns: ArmTrajectory: A new trajectory representing a segment of the original trajectory \"\"\" start_index = np . searchsorted ( self . times , start_time ) end_ index = np . searchsorted ( self . times , end_ time ) if end_ index == len ( self . times ) : # Past the max time ... somewhat of a HACK dt = self . times [ - 1 ] - self . times [ - 2 ] time_after = end_ time - self . times [ - 1 ] end_ index = len ( self . times ) - 1 + round ( time_after / dt ) return self . get_segment ( start_index , end_ index , reset_time )","title":"get_segment_from_times"},{"location":"reference/pyastrobee/trajectories/trajectory/#plot","text":"def plot ( self ) View Source def plot ( self ): if self . times is None or np . size ( self . times ) == 0 : x_axis = range ( self . num_timesteps ) x_label = \"Timesteps\" else : x_axis = self . times x_label = \"Time, s\" n_subplots = len ( self . joint_ids ) subplot_shape = num_subplots_to_shape ( n_subplots ) fig = plt . figure () for j , index in enumerate ( self . joint_ids ): plt . subplot ( * subplot_shape , j + 1 ) plt . plot ( x_axis , self . angles [:, j ]) plt . title ( f \"Joint {index}\" ) plt . xlabel ( x_label ) plt . ylabel ( \"Angle\" ) plt . show ()","title":"plot"},{"location":"reference/pyastrobee/trajectories/trajectory/#trajectory","text":"class Trajectory ( positions : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , quats : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , lin_vels : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , ang_vels : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , lin_accels : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , ang_accels : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , times : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None ) Trajectory class: Keeps track of a sequence of poses/velocities/accels over a period of time All arguments can be omitted as needed (for instance, a pose-only trajectory without velocities, or a trajectory without time information) All positions/orientations/velocities... are assumed to be defined in world frame","title":"Trajectory"},{"location":"reference/pyastrobee/trajectories/trajectory/#attributes_1","text":"Name Type Description Default positions Optional[npt.ArrayLike] Sequence of XYZ positions, shape (n, 3) None quats Optional[npt.ArrayLike] Sequence of XYZW quaternions, shape (n, 4) None lin_vels Optional[npt.ArrayLike] Sequence of (vx, vy, vz) linear velocities, shape (n, 3) None ang_vels Optional[npt.ArrayLike] Sequence of (wx, wy, wz) angular velocities, shape (n, 3) None lin_accels Optional[npt.ArrayLike] Sequence of (ax, ay, az) linear accelerations, shape (n, 3) None ang_accels Optional[npt.ArrayLike] Sequence of (al_x, al_y, al_z) angular accelerations, shape (n, 3) None times Optional[npt.ArrayLike] Times corresponding to each trajectory entry, shape (n) None View Source class Trajectory : \"\"\"Trajectory class: Keeps track of a sequence of poses/velocities/accels over a period of time - All arguments can be omitted as needed (for instance, a pose-only trajectory without velocities, or a trajectory without time information) - All positions/orientations/velocities... are assumed to be defined in world frame Args: positions (Optional[npt.ArrayLike]): Sequence of XYZ positions, shape (n, 3) quats (Optional[npt.ArrayLike]): Sequence of XYZW quaternions, shape (n, 4) lin_vels (Optional[npt.ArrayLike]): Sequence of (vx, vy, vz) linear velocities, shape (n, 3) ang_vels (Optional[npt.ArrayLike]): Sequence of (wx, wy, wz) angular velocities, shape (n, 3) lin_accels (Optional[npt.ArrayLike]): Sequence of (ax, ay, az) linear accelerations, shape (n, 3) ang_accels (Optional[npt.ArrayLike]): Sequence of (al_x, al_y, al_z) angular accelerations, shape (n, 3) times (Optional[npt.ArrayLike]): Times corresponding to each trajectory entry, shape (n) \"\"\" def __init__ ( self , positions : Optional [ npt.ArrayLike ] = None , quats : Optional [ npt.ArrayLike ] = None , lin_vels : Optional [ npt.ArrayLike ] = None , ang_vels : Optional [ npt.ArrayLike ] = None , lin_accels : Optional [ npt.ArrayLike ] = None , ang_accels : Optional [ npt.ArrayLike ] = None , times : Optional [ npt.ArrayLike ] = None , ) : self . _positions = positions if positions is not None else [] self . _quats = quats if quats is not None else [] self . _lin_vels = lin_vels if lin_vels is not None else [] self . _ang_vels = ang_vels if ang_vels is not None else [] self . _lin_accels = lin_accels if lin_accels is not None else [] self . _ang_accels = ang_accels if ang_accels is not None else [] self . _times = times if times is not None else [] self . _poses = None # Init self . _tmats = None # Init self . _num_timesteps = None # Init @property def positions ( self ) -> np . ndarray : return np . atleast_2d ( self . _positions ) @property def quaternions ( self ) -> np . ndarray : return np . atleast_2d ( self . _quats ) @property def linear_velocities ( self ) -> np . ndarray : return np . atleast_2d ( self . _lin_vels ) @property def angular_velocities ( self ) -> np . ndarray : return np . atleast_2d ( self . _ang_vels ) @property def linear_accels ( self ) -> np . ndarray : return np . atleast_2d ( self . _lin_accels ) @property def angular_accels ( self ) -> np . ndarray : return np . atleast_2d ( self . _ang_accels ) @property def times ( self ) -> np . ndarray : return np . asarray ( self . _times ) @property def timestep ( self ) -> float | None : if np . size ( self . _times ) == 0 : return None return self . _times [ 1 ] - self . _times [ 0 ] @property def num_timesteps ( self ) -> int : if self . _num_timesteps is None : if np . size ( self . positions ) > 0 : self . _num_timesteps = self . positions . shape [ 0 ] elif np . size ( self . quaternions ) > 0 : self . _num_timesteps = self . quaternions . shape [ 0 ] # If there is no position or orientation info , trajectory is empty ( None ) return self . _num_timesteps @property def duration ( self ) -> float : return self . _times [ -1 ] - self . _times [ 0 ] @property def poses ( self ) -> np . ndarray : \"\"\"Pose array (position + xyzw quaternion), shape (n, 7)\"\"\" # if self . _poses is not None : # return self . _poses # Only calculate this once if self . positions . size == 0 : raise ValueError ( \"No position information available\" ) if self . quaternions . size == 0 : raise ValueError ( \"No orientation information available\" ) self . _poses = np . column_stack ( [ self.positions, self.quaternions ] ) return self . _poses @property def tmats ( self ) -> np . ndarray : \"\"\"Poses expressed as transformation matrices, shape (n, 4, 4)\"\"\" # if self . _tmats is not None : # return self . _tmats # Only calculate this once self . _tmats = batched_pos_quats_to_tmats ( self . poses ) return self . _tmats @property def contains_pos_only ( self ) -> bool : \"\"\"Whether the trajectory contains only position info\"\"\" return self . positions . size > 0 and self . quaternions . size == 0 @property def contains_orn_only ( self ) -> bool : \"\"\"Whether the trajectory contains only orientation info\"\"\" return self . positions . size == 0 and self . quaternions . size > 0 @property def contains_pos_and_orn ( self ) -> bool : \"\"\"Whether the trajectory contains both position and orientation info\"\"\" return self . positions . size > 0 and self . quaternions . size > 0 @property def is_empty ( self ) -> bool : \"\"\"Whether the trajectory contains no position/orientation info\"\"\" return self . positions . size == 0 and self . quaternions . size == 0 def visualize ( self , n : Optional [ int ] = None , size : float = 0.5 , client : Optional [ BulletClient ] = None , ) -> list [ int ] : \"\"\"View the trajectory in Pybullet Args: n (Optional[int]): Number of frames to plot, if plotting all of the frames is not desired. Defaults to None (plot all frames) size (float, optional): Length of the lines to plot for each frame. Defaults to 0.5 (this gives a good scale with respect to the dimensions of the Astrobee) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: list[int]: Pybullet IDs for the lines drawn onto the GUI \"\"\" client : pybullet = pybullet if client is None else client connection_status = client . isConnected () # Bring up the Pybullet GUI if needed if not connection_status : client . connect ( pybullet . GUI ) if self . contains_pos_and_orn : ids = visualize_traj ( self , n , size , client = client ) elif self . contains_pos_only : print ( \"Trajectory only contains position info. Showing path instead\" ) ids = visualize_path ( self . positions , n , client = client ) elif self . contains_orn_only : raise NotImplementedError ( \"Visualizing a sequence of purely orientations is not implemented yet\" ) else : # Empty trajectory raise ValueError ( \"No trajectory information to visualize\" ) # Disconnect Pybullet if we originally weren ' t connected if not connection_status : input ( \"Press Enter to disconnect Pybullet\" ) client . disconnect () return ids def plot ( self , show : bool = True ) -> Figure : \"\"\"Plot the trajectory components over time Args: show (bool, optional): Whether or not to display the plot. Defaults to True. Returns: Figure: Matplotlib figure containing the plots \"\"\" return plot_traj ( self , show = show ) def get_segment ( self , start_index : int , end_index : int , reset_time : bool = True ) -> \"Trajectory\" : \"\"\"Construct a trajectory segment from a larger trajectory Args: start_index (int): Starting index of the larger trajectory to extract the segment end_index (int): Ending index of the larger trajectory to extract the segment reset_time (bool): Whether to maintain the time association with the original trajectory, or reset the start time back to 0. Defaults to True (reset start time back to 0) Returns: Trajectory: A new trajectory representing a segment of the original trajectory \"\"\" # TODO : add check for invalid slicing indices ? Or just leave it up to numpy # Time needs to get handled differently because the trajectory may or may not have time info if np . size ( self . times ) == 0 : # No time info new_times = None else : new_times = self . times [ start_index:end_index ] if reset_time : new_times -= new_times [ 0 ] return Trajectory ( self . positions [ start_index:end_index ] , self . quaternions [ start_index:end_index ] , self . linear_velocities [ start_index:end_index ] , self . angular_velocities [ start_index:end_index ] , self . linear_accels [ start_index:end_index ] , self . angular_accels [ start_index:end_index ] , new_times , ) def get_segment_between_times ( self , start_time , end_time , reset_time : bool = True ) : # start_index = np . searchsorted ( self . times , start_time ) # end_index = np . searchsorted ( self . times , end_time ) raise NotImplementedError ( \"TODO\" )","title":"Attributes"},{"location":"reference/pyastrobee/trajectories/trajectory/#descendants","text":"pyastrobee.trajectories.trajectory.TrajectoryLogger","title":"Descendants"},{"location":"reference/pyastrobee/trajectories/trajectory/#instance-variables","text":"angular_accels angular_velocities contains_orn_only Whether the trajectory contains only orientation info contains_pos_and_orn Whether the trajectory contains both position and orientation info contains_pos_only Whether the trajectory contains only position info duration is_empty Whether the trajectory contains no position/orientation info linear_accels linear_velocities num_timesteps poses Pose array (position + xyzw quaternion), shape (n, 7) positions quaternions times timestep tmats Poses expressed as transformation matrices, shape (n, 4, 4)","title":"Instance variables"},{"location":"reference/pyastrobee/trajectories/trajectory/#methods_1","text":"","title":"Methods"},{"location":"reference/pyastrobee/trajectories/trajectory/#get_segment_1","text":"def get_segment ( self , start_index : int , end_index : int , reset_time : bool = True ) -> 'Trajectory' Construct a trajectory segment from a larger trajectory Parameters: Name Type Description Default start_index int Starting index of the larger trajectory to extract the segment None end_index int Ending index of the larger trajectory to extract the segment None reset_time bool Whether to maintain the time association with the original trajectory, or reset the start time back to 0. Defaults to True (reset start time back to 0) None Returns: Type Description Trajectory A new trajectory representing a segment of the original trajectory View Source def get_segment ( self , start_index : int , end_ index : int , reset_time : bool = True ) -> \"Trajectory\" : \"\"\"Construct a trajectory segment from a larger trajectory Args: start_index (int): Starting index of the larger trajectory to extract the segment end_index (int): Ending index of the larger trajectory to extract the segment reset_time (bool): Whether to maintain the time association with the original trajectory, or reset the start time back to 0. Defaults to True (reset start time back to 0) Returns: Trajectory: A new trajectory representing a segment of the original trajectory \"\"\" # TODO : add check for invalid slicing indices ? Or just leave it up to numpy # Time needs to get handled differently because the trajectory may or may not have time info if np . size ( self . times ) == 0 : # No time info new_times = None else : new_times = self . times [ start_index : end_ index ] if reset_time : new_times -= new_times [ 0 ] return Trajectory ( self . positions [ start_index : end_ index ], self . quaternions [ start_index : end_ index ], self . linear_velocities [ start_index : end_ index ], self . angular_velocities [ start_index : end_ index ], self . linear_accels [ start_index : end_ index ], self . angular_accels [ start_index : end_ index ], new_times , )","title":"get_segment"},{"location":"reference/pyastrobee/trajectories/trajectory/#get_segment_between_times","text":"def get_segment_between_times ( self , start_time , end_time , reset_time : bool = True ) View Source def get_segment_between_times(self, start_time, end_time, reset_time: bool = True): # start_index = np.searchsorted(self.times, start_time) # end_index = np.searchsorted(self.times, end_time) raise NotImplementedError(\"TODO\")","title":"get_segment_between_times"},{"location":"reference/pyastrobee/trajectories/trajectory/#plot_1","text":"def plot ( self , show : bool = True ) -> matplotlib . figure . Figure Plot the trajectory components over time Parameters: Name Type Description Default show bool Whether or not to display the plot. Defaults to True. True Returns: Type Description Figure Matplotlib figure containing the plots View Source def plot ( self , show : bool = True ) -> Figure : \"\"\"Plot the trajectory components over time Args: show (bool, optional): Whether or not to display the plot. Defaults to True. Returns: Figure: Matplotlib figure containing the plots \"\"\" return plot_traj ( self , show = show )","title":"plot"},{"location":"reference/pyastrobee/trajectories/trajectory/#visualize","text":"def visualize ( self , n : Optional [ int ] = None , size : float = 0.5 , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> list [ int ] View the trajectory in Pybullet Parameters: Name Type Description Default n Optional[int] Number of frames to plot, if plotting all of the frames is not desired. Defaults to None (plot all frames) None size float Length of the lines to plot for each frame. Defaults to 0.5 (this gives a good scale with respect to the dimensions of the Astrobee) 0 client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Returns: Type Description list[int] Pybullet IDs for the lines drawn onto the GUI View Source def visualize ( self , n : Optional [ int ] = None , size : float = 0.5 , client : Optional [ BulletClient ] = None , ) -> list [ int ] : \"\"\"View the trajectory in Pybullet Args: n (Optional[int]): Number of frames to plot, if plotting all of the frames is not desired. Defaults to None (plot all frames) size (float, optional): Length of the lines to plot for each frame. Defaults to 0.5 (this gives a good scale with respect to the dimensions of the Astrobee) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: list[int]: Pybullet IDs for the lines drawn onto the GUI \"\"\" client : pybullet = pybullet if client is None else client connection_status = client . isConnected () # Bring up the Pybullet GUI if needed if not connection_status : client . connect ( pybullet . GUI ) if self . contains_pos_and_orn : ids = visualize_traj ( self , n , size , client = client ) elif self . contains_pos_only : print ( \"Trajectory only contains position info. Showing path instead\" ) ids = visualize_path ( self . positions , n , client = client ) elif self . contains_orn_only : raise NotImplementedError ( \"Visualizing a sequence of purely orientations is not implemented yet\" ) else : # Empty trajectory raise ValueError ( \"No trajectory information to visualize\" ) # Disconnect Pybullet if we originally weren ' t connected if not connection_status : input ( \"Press Enter to disconnect Pybullet\" ) client . disconnect () return ids","title":"visualize"},{"location":"reference/pyastrobee/trajectories/trajectory/#trajectorylogger","text":"class TrajectoryLogger ( ) Class for maintaining a history of a robot's state over time View Source class TrajectoryLogger ( Trajectory ) : \"\"\"Class for maintaining a history of a robot's state over time\"\"\" def __init__ ( self ) : # Create an empty Trajectory which we will iteratively append to super (). __init__ ( None , None , None , None , None , None , None ) def log_state ( self , pos : npt . ArrayLike , quat : npt . ArrayLike , lin_vel : Optional [ npt.ArrayLike ] = None , ang_vel : Optional [ npt.ArrayLike ] = None , dt : Optional [ float ] = None , ) : \"\"\"Record the robot state at a given timestep If velocity information is not available (for instance, with a softbody), we can log just the position + orientation information Args: pos (npt.ArrayLike): Current position, shape (3,) quat (npt.ArrayLike): Current orientation (XYZW quaternion), shape (4,) lin_vel (Optional[npt.ArrayLike]): Current linear velocity, shape (3,). Defaults to None. ang_vel (Optional[npt.ArrayLike]): Current angular velocity, shape (3,). Defaults to None. dt (Optional[float]): Time elapsed since the previous step. Defaults to None. \"\"\" # TODO refine this functionality # Can log position / orientation info without velocity if needed # These values can be None because matplotlib will just not plot them # Most importantly , we want to make sure that things correspond in time # ( There shouldn ' t be an instance where we have histories of different lengths ) self . _positions . append ( pos ) self . _quats . append ( quat ) self . _lin_vels . append ( lin_vel ) self . _ang_vels . append ( ang_vel ) if dt is not None and len ( self . _times ) == 0 : self . _times . append ( 0.0 ) elif dt is not None : self . _times . append ( self . _times [ -1 ] + dt ) def clear_log ( self ) -> None : \"\"\"Clears the log of all trajectory data\"\"\" self . _positions = [] self . _quats = [] self . _lin_vels = [] self . _ang_vels = [] self . _times = []","title":"TrajectoryLogger"},{"location":"reference/pyastrobee/trajectories/trajectory/#ancestors-in-mro","text":"pyastrobee.trajectories.trajectory.Trajectory","title":"Ancestors (in MRO)"},{"location":"reference/pyastrobee/trajectories/trajectory/#instance-variables_1","text":"angular_accels angular_velocities contains_orn_only Whether the trajectory contains only orientation info contains_pos_and_orn Whether the trajectory contains both position and orientation info contains_pos_only Whether the trajectory contains only position info duration is_empty Whether the trajectory contains no position/orientation info linear_accels linear_velocities num_timesteps poses Pose array (position + xyzw quaternion), shape (n, 7) positions quaternions times timestep tmats Poses expressed as transformation matrices, shape (n, 4, 4)","title":"Instance variables"},{"location":"reference/pyastrobee/trajectories/trajectory/#methods_2","text":"","title":"Methods"},{"location":"reference/pyastrobee/trajectories/trajectory/#clear_log","text":"def clear_log ( self ) -> None Clears the log of all trajectory data View Source def clear_log ( self ) -> None : \"\"\"Clears the log of all trajectory data\"\"\" self . _positions = [] self . _quats = [] self . _lin_vels = [] self . _ang_vels = [] self . _times = []","title":"clear_log"},{"location":"reference/pyastrobee/trajectories/trajectory/#get_segment_2","text":"def get_segment ( self , start_index : int , end_index : int , reset_time : bool = True ) -> 'Trajectory' Construct a trajectory segment from a larger trajectory Parameters: Name Type Description Default start_index int Starting index of the larger trajectory to extract the segment None end_index int Ending index of the larger trajectory to extract the segment None reset_time bool Whether to maintain the time association with the original trajectory, or reset the start time back to 0. Defaults to True (reset start time back to 0) None Returns: Type Description Trajectory A new trajectory representing a segment of the original trajectory View Source def get_segment ( self , start_index : int , end_ index : int , reset_time : bool = True ) -> \"Trajectory\" : \"\"\"Construct a trajectory segment from a larger trajectory Args: start_index (int): Starting index of the larger trajectory to extract the segment end_index (int): Ending index of the larger trajectory to extract the segment reset_time (bool): Whether to maintain the time association with the original trajectory, or reset the start time back to 0. Defaults to True (reset start time back to 0) Returns: Trajectory: A new trajectory representing a segment of the original trajectory \"\"\" # TODO : add check for invalid slicing indices ? Or just leave it up to numpy # Time needs to get handled differently because the trajectory may or may not have time info if np . size ( self . times ) == 0 : # No time info new_times = None else : new_times = self . times [ start_index : end_ index ] if reset_time : new_times -= new_times [ 0 ] return Trajectory ( self . positions [ start_index : end_ index ], self . quaternions [ start_index : end_ index ], self . linear_velocities [ start_index : end_ index ], self . angular_velocities [ start_index : end_ index ], self . linear_accels [ start_index : end_ index ], self . angular_accels [ start_index : end_ index ], new_times , )","title":"get_segment"},{"location":"reference/pyastrobee/trajectories/trajectory/#get_segment_between_times_1","text":"def get_segment_between_times ( self , start_time , end_time , reset_time : bool = True ) View Source def get_segment_between_times(self, start_time, end_time, reset_time: bool = True): # start_index = np.searchsorted(self.times, start_time) # end_index = np.searchsorted(self.times, end_time) raise NotImplementedError(\"TODO\")","title":"get_segment_between_times"},{"location":"reference/pyastrobee/trajectories/trajectory/#log_state","text":"def log_state ( self , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], quat : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], lin_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , ang_vel : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , dt : Optional [ float ] = None ) Record the robot state at a given timestep If velocity information is not available (for instance, with a softbody), we can log just the position + orientation information Parameters: Name Type Description Default pos npt.ArrayLike Current position, shape (3,) None quat npt.ArrayLike Current orientation (XYZW quaternion), shape (4,) None lin_vel Optional[npt.ArrayLike] Current linear velocity, shape (3,). Defaults to None. None ang_vel Optional[npt.ArrayLike] Current angular velocity, shape (3,). Defaults to None. None dt Optional[float] Time elapsed since the previous step. Defaults to None. None View Source def log_state ( self , pos : npt . ArrayLike , quat : npt . ArrayLike , lin_vel : Optional [ npt.ArrayLike ] = None , ang_vel : Optional [ npt.ArrayLike ] = None , dt : Optional [ float ] = None , ) : \"\"\"Record the robot state at a given timestep If velocity information is not available (for instance, with a softbody), we can log just the position + orientation information Args: pos (npt.ArrayLike): Current position, shape (3,) quat (npt.ArrayLike): Current orientation (XYZW quaternion), shape (4,) lin_vel (Optional[npt.ArrayLike]): Current linear velocity, shape (3,). Defaults to None. ang_vel (Optional[npt.ArrayLike]): Current angular velocity, shape (3,). Defaults to None. dt (Optional[float]): Time elapsed since the previous step. Defaults to None. \"\"\" # TODO refine this functionality # Can log position / orientation info without velocity if needed # These values can be None because matplotlib will just not plot them # Most importantly , we want to make sure that things correspond in time # ( There shouldn ' t be an instance where we have histories of different lengths ) self . _positions . append ( pos ) self . _quats . append ( quat ) self . _lin_vels . append ( lin_vel ) self . _ang_vels . append ( ang_vel ) if dt is not None and len ( self . _times ) == 0 : self . _times . append ( 0.0 ) elif dt is not None : self . _times . append ( self . _times [ -1 ] + dt )","title":"log_state"},{"location":"reference/pyastrobee/trajectories/trajectory/#plot_2","text":"def plot ( self , show : bool = True ) -> matplotlib . figure . Figure Plot the trajectory components over time Parameters: Name Type Description Default show bool Whether or not to display the plot. Defaults to True. True Returns: Type Description Figure Matplotlib figure containing the plots View Source def plot ( self , show : bool = True ) -> Figure : \"\"\"Plot the trajectory components over time Args: show (bool, optional): Whether or not to display the plot. Defaults to True. Returns: Figure: Matplotlib figure containing the plots \"\"\" return plot_traj ( self , show = show )","title":"plot"},{"location":"reference/pyastrobee/trajectories/trajectory/#visualize_1","text":"def visualize ( self , n : Optional [ int ] = None , size : float = 0.5 , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> list [ int ] View the trajectory in Pybullet Parameters: Name Type Description Default n Optional[int] Number of frames to plot, if plotting all of the frames is not desired. Defaults to None (plot all frames) None size float Length of the lines to plot for each frame. Defaults to 0.5 (this gives a good scale with respect to the dimensions of the Astrobee) 0 client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Returns: Type Description list[int] Pybullet IDs for the lines drawn onto the GUI View Source def visualize ( self , n : Optional [ int ] = None , size : float = 0.5 , client : Optional [ BulletClient ] = None , ) -> list [ int ] : \"\"\"View the trajectory in Pybullet Args: n (Optional[int]): Number of frames to plot, if plotting all of the frames is not desired. Defaults to None (plot all frames) size (float, optional): Length of the lines to plot for each frame. Defaults to 0.5 (this gives a good scale with respect to the dimensions of the Astrobee) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: list[int]: Pybullet IDs for the lines drawn onto the GUI \"\"\" client : pybullet = pybullet if client is None else client connection_status = client . isConnected () # Bring up the Pybullet GUI if needed if not connection_status : client . connect ( pybullet . GUI ) if self . contains_pos_and_orn : ids = visualize_traj ( self , n , size , client = client ) elif self . contains_pos_only : print ( \"Trajectory only contains position info. Showing path instead\" ) ids = visualize_path ( self . positions , n , client = client ) elif self . contains_orn_only : raise NotImplementedError ( \"Visualizing a sequence of purely orientations is not implemented yet\" ) else : # Empty trajectory raise ValueError ( \"No trajectory information to visualize\" ) # Disconnect Pybullet if we originally weren ' t connected if not connection_status : input ( \"Press Enter to disconnect Pybullet\" ) client . disconnect () return ids","title":"visualize"},{"location":"reference/pyastrobee/trajectories/variable_time_curves/","text":"Module pyastrobee.trajectories.variable_time_curves Generating trajectories with a free final time We optimize using the following cost function: (integral of jerk l2 norm) + (time weight parameter) * (total duration) The weighting on the time component of this cost can be adjusted based on what component matters more. In general, a value of 1e-4 appears to put the two components of the cost (jerk and time) on the same order of magnitude Notes on the search method for the duration: - We know that the jerk function is a quadratic, and if we add an affine factor based on the total duration of the trajectory, it will still be a quadratic. So, a version of quadratic fit search will work well here - Depending on the weighting of this affine time component, the cost may look very linear. Even if this is the case, the search method as implemented will work well, because we will continually approach the boundary of feasibility until we stop within some tolerance - Speaking of this feasibility boundary, this is the main difference between the implemented method and standard quadratic fit search. There is some T such that the trajectory is no longer feasible, given the constraints on velocity/accel/BCs..., and so in general, we want to solve for a T which is small, yet feasible. So, this search method incorporates this knowledge of this infeasible region for small time intervals. - Ideally, we'd just be able to plug this into CVXPY (since it should just be a quadratic program with some constraints anyways). However, I tried a bunch of formulations of the constraints and it didn't seem to be convex or DCP (often leading to either quadratic forms of two variables, or equality constraints on convex functions). Maybe there is a better formulation out there... View Source \"\"\"Generating trajectories with a free final time We optimize using the following cost function: (integral of jerk l2 norm) + (time weight parameter) * (total duration) The weighting on the time component of this cost can be adjusted based on what component matters more. In general, a value of 1e-4 appears to put the two components of the cost (jerk and time) on the same order of magnitude Notes on the search method for the duration: - We know that the jerk function is a quadratic, and if we add an affine factor based on the total duration of the trajectory, it will still be a quadratic. So, a version of quadratic fit search will work well here - Depending on the weighting of this affine time component, the cost may look very linear. Even if this is the case, the search method as implemented will work well, because we will continually approach the boundary of feasibility until we stop within some tolerance - Speaking of this feasibility boundary, this is the main difference between the implemented method and standard quadratic fit search. There is some T such that the trajectory is no longer feasible, given the constraints on velocity/accel/BCs..., and so in general, we want to solve for a T which is small, yet feasible. So, this search method incorporates this knowledge of this infeasible region for small time intervals. - Ideally, we'd just be able to plug this into CVXPY (since it should just be a quadratic program with some constraints anyways). However, I tried a bunch of formulations of the constraints and it didn't seem to be convex or DCP (often leading to either quadratic forms of two variables, or equality constraints on convex functions). Maybe there is a better formulation out there... \"\"\" from typing import Optional , Callable , Any import numpy as np import numpy . typing as npt import pybullet import matplotlib . pyplot as plt from pyastrobee . trajectories . trajectory import plot_traj_constraints from pyastrobee . trajectories . bezier import BezierCurve , bezier_trajectory from pyastrobee . trajectories . splines import ( CompositeBezierCurve , spline_trajectory_with_retiming , ) from pyastrobee . trajectories . curve_utils import traj_from_curve from pyastrobee . utils . boxes import Box from pyastrobee . utils . debug_visualizer import animate_path from pyastrobee . config . astrobee_motion import LINEAR_SPEED_LIMIT , LINEAR_ACCEL_LIMIT from pyastrobee . utils . errors import OptimizationError def left_quadratic_fit_search ( f : Callable [ [float ] , float | tuple [ float, Any ] ] , x_init : float , dx_tol : float , max_iters : int , ) -> tuple [ float, float, list[Any ] ]: \"\"\"A modified version of quadratic fit search that assumes we have an infeasible region for small x (x >= 0) See Algorithms for Optimization (Kochenderfer), Algorithm 3.4 for quadratic fit search Args: f (Callable[[float], float | tuple[float, Any]]): Univariate function to optimize, callable as f(x). The return must have the cost of the evaluation as the first output. Any additional outputs will be stored and the best will be returned at the end of the search x_init (float): Initial location to start the search dx_tol (float): Stopping tolerance on evaluation points: Terminate if the percent change between consecutive evaluation points is less than this tolerance max_iters (int): Maximum iterations of the algorithm (if the stopping tolerance is not achieved) Raises: OptimizationError: If no feasible solution is found in max_iters iterations Returns: tuple[float, float, list[Any]]: float: Best evaluation point x float: Cost of the function evaluation at the best x value list[Any]: Additional outputs of the function being optimized at the best x value. Empty list if there are no additional outputs \"\"\" # Mutable dicts to keep track of the optimization process best = { \"x\" : None , \"cost\" : np . inf , \"out\" : []} # init log = { \"iters\" : 0 , \"feasibility_bound\" : 0 } # init # Create wrapper around the function to handle if it has multiple outputs # Return will solely be the cost of the evaluation , but we store the other outputs # in the dictionaries as needed def _f ( x : float ) -> float : fx = f ( x ) log [ \"iters\" ] += 1 if isinstance ( fx , tuple ) : cost , * out = fx # Out will by default be packed into a list else : cost = fx out = [] # Check to see if this is the best so far - if so , update if cost <= best [ \"cost\" ] and cost != np . inf : best [ \"x\" ] = x best [ \"cost\" ] = cost best [ \"out\" ] = out return cost # Find the quadratic fit search interval ( a , b , c ) given an initial search location # This assumes that x is a positive value and that the only infeasible values occurs # when x is too small def _find_init_interval_from_guess ( x : float ) : b = x yb = _f ( b ) if yb == np . inf : while yb == np . inf and log [ \"iters\" ] <= max_iters - 1 : log [ \"feasibility_bound\" ] = max ( b , log [ \"feasibility_bound\" ] ) b *= 2 yb = _f ( b ) a = ( log [ \"feasibility_bound\" ] + b ) / 2 ya = _f ( a ) if ya == np . inf : while ya == np . inf and log [ \"iters\" ] <= max_iters - 1 : log [ \"feasibility_bound\" ] = max ( a , log [ \"feasibility_bound\" ] ) a = ( a + b ) / 2 ya = _f ( a ) # we know c will be valid c = b + ( b - a ) yc = _f ( c ) return a , b , c , ya , yb , yc a , b , c , ya , yb , yc = _find_init_interval_from_guess ( x_init ) x_prev = None # init while log [ \"iters\" ] <= max_iters - 1 : # Quadratic fit for the next search location x = ( 0.5 * ( ya * ( b ** 2 - c ** 2 ) + yb * ( c ** 2 - a ** 2 ) + yc * ( a ** 2 - b ** 2 )) / ( ya * ( b - c ) + yb * ( c - a ) + yc * ( a - b )) ) # Handle if the fit location is known to be infeasible if x <= log [ \"feasibility_bound\" ] : x = ( log [ \"feasibility_bound\" ] + a ) / 2 yx = _f ( x ) if yx == np . inf : # Infeasible log [ \"feasibility_bound\" ] = max ( log [ \"feasibility_bound\" ] , x ) else : # Standard quadratic fit update , with extra cases when x is not between a and c if x < a : if yx < ya : a , ya = x , yx elif a <= x <= c : if x > b : if yx > yb : c , yc = x , yx else : a , ya , b , yb = b , yb , x , yx elif x < b : if yx > yb : a , ya = x , yx else : c , yc , b , yb = b , yb , x , yx else : # x > c if yx < yc : c , yc = x , yx # Termination criteria : if our evaluation point update has shrunk to within some tolerance if x_prev is not None and abs (( x - x_prev ) / x_prev ) < dx_tol : break x_prev = x if best [ \"x\" ] is None : raise OptimizationError ( \"Unable to find a feasible solution\" ) return best [ \"x\" ] , best [ \"cost\" ] , best [ \"out\" ] def free_final_time_bezier ( p0 : npt . ArrayLike , pf : npt . ArrayLike , t0 : float , tf_init : float , n_control_pts : int , v0 : Optional [ npt.ArrayLike ] = None , vf : Optional [ npt.ArrayLike ] = None , a0 : Optional [ npt.ArrayLike ] = None , af : Optional [ npt.ArrayLike ] = None , box : Optional [ Box ] = None , v_max : Optional [ float ] = None , a_max : Optional [ float ] = None , time_weight : float = 1e-4 , timing_rtol : float = 0.01 , max_iters : int = 15 , debug : bool = False , ) -> BezierCurve : \"\"\"Optimize a Bezier curve trajectory to balance minimizing jerk with minimizing the total duration Args: p0 (npt.ArrayLike): Initial position, shape (3,) pf (npt.ArrayLike): Final position, shape (3,) t0 (float): Starting time tf_init (float): Initial estimate of the final time n_control_pts (int): Number of control points for the Bezier curve. Must be >= to the number of constraints, and should not be too large (>15ish) as this can reduce optimization performance. 6-10 is usually good v0 (Optional[npt.ArrayLike]): Initial velocity, shape (3,). Defaults to None (unconstrained) vf (Optional[npt.ArrayLike]): Final velocity, shape (3,). Defaults to None (unconstrained) a0 (Optional[npt.ArrayLike]): Initial acceleration, shape (3,). Defaults to None (unconstrained) af (Optional[npt.ArrayLike]): Final acceleration, shape (3,). Defaults to None (unconstrained) box (Optional[Box]): Box constraint on (lower, upper) position bounds. Defaults to None (unconstrained) v_max (Optional[float]): Maximum L2 norm of the velocity. Defaults to None (unconstrained) a_max (Optional[float]): Maximum L2 norm of the acceleration. Defaults to None (unconstrained) time_weight (float, optional): Objective function weight corresponding to a linear penalty on the duration. Defaults to 1e-4. (this was observed to give duration roughly the same weighting as jerk) timing_rtol (float, optional): Tolerance on the free-final-time optimization. Defaults to 0.01 (within 1% of the optimal time) max_iters (int, optional): Maximum number of iterations for the free-final-time optimization. Defaults to 15. debug (bool, optional): Whether to print/plot details on the free-final-time optimization. Defaults to False. Returns: BezierCurve: The optimal curve \"\"\" curve_kwargs = dict ( p0 = p0 , pf = pf , t0 = t0 , tf = tf_init , n_control_pts = n_control_pts , v0 = v0 , vf = vf , a0 = a0 , af = af , box = box , v_max = v_max , a_max = a_max , time_weight = time_weight , ) if debug : # Keep track of the costs per time to plot afterwards costs_log : dict [ float, float ] = {} # Wrapper around the bezier trajectory function so that we can pop this into our quadratic fit search # method with the expected inputs / outputs , and handle when we can 't solve for the curve # e.g. time as the input, and output the cost and the solved curve def _curve_wrapper(t: float) -> tuple[float, BezierCurve]: kwargs = curve_kwargs | {\"tf\": t} print(\"Evaluating time: \", t) try: curve, cost = bezier_trajectory(**kwargs) except OptimizationError: curve, cost = None, np.inf if debug: # Print info on the breakdown of the cost between jerk and time print( \"Cost: \", cost, \" Jerk: \", cost - time_weight * t, \" Time: \", time_weight * t, ) costs_log[t] = cost # The quadratic search assumes that cost is the first output return cost, curve t, cost, output = left_quadratic_fit_search( _curve_wrapper, tf_init, timing_rtol, max_iters ) best_curve = output[0] if debug: print(\"Optimal time: \", t, \" yields cost: \", cost) _plot_optimization_data(costs_log) return best_curve def free_final_time_spline( p0: npt.ArrayLike, pf: npt.ArrayLike, t0: float, tf_init: float, pts_per_curve: int, boxes: list[Box], initial_durations: npt.ArrayLike, v0: Optional[npt.ArrayLike] = None, vf: Optional[npt.ArrayLike] = None, a0: Optional[npt.ArrayLike] = None, af: Optional[npt.ArrayLike] = None, v_max: Optional[float] = None, a_max: Optional[float] = None, kappa_min: float = 1e-2, omega: float = 3, max_retiming_iters: int = 10, time_weight: float = 1e-4, timing_rtol: float = 0.01, max_iters: int = 15, debug: bool = False, ) -> CompositeBezierCurve: \"\"\"Optimize a spline trajectory to balance minimizing jerk with minimizing the total duration Args: p0 (npt.ArrayLike): Initial position, shape (3,) pf (npt.ArrayLike): Final position, shape (3,) t0 (float): Starting time tf_init (float): Initial estimate of the final time pts_per_curve (int): Number of control points per Bezier curve. Generally, should be around 6-10 boxes (list[Box]): Sequential list of safe box regions pass through initial_durations (npt.ArrayLike): Initial estimate of the durations for each segment of the trajectory. These will be refined during the retiming process. Shape (num_boxes,) v0 (Optional[npt.ArrayLike]): Initial velocity, shape (3,). Defaults to None (unconstrained) vf (Optional[npt.ArrayLike]): Final velocity, shape (3,). Defaults to None (unconstrained) a0 (Optional[npt.ArrayLike]): Initial acceleration, shape (3,). Defaults to None (unconstrained) af (Optional[npt.ArrayLike]): Final acceleration, shape (3,). Defaults to None (unconstrained) v_max (Optional[float]): Maximum L2 norm of the velocity. Defaults to None (unconstrained) a_max (Optional[float]): Maximum L2 norm of the acceleration. Defaults to None (unconstrained) kappa_min (float, optional): Retiming trust region parameter: Defines the maximum change in adjacent scaling factors. Defaults to 1e-2. omega (float, optional): Retiming parameter: Defines the rate at which kappa decays after each iteration. Must be > 1. Small values (~2) work well when transition time estimates are poor, but larger values (~5) are more effective otherwise. Defaults to 3. max_retiming_iters (int, optional): Maximum number of iterations for the retiming process. Defaults to 10. time_weight (float, optional): Objective function weight corresponding to a linear penalty on the duration. Defaults to 1e-4 (this was observed to give duration roughly the same weighting as jerk) timing_rtol (float, optional): Tolerance on the free-final-time optimization. Defaults to 0.01 (within 1% of the optimal time) max_iters (int, optional): Maximum number of iterations for the free-final-time optimization. Defaults to 15. debug (bool, optional): Whether to print/plot details on the free-final-time optimization. Defaults to False. Returns: CompositeBezierCurve: The optimal curve \"\"\" curve_kwargs = dict( p0=p0, pf=pf, t0=t0, tf=tf_init, pts_per_curve=pts_per_curve, boxes=boxes, initial_durations=initial_durations, v0=v0, vf=vf, a0=a0, af=af, v_max=v_max, a_max=a_max, kappa_min=kappa_min, omega=omega, max_retiming_iters=max_retiming_iters, time_weight=time_weight, ) # As we vary the final time, we need to make sure that the durations per box # also get updated. So, use the fractional durations and rescale based on the total time duration_fractions = initial_durations / (tf_init - t0) if debug: # Keep track of the costs per time to plot afterwards costs_log: dict[float, float] = {} # Wrapper around the spline trajectory function so that we can pop this into our quadratic fit search # method with the expected inputs/outputs, and handle when we can' t solve for the curve # e . g . time as the input , and output the cost and the solved curve def _curve_wrapper ( t : float ) -> tuple [ float, CompositeBezierCurve ] : nonlocal duration_fractions kwargs = curve_kwargs | { \"tf\" : t , \"initial_durations\" : t * duration_fractions , } print ( \"Evaluating duration: \" , t ) try : curve , cost = spline_trajectory_with_retiming ( ** kwargs ) # Update our understanding of the best curve durations based on the retiming process duration_fractions = curve . segment_durations / curve . duration except OptimizationError : curve , cost = None , np . inf if debug : # Print info on the breakdown of the cost between jerk and time print ( \"Cost: \" , cost , \" Jerk: \" , cost - time_weight * t , \" Time: \" , time_weight * t , ) costs_log [ t ] = cost # The quadratic search assumes that cost is the first output return cost , curve t , cost , output = left_quadratic_fit_search ( _curve_wrapper , tf_init , timing_rtol , max_iters ) best_curve = output [ 0 ] if debug : print ( \"Optimal time: \" , t , \" yields cost: \" , cost ) _plot_optimization_data ( costs_log ) return best_curve def _plot_optimization_data ( cost_log : dict [ float, float ] , show : bool = True ) : \"\"\"Helper function to plot the time optimization results when debugging Args: cost_log (dict[float, float]): Costs for each duration. Keys: times, Values: costs show (bool, optional): Whether or not to show the plot. Defaults to True. \"\"\" fig = plt . figure () times , costs = zip ( * cost_log . items ()) plt . subplot ( 1 , 2 , 1 ) plt . scatter ( times , costs ) sort_idxs = np . argsort ( times ) times_sorted = np . array ( times ) [ sort_idxs ] costs_sorted = np . array ( costs ) [ sort_idxs ] plt . plot ( times_sorted , costs_sorted , \"--\" ) plt . xlabel ( \"Time\" ) plt . ylabel ( \"Cost\" ) plt . title ( \"Cost vs duration\" ) plt . subplot ( 1 , 2 , 2 ) plt . plot ( range ( len ( costs )), costs ) plt . scatter ( range ( len ( costs )), costs ) plt . xlabel ( \"Iteration\" ) plt . ylabel ( \"Cost\" ) plt . title ( \"Convergence\" ) if show : plt . show () def _bezier_main () : p0 = ( 0 , 0 , 0 ) pf = ( 1 , 2 , 3 ) t0 = 0 tf_init = 30 n_control_pts = 30 dt = 0.1 v0 = ( 0.3 , 0.2 , 0.1 ) vf = ( 0 , 0 , 0 ) a0 = ( 0 , 0 , 0 ) af = ( 0 , 0 , 0 ) print ( \"Speed limit: \" , LINEAR_SPEED_LIMIT ) print ( \"Accel limit: \" , LINEAR_ACCEL_LIMIT ) curve = free_final_time_bezier ( p0 , pf , t0 , tf_init , n_control_pts , v0 , vf , a0 , af , None , LINEAR_SPEED_LIMIT , LINEAR_ACCEL_LIMIT , debug = True , ) traj = traj_from_curve ( curve , dt ) traj . plot () plot_traj_constraints ( traj , None , LINEAR_SPEED_LIMIT , LINEAR_ACCEL_LIMIT , None , None ) pybullet . connect ( pybullet . GUI ) traj . visualize ( 30 ) animate_path ( traj . positions , 5 ) input ( \"Animation complete, press Enter to finish\" ) def _spline_main () : p0 = [ 0.1, 0.2, 0.3 ] pf = [ 1.5, 5, 1.7 ] t0 = 0 tf_init = 30 pts_per_curve = 20 # 8 v0 = np . zeros ( 3 ) vf = np . zeros ( 3 ) a0 = np . zeros ( 3 ) af = np . zeros ( 3 ) dt = 0.1 boxes = [ Box((0, 0, 0), (1, 1, 1)), Box((0.5, 0.5, 0.5), (1.5, 5, 1.5)), Box((1, 4.5, 1), (2, 5.5, 2)), ] n_curves = len ( boxes ) durations = np . ones ( n_curves ) * ( tf_init - t0 ) / n_curves curve = free_final_time_spline ( p0 , pf , t0 , tf_init , pts_per_curve , boxes , durations , v0 , vf , a0 , af , LINEAR_SPEED_LIMIT , LINEAR_ACCEL_LIMIT , debug = True , ) traj = traj_from_curve ( curve , dt ) traj . plot () plot_traj_constraints ( traj , None , LINEAR_SPEED_LIMIT , LINEAR_ACCEL_LIMIT , None , None ) pybullet . connect ( pybullet . GUI ) traj . visualize ( 30 ) animate_path ( traj . positions , 5 ) input ( \"Animation complete, press Enter to finish\" ) if __name__ == \"__main__\" : # _bezier_main () _spline_main () Variables LINEAR_ACCEL_LIMIT LINEAR_SPEED_LIMIT Functions free_final_time_bezier def free_final_time_bezier ( p0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], t0 : float , tf_init : float , n_control_pts : int , v0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , vf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , a0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , af : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , box : Optional [ pyastrobee . utils . boxes . Box ] = None , v_max : Optional [ float ] = None , a_max : Optional [ float ] = None , time_weight : float = 0.0001 , timing_rtol : float = 0.01 , max_iters : int = 15 , debug : bool = False ) -> pyastrobee . trajectories . bezier . BezierCurve Optimize a Bezier curve trajectory to balance minimizing jerk with minimizing the total duration Parameters: Name Type Description Default p0 npt.ArrayLike Initial position, shape (3,) None pf npt.ArrayLike Final position, shape (3,) None t0 float Starting time None tf_init float Initial estimate of the final time None n_control_pts int Number of control points for the Bezier curve. Must be >= to the number of constraints, and should not be too large (>15ish) as this can reduce optimization performance. 6-10 is usually good None v0 Optional[npt.ArrayLike] Initial velocity, shape (3,). Defaults to None (unconstrained) None vf Optional[npt.ArrayLike] Final velocity, shape (3,). Defaults to None (unconstrained) None a0 Optional[npt.ArrayLike] Initial acceleration, shape (3,). Defaults to None (unconstrained) None af Optional[npt.ArrayLike] Final acceleration, shape (3,). Defaults to None (unconstrained) None box Optional[Box] Box constraint on (lower, upper) position bounds. Defaults to None (unconstrained) None v_max Optional[float] Maximum L2 norm of the velocity. Defaults to None (unconstrained) None a_max Optional[float] Maximum L2 norm of the acceleration. Defaults to None (unconstrained) None time_weight float Objective function weight corresponding to a linear penalty on the duration. Defaults to 1e-4. (this was observed to give duration roughly the same weighting as jerk) None timing_rtol float Tolerance on the free-final-time optimization. Defaults to 0.01 (within 1% of the optimal time) 0 max_iters int Maximum number of iterations for the free-final-time optimization. Defaults to 15. 15 debug bool Whether to print/plot details on the free-final-time optimization. Defaults to False. False Returns: Type Description BezierCurve The optimal curve View Source def free_final_time_bezier ( p0 : npt . ArrayLike , pf : npt . ArrayLike , t0 : float , tf_init : float , n_control_pts : int , v0 : Optional [ npt.ArrayLike ] = None , vf : Optional [ npt.ArrayLike ] = None , a0 : Optional [ npt.ArrayLike ] = None , af : Optional [ npt.ArrayLike ] = None , box : Optional [ Box ] = None , v_max : Optional [ float ] = None , a_max : Optional [ float ] = None , time_weight : float = 1e-4 , timing_rtol : float = 0.01 , max_iters : int = 15 , debug : bool = False , ) -> BezierCurve : \"\"\"Optimize a Bezier curve trajectory to balance minimizing jerk with minimizing the total duration Args: p0 (npt.ArrayLike): Initial position, shape (3,) pf (npt.ArrayLike): Final position, shape (3,) t0 (float): Starting time tf_init (float): Initial estimate of the final time n_control_pts (int): Number of control points for the Bezier curve. Must be >= to the number of constraints, and should not be too large (>15ish) as this can reduce optimization performance. 6-10 is usually good v0 (Optional[npt.ArrayLike]): Initial velocity, shape (3,). Defaults to None (unconstrained) vf (Optional[npt.ArrayLike]): Final velocity, shape (3,). Defaults to None (unconstrained) a0 (Optional[npt.ArrayLike]): Initial acceleration, shape (3,). Defaults to None (unconstrained) af (Optional[npt.ArrayLike]): Final acceleration, shape (3,). Defaults to None (unconstrained) box (Optional[Box]): Box constraint on (lower, upper) position bounds. Defaults to None (unconstrained) v_max (Optional[float]): Maximum L2 norm of the velocity. Defaults to None (unconstrained) a_max (Optional[float]): Maximum L2 norm of the acceleration. Defaults to None (unconstrained) time_weight (float, optional): Objective function weight corresponding to a linear penalty on the duration. Defaults to 1e-4. (this was observed to give duration roughly the same weighting as jerk) timing_rtol (float, optional): Tolerance on the free-final-time optimization. Defaults to 0.01 (within 1% of the optimal time) max_iters (int, optional): Maximum number of iterations for the free-final-time optimization. Defaults to 15. debug (bool, optional): Whether to print/plot details on the free-final-time optimization. Defaults to False. Returns: BezierCurve: The optimal curve \"\"\" curve_kwargs = dict ( p0 = p0 , pf = pf , t0 = t0 , tf = tf_init , n_control_pts = n_control_pts , v0 = v0 , vf = vf , a0 = a0 , af = af , box = box , v_max = v_max , a_max = a_max , time_weight = time_weight , ) if debug : # Keep track of the costs per time to plot afterwards costs_log : dict [ float, float ] = {} # Wrapper around the bezier trajectory function so that we can pop this into our quadratic fit search # method with the expected inputs / outputs , and handle when we can ' t solve for the curve # e . g . time as the input , and output the cost and the solved curve def _curve_wrapper ( t : float ) -> tuple [ float, BezierCurve ] : kwargs = curve_kwargs | { \"tf\" : t } print ( \"Evaluating time: \" , t ) try : curve , cost = bezier_trajectory ( ** kwargs ) except OptimizationError : curve , cost = None , np . inf if debug : # Print info on the breakdown of the cost between jerk and time print ( \"Cost: \" , cost , \" Jerk: \" , cost - time_weight * t , \" Time: \" , time_weight * t , ) costs_log [ t ] = cost # The quadratic search assumes that cost is the first output return cost , curve t , cost , output = left_quadratic_fit_search ( _curve_wrapper , tf_init , timing_rtol , max_iters ) best_curve = output [ 0 ] if debug : print ( \"Optimal time: \" , t , \" yields cost: \" , cost ) _plot_optimization_data ( costs_log ) return best_curve free_final_time_spline def free_final_time_spline ( p0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], t0 : float , tf_init : float , pts_per_curve : int , boxes : list [ pyastrobee . utils . boxes . Box ], initial_durations : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], v0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , vf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , a0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , af : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , v_max : Optional [ float ] = None , a_max : Optional [ float ] = None , kappa_min : float = 0.01 , omega : float = 3 , max_retiming_iters : int = 10 , time_weight : float = 0.0001 , timing_rtol : float = 0.01 , max_iters : int = 15 , debug : bool = False ) -> pyastrobee . trajectories . splines . CompositeBezierCurve Optimize a spline trajectory to balance minimizing jerk with minimizing the total duration Parameters: Name Type Description Default p0 npt.ArrayLike Initial position, shape (3,) None pf npt.ArrayLike Final position, shape (3,) None t0 float Starting time None tf_init float Initial estimate of the final time None pts_per_curve int Number of control points per Bezier curve. Generally, should be around 6-10 None boxes list[Box] Sequential list of safe box regions pass through None initial_durations npt.ArrayLike Initial estimate of the durations for each segment of the trajectory. These will be refined during the retiming process. Shape (num_boxes,) None v0 Optional[npt.ArrayLike] Initial velocity, shape (3,). Defaults to None (unconstrained) None vf Optional[npt.ArrayLike] Final velocity, shape (3,). Defaults to None (unconstrained) None a0 Optional[npt.ArrayLike] Initial acceleration, shape (3,). Defaults to None (unconstrained) None af Optional[npt.ArrayLike] Final acceleration, shape (3,). Defaults to None (unconstrained) None v_max Optional[float] Maximum L2 norm of the velocity. Defaults to None (unconstrained) None a_max Optional[float] Maximum L2 norm of the acceleration. Defaults to None (unconstrained) None kappa_min float Retiming trust region parameter: Defines the maximum change in adjacent scaling factors. Defaults to 1e-2. None omega float Retiming parameter: Defines the rate at which kappa decays after each iteration. Must be > 1. Small values (~2) work well when transition time estimates are poor, but larger values (~5) are more effective otherwise. Defaults to 3. None max_retiming_iters int Maximum number of iterations for the retiming process. Defaults to 10. 10 time_weight float Objective function weight corresponding to a linear penalty on the duration. Defaults to 1e-4 (this was observed to give duration roughly the same weighting as jerk) None timing_rtol float Tolerance on the free-final-time optimization. Defaults to 0.01 (within 1% of the optimal time) 0 max_iters int Maximum number of iterations for the free-final-time optimization. Defaults to 15. 15 debug bool Whether to print/plot details on the free-final-time optimization. Defaults to False. False Returns: Type Description CompositeBezierCurve The optimal curve View Source def free_final_time_spline ( p0 : npt . ArrayLike , pf : npt . ArrayLike , t0 : float , tf_init : float , pts_per_curve : int , boxes : list [ Box ] , initial_durations : npt . ArrayLike , v0 : Optional [ npt.ArrayLike ] = None , vf : Optional [ npt.ArrayLike ] = None , a0 : Optional [ npt.ArrayLike ] = None , af : Optional [ npt.ArrayLike ] = None , v_max : Optional [ float ] = None , a_max : Optional [ float ] = None , kappa_min : float = 1e-2 , omega : float = 3 , max_retiming_iters : int = 10 , time_weight : float = 1e-4 , timing_rtol : float = 0.01 , max_iters : int = 15 , debug : bool = False , ) -> CompositeBezierCurve : \"\"\"Optimize a spline trajectory to balance minimizing jerk with minimizing the total duration Args: p0 (npt.ArrayLike): Initial position, shape (3,) pf (npt.ArrayLike): Final position, shape (3,) t0 (float): Starting time tf_init (float): Initial estimate of the final time pts_per_curve (int): Number of control points per Bezier curve. Generally, should be around 6-10 boxes (list[Box]): Sequential list of safe box regions pass through initial_durations (npt.ArrayLike): Initial estimate of the durations for each segment of the trajectory. These will be refined during the retiming process. Shape (num_boxes,) v0 (Optional[npt.ArrayLike]): Initial velocity, shape (3,). Defaults to None (unconstrained) vf (Optional[npt.ArrayLike]): Final velocity, shape (3,). Defaults to None (unconstrained) a0 (Optional[npt.ArrayLike]): Initial acceleration, shape (3,). Defaults to None (unconstrained) af (Optional[npt.ArrayLike]): Final acceleration, shape (3,). Defaults to None (unconstrained) v_max (Optional[float]): Maximum L2 norm of the velocity. Defaults to None (unconstrained) a_max (Optional[float]): Maximum L2 norm of the acceleration. Defaults to None (unconstrained) kappa_min (float, optional): Retiming trust region parameter: Defines the maximum change in adjacent scaling factors. Defaults to 1e-2. omega (float, optional): Retiming parameter: Defines the rate at which kappa decays after each iteration. Must be > 1. Small values (~2) work well when transition time estimates are poor, but larger values (~5) are more effective otherwise. Defaults to 3. max_retiming_iters (int, optional): Maximum number of iterations for the retiming process. Defaults to 10. time_weight (float, optional): Objective function weight corresponding to a linear penalty on the duration. Defaults to 1e-4 (this was observed to give duration roughly the same weighting as jerk) timing_rtol (float, optional): Tolerance on the free-final-time optimization. Defaults to 0.01 (within 1% of the optimal time) max_iters (int, optional): Maximum number of iterations for the free-final-time optimization. Defaults to 15. debug (bool, optional): Whether to print/plot details on the free-final-time optimization. Defaults to False. Returns: CompositeBezierCurve: The optimal curve \"\"\" curve_kwargs = dict ( p0 = p0 , pf = pf , t0 = t0 , tf = tf_init , pts_per_curve = pts_per_curve , boxes = boxes , initial_durations = initial_durations , v0 = v0 , vf = vf , a0 = a0 , af = af , v_max = v_max , a_max = a_max , kappa_min = kappa_min , omega = omega , max_retiming_iters = max_retiming_iters , time_weight = time_weight , ) # As we vary the final time , we need to make sure that the durations per box # also get updated . So , use the fractional durations and rescale based on the total time duration_fractions = initial_durations / ( tf_init - t0 ) if debug : # Keep track of the costs per time to plot afterwards costs_log : dict [ float, float ] = {} # Wrapper around the spline trajectory function so that we can pop this into our quadratic fit search # method with the expected inputs / outputs , and handle when we can ' t solve for the curve # e . g . time as the input , and output the cost and the solved curve def _curve_wrapper ( t : float ) -> tuple [ float, CompositeBezierCurve ] : nonlocal duration_fractions kwargs = curve_kwargs | { \"tf\" : t , \"initial_durations\" : t * duration_fractions , } print ( \"Evaluating duration: \" , t ) try : curve , cost = spline_trajectory_with_retiming ( ** kwargs ) # Update our understanding of the best curve durations based on the retiming process duration_fractions = curve . segment_durations / curve . duration except OptimizationError : curve , cost = None , np . inf if debug : # Print info on the breakdown of the cost between jerk and time print ( \"Cost: \" , cost , \" Jerk: \" , cost - time_weight * t , \" Time: \" , time_weight * t , ) costs_log [ t ] = cost # The quadratic search assumes that cost is the first output return cost , curve t , cost , output = left_quadratic_fit_search ( _curve_wrapper , tf_init , timing_rtol , max_iters ) best_curve = output [ 0 ] if debug : print ( \"Optimal time: \" , t , \" yields cost: \" , cost ) _plot_optimization_data ( costs_log ) return best_curve left_quadratic_fit_search def left_quadratic_fit_search ( f : Callable [[ float ], float | tuple [ float , Any ]], x_init : float , dx_tol : float , max_iters : int ) -> tuple [ float , float , list [ typing . Any ]] A modified version of quadratic fit search that assumes we have an infeasible region for small x (x >= 0) See Algorithms for Optimization (Kochenderfer), Algorithm 3.4 for quadratic fit search Parameters: Name Type Description Default f Callable[[float], float tuple[float, Any]] Univariate function to optimize, callable as f(x). The return must have the cost of the evaluation as the first output. Any additional outputs will be stored and the best will be returned at the end of the search x_init float Initial location to start the search None dx_tol float Stopping tolerance on evaluation points: Terminate if the percent change between consecutive evaluation points is less than this tolerance None max_iters int Maximum iterations of the algorithm (if the stopping tolerance is not achieved) None Returns: Type Description tuple[float, float, list[Any]] float: Best evaluation point x float: Cost of the function evaluation at the best x value list[Any]: Additional outputs of the function being optimized at the best x value. Empty list if there are no additional outputs Raises: Type Description OptimizationError If no feasible solution is found in max_iters iterations View Source def left_quadratic_fit_search ( f : Callable [ [float ] , float | tuple [ float, Any ] ] , x_init : float , dx_tol : float , max_iters : int , ) -> tuple [ float, float, list[Any ] ]: \"\"\"A modified version of quadratic fit search that assumes we have an infeasible region for small x (x >= 0) See Algorithms for Optimization (Kochenderfer), Algorithm 3.4 for quadratic fit search Args: f (Callable[[float], float | tuple[float, Any]]): Univariate function to optimize, callable as f(x). The return must have the cost of the evaluation as the first output. Any additional outputs will be stored and the best will be returned at the end of the search x_init (float): Initial location to start the search dx_tol (float): Stopping tolerance on evaluation points: Terminate if the percent change between consecutive evaluation points is less than this tolerance max_iters (int): Maximum iterations of the algorithm (if the stopping tolerance is not achieved) Raises: OptimizationError: If no feasible solution is found in max_iters iterations Returns: tuple[float, float, list[Any]]: float: Best evaluation point x float: Cost of the function evaluation at the best x value list[Any]: Additional outputs of the function being optimized at the best x value. Empty list if there are no additional outputs \"\"\" # Mutable dicts to keep track of the optimization process best = { \"x\" : None , \"cost\" : np . inf , \"out\" : []} # init log = { \"iters\" : 0 , \"feasibility_bound\" : 0 } # init # Create wrapper around the function to handle if it has multiple outputs # Return will solely be the cost of the evaluation , but we store the other outputs # in the dictionaries as needed def _f ( x : float ) -> float : fx = f ( x ) log [ \"iters\" ] += 1 if isinstance ( fx , tuple ) : cost , * out = fx # Out will by default be packed into a list else : cost = fx out = [] # Check to see if this is the best so far - if so , update if cost <= best [ \"cost\" ] and cost != np . inf : best [ \"x\" ] = x best [ \"cost\" ] = cost best [ \"out\" ] = out return cost # Find the quadratic fit search interval ( a , b , c ) given an initial search location # This assumes that x is a positive value and that the only infeasible values occurs # when x is too small def _find_init_interval_from_guess ( x : float ) : b = x yb = _f ( b ) if yb == np . inf : while yb == np . inf and log [ \"iters\" ] <= max_iters - 1 : log [ \"feasibility_bound\" ] = max ( b , log [ \"feasibility_bound\" ] ) b *= 2 yb = _f ( b ) a = ( log [ \"feasibility_bound\" ] + b ) / 2 ya = _f ( a ) if ya == np . inf : while ya == np . inf and log [ \"iters\" ] <= max_iters - 1 : log [ \"feasibility_bound\" ] = max ( a , log [ \"feasibility_bound\" ] ) a = ( a + b ) / 2 ya = _f ( a ) # we know c will be valid c = b + ( b - a ) yc = _f ( c ) return a , b , c , ya , yb , yc a , b , c , ya , yb , yc = _find_init_interval_from_guess ( x_init ) x_prev = None # init while log [ \"iters\" ] <= max_iters - 1 : # Quadratic fit for the next search location x = ( 0.5 * ( ya * ( b ** 2 - c ** 2 ) + yb * ( c ** 2 - a ** 2 ) + yc * ( a ** 2 - b ** 2 )) / ( ya * ( b - c ) + yb * ( c - a ) + yc * ( a - b )) ) # Handle if the fit location is known to be infeasible if x <= log [ \"feasibility_bound\" ] : x = ( log [ \"feasibility_bound\" ] + a ) / 2 yx = _f ( x ) if yx == np . inf : # Infeasible log [ \"feasibility_bound\" ] = max ( log [ \"feasibility_bound\" ] , x ) else : # Standard quadratic fit update , with extra cases when x is not between a and c if x < a : if yx < ya : a , ya = x , yx elif a <= x <= c : if x > b : if yx > yb : c , yc = x , yx else : a , ya , b , yb = b , yb , x , yx elif x < b : if yx > yb : a , ya = x , yx else : c , yc , b , yb = b , yb , x , yx else : # x > c if yx < yc : c , yc = x , yx # Termination criteria : if our evaluation point update has shrunk to within some tolerance if x_prev is not None and abs (( x - x_prev ) / x_prev ) < dx_tol : break x_prev = x if best [ \"x\" ] is None : raise OptimizationError ( \"Unable to find a feasible solution\" ) return best [ \"x\" ] , best [ \"cost\" ] , best [ \"out\" ]","title":"Variable Time Curves"},{"location":"reference/pyastrobee/trajectories/variable_time_curves/#module-pyastrobeetrajectoriesvariable_time_curves","text":"Generating trajectories with a free final time We optimize using the following cost function: (integral of jerk l2 norm) + (time weight parameter) * (total duration) The weighting on the time component of this cost can be adjusted based on what component matters more. In general, a value of 1e-4 appears to put the two components of the cost (jerk and time) on the same order of magnitude Notes on the search method for the duration: - We know that the jerk function is a quadratic, and if we add an affine factor based on the total duration of the trajectory, it will still be a quadratic. So, a version of quadratic fit search will work well here - Depending on the weighting of this affine time component, the cost may look very linear. Even if this is the case, the search method as implemented will work well, because we will continually approach the boundary of feasibility until we stop within some tolerance - Speaking of this feasibility boundary, this is the main difference between the implemented method and standard quadratic fit search. There is some T such that the trajectory is no longer feasible, given the constraints on velocity/accel/BCs..., and so in general, we want to solve for a T which is small, yet feasible. So, this search method incorporates this knowledge of this infeasible region for small time intervals. - Ideally, we'd just be able to plug this into CVXPY (since it should just be a quadratic program with some constraints anyways). However, I tried a bunch of formulations of the constraints and it didn't seem to be convex or DCP (often leading to either quadratic forms of two variables, or equality constraints on convex functions). Maybe there is a better formulation out there... View Source \"\"\"Generating trajectories with a free final time We optimize using the following cost function: (integral of jerk l2 norm) + (time weight parameter) * (total duration) The weighting on the time component of this cost can be adjusted based on what component matters more. In general, a value of 1e-4 appears to put the two components of the cost (jerk and time) on the same order of magnitude Notes on the search method for the duration: - We know that the jerk function is a quadratic, and if we add an affine factor based on the total duration of the trajectory, it will still be a quadratic. So, a version of quadratic fit search will work well here - Depending on the weighting of this affine time component, the cost may look very linear. Even if this is the case, the search method as implemented will work well, because we will continually approach the boundary of feasibility until we stop within some tolerance - Speaking of this feasibility boundary, this is the main difference between the implemented method and standard quadratic fit search. There is some T such that the trajectory is no longer feasible, given the constraints on velocity/accel/BCs..., and so in general, we want to solve for a T which is small, yet feasible. So, this search method incorporates this knowledge of this infeasible region for small time intervals. - Ideally, we'd just be able to plug this into CVXPY (since it should just be a quadratic program with some constraints anyways). However, I tried a bunch of formulations of the constraints and it didn't seem to be convex or DCP (often leading to either quadratic forms of two variables, or equality constraints on convex functions). Maybe there is a better formulation out there... \"\"\" from typing import Optional , Callable , Any import numpy as np import numpy . typing as npt import pybullet import matplotlib . pyplot as plt from pyastrobee . trajectories . trajectory import plot_traj_constraints from pyastrobee . trajectories . bezier import BezierCurve , bezier_trajectory from pyastrobee . trajectories . splines import ( CompositeBezierCurve , spline_trajectory_with_retiming , ) from pyastrobee . trajectories . curve_utils import traj_from_curve from pyastrobee . utils . boxes import Box from pyastrobee . utils . debug_visualizer import animate_path from pyastrobee . config . astrobee_motion import LINEAR_SPEED_LIMIT , LINEAR_ACCEL_LIMIT from pyastrobee . utils . errors import OptimizationError def left_quadratic_fit_search ( f : Callable [ [float ] , float | tuple [ float, Any ] ] , x_init : float , dx_tol : float , max_iters : int , ) -> tuple [ float, float, list[Any ] ]: \"\"\"A modified version of quadratic fit search that assumes we have an infeasible region for small x (x >= 0) See Algorithms for Optimization (Kochenderfer), Algorithm 3.4 for quadratic fit search Args: f (Callable[[float], float | tuple[float, Any]]): Univariate function to optimize, callable as f(x). The return must have the cost of the evaluation as the first output. Any additional outputs will be stored and the best will be returned at the end of the search x_init (float): Initial location to start the search dx_tol (float): Stopping tolerance on evaluation points: Terminate if the percent change between consecutive evaluation points is less than this tolerance max_iters (int): Maximum iterations of the algorithm (if the stopping tolerance is not achieved) Raises: OptimizationError: If no feasible solution is found in max_iters iterations Returns: tuple[float, float, list[Any]]: float: Best evaluation point x float: Cost of the function evaluation at the best x value list[Any]: Additional outputs of the function being optimized at the best x value. Empty list if there are no additional outputs \"\"\" # Mutable dicts to keep track of the optimization process best = { \"x\" : None , \"cost\" : np . inf , \"out\" : []} # init log = { \"iters\" : 0 , \"feasibility_bound\" : 0 } # init # Create wrapper around the function to handle if it has multiple outputs # Return will solely be the cost of the evaluation , but we store the other outputs # in the dictionaries as needed def _f ( x : float ) -> float : fx = f ( x ) log [ \"iters\" ] += 1 if isinstance ( fx , tuple ) : cost , * out = fx # Out will by default be packed into a list else : cost = fx out = [] # Check to see if this is the best so far - if so , update if cost <= best [ \"cost\" ] and cost != np . inf : best [ \"x\" ] = x best [ \"cost\" ] = cost best [ \"out\" ] = out return cost # Find the quadratic fit search interval ( a , b , c ) given an initial search location # This assumes that x is a positive value and that the only infeasible values occurs # when x is too small def _find_init_interval_from_guess ( x : float ) : b = x yb = _f ( b ) if yb == np . inf : while yb == np . inf and log [ \"iters\" ] <= max_iters - 1 : log [ \"feasibility_bound\" ] = max ( b , log [ \"feasibility_bound\" ] ) b *= 2 yb = _f ( b ) a = ( log [ \"feasibility_bound\" ] + b ) / 2 ya = _f ( a ) if ya == np . inf : while ya == np . inf and log [ \"iters\" ] <= max_iters - 1 : log [ \"feasibility_bound\" ] = max ( a , log [ \"feasibility_bound\" ] ) a = ( a + b ) / 2 ya = _f ( a ) # we know c will be valid c = b + ( b - a ) yc = _f ( c ) return a , b , c , ya , yb , yc a , b , c , ya , yb , yc = _find_init_interval_from_guess ( x_init ) x_prev = None # init while log [ \"iters\" ] <= max_iters - 1 : # Quadratic fit for the next search location x = ( 0.5 * ( ya * ( b ** 2 - c ** 2 ) + yb * ( c ** 2 - a ** 2 ) + yc * ( a ** 2 - b ** 2 )) / ( ya * ( b - c ) + yb * ( c - a ) + yc * ( a - b )) ) # Handle if the fit location is known to be infeasible if x <= log [ \"feasibility_bound\" ] : x = ( log [ \"feasibility_bound\" ] + a ) / 2 yx = _f ( x ) if yx == np . inf : # Infeasible log [ \"feasibility_bound\" ] = max ( log [ \"feasibility_bound\" ] , x ) else : # Standard quadratic fit update , with extra cases when x is not between a and c if x < a : if yx < ya : a , ya = x , yx elif a <= x <= c : if x > b : if yx > yb : c , yc = x , yx else : a , ya , b , yb = b , yb , x , yx elif x < b : if yx > yb : a , ya = x , yx else : c , yc , b , yb = b , yb , x , yx else : # x > c if yx < yc : c , yc = x , yx # Termination criteria : if our evaluation point update has shrunk to within some tolerance if x_prev is not None and abs (( x - x_prev ) / x_prev ) < dx_tol : break x_prev = x if best [ \"x\" ] is None : raise OptimizationError ( \"Unable to find a feasible solution\" ) return best [ \"x\" ] , best [ \"cost\" ] , best [ \"out\" ] def free_final_time_bezier ( p0 : npt . ArrayLike , pf : npt . ArrayLike , t0 : float , tf_init : float , n_control_pts : int , v0 : Optional [ npt.ArrayLike ] = None , vf : Optional [ npt.ArrayLike ] = None , a0 : Optional [ npt.ArrayLike ] = None , af : Optional [ npt.ArrayLike ] = None , box : Optional [ Box ] = None , v_max : Optional [ float ] = None , a_max : Optional [ float ] = None , time_weight : float = 1e-4 , timing_rtol : float = 0.01 , max_iters : int = 15 , debug : bool = False , ) -> BezierCurve : \"\"\"Optimize a Bezier curve trajectory to balance minimizing jerk with minimizing the total duration Args: p0 (npt.ArrayLike): Initial position, shape (3,) pf (npt.ArrayLike): Final position, shape (3,) t0 (float): Starting time tf_init (float): Initial estimate of the final time n_control_pts (int): Number of control points for the Bezier curve. Must be >= to the number of constraints, and should not be too large (>15ish) as this can reduce optimization performance. 6-10 is usually good v0 (Optional[npt.ArrayLike]): Initial velocity, shape (3,). Defaults to None (unconstrained) vf (Optional[npt.ArrayLike]): Final velocity, shape (3,). Defaults to None (unconstrained) a0 (Optional[npt.ArrayLike]): Initial acceleration, shape (3,). Defaults to None (unconstrained) af (Optional[npt.ArrayLike]): Final acceleration, shape (3,). Defaults to None (unconstrained) box (Optional[Box]): Box constraint on (lower, upper) position bounds. Defaults to None (unconstrained) v_max (Optional[float]): Maximum L2 norm of the velocity. Defaults to None (unconstrained) a_max (Optional[float]): Maximum L2 norm of the acceleration. Defaults to None (unconstrained) time_weight (float, optional): Objective function weight corresponding to a linear penalty on the duration. Defaults to 1e-4. (this was observed to give duration roughly the same weighting as jerk) timing_rtol (float, optional): Tolerance on the free-final-time optimization. Defaults to 0.01 (within 1% of the optimal time) max_iters (int, optional): Maximum number of iterations for the free-final-time optimization. Defaults to 15. debug (bool, optional): Whether to print/plot details on the free-final-time optimization. Defaults to False. Returns: BezierCurve: The optimal curve \"\"\" curve_kwargs = dict ( p0 = p0 , pf = pf , t0 = t0 , tf = tf_init , n_control_pts = n_control_pts , v0 = v0 , vf = vf , a0 = a0 , af = af , box = box , v_max = v_max , a_max = a_max , time_weight = time_weight , ) if debug : # Keep track of the costs per time to plot afterwards costs_log : dict [ float, float ] = {} # Wrapper around the bezier trajectory function so that we can pop this into our quadratic fit search # method with the expected inputs / outputs , and handle when we can 't solve for the curve # e.g. time as the input, and output the cost and the solved curve def _curve_wrapper(t: float) -> tuple[float, BezierCurve]: kwargs = curve_kwargs | {\"tf\": t} print(\"Evaluating time: \", t) try: curve, cost = bezier_trajectory(**kwargs) except OptimizationError: curve, cost = None, np.inf if debug: # Print info on the breakdown of the cost between jerk and time print( \"Cost: \", cost, \" Jerk: \", cost - time_weight * t, \" Time: \", time_weight * t, ) costs_log[t] = cost # The quadratic search assumes that cost is the first output return cost, curve t, cost, output = left_quadratic_fit_search( _curve_wrapper, tf_init, timing_rtol, max_iters ) best_curve = output[0] if debug: print(\"Optimal time: \", t, \" yields cost: \", cost) _plot_optimization_data(costs_log) return best_curve def free_final_time_spline( p0: npt.ArrayLike, pf: npt.ArrayLike, t0: float, tf_init: float, pts_per_curve: int, boxes: list[Box], initial_durations: npt.ArrayLike, v0: Optional[npt.ArrayLike] = None, vf: Optional[npt.ArrayLike] = None, a0: Optional[npt.ArrayLike] = None, af: Optional[npt.ArrayLike] = None, v_max: Optional[float] = None, a_max: Optional[float] = None, kappa_min: float = 1e-2, omega: float = 3, max_retiming_iters: int = 10, time_weight: float = 1e-4, timing_rtol: float = 0.01, max_iters: int = 15, debug: bool = False, ) -> CompositeBezierCurve: \"\"\"Optimize a spline trajectory to balance minimizing jerk with minimizing the total duration Args: p0 (npt.ArrayLike): Initial position, shape (3,) pf (npt.ArrayLike): Final position, shape (3,) t0 (float): Starting time tf_init (float): Initial estimate of the final time pts_per_curve (int): Number of control points per Bezier curve. Generally, should be around 6-10 boxes (list[Box]): Sequential list of safe box regions pass through initial_durations (npt.ArrayLike): Initial estimate of the durations for each segment of the trajectory. These will be refined during the retiming process. Shape (num_boxes,) v0 (Optional[npt.ArrayLike]): Initial velocity, shape (3,). Defaults to None (unconstrained) vf (Optional[npt.ArrayLike]): Final velocity, shape (3,). Defaults to None (unconstrained) a0 (Optional[npt.ArrayLike]): Initial acceleration, shape (3,). Defaults to None (unconstrained) af (Optional[npt.ArrayLike]): Final acceleration, shape (3,). Defaults to None (unconstrained) v_max (Optional[float]): Maximum L2 norm of the velocity. Defaults to None (unconstrained) a_max (Optional[float]): Maximum L2 norm of the acceleration. Defaults to None (unconstrained) kappa_min (float, optional): Retiming trust region parameter: Defines the maximum change in adjacent scaling factors. Defaults to 1e-2. omega (float, optional): Retiming parameter: Defines the rate at which kappa decays after each iteration. Must be > 1. Small values (~2) work well when transition time estimates are poor, but larger values (~5) are more effective otherwise. Defaults to 3. max_retiming_iters (int, optional): Maximum number of iterations for the retiming process. Defaults to 10. time_weight (float, optional): Objective function weight corresponding to a linear penalty on the duration. Defaults to 1e-4 (this was observed to give duration roughly the same weighting as jerk) timing_rtol (float, optional): Tolerance on the free-final-time optimization. Defaults to 0.01 (within 1% of the optimal time) max_iters (int, optional): Maximum number of iterations for the free-final-time optimization. Defaults to 15. debug (bool, optional): Whether to print/plot details on the free-final-time optimization. Defaults to False. Returns: CompositeBezierCurve: The optimal curve \"\"\" curve_kwargs = dict( p0=p0, pf=pf, t0=t0, tf=tf_init, pts_per_curve=pts_per_curve, boxes=boxes, initial_durations=initial_durations, v0=v0, vf=vf, a0=a0, af=af, v_max=v_max, a_max=a_max, kappa_min=kappa_min, omega=omega, max_retiming_iters=max_retiming_iters, time_weight=time_weight, ) # As we vary the final time, we need to make sure that the durations per box # also get updated. So, use the fractional durations and rescale based on the total time duration_fractions = initial_durations / (tf_init - t0) if debug: # Keep track of the costs per time to plot afterwards costs_log: dict[float, float] = {} # Wrapper around the spline trajectory function so that we can pop this into our quadratic fit search # method with the expected inputs/outputs, and handle when we can' t solve for the curve # e . g . time as the input , and output the cost and the solved curve def _curve_wrapper ( t : float ) -> tuple [ float, CompositeBezierCurve ] : nonlocal duration_fractions kwargs = curve_kwargs | { \"tf\" : t , \"initial_durations\" : t * duration_fractions , } print ( \"Evaluating duration: \" , t ) try : curve , cost = spline_trajectory_with_retiming ( ** kwargs ) # Update our understanding of the best curve durations based on the retiming process duration_fractions = curve . segment_durations / curve . duration except OptimizationError : curve , cost = None , np . inf if debug : # Print info on the breakdown of the cost between jerk and time print ( \"Cost: \" , cost , \" Jerk: \" , cost - time_weight * t , \" Time: \" , time_weight * t , ) costs_log [ t ] = cost # The quadratic search assumes that cost is the first output return cost , curve t , cost , output = left_quadratic_fit_search ( _curve_wrapper , tf_init , timing_rtol , max_iters ) best_curve = output [ 0 ] if debug : print ( \"Optimal time: \" , t , \" yields cost: \" , cost ) _plot_optimization_data ( costs_log ) return best_curve def _plot_optimization_data ( cost_log : dict [ float, float ] , show : bool = True ) : \"\"\"Helper function to plot the time optimization results when debugging Args: cost_log (dict[float, float]): Costs for each duration. Keys: times, Values: costs show (bool, optional): Whether or not to show the plot. Defaults to True. \"\"\" fig = plt . figure () times , costs = zip ( * cost_log . items ()) plt . subplot ( 1 , 2 , 1 ) plt . scatter ( times , costs ) sort_idxs = np . argsort ( times ) times_sorted = np . array ( times ) [ sort_idxs ] costs_sorted = np . array ( costs ) [ sort_idxs ] plt . plot ( times_sorted , costs_sorted , \"--\" ) plt . xlabel ( \"Time\" ) plt . ylabel ( \"Cost\" ) plt . title ( \"Cost vs duration\" ) plt . subplot ( 1 , 2 , 2 ) plt . plot ( range ( len ( costs )), costs ) plt . scatter ( range ( len ( costs )), costs ) plt . xlabel ( \"Iteration\" ) plt . ylabel ( \"Cost\" ) plt . title ( \"Convergence\" ) if show : plt . show () def _bezier_main () : p0 = ( 0 , 0 , 0 ) pf = ( 1 , 2 , 3 ) t0 = 0 tf_init = 30 n_control_pts = 30 dt = 0.1 v0 = ( 0.3 , 0.2 , 0.1 ) vf = ( 0 , 0 , 0 ) a0 = ( 0 , 0 , 0 ) af = ( 0 , 0 , 0 ) print ( \"Speed limit: \" , LINEAR_SPEED_LIMIT ) print ( \"Accel limit: \" , LINEAR_ACCEL_LIMIT ) curve = free_final_time_bezier ( p0 , pf , t0 , tf_init , n_control_pts , v0 , vf , a0 , af , None , LINEAR_SPEED_LIMIT , LINEAR_ACCEL_LIMIT , debug = True , ) traj = traj_from_curve ( curve , dt ) traj . plot () plot_traj_constraints ( traj , None , LINEAR_SPEED_LIMIT , LINEAR_ACCEL_LIMIT , None , None ) pybullet . connect ( pybullet . GUI ) traj . visualize ( 30 ) animate_path ( traj . positions , 5 ) input ( \"Animation complete, press Enter to finish\" ) def _spline_main () : p0 = [ 0.1, 0.2, 0.3 ] pf = [ 1.5, 5, 1.7 ] t0 = 0 tf_init = 30 pts_per_curve = 20 # 8 v0 = np . zeros ( 3 ) vf = np . zeros ( 3 ) a0 = np . zeros ( 3 ) af = np . zeros ( 3 ) dt = 0.1 boxes = [ Box((0, 0, 0), (1, 1, 1)), Box((0.5, 0.5, 0.5), (1.5, 5, 1.5)), Box((1, 4.5, 1), (2, 5.5, 2)), ] n_curves = len ( boxes ) durations = np . ones ( n_curves ) * ( tf_init - t0 ) / n_curves curve = free_final_time_spline ( p0 , pf , t0 , tf_init , pts_per_curve , boxes , durations , v0 , vf , a0 , af , LINEAR_SPEED_LIMIT , LINEAR_ACCEL_LIMIT , debug = True , ) traj = traj_from_curve ( curve , dt ) traj . plot () plot_traj_constraints ( traj , None , LINEAR_SPEED_LIMIT , LINEAR_ACCEL_LIMIT , None , None ) pybullet . connect ( pybullet . GUI ) traj . visualize ( 30 ) animate_path ( traj . positions , 5 ) input ( \"Animation complete, press Enter to finish\" ) if __name__ == \"__main__\" : # _bezier_main () _spline_main ()","title":"Module pyastrobee.trajectories.variable_time_curves"},{"location":"reference/pyastrobee/trajectories/variable_time_curves/#variables","text":"LINEAR_ACCEL_LIMIT LINEAR_SPEED_LIMIT","title":"Variables"},{"location":"reference/pyastrobee/trajectories/variable_time_curves/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/trajectories/variable_time_curves/#free_final_time_bezier","text":"def free_final_time_bezier ( p0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], t0 : float , tf_init : float , n_control_pts : int , v0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , vf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , a0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , af : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , box : Optional [ pyastrobee . utils . boxes . Box ] = None , v_max : Optional [ float ] = None , a_max : Optional [ float ] = None , time_weight : float = 0.0001 , timing_rtol : float = 0.01 , max_iters : int = 15 , debug : bool = False ) -> pyastrobee . trajectories . bezier . BezierCurve Optimize a Bezier curve trajectory to balance minimizing jerk with minimizing the total duration Parameters: Name Type Description Default p0 npt.ArrayLike Initial position, shape (3,) None pf npt.ArrayLike Final position, shape (3,) None t0 float Starting time None tf_init float Initial estimate of the final time None n_control_pts int Number of control points for the Bezier curve. Must be >= to the number of constraints, and should not be too large (>15ish) as this can reduce optimization performance. 6-10 is usually good None v0 Optional[npt.ArrayLike] Initial velocity, shape (3,). Defaults to None (unconstrained) None vf Optional[npt.ArrayLike] Final velocity, shape (3,). Defaults to None (unconstrained) None a0 Optional[npt.ArrayLike] Initial acceleration, shape (3,). Defaults to None (unconstrained) None af Optional[npt.ArrayLike] Final acceleration, shape (3,). Defaults to None (unconstrained) None box Optional[Box] Box constraint on (lower, upper) position bounds. Defaults to None (unconstrained) None v_max Optional[float] Maximum L2 norm of the velocity. Defaults to None (unconstrained) None a_max Optional[float] Maximum L2 norm of the acceleration. Defaults to None (unconstrained) None time_weight float Objective function weight corresponding to a linear penalty on the duration. Defaults to 1e-4. (this was observed to give duration roughly the same weighting as jerk) None timing_rtol float Tolerance on the free-final-time optimization. Defaults to 0.01 (within 1% of the optimal time) 0 max_iters int Maximum number of iterations for the free-final-time optimization. Defaults to 15. 15 debug bool Whether to print/plot details on the free-final-time optimization. Defaults to False. False Returns: Type Description BezierCurve The optimal curve View Source def free_final_time_bezier ( p0 : npt . ArrayLike , pf : npt . ArrayLike , t0 : float , tf_init : float , n_control_pts : int , v0 : Optional [ npt.ArrayLike ] = None , vf : Optional [ npt.ArrayLike ] = None , a0 : Optional [ npt.ArrayLike ] = None , af : Optional [ npt.ArrayLike ] = None , box : Optional [ Box ] = None , v_max : Optional [ float ] = None , a_max : Optional [ float ] = None , time_weight : float = 1e-4 , timing_rtol : float = 0.01 , max_iters : int = 15 , debug : bool = False , ) -> BezierCurve : \"\"\"Optimize a Bezier curve trajectory to balance minimizing jerk with minimizing the total duration Args: p0 (npt.ArrayLike): Initial position, shape (3,) pf (npt.ArrayLike): Final position, shape (3,) t0 (float): Starting time tf_init (float): Initial estimate of the final time n_control_pts (int): Number of control points for the Bezier curve. Must be >= to the number of constraints, and should not be too large (>15ish) as this can reduce optimization performance. 6-10 is usually good v0 (Optional[npt.ArrayLike]): Initial velocity, shape (3,). Defaults to None (unconstrained) vf (Optional[npt.ArrayLike]): Final velocity, shape (3,). Defaults to None (unconstrained) a0 (Optional[npt.ArrayLike]): Initial acceleration, shape (3,). Defaults to None (unconstrained) af (Optional[npt.ArrayLike]): Final acceleration, shape (3,). Defaults to None (unconstrained) box (Optional[Box]): Box constraint on (lower, upper) position bounds. Defaults to None (unconstrained) v_max (Optional[float]): Maximum L2 norm of the velocity. Defaults to None (unconstrained) a_max (Optional[float]): Maximum L2 norm of the acceleration. Defaults to None (unconstrained) time_weight (float, optional): Objective function weight corresponding to a linear penalty on the duration. Defaults to 1e-4. (this was observed to give duration roughly the same weighting as jerk) timing_rtol (float, optional): Tolerance on the free-final-time optimization. Defaults to 0.01 (within 1% of the optimal time) max_iters (int, optional): Maximum number of iterations for the free-final-time optimization. Defaults to 15. debug (bool, optional): Whether to print/plot details on the free-final-time optimization. Defaults to False. Returns: BezierCurve: The optimal curve \"\"\" curve_kwargs = dict ( p0 = p0 , pf = pf , t0 = t0 , tf = tf_init , n_control_pts = n_control_pts , v0 = v0 , vf = vf , a0 = a0 , af = af , box = box , v_max = v_max , a_max = a_max , time_weight = time_weight , ) if debug : # Keep track of the costs per time to plot afterwards costs_log : dict [ float, float ] = {} # Wrapper around the bezier trajectory function so that we can pop this into our quadratic fit search # method with the expected inputs / outputs , and handle when we can ' t solve for the curve # e . g . time as the input , and output the cost and the solved curve def _curve_wrapper ( t : float ) -> tuple [ float, BezierCurve ] : kwargs = curve_kwargs | { \"tf\" : t } print ( \"Evaluating time: \" , t ) try : curve , cost = bezier_trajectory ( ** kwargs ) except OptimizationError : curve , cost = None , np . inf if debug : # Print info on the breakdown of the cost between jerk and time print ( \"Cost: \" , cost , \" Jerk: \" , cost - time_weight * t , \" Time: \" , time_weight * t , ) costs_log [ t ] = cost # The quadratic search assumes that cost is the first output return cost , curve t , cost , output = left_quadratic_fit_search ( _curve_wrapper , tf_init , timing_rtol , max_iters ) best_curve = output [ 0 ] if debug : print ( \"Optimal time: \" , t , \" yields cost: \" , cost ) _plot_optimization_data ( costs_log ) return best_curve","title":"free_final_time_bezier"},{"location":"reference/pyastrobee/trajectories/variable_time_curves/#free_final_time_spline","text":"def free_final_time_spline ( p0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], t0 : float , tf_init : float , pts_per_curve : int , boxes : list [ pyastrobee . utils . boxes . Box ], initial_durations : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], v0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , vf : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , a0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , af : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , v_max : Optional [ float ] = None , a_max : Optional [ float ] = None , kappa_min : float = 0.01 , omega : float = 3 , max_retiming_iters : int = 10 , time_weight : float = 0.0001 , timing_rtol : float = 0.01 , max_iters : int = 15 , debug : bool = False ) -> pyastrobee . trajectories . splines . CompositeBezierCurve Optimize a spline trajectory to balance minimizing jerk with minimizing the total duration Parameters: Name Type Description Default p0 npt.ArrayLike Initial position, shape (3,) None pf npt.ArrayLike Final position, shape (3,) None t0 float Starting time None tf_init float Initial estimate of the final time None pts_per_curve int Number of control points per Bezier curve. Generally, should be around 6-10 None boxes list[Box] Sequential list of safe box regions pass through None initial_durations npt.ArrayLike Initial estimate of the durations for each segment of the trajectory. These will be refined during the retiming process. Shape (num_boxes,) None v0 Optional[npt.ArrayLike] Initial velocity, shape (3,). Defaults to None (unconstrained) None vf Optional[npt.ArrayLike] Final velocity, shape (3,). Defaults to None (unconstrained) None a0 Optional[npt.ArrayLike] Initial acceleration, shape (3,). Defaults to None (unconstrained) None af Optional[npt.ArrayLike] Final acceleration, shape (3,). Defaults to None (unconstrained) None v_max Optional[float] Maximum L2 norm of the velocity. Defaults to None (unconstrained) None a_max Optional[float] Maximum L2 norm of the acceleration. Defaults to None (unconstrained) None kappa_min float Retiming trust region parameter: Defines the maximum change in adjacent scaling factors. Defaults to 1e-2. None omega float Retiming parameter: Defines the rate at which kappa decays after each iteration. Must be > 1. Small values (~2) work well when transition time estimates are poor, but larger values (~5) are more effective otherwise. Defaults to 3. None max_retiming_iters int Maximum number of iterations for the retiming process. Defaults to 10. 10 time_weight float Objective function weight corresponding to a linear penalty on the duration. Defaults to 1e-4 (this was observed to give duration roughly the same weighting as jerk) None timing_rtol float Tolerance on the free-final-time optimization. Defaults to 0.01 (within 1% of the optimal time) 0 max_iters int Maximum number of iterations for the free-final-time optimization. Defaults to 15. 15 debug bool Whether to print/plot details on the free-final-time optimization. Defaults to False. False Returns: Type Description CompositeBezierCurve The optimal curve View Source def free_final_time_spline ( p0 : npt . ArrayLike , pf : npt . ArrayLike , t0 : float , tf_init : float , pts_per_curve : int , boxes : list [ Box ] , initial_durations : npt . ArrayLike , v0 : Optional [ npt.ArrayLike ] = None , vf : Optional [ npt.ArrayLike ] = None , a0 : Optional [ npt.ArrayLike ] = None , af : Optional [ npt.ArrayLike ] = None , v_max : Optional [ float ] = None , a_max : Optional [ float ] = None , kappa_min : float = 1e-2 , omega : float = 3 , max_retiming_iters : int = 10 , time_weight : float = 1e-4 , timing_rtol : float = 0.01 , max_iters : int = 15 , debug : bool = False , ) -> CompositeBezierCurve : \"\"\"Optimize a spline trajectory to balance minimizing jerk with minimizing the total duration Args: p0 (npt.ArrayLike): Initial position, shape (3,) pf (npt.ArrayLike): Final position, shape (3,) t0 (float): Starting time tf_init (float): Initial estimate of the final time pts_per_curve (int): Number of control points per Bezier curve. Generally, should be around 6-10 boxes (list[Box]): Sequential list of safe box regions pass through initial_durations (npt.ArrayLike): Initial estimate of the durations for each segment of the trajectory. These will be refined during the retiming process. Shape (num_boxes,) v0 (Optional[npt.ArrayLike]): Initial velocity, shape (3,). Defaults to None (unconstrained) vf (Optional[npt.ArrayLike]): Final velocity, shape (3,). Defaults to None (unconstrained) a0 (Optional[npt.ArrayLike]): Initial acceleration, shape (3,). Defaults to None (unconstrained) af (Optional[npt.ArrayLike]): Final acceleration, shape (3,). Defaults to None (unconstrained) v_max (Optional[float]): Maximum L2 norm of the velocity. Defaults to None (unconstrained) a_max (Optional[float]): Maximum L2 norm of the acceleration. Defaults to None (unconstrained) kappa_min (float, optional): Retiming trust region parameter: Defines the maximum change in adjacent scaling factors. Defaults to 1e-2. omega (float, optional): Retiming parameter: Defines the rate at which kappa decays after each iteration. Must be > 1. Small values (~2) work well when transition time estimates are poor, but larger values (~5) are more effective otherwise. Defaults to 3. max_retiming_iters (int, optional): Maximum number of iterations for the retiming process. Defaults to 10. time_weight (float, optional): Objective function weight corresponding to a linear penalty on the duration. Defaults to 1e-4 (this was observed to give duration roughly the same weighting as jerk) timing_rtol (float, optional): Tolerance on the free-final-time optimization. Defaults to 0.01 (within 1% of the optimal time) max_iters (int, optional): Maximum number of iterations for the free-final-time optimization. Defaults to 15. debug (bool, optional): Whether to print/plot details on the free-final-time optimization. Defaults to False. Returns: CompositeBezierCurve: The optimal curve \"\"\" curve_kwargs = dict ( p0 = p0 , pf = pf , t0 = t0 , tf = tf_init , pts_per_curve = pts_per_curve , boxes = boxes , initial_durations = initial_durations , v0 = v0 , vf = vf , a0 = a0 , af = af , v_max = v_max , a_max = a_max , kappa_min = kappa_min , omega = omega , max_retiming_iters = max_retiming_iters , time_weight = time_weight , ) # As we vary the final time , we need to make sure that the durations per box # also get updated . So , use the fractional durations and rescale based on the total time duration_fractions = initial_durations / ( tf_init - t0 ) if debug : # Keep track of the costs per time to plot afterwards costs_log : dict [ float, float ] = {} # Wrapper around the spline trajectory function so that we can pop this into our quadratic fit search # method with the expected inputs / outputs , and handle when we can ' t solve for the curve # e . g . time as the input , and output the cost and the solved curve def _curve_wrapper ( t : float ) -> tuple [ float, CompositeBezierCurve ] : nonlocal duration_fractions kwargs = curve_kwargs | { \"tf\" : t , \"initial_durations\" : t * duration_fractions , } print ( \"Evaluating duration: \" , t ) try : curve , cost = spline_trajectory_with_retiming ( ** kwargs ) # Update our understanding of the best curve durations based on the retiming process duration_fractions = curve . segment_durations / curve . duration except OptimizationError : curve , cost = None , np . inf if debug : # Print info on the breakdown of the cost between jerk and time print ( \"Cost: \" , cost , \" Jerk: \" , cost - time_weight * t , \" Time: \" , time_weight * t , ) costs_log [ t ] = cost # The quadratic search assumes that cost is the first output return cost , curve t , cost , output = left_quadratic_fit_search ( _curve_wrapper , tf_init , timing_rtol , max_iters ) best_curve = output [ 0 ] if debug : print ( \"Optimal time: \" , t , \" yields cost: \" , cost ) _plot_optimization_data ( costs_log ) return best_curve","title":"free_final_time_spline"},{"location":"reference/pyastrobee/trajectories/variable_time_curves/#left_quadratic_fit_search","text":"def left_quadratic_fit_search ( f : Callable [[ float ], float | tuple [ float , Any ]], x_init : float , dx_tol : float , max_iters : int ) -> tuple [ float , float , list [ typing . Any ]] A modified version of quadratic fit search that assumes we have an infeasible region for small x (x >= 0) See Algorithms for Optimization (Kochenderfer), Algorithm 3.4 for quadratic fit search Parameters: Name Type Description Default f Callable[[float], float tuple[float, Any]] Univariate function to optimize, callable as f(x). The return must have the cost of the evaluation as the first output. Any additional outputs will be stored and the best will be returned at the end of the search x_init float Initial location to start the search None dx_tol float Stopping tolerance on evaluation points: Terminate if the percent change between consecutive evaluation points is less than this tolerance None max_iters int Maximum iterations of the algorithm (if the stopping tolerance is not achieved) None Returns: Type Description tuple[float, float, list[Any]] float: Best evaluation point x float: Cost of the function evaluation at the best x value list[Any]: Additional outputs of the function being optimized at the best x value. Empty list if there are no additional outputs Raises: Type Description OptimizationError If no feasible solution is found in max_iters iterations View Source def left_quadratic_fit_search ( f : Callable [ [float ] , float | tuple [ float, Any ] ] , x_init : float , dx_tol : float , max_iters : int , ) -> tuple [ float, float, list[Any ] ]: \"\"\"A modified version of quadratic fit search that assumes we have an infeasible region for small x (x >= 0) See Algorithms for Optimization (Kochenderfer), Algorithm 3.4 for quadratic fit search Args: f (Callable[[float], float | tuple[float, Any]]): Univariate function to optimize, callable as f(x). The return must have the cost of the evaluation as the first output. Any additional outputs will be stored and the best will be returned at the end of the search x_init (float): Initial location to start the search dx_tol (float): Stopping tolerance on evaluation points: Terminate if the percent change between consecutive evaluation points is less than this tolerance max_iters (int): Maximum iterations of the algorithm (if the stopping tolerance is not achieved) Raises: OptimizationError: If no feasible solution is found in max_iters iterations Returns: tuple[float, float, list[Any]]: float: Best evaluation point x float: Cost of the function evaluation at the best x value list[Any]: Additional outputs of the function being optimized at the best x value. Empty list if there are no additional outputs \"\"\" # Mutable dicts to keep track of the optimization process best = { \"x\" : None , \"cost\" : np . inf , \"out\" : []} # init log = { \"iters\" : 0 , \"feasibility_bound\" : 0 } # init # Create wrapper around the function to handle if it has multiple outputs # Return will solely be the cost of the evaluation , but we store the other outputs # in the dictionaries as needed def _f ( x : float ) -> float : fx = f ( x ) log [ \"iters\" ] += 1 if isinstance ( fx , tuple ) : cost , * out = fx # Out will by default be packed into a list else : cost = fx out = [] # Check to see if this is the best so far - if so , update if cost <= best [ \"cost\" ] and cost != np . inf : best [ \"x\" ] = x best [ \"cost\" ] = cost best [ \"out\" ] = out return cost # Find the quadratic fit search interval ( a , b , c ) given an initial search location # This assumes that x is a positive value and that the only infeasible values occurs # when x is too small def _find_init_interval_from_guess ( x : float ) : b = x yb = _f ( b ) if yb == np . inf : while yb == np . inf and log [ \"iters\" ] <= max_iters - 1 : log [ \"feasibility_bound\" ] = max ( b , log [ \"feasibility_bound\" ] ) b *= 2 yb = _f ( b ) a = ( log [ \"feasibility_bound\" ] + b ) / 2 ya = _f ( a ) if ya == np . inf : while ya == np . inf and log [ \"iters\" ] <= max_iters - 1 : log [ \"feasibility_bound\" ] = max ( a , log [ \"feasibility_bound\" ] ) a = ( a + b ) / 2 ya = _f ( a ) # we know c will be valid c = b + ( b - a ) yc = _f ( c ) return a , b , c , ya , yb , yc a , b , c , ya , yb , yc = _find_init_interval_from_guess ( x_init ) x_prev = None # init while log [ \"iters\" ] <= max_iters - 1 : # Quadratic fit for the next search location x = ( 0.5 * ( ya * ( b ** 2 - c ** 2 ) + yb * ( c ** 2 - a ** 2 ) + yc * ( a ** 2 - b ** 2 )) / ( ya * ( b - c ) + yb * ( c - a ) + yc * ( a - b )) ) # Handle if the fit location is known to be infeasible if x <= log [ \"feasibility_bound\" ] : x = ( log [ \"feasibility_bound\" ] + a ) / 2 yx = _f ( x ) if yx == np . inf : # Infeasible log [ \"feasibility_bound\" ] = max ( log [ \"feasibility_bound\" ] , x ) else : # Standard quadratic fit update , with extra cases when x is not between a and c if x < a : if yx < ya : a , ya = x , yx elif a <= x <= c : if x > b : if yx > yb : c , yc = x , yx else : a , ya , b , yb = b , yb , x , yx elif x < b : if yx > yb : a , ya = x , yx else : c , yc , b , yb = b , yb , x , yx else : # x > c if yx < yc : c , yc = x , yx # Termination criteria : if our evaluation point update has shrunk to within some tolerance if x_prev is not None and abs (( x - x_prev ) / x_prev ) < dx_tol : break x_prev = x if best [ \"x\" ] is None : raise OptimizationError ( \"Unable to find a feasible solution\" ) return best [ \"x\" ] , best [ \"cost\" ] , best [ \"out\" ]","title":"left_quadratic_fit_search"},{"location":"reference/pyastrobee/utils/","text":"Module pyastrobee.utils Sub-modules pyastrobee.utils.algos pyastrobee.utils.bag_frame pyastrobee.utils.boxes pyastrobee.utils.bullet_utils pyastrobee.utils.debug_visualizer pyastrobee.utils.dynamics pyastrobee.utils.errors pyastrobee.utils.math_utils pyastrobee.utils.mesh_utils pyastrobee.utils.poses pyastrobee.utils.python_utils pyastrobee.utils.quaternion_derivatives pyastrobee.utils.quaternions pyastrobee.utils.rotations pyastrobee.utils.transformations pyastrobee.utils.video_concatenation","title":"Index"},{"location":"reference/pyastrobee/utils/#module-pyastrobeeutils","text":"","title":"Module pyastrobee.utils"},{"location":"reference/pyastrobee/utils/#sub-modules","text":"pyastrobee.utils.algos pyastrobee.utils.bag_frame pyastrobee.utils.boxes pyastrobee.utils.bullet_utils pyastrobee.utils.debug_visualizer pyastrobee.utils.dynamics pyastrobee.utils.errors pyastrobee.utils.math_utils pyastrobee.utils.mesh_utils pyastrobee.utils.poses pyastrobee.utils.python_utils pyastrobee.utils.quaternion_derivatives pyastrobee.utils.quaternions pyastrobee.utils.rotations pyastrobee.utils.transformations pyastrobee.utils.video_concatenation","title":"Sub-modules"},{"location":"reference/pyastrobee/utils/algos/","text":"Module pyastrobee.utils.algos Common algorithms View Source \"\"\"Common algorithms\"\"\" from typing import Iterable , TypeVar , Optional T = TypeVar ( \"T\" ) def dfs ( graph : dict [ T , Iterable [ T ]], start : T , end : T ) -> Optional [ list [ T ]]: \"\"\"Depth first search Args: graph (dict[T, Iterable[T]]): Graph to search. Maps nodes to a list or other iterable of neighbors start (T): Starting node end (T): Ending node Returns: Optional[list[T]]: Sequence of nodes from start to end. None if the the path does not exist \"\"\" if start not in graph or end not in graph : return None visited = set () path = [ start ] def dfs_rec ( node : T ) -> bool : if node == end : return True visited . add ( node ) for neighbor in graph [ node ]: if neighbor not in visited : path . append ( neighbor ) if dfs_rec ( neighbor ): return True path . pop () return False found_path = dfs_rec ( start ) if not found_path : return None return path Variables T Functions dfs def dfs ( graph : dict [ ~ T , typing . Iterable [ ~ T ]], start : ~ T , end : ~ T ) -> Optional [ list [ ~ T ]] Depth first search Parameters: Name Type Description Default graph dict[T, Iterable[T]] Graph to search. Maps nodes to a list or other iterable of neighbors None start T Starting node None end T Ending node None Returns: Type Description Optional[list[T]] Sequence of nodes from start to end. None if the the path does not exist View Source def dfs ( graph : dict [ T, Iterable[T ] ] , start : T , end : T ) -> Optional [ list[T ] ]: \"\"\"Depth first search Args: graph (dict[T, Iterable[T]]): Graph to search. Maps nodes to a list or other iterable of neighbors start (T): Starting node end (T): Ending node Returns: Optional[list[T]]: Sequence of nodes from start to end. None if the the path does not exist \"\"\" if start not in graph or end not in graph : return None visited = set () path = [ start ] def dfs_rec ( node : T ) -> bool : if node == end : return True visited . add ( node ) for neighbor in graph [ node ] : if neighbor not in visited : path . append ( neighbor ) if dfs_rec ( neighbor ) : return True path . pop () return False found_path = dfs_rec ( start ) if not found_path : return None return path","title":"Algos"},{"location":"reference/pyastrobee/utils/algos/#module-pyastrobeeutilsalgos","text":"Common algorithms View Source \"\"\"Common algorithms\"\"\" from typing import Iterable , TypeVar , Optional T = TypeVar ( \"T\" ) def dfs ( graph : dict [ T , Iterable [ T ]], start : T , end : T ) -> Optional [ list [ T ]]: \"\"\"Depth first search Args: graph (dict[T, Iterable[T]]): Graph to search. Maps nodes to a list or other iterable of neighbors start (T): Starting node end (T): Ending node Returns: Optional[list[T]]: Sequence of nodes from start to end. None if the the path does not exist \"\"\" if start not in graph or end not in graph : return None visited = set () path = [ start ] def dfs_rec ( node : T ) -> bool : if node == end : return True visited . add ( node ) for neighbor in graph [ node ]: if neighbor not in visited : path . append ( neighbor ) if dfs_rec ( neighbor ): return True path . pop () return False found_path = dfs_rec ( start ) if not found_path : return None return path","title":"Module pyastrobee.utils.algos"},{"location":"reference/pyastrobee/utils/algos/#variables","text":"T","title":"Variables"},{"location":"reference/pyastrobee/utils/algos/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/utils/algos/#dfs","text":"def dfs ( graph : dict [ ~ T , typing . Iterable [ ~ T ]], start : ~ T , end : ~ T ) -> Optional [ list [ ~ T ]] Depth first search Parameters: Name Type Description Default graph dict[T, Iterable[T]] Graph to search. Maps nodes to a list or other iterable of neighbors None start T Starting node None end T Ending node None Returns: Type Description Optional[list[T]] Sequence of nodes from start to end. None if the the path does not exist View Source def dfs ( graph : dict [ T, Iterable[T ] ] , start : T , end : T ) -> Optional [ list[T ] ]: \"\"\"Depth first search Args: graph (dict[T, Iterable[T]]): Graph to search. Maps nodes to a list or other iterable of neighbors start (T): Starting node end (T): Ending node Returns: Optional[list[T]]: Sequence of nodes from start to end. None if the the path does not exist \"\"\" if start not in graph or end not in graph : return None visited = set () path = [ start ] def dfs_rec ( node : T ) -> bool : if node == end : return True visited . add ( node ) for neighbor in graph [ node ] : if neighbor not in visited : path . append ( neighbor ) if dfs_rec ( neighbor ) : return True path . pop () return False found_path = dfs_rec ( start ) if not found_path : return None return path","title":"dfs"},{"location":"reference/pyastrobee/utils/bag_frame/","text":"Module pyastrobee.utils.bag_frame Tools for determining the (approximate) position/orientation of a volumetric softbody Pybullet's built-in functions don't work well on softbodies (can't get reliable angular information) so this will help determine the state of the cargo bag Here, we use the positions of the eight mesh vertices closest to the corners of the bag's main compartment to approximate the delta-x/y/z values, and then create an orthonormal basis from that See the find_corner_verts script for more info on the corner-vertex identification process View Source \"\"\"Tools for determining the (approximate) position/orientation of a volumetric softbody Pybullet's built-in functions don't work well on softbodies (can't get reliable angular information) so this will help determine the state of the cargo bag Here, we use the positions of the eight mesh vertices closest to the corners of the bag's main compartment to approximate the delta-x/y/z values, and then create an orthonormal basis from that See the find_corner_verts script for more info on the corner-vertex identification process \"\"\" import time import numpy as np import numpy.typing as npt import pybullet from pyastrobee.utils.transformations import make_transform_mat from pyastrobee.utils.debug_visualizer import visualize_frame from pyastrobee.utils.mesh_utils import get_mesh_data from pyastrobee.utils.bullet_utils import load_deformable_object from pyastrobee.config.bag_properties import TOP_HANDLE_BAG_CORNERS # For indexing into the list of vertices # Naming these as constants so their usage is clearer in the functions below RIGHT_BACK_TOP = 0 RIGHT_BACK_BOT = 1 RIGHT_FRONT_TOP = 2 RIGHT_FRONT_BOT = 3 LEFT_BACK_TOP = 4 LEFT_BACK_BOT = 5 LEFT_FRONT_TOP = 6 LEFT_FRONT_BOT = 7 def get_x_axis ( mesh : npt . ArrayLike , corners : list [ int ]) -> np . ndarray : \"\"\"Calculate the x-axis of the bag frame based on averaging the length-wise vectors between corners Args: mesh (npt.ArrayLike): Bag mesh vertex positions, shape (num_verts, 3) corners (list[int]): Indices of the 8 vertices closest to the corners of the bag Returns: np.ndarray: Best-fit axis based on the corner positions, shape (3,) \"\"\" a = mesh [ corners [ RIGHT_BACK_TOP ]] - mesh [ corners [ LEFT_BACK_TOP ]] b = mesh [ corners [ RIGHT_BACK_BOT ]] - mesh [ corners [ LEFT_BACK_BOT ]] c = mesh [ corners [ RIGHT_FRONT_TOP ]] - mesh [ corners [ LEFT_FRONT_TOP ]] d = mesh [ corners [ RIGHT_FRONT_BOT ]] - mesh [ corners [ LEFT_FRONT_BOT ]] return np . average ([ a , b , c , d ], axis = 0 ) def get_y_axis ( mesh : npt . ArrayLike , corners : list [ int ]): \"\"\"Calculate the y-axis of the bag frame based on averaging the width-wise vectors between corners Args: mesh (npt.ArrayLike): Bag mesh vertex positions, shape (num_verts, 3) corners (list[int]): Indices of the 8 vertices closest to the corners of the bag Returns: np.ndarray: Best-fit axis based on the corner positions, shape (3,) \"\"\" a = mesh [ corners [ RIGHT_BACK_TOP ]] - mesh [ corners [ RIGHT_FRONT_TOP ]] b = mesh [ corners [ RIGHT_BACK_BOT ]] - mesh [ corners [ RIGHT_FRONT_BOT ]] c = mesh [ corners [ LEFT_BACK_TOP ]] - mesh [ corners [ LEFT_FRONT_TOP ]] d = mesh [ corners [ LEFT_BACK_BOT ]] - mesh [ corners [ LEFT_FRONT_BOT ]] return np . average ([ a , b , c , d ], axis = 0 ) def get_z_axis ( mesh : npt . ArrayLike , corners : list [ int ]): \"\"\"Calculate the z-axis of the bag frame based on averaging the height-wise vectors between corners Args: mesh (npt.ArrayLike): Bag mesh vertex positions, shape (num_verts, 3) corners (list[int]): Indices of the 8 vertices closest to the corners of the bag Returns: np.ndarray: Best-fit axis based on the corner positions, shape (3,) \"\"\" a = mesh [ corners [ RIGHT_BACK_TOP ]] - mesh [ corners [ RIGHT_BACK_BOT ]] b = mesh [ corners [ RIGHT_FRONT_TOP ]] - mesh [ corners [ RIGHT_FRONT_BOT ]] c = mesh [ corners [ LEFT_BACK_TOP ]] - mesh [ corners [ LEFT_BACK_BOT ]] d = mesh [ corners [ LEFT_FRONT_TOP ]] - mesh [ corners [ LEFT_FRONT_BOT ]] return np . average ([ a , b , c , d ], axis = 0 ) def orthogonalize ( x : npt . ArrayLike , y : npt . ArrayLike , z : npt . ArrayLike ) -> tuple [ np . ndarray , np . ndarray , np . ndarray ]: \"\"\"Turn three linearly independent vectors into an orthogonal/orthonormal basis We assume that the direction of x is correct, and base the other calculations on this Args: x (npt.ArrayLike): Initial x axis, shape (3,) y (npt.ArrayLike): Initial y axis, shape (3,) z (npt.ArrayLike): Initial z axis, shape (3,) Returns: Tuple[np.ndarray, np.ndarray, np.ndarray]: The new normalized + orthogonal x, y, and z axes \"\"\" x_new = x / np . linalg . norm ( x ) y_new = np . cross ( z , x ) y_new = y_new / np . linalg . norm ( y_new ) z_new = np . cross ( x , y ) z_new = z_new / np . linalg . norm ( z_new ) return x_new , y_new , z_new def get_bag_frame ( mesh : npt . ArrayLike , corners : list [ int ]) -> np . ndarray : \"\"\"Determine the transformation matrix for the cargo bag frame Args: mesh (npt.ArrayLike): Bag mesh vertex positions, shape (num_verts, 3) corners (list[int]): Indices of the 8 vertices closest to the corners of the bag Returns: np.ndarray: Transformation matrix, shape (4, 4) \"\"\" x = get_x_axis ( mesh , corners ) y = get_y_axis ( mesh , corners ) z = get_z_axis ( mesh , corners ) R = np . column_stack ( orthogonalize ( x , y , z )) origin = np . average ( mesh , axis = 0 ) return make_transform_mat ( R , origin ) if __name__ == \"__main__\" : pybullet . connect ( pybullet . GUI ) pybullet . resetSimulation ( pybullet . RESET_USE_DEFORMABLE_WORLD ) filename = \"pyastrobee/assets/meshes/bags/top_handle.vtk\" bag_id = load_deformable_object ( filename , bending_stiffness = 10 ) while True : n_verts , bag_mesh = get_mesh_data ( bag_id ) T = get_bag_frame ( bag_mesh , TOP_HANDLE_BAG_CORNERS ) visualize_frame ( T , lifetime = 1 ) pybullet . stepSimulation () time . sleep ( 1 / 240 ) Variables LEFT_BACK_BOT LEFT_BACK_TOP LEFT_FRONT_BOT LEFT_FRONT_TOP RIGHT_BACK_BOT RIGHT_BACK_TOP RIGHT_FRONT_BOT RIGHT_FRONT_TOP TOP_HANDLE_BAG_CORNERS Functions get_bag_frame def get_bag_frame ( mesh : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], corners : list [ int ] ) -> numpy . ndarray Determine the transformation matrix for the cargo bag frame Parameters: Name Type Description Default mesh npt.ArrayLike Bag mesh vertex positions, shape (num_verts, 3) None corners list[int] Indices of the 8 vertices closest to the corners of the bag None Returns: Type Description np.ndarray Transformation matrix, shape (4, 4) View Source def get_bag_frame ( mesh : npt . ArrayLike , corners : list [ int ] ) -> np . ndarray : \"\"\"Determine the transformation matrix for the cargo bag frame Args: mesh (npt.ArrayLike): Bag mesh vertex positions, shape (num_verts, 3) corners (list[int]): Indices of the 8 vertices closest to the corners of the bag Returns: np.ndarray: Transformation matrix, shape (4, 4) \"\"\" x = get_x_axis ( mesh , corners ) y = get_y_axis ( mesh , corners ) z = get_z_axis ( mesh , corners ) R = np . column_stack ( orthogonalize ( x , y , z )) origin = np . average ( mesh , axis = 0 ) return make_transform_mat ( R , origin ) get_x_axis def get_x_axis ( mesh : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], corners : list [ int ] ) -> numpy . ndarray Calculate the x-axis of the bag frame based on averaging the length-wise vectors between corners Parameters: Name Type Description Default mesh npt.ArrayLike Bag mesh vertex positions, shape (num_verts, 3) None corners list[int] Indices of the 8 vertices closest to the corners of the bag None Returns: Type Description np.ndarray Best-fit axis based on the corner positions, shape (3,) View Source def get_x_axis ( mesh : npt . ArrayLike , corners : list [ int ] ) -> np . ndarray : \"\"\"Calculate the x-axis of the bag frame based on averaging the length-wise vectors between corners Args: mesh (npt.ArrayLike): Bag mesh vertex positions, shape (num_verts, 3) corners (list[int]): Indices of the 8 vertices closest to the corners of the bag Returns: np.ndarray: Best-fit axis based on the corner positions, shape (3,) \"\"\" a = mesh [ corners[RIGHT_BACK_TOP ] ] - mesh [ corners[LEFT_BACK_TOP ] ] b = mesh [ corners[RIGHT_BACK_BOT ] ] - mesh [ corners[LEFT_BACK_BOT ] ] c = mesh [ corners[RIGHT_FRONT_TOP ] ] - mesh [ corners[LEFT_FRONT_TOP ] ] d = mesh [ corners[RIGHT_FRONT_BOT ] ] - mesh [ corners[LEFT_FRONT_BOT ] ] return np . average ( [ a, b, c, d ] , axis = 0 ) get_y_axis def get_y_axis ( mesh : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], corners : list [ int ] ) Calculate the y-axis of the bag frame based on averaging the width-wise vectors between corners Parameters: Name Type Description Default mesh npt.ArrayLike Bag mesh vertex positions, shape (num_verts, 3) None corners list[int] Indices of the 8 vertices closest to the corners of the bag None Returns: Type Description np.ndarray Best-fit axis based on the corner positions, shape (3,) View Source def get_y_axis ( mesh : npt . ArrayLike , corners : list [ int ] ) : \"\"\"Calculate the y-axis of the bag frame based on averaging the width-wise vectors between corners Args: mesh (npt.ArrayLike): Bag mesh vertex positions, shape (num_verts, 3) corners (list[int]): Indices of the 8 vertices closest to the corners of the bag Returns: np.ndarray: Best-fit axis based on the corner positions, shape (3,) \"\"\" a = mesh [ corners[RIGHT_BACK_TOP ] ] - mesh [ corners[RIGHT_FRONT_TOP ] ] b = mesh [ corners[RIGHT_BACK_BOT ] ] - mesh [ corners[RIGHT_FRONT_BOT ] ] c = mesh [ corners[LEFT_BACK_TOP ] ] - mesh [ corners[LEFT_FRONT_TOP ] ] d = mesh [ corners[LEFT_BACK_BOT ] ] - mesh [ corners[LEFT_FRONT_BOT ] ] return np . average ( [ a, b, c, d ] , axis = 0 ) get_z_axis def get_z_axis ( mesh : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], corners : list [ int ] ) Calculate the z-axis of the bag frame based on averaging the height-wise vectors between corners Parameters: Name Type Description Default mesh npt.ArrayLike Bag mesh vertex positions, shape (num_verts, 3) None corners list[int] Indices of the 8 vertices closest to the corners of the bag None Returns: Type Description np.ndarray Best-fit axis based on the corner positions, shape (3,) View Source def get_z_axis ( mesh : npt . ArrayLike , corners : list [ int ] ) : \"\"\"Calculate the z-axis of the bag frame based on averaging the height-wise vectors between corners Args: mesh (npt.ArrayLike): Bag mesh vertex positions, shape (num_verts, 3) corners (list[int]): Indices of the 8 vertices closest to the corners of the bag Returns: np.ndarray: Best-fit axis based on the corner positions, shape (3,) \"\"\" a = mesh [ corners[RIGHT_BACK_TOP ] ] - mesh [ corners[RIGHT_BACK_BOT ] ] b = mesh [ corners[RIGHT_FRONT_TOP ] ] - mesh [ corners[RIGHT_FRONT_BOT ] ] c = mesh [ corners[LEFT_BACK_TOP ] ] - mesh [ corners[LEFT_BACK_BOT ] ] d = mesh [ corners[LEFT_FRONT_TOP ] ] - mesh [ corners[LEFT_FRONT_BOT ] ] return np . average ( [ a, b, c, d ] , axis = 0 ) orthogonalize def orthogonalize ( x : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], y : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], z : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> tuple [ numpy . ndarray , numpy . ndarray , numpy . ndarray ] Turn three linearly independent vectors into an orthogonal/orthonormal basis We assume that the direction of x is correct, and base the other calculations on this Parameters: Name Type Description Default x npt.ArrayLike Initial x axis, shape (3,) None y npt.ArrayLike Initial y axis, shape (3,) None z npt.ArrayLike Initial z axis, shape (3,) None Returns: Type Description Tuple[np.ndarray, np.ndarray, np.ndarray] The new normalized + orthogonal x, y, and z axes View Source def orthogonalize ( x : npt . ArrayLike , y : npt . ArrayLike , z : npt . ArrayLike ) -> tuple [ np . ndarray , np . ndarray , np . ndarray ] : \"\"\"Turn three linearly independent vectors into an orthogonal/orthonormal basis We assume that the direction of x is correct, and base the other calculations on this Args: x (npt.ArrayLike): Initial x axis, shape (3,) y (npt.ArrayLike): Initial y axis, shape (3,) z (npt.ArrayLike): Initial z axis, shape (3,) Returns: Tuple[np.ndarray, np.ndarray, np.ndarray]: The new normalized + orthogonal x, y, and z axes \"\"\" x_new = x / np . linalg . norm ( x ) y_new = np . cross ( z , x ) y_new = y_new / np . linalg . norm ( y_new ) z_new = np . cross ( x , y ) z_new = z_new / np . linalg . norm ( z_new ) return x_new , y_new , z_new","title":"Bag Frame"},{"location":"reference/pyastrobee/utils/bag_frame/#module-pyastrobeeutilsbag_frame","text":"Tools for determining the (approximate) position/orientation of a volumetric softbody Pybullet's built-in functions don't work well on softbodies (can't get reliable angular information) so this will help determine the state of the cargo bag Here, we use the positions of the eight mesh vertices closest to the corners of the bag's main compartment to approximate the delta-x/y/z values, and then create an orthonormal basis from that See the find_corner_verts script for more info on the corner-vertex identification process View Source \"\"\"Tools for determining the (approximate) position/orientation of a volumetric softbody Pybullet's built-in functions don't work well on softbodies (can't get reliable angular information) so this will help determine the state of the cargo bag Here, we use the positions of the eight mesh vertices closest to the corners of the bag's main compartment to approximate the delta-x/y/z values, and then create an orthonormal basis from that See the find_corner_verts script for more info on the corner-vertex identification process \"\"\" import time import numpy as np import numpy.typing as npt import pybullet from pyastrobee.utils.transformations import make_transform_mat from pyastrobee.utils.debug_visualizer import visualize_frame from pyastrobee.utils.mesh_utils import get_mesh_data from pyastrobee.utils.bullet_utils import load_deformable_object from pyastrobee.config.bag_properties import TOP_HANDLE_BAG_CORNERS # For indexing into the list of vertices # Naming these as constants so their usage is clearer in the functions below RIGHT_BACK_TOP = 0 RIGHT_BACK_BOT = 1 RIGHT_FRONT_TOP = 2 RIGHT_FRONT_BOT = 3 LEFT_BACK_TOP = 4 LEFT_BACK_BOT = 5 LEFT_FRONT_TOP = 6 LEFT_FRONT_BOT = 7 def get_x_axis ( mesh : npt . ArrayLike , corners : list [ int ]) -> np . ndarray : \"\"\"Calculate the x-axis of the bag frame based on averaging the length-wise vectors between corners Args: mesh (npt.ArrayLike): Bag mesh vertex positions, shape (num_verts, 3) corners (list[int]): Indices of the 8 vertices closest to the corners of the bag Returns: np.ndarray: Best-fit axis based on the corner positions, shape (3,) \"\"\" a = mesh [ corners [ RIGHT_BACK_TOP ]] - mesh [ corners [ LEFT_BACK_TOP ]] b = mesh [ corners [ RIGHT_BACK_BOT ]] - mesh [ corners [ LEFT_BACK_BOT ]] c = mesh [ corners [ RIGHT_FRONT_TOP ]] - mesh [ corners [ LEFT_FRONT_TOP ]] d = mesh [ corners [ RIGHT_FRONT_BOT ]] - mesh [ corners [ LEFT_FRONT_BOT ]] return np . average ([ a , b , c , d ], axis = 0 ) def get_y_axis ( mesh : npt . ArrayLike , corners : list [ int ]): \"\"\"Calculate the y-axis of the bag frame based on averaging the width-wise vectors between corners Args: mesh (npt.ArrayLike): Bag mesh vertex positions, shape (num_verts, 3) corners (list[int]): Indices of the 8 vertices closest to the corners of the bag Returns: np.ndarray: Best-fit axis based on the corner positions, shape (3,) \"\"\" a = mesh [ corners [ RIGHT_BACK_TOP ]] - mesh [ corners [ RIGHT_FRONT_TOP ]] b = mesh [ corners [ RIGHT_BACK_BOT ]] - mesh [ corners [ RIGHT_FRONT_BOT ]] c = mesh [ corners [ LEFT_BACK_TOP ]] - mesh [ corners [ LEFT_FRONT_TOP ]] d = mesh [ corners [ LEFT_BACK_BOT ]] - mesh [ corners [ LEFT_FRONT_BOT ]] return np . average ([ a , b , c , d ], axis = 0 ) def get_z_axis ( mesh : npt . ArrayLike , corners : list [ int ]): \"\"\"Calculate the z-axis of the bag frame based on averaging the height-wise vectors between corners Args: mesh (npt.ArrayLike): Bag mesh vertex positions, shape (num_verts, 3) corners (list[int]): Indices of the 8 vertices closest to the corners of the bag Returns: np.ndarray: Best-fit axis based on the corner positions, shape (3,) \"\"\" a = mesh [ corners [ RIGHT_BACK_TOP ]] - mesh [ corners [ RIGHT_BACK_BOT ]] b = mesh [ corners [ RIGHT_FRONT_TOP ]] - mesh [ corners [ RIGHT_FRONT_BOT ]] c = mesh [ corners [ LEFT_BACK_TOP ]] - mesh [ corners [ LEFT_BACK_BOT ]] d = mesh [ corners [ LEFT_FRONT_TOP ]] - mesh [ corners [ LEFT_FRONT_BOT ]] return np . average ([ a , b , c , d ], axis = 0 ) def orthogonalize ( x : npt . ArrayLike , y : npt . ArrayLike , z : npt . ArrayLike ) -> tuple [ np . ndarray , np . ndarray , np . ndarray ]: \"\"\"Turn three linearly independent vectors into an orthogonal/orthonormal basis We assume that the direction of x is correct, and base the other calculations on this Args: x (npt.ArrayLike): Initial x axis, shape (3,) y (npt.ArrayLike): Initial y axis, shape (3,) z (npt.ArrayLike): Initial z axis, shape (3,) Returns: Tuple[np.ndarray, np.ndarray, np.ndarray]: The new normalized + orthogonal x, y, and z axes \"\"\" x_new = x / np . linalg . norm ( x ) y_new = np . cross ( z , x ) y_new = y_new / np . linalg . norm ( y_new ) z_new = np . cross ( x , y ) z_new = z_new / np . linalg . norm ( z_new ) return x_new , y_new , z_new def get_bag_frame ( mesh : npt . ArrayLike , corners : list [ int ]) -> np . ndarray : \"\"\"Determine the transformation matrix for the cargo bag frame Args: mesh (npt.ArrayLike): Bag mesh vertex positions, shape (num_verts, 3) corners (list[int]): Indices of the 8 vertices closest to the corners of the bag Returns: np.ndarray: Transformation matrix, shape (4, 4) \"\"\" x = get_x_axis ( mesh , corners ) y = get_y_axis ( mesh , corners ) z = get_z_axis ( mesh , corners ) R = np . column_stack ( orthogonalize ( x , y , z )) origin = np . average ( mesh , axis = 0 ) return make_transform_mat ( R , origin ) if __name__ == \"__main__\" : pybullet . connect ( pybullet . GUI ) pybullet . resetSimulation ( pybullet . RESET_USE_DEFORMABLE_WORLD ) filename = \"pyastrobee/assets/meshes/bags/top_handle.vtk\" bag_id = load_deformable_object ( filename , bending_stiffness = 10 ) while True : n_verts , bag_mesh = get_mesh_data ( bag_id ) T = get_bag_frame ( bag_mesh , TOP_HANDLE_BAG_CORNERS ) visualize_frame ( T , lifetime = 1 ) pybullet . stepSimulation () time . sleep ( 1 / 240 )","title":"Module pyastrobee.utils.bag_frame"},{"location":"reference/pyastrobee/utils/bag_frame/#variables","text":"LEFT_BACK_BOT LEFT_BACK_TOP LEFT_FRONT_BOT LEFT_FRONT_TOP RIGHT_BACK_BOT RIGHT_BACK_TOP RIGHT_FRONT_BOT RIGHT_FRONT_TOP TOP_HANDLE_BAG_CORNERS","title":"Variables"},{"location":"reference/pyastrobee/utils/bag_frame/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/utils/bag_frame/#get_bag_frame","text":"def get_bag_frame ( mesh : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], corners : list [ int ] ) -> numpy . ndarray Determine the transformation matrix for the cargo bag frame Parameters: Name Type Description Default mesh npt.ArrayLike Bag mesh vertex positions, shape (num_verts, 3) None corners list[int] Indices of the 8 vertices closest to the corners of the bag None Returns: Type Description np.ndarray Transformation matrix, shape (4, 4) View Source def get_bag_frame ( mesh : npt . ArrayLike , corners : list [ int ] ) -> np . ndarray : \"\"\"Determine the transformation matrix for the cargo bag frame Args: mesh (npt.ArrayLike): Bag mesh vertex positions, shape (num_verts, 3) corners (list[int]): Indices of the 8 vertices closest to the corners of the bag Returns: np.ndarray: Transformation matrix, shape (4, 4) \"\"\" x = get_x_axis ( mesh , corners ) y = get_y_axis ( mesh , corners ) z = get_z_axis ( mesh , corners ) R = np . column_stack ( orthogonalize ( x , y , z )) origin = np . average ( mesh , axis = 0 ) return make_transform_mat ( R , origin )","title":"get_bag_frame"},{"location":"reference/pyastrobee/utils/bag_frame/#get_x_axis","text":"def get_x_axis ( mesh : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], corners : list [ int ] ) -> numpy . ndarray Calculate the x-axis of the bag frame based on averaging the length-wise vectors between corners Parameters: Name Type Description Default mesh npt.ArrayLike Bag mesh vertex positions, shape (num_verts, 3) None corners list[int] Indices of the 8 vertices closest to the corners of the bag None Returns: Type Description np.ndarray Best-fit axis based on the corner positions, shape (3,) View Source def get_x_axis ( mesh : npt . ArrayLike , corners : list [ int ] ) -> np . ndarray : \"\"\"Calculate the x-axis of the bag frame based on averaging the length-wise vectors between corners Args: mesh (npt.ArrayLike): Bag mesh vertex positions, shape (num_verts, 3) corners (list[int]): Indices of the 8 vertices closest to the corners of the bag Returns: np.ndarray: Best-fit axis based on the corner positions, shape (3,) \"\"\" a = mesh [ corners[RIGHT_BACK_TOP ] ] - mesh [ corners[LEFT_BACK_TOP ] ] b = mesh [ corners[RIGHT_BACK_BOT ] ] - mesh [ corners[LEFT_BACK_BOT ] ] c = mesh [ corners[RIGHT_FRONT_TOP ] ] - mesh [ corners[LEFT_FRONT_TOP ] ] d = mesh [ corners[RIGHT_FRONT_BOT ] ] - mesh [ corners[LEFT_FRONT_BOT ] ] return np . average ( [ a, b, c, d ] , axis = 0 )","title":"get_x_axis"},{"location":"reference/pyastrobee/utils/bag_frame/#get_y_axis","text":"def get_y_axis ( mesh : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], corners : list [ int ] ) Calculate the y-axis of the bag frame based on averaging the width-wise vectors between corners Parameters: Name Type Description Default mesh npt.ArrayLike Bag mesh vertex positions, shape (num_verts, 3) None corners list[int] Indices of the 8 vertices closest to the corners of the bag None Returns: Type Description np.ndarray Best-fit axis based on the corner positions, shape (3,) View Source def get_y_axis ( mesh : npt . ArrayLike , corners : list [ int ] ) : \"\"\"Calculate the y-axis of the bag frame based on averaging the width-wise vectors between corners Args: mesh (npt.ArrayLike): Bag mesh vertex positions, shape (num_verts, 3) corners (list[int]): Indices of the 8 vertices closest to the corners of the bag Returns: np.ndarray: Best-fit axis based on the corner positions, shape (3,) \"\"\" a = mesh [ corners[RIGHT_BACK_TOP ] ] - mesh [ corners[RIGHT_FRONT_TOP ] ] b = mesh [ corners[RIGHT_BACK_BOT ] ] - mesh [ corners[RIGHT_FRONT_BOT ] ] c = mesh [ corners[LEFT_BACK_TOP ] ] - mesh [ corners[LEFT_FRONT_TOP ] ] d = mesh [ corners[LEFT_BACK_BOT ] ] - mesh [ corners[LEFT_FRONT_BOT ] ] return np . average ( [ a, b, c, d ] , axis = 0 )","title":"get_y_axis"},{"location":"reference/pyastrobee/utils/bag_frame/#get_z_axis","text":"def get_z_axis ( mesh : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], corners : list [ int ] ) Calculate the z-axis of the bag frame based on averaging the height-wise vectors between corners Parameters: Name Type Description Default mesh npt.ArrayLike Bag mesh vertex positions, shape (num_verts, 3) None corners list[int] Indices of the 8 vertices closest to the corners of the bag None Returns: Type Description np.ndarray Best-fit axis based on the corner positions, shape (3,) View Source def get_z_axis ( mesh : npt . ArrayLike , corners : list [ int ] ) : \"\"\"Calculate the z-axis of the bag frame based on averaging the height-wise vectors between corners Args: mesh (npt.ArrayLike): Bag mesh vertex positions, shape (num_verts, 3) corners (list[int]): Indices of the 8 vertices closest to the corners of the bag Returns: np.ndarray: Best-fit axis based on the corner positions, shape (3,) \"\"\" a = mesh [ corners[RIGHT_BACK_TOP ] ] - mesh [ corners[RIGHT_BACK_BOT ] ] b = mesh [ corners[RIGHT_FRONT_TOP ] ] - mesh [ corners[RIGHT_FRONT_BOT ] ] c = mesh [ corners[LEFT_BACK_TOP ] ] - mesh [ corners[LEFT_BACK_BOT ] ] d = mesh [ corners[LEFT_FRONT_TOP ] ] - mesh [ corners[LEFT_FRONT_BOT ] ] return np . average ( [ a, b, c, d ] , axis = 0 )","title":"get_z_axis"},{"location":"reference/pyastrobee/utils/bag_frame/#orthogonalize","text":"def orthogonalize ( x : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], y : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], z : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> tuple [ numpy . ndarray , numpy . ndarray , numpy . ndarray ] Turn three linearly independent vectors into an orthogonal/orthonormal basis We assume that the direction of x is correct, and base the other calculations on this Parameters: Name Type Description Default x npt.ArrayLike Initial x axis, shape (3,) None y npt.ArrayLike Initial y axis, shape (3,) None z npt.ArrayLike Initial z axis, shape (3,) None Returns: Type Description Tuple[np.ndarray, np.ndarray, np.ndarray] The new normalized + orthogonal x, y, and z axes View Source def orthogonalize ( x : npt . ArrayLike , y : npt . ArrayLike , z : npt . ArrayLike ) -> tuple [ np . ndarray , np . ndarray , np . ndarray ] : \"\"\"Turn three linearly independent vectors into an orthogonal/orthonormal basis We assume that the direction of x is correct, and base the other calculations on this Args: x (npt.ArrayLike): Initial x axis, shape (3,) y (npt.ArrayLike): Initial y axis, shape (3,) z (npt.ArrayLike): Initial z axis, shape (3,) Returns: Tuple[np.ndarray, np.ndarray, np.ndarray]: The new normalized + orthogonal x, y, and z axes \"\"\" x_new = x / np . linalg . norm ( x ) y_new = np . cross ( z , x ) y_new = y_new / np . linalg . norm ( y_new ) z_new = np . cross ( x , y ) z_new = z_new / np . linalg . norm ( z_new ) return x_new , y_new , z_new","title":"orthogonalize"},{"location":"reference/pyastrobee/utils/boxes/","text":"Module pyastrobee.utils.boxes Boxes and associated utility functions These are currently used as the definition of the safe sets in the trajectory optimization Based on: https://github.com/cvxgrp/fastpathplanning/blob/main/fastpathplanning/boxes.py View Source \"\"\"Boxes and associated utility functions These are currently used as the definition of the safe sets in the trajectory optimization Based on: https://github.com/cvxgrp/fastpathplanning/blob/main/fastpathplanning/boxes.py \"\"\" from collections import defaultdict from typing import Optional , Union import numpy as np import numpy.typing as npt import matplotlib.pyplot as plt from pybullet_utils.bullet_client import BulletClient from pyastrobee.utils.bullet_utils import create_box class Box : \"\"\"Representation of a box defined by lower/upper limits on its coordinates Unpackable as (lower, upper) = box Args: lower (npt.ArrayLike): Lower limits on the box coordinates, shape (box_dim,) upper (npt.ArrayLike): Upper limits on the box coordinates, shape (box_dim,) \"\"\" def __init__ ( self , lower : npt . ArrayLike , upper : npt . ArrayLike ): self . lower = np . ravel ( lower ) . astype ( np . float64 ) self . upper = np . ravel ( upper ) . astype ( np . float64 ) self . _validate () self . center = ( self . lower + self . upper ) / 2 self . dim = len ( self . lower ) def __iter__ ( self ): return iter ([ self . lower , self . upper ]) def __str__ ( self ): return f \"Lower: { list ( self . lower ) } , Upper: { list ( self . upper ) } \" def __repr__ ( self ): return ( f \" { type ( self ) . __name__ } (lower= { list ( self . lower ) } , upper= { list ( self . upper ) } )\" ) def _validate ( self ): if len ( self . lower ) != len ( self . upper ): raise ValueError ( \"Invalid input dimensions\" ) if np . any ( self . lower >= self . upper ): raise ValueError ( \"Invalid inputs: Mismatched order of lower/upper points\" ) def expand_box ( box : Box , distance : float ) -> Box : \"\"\"Increases the size of a box by a given distance Args: box (Box): The reference box distance (float): Amount to increase the size of the box in all dimensions Returns: Box: The increased-size box \"\"\" return Box ( box . lower - distance , box . upper + distance ) def contract_box ( box : Box , distance : float ) -> Box : \"\"\"Reduces the size of a box by a given distance Args: box (Box): The reference box distance (float): Amount to decrease the size of the box in all dimensions Returns: Box: The reduced-size box \"\"\" return Box ( box . lower + distance , box . upper - distance ) def intersect_boxes ( b1 : Box , b2 : Box ) -> Box : \"\"\"Calculate the intersection of two boxes Args: b1 (Box): First box b2 (Box): Second box Returns: Box: The intersection region \"\"\" return Box ( np . maximum ( b1 . lower , b2 . lower ), np . minimum ( b1 . upper , b2 . upper )) def check_box_intersection ( b1 : Box , b2 : Box ) -> bool : \"\"\"Evaluate if two boxes intersect or not Args: b1 (Box): First box b2 (Box): Second box Returns: bool: True if the boxes intersect, False if not \"\"\" l = np . maximum ( b1 . lower , b2 . lower ) u = np . minimum ( b1 . upper , b2 . upper ) return np . all ( u >= l ) def is_in_box ( point : npt . ArrayLike , box : Box ) -> bool : \"\"\"Evaluate if a point lies within a box Args: point (npt.ArrayLike): Point to evaluate, shape (box_dim,) box (Box): Box to test Returns: bool: True if the point is inside the bounds of the box, False otherwise \"\"\" assert np . size ( point ) == box . dim return np . all ( point >= box . lower ) and np . all ( point <= box . upper ) def find_containing_box ( point : npt . ArrayLike , boxes : Union [ list [ Box ], npt . ArrayLike ] ) -> Optional [ int ]: \"\"\"Find the index of the first box which contains a certain point Args: point (npt.ArrayLike): Point to evaluate boxes (Union[list[Box], npt.ArrayLike]): Boxes to search. If an array, must be of shape (n_boxes, 2, box_dim) Returns: Optional[int]: Index of the first box which contains the point. None if the point is not in any box \"\"\" for i , box in enumerate ( boxes ): lower , upper = box if np . all ( point >= lower ) and np . all ( point <= upper ): return i return None def find_containing_box_name ( point : npt . ArrayLike , boxes : dict [ str , Box ] ) -> Optional [ str ]: \"\"\"Find the name of the first box which contains a certain point Args: point (npt.ArrayLike): Point to evaluate boxes (dict[str, Box]): Boxes to search. Key/value: (box name) -> box Returns: Optional[str]: Name of the first box which contains the point. None if the point is not in any box \"\"\" for name , box in boxes . items (): if np . all ( point >= box . lower ) and np . all ( point <= box . upper ): return name return None def visualize_3D_box ( box : Union [ Box , npt . ArrayLike ], padding : Optional [ npt . ArrayLike ] = None , rgba : npt . ArrayLike = ( 1 , 0 , 0 , 0.5 ), client : Optional [ BulletClient ] = None , ) -> int : \"\"\"Visualize a box in Pybullet Args: box (Union[Box, npt.ArrayLike]): Box to visualize. If an array, must be of shape (1, 2, box_dim) padding (Optional[npt.ArrayLike]): If expanding (or contracting) the boxes by a certain amount, include the (x, y, z) padding distances here (shape (3,)). Defaults to None. rgba (npt.ArrayLike): Color of the box (RGB + alpha), shape (4,). Defaults to (1, 0, 0, 0.5). client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: int: Pybullet ID of the box \"\"\" lower , upper = box if padding is not None : lower -= padding upper += padding return create_box ( pos = ( lower + ( upper - lower ) / 2 ), # Midpoint orn = ( 0 , 0 , 0 , 1 ), mass = 0 , sidelengths = ( upper - lower ), use_collision = False , rgba = rgba , client = client , ) def plot_2D_box ( box : Box , ax : Optional [ plt . Axes ] = None , show : bool = True , * args , ** kwargs ) -> plt . Axes : \"\"\"Plots the boundary of a 2D box Args: box (Box): 2D box to plot ax (Optional[plt.Axes]): If re-using existing plotting axes, include them here. Defaults to None. show (bool, optional): Whether or not to show the plot. Defaults to True. Returns: plt.Axes: The plotting axes \"\"\" assert box . dim == 2 if ax is None : ax = plt . gca () pts = np . array ( [ box . lower , [ box . lower [ 0 ], box . upper [ 1 ]], box . upper , [ box . upper [ 0 ], box . lower [ 1 ]], box . lower , ] ) ax . plot ( * pts . T , * args , ** kwargs ) if show : plt . show () return ax def compute_graph ( boxes : dict [ str , Box ]) -> dict [ str , list [ str ]]: \"\"\"Computes the graph between a set of boxes Returns: dict[str, list[str]]: Adjacency list / graph dictating safe paths within the boxes. Key/value pair is: (name of the box) -> (list of names of all neighbors of that box) \"\"\" names = list ( boxes . keys ()) n = len ( names ) adj = defaultdict ( list ) for i in range ( n ): for j in range ( i + 1 , n ): if check_box_intersection ( boxes [ names [ i ]], boxes [ names [ j ]]): adj [ names [ i ]] . append ( names [ j ]) adj [ names [ j ]] . append ( names [ i ]) return adj def check_box_containment ( bounding_box : Union [ Box , npt . ArrayLike ], safe_set : list [ Box ] ) -> bool : \"\"\"Determine if the bounding box of an object is fully contained within a safe set Args: bounding_box (Union[Box, npt.ArrayLike]): Axis-aligned bounding box. If ArrayLike, must be of shape (2, 3) e.g. the lower and upper XYZ values defining the box safe_set (list[Box]): Boxes to check containment Returns: bool: True if the bounding box is contained in the safe set, False otherwise \"\"\" return any ( np . all ( bounding_box [ 0 ] > box . lower ) and np . all ( bounding_box [ 1 ] < box . upper ) for box in safe_set ) Functions check_box_containment def check_box_containment ( bounding_box : Union [ pyastrobee . utils . boxes . Box , numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], safe_set : list [ pyastrobee . utils . boxes . Box ] ) -> bool Determine if the bounding box of an object is fully contained within a safe set Parameters: Name Type Description Default bounding_box Union[Box, npt.ArrayLike] Axis-aligned bounding box. If ArrayLike, must be of shape (2, 3) e.g. the lower and upper XYZ values defining the box None safe_set list[Box] Boxes to check containment None Returns: Type Description bool True if the bounding box is contained in the safe set, False otherwise View Source def check_box_containment ( bounding_box : Union [ Box, npt.ArrayLike ] , safe_set : list [ Box ] ) -> bool : \"\"\"Determine if the bounding box of an object is fully contained within a safe set Args: bounding_box (Union[Box, npt.ArrayLike]): Axis-aligned bounding box. If ArrayLike, must be of shape (2, 3) e.g. the lower and upper XYZ values defining the box safe_set (list[Box]): Boxes to check containment Returns: bool: True if the bounding box is contained in the safe set, False otherwise \"\"\" return any ( np . all ( bounding_box [ 0 ] > box . lower ) and np . all ( bounding_box [ 1 ] < box . upper ) for box in safe_set ) check_box_intersection def check_box_intersection ( b1 : pyastrobee . utils . boxes . Box , b2 : pyastrobee . utils . boxes . Box ) -> bool Evaluate if two boxes intersect or not Parameters: Name Type Description Default b1 Box First box None b2 Box Second box None Returns: Type Description bool True if the boxes intersect, False if not View Source def check_box_intersection ( b1 : Box , b2 : Box ) -> bool : \"\"\"Evaluate if two boxes intersect or not Args: b1 (Box): First box b2 (Box): Second box Returns: bool: True if the boxes intersect, False if not \"\"\" l = np . maximum ( b1 . lower , b2 . lower ) u = np . minimum ( b1 . upper , b2 . upper ) return np . all ( u >= l ) compute_graph def compute_graph ( boxes : dict [ str , pyastrobee . utils . boxes . Box ] ) -> dict [ str , list [ str ]] Computes the graph between a set of boxes Returns: Type Description dict[str, list[str]] Adjacency list / graph dictating safe paths within the boxes. Key/value pair is: (name of the box) -> (list of names of all neighbors of that box) View Source def compute_graph ( boxes : dict [ str, Box ] ) -> dict [ str, list[str ] ]: \"\"\"Computes the graph between a set of boxes Returns: dict[str, list[str]]: Adjacency list / graph dictating safe paths within the boxes. Key/value pair is: (name of the box) -> (list of names of all neighbors of that box) \"\"\" names = list ( boxes . keys ()) n = len ( names ) adj = defaultdict ( list ) for i in range ( n ) : for j in range ( i + 1 , n ) : if check_box_intersection ( boxes [ names[i ] ] , boxes [ names[j ] ] ) : adj [ names[i ] ] . append ( names [ j ] ) adj [ names[j ] ] . append ( names [ i ] ) return adj contract_box def contract_box ( box : pyastrobee . utils . boxes . Box , distance : float ) -> pyastrobee . utils . boxes . Box Reduces the size of a box by a given distance Parameters: Name Type Description Default box Box The reference box None distance float Amount to decrease the size of the box in all dimensions None Returns: Type Description Box The reduced-size box View Source def contract_box ( box : Box , distance : float ) -> Box : \"\"\"Reduces the size of a box by a given distance Args: box (Box): The reference box distance (float): Amount to decrease the size of the box in all dimensions Returns: Box: The reduced-size box \"\"\" return Box ( box . lower + distance , box . upper - distance ) expand_box def expand_box ( box : pyastrobee . utils . boxes . Box , distance : float ) -> pyastrobee . utils . boxes . Box Increases the size of a box by a given distance Parameters: Name Type Description Default box Box The reference box None distance float Amount to increase the size of the box in all dimensions None Returns: Type Description Box The increased-size box View Source def expand_box ( box : Box , distance : float ) -> Box : \"\"\"Increases the size of a box by a given distance Args: box (Box): The reference box distance (float): Amount to increase the size of the box in all dimensions Returns: Box: The increased-size box \"\"\" return Box ( box . lower - distance , box . upper + distance ) find_containing_box def find_containing_box ( point : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], boxes : Union [ list [ pyastrobee . utils . boxes . Box ], numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> Optional [ int ] Find the index of the first box which contains a certain point Parameters: Name Type Description Default point npt.ArrayLike Point to evaluate None boxes Union[list[Box], npt.ArrayLike] Boxes to search. If an array, must be of shape (n_boxes, 2, box_dim) None Returns: Type Description Optional[int] Index of the first box which contains the point. None if the point is not in any box View Source def find_containing_box ( point : npt . ArrayLike , boxes : Union [ list[Box ] , npt . ArrayLike ] ) -> Optional [ int ] : \"\"\"Find the index of the first box which contains a certain point Args: point (npt.ArrayLike): Point to evaluate boxes (Union[list[Box], npt.ArrayLike]): Boxes to search. If an array, must be of shape (n_boxes, 2, box_dim) Returns: Optional[int]: Index of the first box which contains the point. None if the point is not in any box \"\"\" for i , box in enumerate ( boxes ) : lower , upper = box if np . all ( point >= lower ) and np . all ( point <= upper ) : return i return None find_containing_box_name def find_containing_box_name ( point : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], boxes : dict [ str , pyastrobee . utils . boxes . Box ] ) -> Optional [ str ] Find the name of the first box which contains a certain point Parameters: Name Type Description Default point npt.ArrayLike Point to evaluate None boxes dict[str, Box] Boxes to search. Key/value: (box name) -> box None Returns: Type Description Optional[str] Name of the first box which contains the point. None if the point is not in any box View Source def find_containing_box_name ( point : npt . ArrayLike , boxes : dict [ str, Box ] ) -> Optional [ str ] : \"\"\"Find the name of the first box which contains a certain point Args: point (npt.ArrayLike): Point to evaluate boxes (dict[str, Box]): Boxes to search. Key/value: (box name) -> box Returns: Optional[str]: Name of the first box which contains the point. None if the point is not in any box \"\"\" for name , box in boxes . items () : if np . all ( point >= box . lower ) and np . all ( point <= box . upper ) : return name return None intersect_boxes def intersect_boxes ( b1 : pyastrobee . utils . boxes . Box , b2 : pyastrobee . utils . boxes . Box ) -> pyastrobee . utils . boxes . Box Calculate the intersection of two boxes Parameters: Name Type Description Default b1 Box First box None b2 Box Second box None Returns: Type Description Box The intersection region View Source def intersect_boxes ( b1: Box , b2: Box ) -> Box: \"\"\"Calculate the intersection of two boxes Args: b1 ( Box ) : First box b2 ( Box ) : Second box Returns: Box: The intersection region \"\"\" return Box ( np . maximum ( b1 . lower , b2 . lower ), np . minimum ( b1 . upper , b2 . upper )) is_in_box def is_in_box ( point : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], box : pyastrobee . utils . boxes . Box ) -> bool Evaluate if a point lies within a box Parameters: Name Type Description Default point npt.ArrayLike Point to evaluate, shape (box_dim,) None box Box Box to test None Returns: Type Description bool True if the point is inside the bounds of the box, False otherwise View Source def is_in_box ( point : npt . ArrayLike , box : Box ) -> bool : \"\"\"Evaluate if a point lies within a box Args: point (npt.ArrayLike): Point to evaluate, shape (box_dim,) box (Box): Box to test Returns: bool: True if the point is inside the bounds of the box, False otherwise \"\"\" assert np . size ( point ) == box . dim return np . all ( point >= box . lower ) and np . all ( point <= box . upper ) plot_2D_box def plot_2D_box ( box : pyastrobee . utils . boxes . Box , ax : Optional [ matplotlib . axes . _axes . Axes ] = None , show : bool = True , * args , ** kwargs ) -> matplotlib . axes . _axes . Axes Plots the boundary of a 2D box Parameters: Name Type Description Default box Box 2D box to plot None ax Optional[plt.Axes] If re-using existing plotting axes, include them here. Defaults to None. None show bool Whether or not to show the plot. Defaults to True. True Returns: Type Description plt.Axes The plotting axes View Source def plot_2D_box( box: Box, ax: Optional[plt.Axes] = None, show: bool = True, *args, * *kwargs ) -> plt.Axes: \"\"\"Plots the boundary of a 2D box Args: box (Box): 2D box to plot ax (Optional[plt.Axes]): If re-using existing plotting axes, include them here. Defaults to None. show (bool, optional): Whether or not to show the plot. Defaults to True. Returns: plt.Axes: The plotting axes \"\"\" assert box.dim == 2 if ax is None: ax = plt.gca() pts = np.array( [ box.lower, [box.lower[0], box.upper[1]], box.upper, [box.upper[0], box.lower[1]], box.lower, ] ) ax.plot(*pts.T, *args, * *kwargs) if show: plt.show() return ax visualize_3D_box def visualize_3D_box ( box : Union [ pyastrobee . utils . boxes . Box , numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], padding : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , rgba : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 1 , 0 , 0 , 0.5 ), client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> int Visualize a box in Pybullet Parameters: Name Type Description Default box Union[Box, npt.ArrayLike] Box to visualize. If an array, must be of shape (1, 2, box_dim) None padding Optional[npt.ArrayLike] If expanding (or contracting) the boxes by a certain amount, include the (x, y, z) padding distances here (shape (3,)). Defaults to None. None rgba npt.ArrayLike Color of the box (RGB + alpha), shape (4,). Defaults to (1, 0, 0, 0.5). (1, 0, 0, 0.5) client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Returns: Type Description int Pybullet ID of the box View Source def visualize_3D_box ( box : Union [ Box, npt.ArrayLike ] , padding : Optional [ npt.ArrayLike ] = None , rgba : npt . ArrayLike = ( 1 , 0 , 0 , 0.5 ), client : Optional [ BulletClient ] = None , ) -> int : \"\"\"Visualize a box in Pybullet Args: box (Union[Box, npt.ArrayLike]): Box to visualize. If an array, must be of shape (1, 2, box_dim) padding (Optional[npt.ArrayLike]): If expanding (or contracting) the boxes by a certain amount, include the (x, y, z) padding distances here (shape (3,)). Defaults to None. rgba (npt.ArrayLike): Color of the box (RGB + alpha), shape (4,). Defaults to (1, 0, 0, 0.5). client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: int: Pybullet ID of the box \"\"\" lower , upper = box if padding is not None : lower -= padding upper += padding return create_box ( pos = ( lower + ( upper - lower ) / 2 ), # Midpoint orn = ( 0 , 0 , 0 , 1 ), mass = 0 , sidelengths = ( upper - lower ), use_collision = False , rgba = rgba , client = client , ) Classes Box class Box ( lower : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], upper : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) Representation of a box defined by lower/upper limits on its coordinates Unpackable as (lower, upper) = box Attributes Name Type Description Default lower npt.ArrayLike Lower limits on the box coordinates, shape (box_dim,) None upper npt.ArrayLike Upper limits on the box coordinates, shape (box_dim,) None View Source class Box : \"\"\"Representation of a box defined by lower/upper limits on its coordinates Unpackable as (lower, upper) = box Args: lower (npt.ArrayLike): Lower limits on the box coordinates, shape (box_dim,) upper (npt.ArrayLike): Upper limits on the box coordinates, shape (box_dim,) \"\"\" def __init__ ( self , lower : npt . ArrayLike , upper : npt . ArrayLike ): self . lower = np . ravel ( lower ). astype ( np . float64 ) self . upper = np . ravel ( upper ). astype ( np . float64 ) self . _validate () self . center = ( self . lower + self . upper ) / 2 self . dim = len ( self . lower ) def __iter__ ( self ): return iter ([ self . lower , self . upper ]) def __str__ ( self ): return f \"Lower: {list(self.lower)}, Upper: {list(self.upper)}\" def __repr__ ( self ): return ( f \"{type(self).__name__}(lower={list(self.lower)}, upper={list(self.upper)})\" ) def _validate ( self ): if len ( self . lower ) != len ( self . upper ): raise ValueError ( \"Invalid input dimensions\" ) if np . any ( self . lower >= self . upper ): raise ValueError ( \"Invalid inputs: Mismatched order of lower/upper points\" )","title":"Boxes"},{"location":"reference/pyastrobee/utils/boxes/#module-pyastrobeeutilsboxes","text":"Boxes and associated utility functions These are currently used as the definition of the safe sets in the trajectory optimization Based on: https://github.com/cvxgrp/fastpathplanning/blob/main/fastpathplanning/boxes.py View Source \"\"\"Boxes and associated utility functions These are currently used as the definition of the safe sets in the trajectory optimization Based on: https://github.com/cvxgrp/fastpathplanning/blob/main/fastpathplanning/boxes.py \"\"\" from collections import defaultdict from typing import Optional , Union import numpy as np import numpy.typing as npt import matplotlib.pyplot as plt from pybullet_utils.bullet_client import BulletClient from pyastrobee.utils.bullet_utils import create_box class Box : \"\"\"Representation of a box defined by lower/upper limits on its coordinates Unpackable as (lower, upper) = box Args: lower (npt.ArrayLike): Lower limits on the box coordinates, shape (box_dim,) upper (npt.ArrayLike): Upper limits on the box coordinates, shape (box_dim,) \"\"\" def __init__ ( self , lower : npt . ArrayLike , upper : npt . ArrayLike ): self . lower = np . ravel ( lower ) . astype ( np . float64 ) self . upper = np . ravel ( upper ) . astype ( np . float64 ) self . _validate () self . center = ( self . lower + self . upper ) / 2 self . dim = len ( self . lower ) def __iter__ ( self ): return iter ([ self . lower , self . upper ]) def __str__ ( self ): return f \"Lower: { list ( self . lower ) } , Upper: { list ( self . upper ) } \" def __repr__ ( self ): return ( f \" { type ( self ) . __name__ } (lower= { list ( self . lower ) } , upper= { list ( self . upper ) } )\" ) def _validate ( self ): if len ( self . lower ) != len ( self . upper ): raise ValueError ( \"Invalid input dimensions\" ) if np . any ( self . lower >= self . upper ): raise ValueError ( \"Invalid inputs: Mismatched order of lower/upper points\" ) def expand_box ( box : Box , distance : float ) -> Box : \"\"\"Increases the size of a box by a given distance Args: box (Box): The reference box distance (float): Amount to increase the size of the box in all dimensions Returns: Box: The increased-size box \"\"\" return Box ( box . lower - distance , box . upper + distance ) def contract_box ( box : Box , distance : float ) -> Box : \"\"\"Reduces the size of a box by a given distance Args: box (Box): The reference box distance (float): Amount to decrease the size of the box in all dimensions Returns: Box: The reduced-size box \"\"\" return Box ( box . lower + distance , box . upper - distance ) def intersect_boxes ( b1 : Box , b2 : Box ) -> Box : \"\"\"Calculate the intersection of two boxes Args: b1 (Box): First box b2 (Box): Second box Returns: Box: The intersection region \"\"\" return Box ( np . maximum ( b1 . lower , b2 . lower ), np . minimum ( b1 . upper , b2 . upper )) def check_box_intersection ( b1 : Box , b2 : Box ) -> bool : \"\"\"Evaluate if two boxes intersect or not Args: b1 (Box): First box b2 (Box): Second box Returns: bool: True if the boxes intersect, False if not \"\"\" l = np . maximum ( b1 . lower , b2 . lower ) u = np . minimum ( b1 . upper , b2 . upper ) return np . all ( u >= l ) def is_in_box ( point : npt . ArrayLike , box : Box ) -> bool : \"\"\"Evaluate if a point lies within a box Args: point (npt.ArrayLike): Point to evaluate, shape (box_dim,) box (Box): Box to test Returns: bool: True if the point is inside the bounds of the box, False otherwise \"\"\" assert np . size ( point ) == box . dim return np . all ( point >= box . lower ) and np . all ( point <= box . upper ) def find_containing_box ( point : npt . ArrayLike , boxes : Union [ list [ Box ], npt . ArrayLike ] ) -> Optional [ int ]: \"\"\"Find the index of the first box which contains a certain point Args: point (npt.ArrayLike): Point to evaluate boxes (Union[list[Box], npt.ArrayLike]): Boxes to search. If an array, must be of shape (n_boxes, 2, box_dim) Returns: Optional[int]: Index of the first box which contains the point. None if the point is not in any box \"\"\" for i , box in enumerate ( boxes ): lower , upper = box if np . all ( point >= lower ) and np . all ( point <= upper ): return i return None def find_containing_box_name ( point : npt . ArrayLike , boxes : dict [ str , Box ] ) -> Optional [ str ]: \"\"\"Find the name of the first box which contains a certain point Args: point (npt.ArrayLike): Point to evaluate boxes (dict[str, Box]): Boxes to search. Key/value: (box name) -> box Returns: Optional[str]: Name of the first box which contains the point. None if the point is not in any box \"\"\" for name , box in boxes . items (): if np . all ( point >= box . lower ) and np . all ( point <= box . upper ): return name return None def visualize_3D_box ( box : Union [ Box , npt . ArrayLike ], padding : Optional [ npt . ArrayLike ] = None , rgba : npt . ArrayLike = ( 1 , 0 , 0 , 0.5 ), client : Optional [ BulletClient ] = None , ) -> int : \"\"\"Visualize a box in Pybullet Args: box (Union[Box, npt.ArrayLike]): Box to visualize. If an array, must be of shape (1, 2, box_dim) padding (Optional[npt.ArrayLike]): If expanding (or contracting) the boxes by a certain amount, include the (x, y, z) padding distances here (shape (3,)). Defaults to None. rgba (npt.ArrayLike): Color of the box (RGB + alpha), shape (4,). Defaults to (1, 0, 0, 0.5). client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: int: Pybullet ID of the box \"\"\" lower , upper = box if padding is not None : lower -= padding upper += padding return create_box ( pos = ( lower + ( upper - lower ) / 2 ), # Midpoint orn = ( 0 , 0 , 0 , 1 ), mass = 0 , sidelengths = ( upper - lower ), use_collision = False , rgba = rgba , client = client , ) def plot_2D_box ( box : Box , ax : Optional [ plt . Axes ] = None , show : bool = True , * args , ** kwargs ) -> plt . Axes : \"\"\"Plots the boundary of a 2D box Args: box (Box): 2D box to plot ax (Optional[plt.Axes]): If re-using existing plotting axes, include them here. Defaults to None. show (bool, optional): Whether or not to show the plot. Defaults to True. Returns: plt.Axes: The plotting axes \"\"\" assert box . dim == 2 if ax is None : ax = plt . gca () pts = np . array ( [ box . lower , [ box . lower [ 0 ], box . upper [ 1 ]], box . upper , [ box . upper [ 0 ], box . lower [ 1 ]], box . lower , ] ) ax . plot ( * pts . T , * args , ** kwargs ) if show : plt . show () return ax def compute_graph ( boxes : dict [ str , Box ]) -> dict [ str , list [ str ]]: \"\"\"Computes the graph between a set of boxes Returns: dict[str, list[str]]: Adjacency list / graph dictating safe paths within the boxes. Key/value pair is: (name of the box) -> (list of names of all neighbors of that box) \"\"\" names = list ( boxes . keys ()) n = len ( names ) adj = defaultdict ( list ) for i in range ( n ): for j in range ( i + 1 , n ): if check_box_intersection ( boxes [ names [ i ]], boxes [ names [ j ]]): adj [ names [ i ]] . append ( names [ j ]) adj [ names [ j ]] . append ( names [ i ]) return adj def check_box_containment ( bounding_box : Union [ Box , npt . ArrayLike ], safe_set : list [ Box ] ) -> bool : \"\"\"Determine if the bounding box of an object is fully contained within a safe set Args: bounding_box (Union[Box, npt.ArrayLike]): Axis-aligned bounding box. If ArrayLike, must be of shape (2, 3) e.g. the lower and upper XYZ values defining the box safe_set (list[Box]): Boxes to check containment Returns: bool: True if the bounding box is contained in the safe set, False otherwise \"\"\" return any ( np . all ( bounding_box [ 0 ] > box . lower ) and np . all ( bounding_box [ 1 ] < box . upper ) for box in safe_set )","title":"Module pyastrobee.utils.boxes"},{"location":"reference/pyastrobee/utils/boxes/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/utils/boxes/#check_box_containment","text":"def check_box_containment ( bounding_box : Union [ pyastrobee . utils . boxes . Box , numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], safe_set : list [ pyastrobee . utils . boxes . Box ] ) -> bool Determine if the bounding box of an object is fully contained within a safe set Parameters: Name Type Description Default bounding_box Union[Box, npt.ArrayLike] Axis-aligned bounding box. If ArrayLike, must be of shape (2, 3) e.g. the lower and upper XYZ values defining the box None safe_set list[Box] Boxes to check containment None Returns: Type Description bool True if the bounding box is contained in the safe set, False otherwise View Source def check_box_containment ( bounding_box : Union [ Box, npt.ArrayLike ] , safe_set : list [ Box ] ) -> bool : \"\"\"Determine if the bounding box of an object is fully contained within a safe set Args: bounding_box (Union[Box, npt.ArrayLike]): Axis-aligned bounding box. If ArrayLike, must be of shape (2, 3) e.g. the lower and upper XYZ values defining the box safe_set (list[Box]): Boxes to check containment Returns: bool: True if the bounding box is contained in the safe set, False otherwise \"\"\" return any ( np . all ( bounding_box [ 0 ] > box . lower ) and np . all ( bounding_box [ 1 ] < box . upper ) for box in safe_set )","title":"check_box_containment"},{"location":"reference/pyastrobee/utils/boxes/#check_box_intersection","text":"def check_box_intersection ( b1 : pyastrobee . utils . boxes . Box , b2 : pyastrobee . utils . boxes . Box ) -> bool Evaluate if two boxes intersect or not Parameters: Name Type Description Default b1 Box First box None b2 Box Second box None Returns: Type Description bool True if the boxes intersect, False if not View Source def check_box_intersection ( b1 : Box , b2 : Box ) -> bool : \"\"\"Evaluate if two boxes intersect or not Args: b1 (Box): First box b2 (Box): Second box Returns: bool: True if the boxes intersect, False if not \"\"\" l = np . maximum ( b1 . lower , b2 . lower ) u = np . minimum ( b1 . upper , b2 . upper ) return np . all ( u >= l )","title":"check_box_intersection"},{"location":"reference/pyastrobee/utils/boxes/#compute_graph","text":"def compute_graph ( boxes : dict [ str , pyastrobee . utils . boxes . Box ] ) -> dict [ str , list [ str ]] Computes the graph between a set of boxes Returns: Type Description dict[str, list[str]] Adjacency list / graph dictating safe paths within the boxes. Key/value pair is: (name of the box) -> (list of names of all neighbors of that box) View Source def compute_graph ( boxes : dict [ str, Box ] ) -> dict [ str, list[str ] ]: \"\"\"Computes the graph between a set of boxes Returns: dict[str, list[str]]: Adjacency list / graph dictating safe paths within the boxes. Key/value pair is: (name of the box) -> (list of names of all neighbors of that box) \"\"\" names = list ( boxes . keys ()) n = len ( names ) adj = defaultdict ( list ) for i in range ( n ) : for j in range ( i + 1 , n ) : if check_box_intersection ( boxes [ names[i ] ] , boxes [ names[j ] ] ) : adj [ names[i ] ] . append ( names [ j ] ) adj [ names[j ] ] . append ( names [ i ] ) return adj","title":"compute_graph"},{"location":"reference/pyastrobee/utils/boxes/#contract_box","text":"def contract_box ( box : pyastrobee . utils . boxes . Box , distance : float ) -> pyastrobee . utils . boxes . Box Reduces the size of a box by a given distance Parameters: Name Type Description Default box Box The reference box None distance float Amount to decrease the size of the box in all dimensions None Returns: Type Description Box The reduced-size box View Source def contract_box ( box : Box , distance : float ) -> Box : \"\"\"Reduces the size of a box by a given distance Args: box (Box): The reference box distance (float): Amount to decrease the size of the box in all dimensions Returns: Box: The reduced-size box \"\"\" return Box ( box . lower + distance , box . upper - distance )","title":"contract_box"},{"location":"reference/pyastrobee/utils/boxes/#expand_box","text":"def expand_box ( box : pyastrobee . utils . boxes . Box , distance : float ) -> pyastrobee . utils . boxes . Box Increases the size of a box by a given distance Parameters: Name Type Description Default box Box The reference box None distance float Amount to increase the size of the box in all dimensions None Returns: Type Description Box The increased-size box View Source def expand_box ( box : Box , distance : float ) -> Box : \"\"\"Increases the size of a box by a given distance Args: box (Box): The reference box distance (float): Amount to increase the size of the box in all dimensions Returns: Box: The increased-size box \"\"\" return Box ( box . lower - distance , box . upper + distance )","title":"expand_box"},{"location":"reference/pyastrobee/utils/boxes/#find_containing_box","text":"def find_containing_box ( point : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], boxes : Union [ list [ pyastrobee . utils . boxes . Box ], numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> Optional [ int ] Find the index of the first box which contains a certain point Parameters: Name Type Description Default point npt.ArrayLike Point to evaluate None boxes Union[list[Box], npt.ArrayLike] Boxes to search. If an array, must be of shape (n_boxes, 2, box_dim) None Returns: Type Description Optional[int] Index of the first box which contains the point. None if the point is not in any box View Source def find_containing_box ( point : npt . ArrayLike , boxes : Union [ list[Box ] , npt . ArrayLike ] ) -> Optional [ int ] : \"\"\"Find the index of the first box which contains a certain point Args: point (npt.ArrayLike): Point to evaluate boxes (Union[list[Box], npt.ArrayLike]): Boxes to search. If an array, must be of shape (n_boxes, 2, box_dim) Returns: Optional[int]: Index of the first box which contains the point. None if the point is not in any box \"\"\" for i , box in enumerate ( boxes ) : lower , upper = box if np . all ( point >= lower ) and np . all ( point <= upper ) : return i return None","title":"find_containing_box"},{"location":"reference/pyastrobee/utils/boxes/#find_containing_box_name","text":"def find_containing_box_name ( point : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], boxes : dict [ str , pyastrobee . utils . boxes . Box ] ) -> Optional [ str ] Find the name of the first box which contains a certain point Parameters: Name Type Description Default point npt.ArrayLike Point to evaluate None boxes dict[str, Box] Boxes to search. Key/value: (box name) -> box None Returns: Type Description Optional[str] Name of the first box which contains the point. None if the point is not in any box View Source def find_containing_box_name ( point : npt . ArrayLike , boxes : dict [ str, Box ] ) -> Optional [ str ] : \"\"\"Find the name of the first box which contains a certain point Args: point (npt.ArrayLike): Point to evaluate boxes (dict[str, Box]): Boxes to search. Key/value: (box name) -> box Returns: Optional[str]: Name of the first box which contains the point. None if the point is not in any box \"\"\" for name , box in boxes . items () : if np . all ( point >= box . lower ) and np . all ( point <= box . upper ) : return name return None","title":"find_containing_box_name"},{"location":"reference/pyastrobee/utils/boxes/#intersect_boxes","text":"def intersect_boxes ( b1 : pyastrobee . utils . boxes . Box , b2 : pyastrobee . utils . boxes . Box ) -> pyastrobee . utils . boxes . Box Calculate the intersection of two boxes Parameters: Name Type Description Default b1 Box First box None b2 Box Second box None Returns: Type Description Box The intersection region View Source def intersect_boxes ( b1: Box , b2: Box ) -> Box: \"\"\"Calculate the intersection of two boxes Args: b1 ( Box ) : First box b2 ( Box ) : Second box Returns: Box: The intersection region \"\"\" return Box ( np . maximum ( b1 . lower , b2 . lower ), np . minimum ( b1 . upper , b2 . upper ))","title":"intersect_boxes"},{"location":"reference/pyastrobee/utils/boxes/#is_in_box","text":"def is_in_box ( point : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], box : pyastrobee . utils . boxes . Box ) -> bool Evaluate if a point lies within a box Parameters: Name Type Description Default point npt.ArrayLike Point to evaluate, shape (box_dim,) None box Box Box to test None Returns: Type Description bool True if the point is inside the bounds of the box, False otherwise View Source def is_in_box ( point : npt . ArrayLike , box : Box ) -> bool : \"\"\"Evaluate if a point lies within a box Args: point (npt.ArrayLike): Point to evaluate, shape (box_dim,) box (Box): Box to test Returns: bool: True if the point is inside the bounds of the box, False otherwise \"\"\" assert np . size ( point ) == box . dim return np . all ( point >= box . lower ) and np . all ( point <= box . upper )","title":"is_in_box"},{"location":"reference/pyastrobee/utils/boxes/#plot_2d_box","text":"def plot_2D_box ( box : pyastrobee . utils . boxes . Box , ax : Optional [ matplotlib . axes . _axes . Axes ] = None , show : bool = True , * args , ** kwargs ) -> matplotlib . axes . _axes . Axes Plots the boundary of a 2D box Parameters: Name Type Description Default box Box 2D box to plot None ax Optional[plt.Axes] If re-using existing plotting axes, include them here. Defaults to None. None show bool Whether or not to show the plot. Defaults to True. True Returns: Type Description plt.Axes The plotting axes View Source def plot_2D_box( box: Box, ax: Optional[plt.Axes] = None, show: bool = True, *args, * *kwargs ) -> plt.Axes: \"\"\"Plots the boundary of a 2D box Args: box (Box): 2D box to plot ax (Optional[plt.Axes]): If re-using existing plotting axes, include them here. Defaults to None. show (bool, optional): Whether or not to show the plot. Defaults to True. Returns: plt.Axes: The plotting axes \"\"\" assert box.dim == 2 if ax is None: ax = plt.gca() pts = np.array( [ box.lower, [box.lower[0], box.upper[1]], box.upper, [box.upper[0], box.lower[1]], box.lower, ] ) ax.plot(*pts.T, *args, * *kwargs) if show: plt.show() return ax","title":"plot_2D_box"},{"location":"reference/pyastrobee/utils/boxes/#visualize_3d_box","text":"def visualize_3D_box ( box : Union [ pyastrobee . utils . boxes . Box , numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], padding : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , rgba : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 1 , 0 , 0 , 0.5 ), client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> int Visualize a box in Pybullet Parameters: Name Type Description Default box Union[Box, npt.ArrayLike] Box to visualize. If an array, must be of shape (1, 2, box_dim) None padding Optional[npt.ArrayLike] If expanding (or contracting) the boxes by a certain amount, include the (x, y, z) padding distances here (shape (3,)). Defaults to None. None rgba npt.ArrayLike Color of the box (RGB + alpha), shape (4,). Defaults to (1, 0, 0, 0.5). (1, 0, 0, 0.5) client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Returns: Type Description int Pybullet ID of the box View Source def visualize_3D_box ( box : Union [ Box, npt.ArrayLike ] , padding : Optional [ npt.ArrayLike ] = None , rgba : npt . ArrayLike = ( 1 , 0 , 0 , 0.5 ), client : Optional [ BulletClient ] = None , ) -> int : \"\"\"Visualize a box in Pybullet Args: box (Union[Box, npt.ArrayLike]): Box to visualize. If an array, must be of shape (1, 2, box_dim) padding (Optional[npt.ArrayLike]): If expanding (or contracting) the boxes by a certain amount, include the (x, y, z) padding distances here (shape (3,)). Defaults to None. rgba (npt.ArrayLike): Color of the box (RGB + alpha), shape (4,). Defaults to (1, 0, 0, 0.5). client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: int: Pybullet ID of the box \"\"\" lower , upper = box if padding is not None : lower -= padding upper += padding return create_box ( pos = ( lower + ( upper - lower ) / 2 ), # Midpoint orn = ( 0 , 0 , 0 , 1 ), mass = 0 , sidelengths = ( upper - lower ), use_collision = False , rgba = rgba , client = client , )","title":"visualize_3D_box"},{"location":"reference/pyastrobee/utils/boxes/#classes","text":"","title":"Classes"},{"location":"reference/pyastrobee/utils/boxes/#box","text":"class Box ( lower : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], upper : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) Representation of a box defined by lower/upper limits on its coordinates Unpackable as (lower, upper) = box","title":"Box"},{"location":"reference/pyastrobee/utils/boxes/#attributes","text":"Name Type Description Default lower npt.ArrayLike Lower limits on the box coordinates, shape (box_dim,) None upper npt.ArrayLike Upper limits on the box coordinates, shape (box_dim,) None View Source class Box : \"\"\"Representation of a box defined by lower/upper limits on its coordinates Unpackable as (lower, upper) = box Args: lower (npt.ArrayLike): Lower limits on the box coordinates, shape (box_dim,) upper (npt.ArrayLike): Upper limits on the box coordinates, shape (box_dim,) \"\"\" def __init__ ( self , lower : npt . ArrayLike , upper : npt . ArrayLike ): self . lower = np . ravel ( lower ). astype ( np . float64 ) self . upper = np . ravel ( upper ). astype ( np . float64 ) self . _validate () self . center = ( self . lower + self . upper ) / 2 self . dim = len ( self . lower ) def __iter__ ( self ): return iter ([ self . lower , self . upper ]) def __str__ ( self ): return f \"Lower: {list(self.lower)}, Upper: {list(self.upper)}\" def __repr__ ( self ): return ( f \"{type(self).__name__}(lower={list(self.lower)}, upper={list(self.upper)})\" ) def _validate ( self ): if len ( self . lower ) != len ( self . upper ): raise ValueError ( \"Invalid input dimensions\" ) if np . any ( self . lower >= self . upper ): raise ValueError ( \"Invalid inputs: Mismatched order of lower/upper points\" )","title":"Attributes"},{"location":"reference/pyastrobee/utils/bullet_utils/","text":"Module pyastrobee.utils.bullet_utils Pybullet-specific helper functions View Source \"\"\"Pybullet-specific helper functions\"\"\" import os import time from typing import Optional , Union import struct import numpy as np import numpy.typing as npt import pybullet import pybullet_data from pybullet_utils.bullet_client import BulletClient from pyastrobee.utils.mesh_utils import get_mesh_data from pyastrobee.utils.python_utils import print_red def load_rigid_object ( filename : str , texture_filename : Optional [ str ] = None , scale : float = 1.0 , pos : npt . ArrayLike = ( 0.0 , 0.0 , 0.0 ), orn : npt . ArrayLike = ( 0.0 , 0.0 , 0.0 , 1.0 ), mass : float = 1.0 , fixed : bool = False , rgba : npt . ArrayLike = ( 1.0 , 1.0 , 1.0 , 1.0 ), client : Optional [ BulletClient ] = None , ) -> int : \"\"\"Loads a rigid object from an OBJ or URDF file Args: filename (str): Path to the OBJ/URDF file to load texture_filename (str, optional): Path to a texture file to apply. Defaults to None, in which case no texture will be applied scale (float, optional): Scaling factor for the loaded object. Defaults to 1.0. pos (npt.ArrayLike, optional): Initial position for the loaded object. Defaults to (0, 0, 0). orn (npt.ArrayLike, optional): Initial XYZW quaternion orientation. Defaults to (0, 0, 0, 1). mass (float, optional): Mass of the loaded object. Defaults to 1.0. fixed (bool, optional): Whether or not to fix the object in space. Defaults to False. rgba (npt.ArrayLike, optional): Color of the object, expressed as RGBA, each within range [0, 1]. Defaults to (1.0, 1.0, 1.0, 1.0) (white). client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Raises: ValueError: If the filename is not a valid OBJ or URDF Returns: int: ID number for the object \"\"\" client : pybullet = pybullet if client is None else client # Deal with pybullet's weird handling of mass = 0 being fixed if mass < 0 : raise ValueError ( \"Mass should not be a negative value\" ) if mass == 0 : print_red ( f \"Warning: the mass of { filename } is 0, which will make it fixed. Use the 'fixed' parameter instead\" ) if fixed : mass = 0.0 if filename . endswith ( \".obj\" ): # mesh info xyz_scale = [ scale , scale , scale ] visual_id = client . createVisualShape ( shapeType = pybullet . GEOM_MESH , rgbaColor = rgba , fileName = filename , meshScale = xyz_scale , ) collision_id = client . createCollisionShape ( shapeType = pybullet . GEOM_MESH , fileName = filename , meshScale = xyz_scale ) rigid_id = client . createMultiBody ( baseMass = mass , # mass==0 => fixed at position where it is loaded basePosition = pos , baseCollisionShapeIndex = collision_id , baseVisualShapeIndex = visual_id , baseOrientation = orn , ) elif filename . endswith ( \".urdf\" ): # URDF file rigid_id = client . loadURDF ( filename , pos , orn , useFixedBase = fixed , globalScaling = scale , ) else : raise ValueError ( f \"Invalid filename: { filename } . Import either an OBJ or URDF file\" ) # TODO: decide if these parameters should be included as inputs rather than hard-coded client . changeDynamics ( rigid_id , - 1 , mass , lateralFriction = 1.0 , spinningFriction = 1.0 , rollingFriction = 1.0 , restitution = 0.0 , ) if texture_filename is not None : add_texture_to_rigid ( rigid_id , texture_filename , client ) return rigid_id def add_texture_to_rigid ( object_id : int , texture_filename : str , client : Optional [ BulletClient ] = None , ) -> None : \"\"\"Applies a texture to a rigid object Args: object_id (int): The ID of the rigid object in the pybullet simulation texture_filename (str): Path to the texture file client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" client : pybullet = pybullet if client is None else client texture_id = client . loadTexture ( texture_filename ) kwargs = {} if hasattr ( pybullet , \"VISUAL_SHAPE_DOUBLE_SIDED\" ): kwargs [ \"flags\" ] = pybullet . VISUAL_SHAPE_DOUBLE_SIDED num_joints = client . getNumJoints ( object_id ) # TODO: check on the indexing here (for now, assuming dedo is correct) for i in range ( - 1 , num_joints ): client . changeVisualShape ( object_id , i , rgbaColor = [ 1 , 1 , 1 , 1 ], textureUniqueId = texture_id , ** kwargs , ) def add_texture_to_deformable ( object_id : int , texture_filename : str , client : Optional [ BulletClient ] = None , ) -> None : \"\"\"Applies a texture to a deformable object Args: object_id (int): The ID of the deformable object in the pybullet simulation texture_filename (str): Path to the texture file client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" client : pybullet = pybullet if client is None else client texture_id = client . loadTexture ( texture_filename ) kwargs = {} if hasattr ( pybullet , \"VISUAL_SHAPE_DOUBLE_SIDED\" ): kwargs [ \"flags\" ] = pybullet . VISUAL_SHAPE_DOUBLE_SIDED client . changeVisualShape ( object_id , - 1 , rgbaColor = [ 1 , 1 , 1 , 1 ], textureUniqueId = texture_id , ** kwargs ) def load_deformable_object ( filename : str , texture_filename : Optional [ str ] = None , scale : float = 1.0 , pos : npt . ArrayLike = ( 0.0 , 0.0 , 0.0 ), orn : npt . ArrayLike = ( 0.0 , 0.0 , 0.0 , 1.0 ), mass : float = 1.0 , bending_stiffness : float = 50.0 , damping_stiffness : float = 0.1 , elastic_stiffness : float = 50.0 , friction_coeff : float = 0.1 , self_collision : bool = False , sim_file_name = \"\" , client : Optional [ BulletClient ] = None , ) -> int : \"\"\"Loads a deformable object from an OBJ file Notes: bending and elastic stiffness >90 cause instabilities. Args: filename (str): Path to the deformable object to load texture_filename (str, optional): Path to a texture file to apply. Defaults to None, in which case no texture will be applied scale (float, optional): Scaling factor for the loaded object. Defaults to 1.0. pos (npt.ArrayLike, optional): Initial position for the loaded object. Defaults to (0.0, 0.0, 0.0). orn (npt.ArrayLike, optional): Initial XYZW quaternion orientation. Defaults to (0, 0, 0, 1). mass (float, optional): Mass of the loaded object. Defaults to 1.0 (Keeping at 1.0 is the most stable option). bending_stiffness (float, optional): Bending stiffness of the loaded object. Defaults to 1.0. damping_stiffness (float, optional): Damping stiffness of the loaded object. Defaults to 0.1. elastic_stiffness (float, optional): Elastic stiffness of the loaded object. Defaults to 1.0. friction_coeff (float, optional): Friction coefficient of the loaded object. Defaults to 0.1. self_collision (bool, optional): Whether or not to allow self-collisions for the object. Defaults to False. Note: setting this as True seemed to lead to mesh collapse sim_file_name (str, optional): This is an undocumented input to loadSoftBody, but it appears to allow you to load an OBJ in the filename (for texture purposes) and a corresponding VTK in the simFileName for volumetric softbody physics client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: int: ID number for the object \"\"\" client : pybullet = pybullet if client is None else client if mass < 1.0 : print_red ( \"Warning: mass > 1 is the most stable for deformables. Small mass can cause instabilities\" ) # TODO: decide if some of these parameters should be included as inputs rather than hard-coded deform_id = client . loadSoftBody ( mass = mass , fileName = filename , scale = scale , basePosition = list ( pos ), baseOrientation = list ( orn ), springElasticStiffness = elastic_stiffness , springDampingStiffness = damping_stiffness , springBendingStiffness = bending_stiffness , frictionCoeff = friction_coeff , # collisionMargin=0.003, # how far apart do two objects begin interacting useSelfCollision = self_collision , springDampingAllDirections = 1 , useFaceContact = True , useNeoHookean = 0 , useMassSpring = True , useBendingSprings = True , # repulsionStiffness=10000000, simFileName = sim_file_name , ) # TODO figure out what this sparseSdfVoxelSize parameter actually does (it's not documented) # See pybullet examples/deformable_anchor.py for its usage there client . setPhysicsEngineParameter ( sparseSdfVoxelSize = 0.25 ) if texture_filename is not None : add_texture_to_deformable ( deform_id , texture_filename , client ) # Validate the size of the mesh to assure stability num_mesh_vertices = get_mesh_data ( deform_id , client )[ 0 ] if num_mesh_vertices > 2 ** 13 : print_red ( f \"Warning: high number of mesh vertices: { num_mesh_vertices } . Consider a lower-res mesh\" ) return deform_id def initialize_pybullet ( use_gui : bool = True , physics_freq : float = 350 , gravity : float = 0.0 , bg_color : npt . ArrayLike = ( 0.0 , 0.0 , 0.0 ), ) -> pybullet : \"\"\"Starts a pybullet client with the required physics parameters we care about NOTE: the client object returned from this function should ALWAYS be assigned to a variable to keep the simulation in scope. i.e. don't just call initialize_pybullet(), use client = initialize_pybullet() even if you're not worrying about multiple physics simulations Args: use_gui (bool, optional): Whether or not to use the GUI as opposed to headless. Defaults to True physics_freq (float, optional): Physics simulation frequency, in Hz. Defaults to 350. Note: Pybullet defaults to 240 Hz, but this seemed to be unstable for soft bodies gravity (float, optional): Z component of gravitational acceleration vector. Defaults to 0. bg_color (npt.ArrayLike, optional): RGB values for the GUI background, each in range [0, 1]. Defaults to (0.0, 0.0, 0.0) (black). Note: (1.0, 1.0, 1.0) is white Returns: BulletClient: Pybullet physics simulation client \"\"\" # Make sure we're in the right directory so filepaths work well with pybullet cwd = os . getcwd () if not cwd . endswith ( \"pyastrobee\" ) or cwd . endswith ( \"pyastrobee/pyastrobee\" ): raise ConnectionRefusedError ( f \"You are running scripts from { cwd } . \\n Ensure you're at the top-level pyastrobee directory.\" ) # Ensure that the background color values are within the proper range bg_color = np . array ( bg_color ) if len ( bg_color ) != 3 or not ( all ( bg_color >= 0 ) and all ( bg_color <= 1 )): raise ValueError ( f \"Invalid background color: { bg_color } \" ) bg_args = ( f \"--background_color_red= { bg_color [ 0 ] } \" + f \"--background_color_green= { bg_color [ 1 ] } \" + f \"--background_color_blue= { bg_color [ 2 ] } \" ) # Connect to pybullet connection_mode = pybullet . GUI if use_gui else pybullet . DIRECT client : pybullet = BulletClient ( connection_mode , options = bg_args ) # Configure physics client . resetSimulation ( pybullet . RESET_USE_DEFORMABLE_WORLD ) client . setTimeStep ( 1.0 / physics_freq ) client . setGravity ( 0 , 0 , gravity ) # Configure search paths client . setAdditionalSearchPath ( pybullet_data . getDataPath ()) # client.setAdditionalSearchPath(os.path.join(os.getcwd(), \"pyastrobee/assets\")) client . setAdditionalSearchPath ( cwd ) # Remove the extra windows in PyBullet GUI (until we use them for cameras). client . configureDebugVisualizer ( pybullet . COV_ENABLE_GUI , False ) return client def configure_visualization ( camera_params : Optional [ list [ float ]] = None , flags_to_enable : Optional [ list [ float ]] = None , flags_to_disable : Optional [ list [ float ]] = None , client : Optional [ BulletClient ] = None , ** kwargs , ) -> None : \"\"\"Configures the pybullet debug visualizer Args: camera_params (list[float], optional): Used to reset camera position. [dist, pitch, yaw, pos_x, pos_y, pos_z] where dist is the distance from eye to camera target, yaw is left/right angle, pitch is up/down angle, and the xyz positions are for the focus point. Defaults to None. flags_to_enable (list[float], optional): A list of pybullet flags (for example, COV_ENABLE_WIREFRAME). Defaults to None. flags_to_disable (list[float], optional): A list of pybullet flags (for example, COV_ENABLE_WIREFRAME). Defaults to None. client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) **kwargs: Any additional kwargs to set. See the pybullet configureDebugVisualizer documentation for more info \"\"\" client : pybullet = pybullet if client is None else client if camera_params : dist , pitch , yaw , pos_x , pos_y , pos_z = camera_params client . resetDebugVisualizerCamera ( cameraDistance = dist , cameraPitch = pitch , cameraYaw = yaw , cameraTargetPosition = [ pos_x , pos_y , pos_z ], ) if flags_to_enable : for flag in flags_to_enable : client . configureDebugVisualizer ( flag , True ) if flags_to_disable : for flag in flags_to_disable : client . configureDebugVisualizer ( flag , False ) if kwargs : client . configureDebugVisualizer ( ** kwargs ) def load_floor ( texture_filename : Optional [ str ] = None , z_pos : float = 0.0 , client : Optional [ BulletClient ] = None , ) -> int : \"\"\"Loads a floor into the pybullet simulation Args: texture_filename (str, optional): If adding a texture to the floor plane, pass in the filename. Defaults to None. z_pos (float, optional): Height (z-coordinate) of the floor in the world. Defaults to 0.0 client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: int: Pybullet ID corresponding to the floor \"\"\" client : pybullet = pybullet if client is None else client client . setAdditionalSearchPath ( pybullet_data . getDataPath ()) floor_id = client . loadURDF ( \"plane.urdf\" , basePosition = [ 0 , 0 , z_pos ]) if texture_filename is not None : texture_id = client . loadTexture ( texture_filename ) client . changeVisualShape ( floor_id , - 1 , rgbaColor = [ 1 , 1 , 1 , 0 ], textureUniqueId = texture_id , ) return floor_id def run_sim ( viz_freq : float = 240 , timeout : Optional [ float ] = None , client : Optional [ BulletClient ] = None , ): \"\"\"Runs the pybullet simulation Args: viz_freq (float, optional): Frequency (Hz) to run the visualization (if connected via GUI). Defaults to 240. timeout (float, optional): Amount of time to run the simulation. Defaults to None, in which case the simulation will remain open until it is killed manually. client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Raises: ConnectionError: If a pybullet client is not currently running ValueError: If the visualization frequency is greater than the physics frequency \"\"\" client : pybullet = pybullet if client is None else client connect_info : dict [ str , int ] = client . getConnectionInfo () if not connect_info [ \"isConnected\" ]: raise ConnectionError ( \"Connect to a pybullet client before running the sim\" ) connect_mode = \"GUI\" if connect_info [ \"connectionMethod\" ] == 1 else \"DIRECT\" phys_info = client . getPhysicsEngineParameters () phys_freq = 1.0 / phys_info [ \"fixedTimeStep\" ] if viz_freq > phys_freq : raise ValueError ( f \"Cannot visualize ( { viz_freq } Hz) faster than the physics ( { phys_freq } Hz)\" ) if timeout is None : timeout = float ( \"inf\" ) start_time = time . time () try : while ( time . time () - start_time < timeout ) and client . isConnected (): client . stepSimulation () if connect_mode == \"GUI\" : time . sleep ( 1.0 / viz_freq ) finally : client . disconnect () def create_sphere ( pos : npt . ArrayLike , mass : float , radius : float , use_collision : bool , rgba : npt . ArrayLike = ( 1 , 1 , 1 , 1 ), client : Optional [ BulletClient ] = None , ) -> int : \"\"\"Creates a rigid sphere in the Pybullet simulation Args: pos (npt.ArrayLike): Position of the sphere in world frame, shape (3) mass (float): Mass of the sphere. If set to 0, the sphere is fixed in space radius (float): Radius of the sphere use_collision (bool): Whether or not collision is enabled for the sphere rgba (npt.ArrayLike, optional): Color of the sphere, with each RGBA value being in [0, 1]. Defaults to (1, 1, 1, 1) (white) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: int: ID of the sphere in Pybullet \"\"\" client : pybullet = pybullet if client is None else client visual_id = client . createVisualShape ( pybullet . GEOM_SPHERE , radius = radius , rgbaColor = rgba ) if use_collision : collision_id = client . createCollisionShape ( pybullet . GEOM_SPHERE , radius = radius ) else : collision_id = - 1 sphere_id = client . createMultiBody ( baseMass = mass , basePosition = pos , baseCollisionShapeIndex = collision_id , baseVisualShapeIndex = visual_id , ) return sphere_id def create_anchor ( soft_body_id : int , vertex_id : int , parent_id : int , link_id : int , parent_frame_pos : Optional [ list [ float ]] = None , add_geom : bool = False , geom_pos : Optional [ npt . ArrayLike ] = None , client : Optional [ BulletClient ] = None , ) -> tuple [ int , Optional [ int ]]: \"\"\"Creates an anchor between a softbody and another object (or the world) Args: soft_body_id (int): ID of the softbody in Pybullet vertex_id (int): Index of the mesh vertex on the softbody we are anchoring to parent_id (int): ID of the parent object in Pybullet. If anchoring to world, this will be -1 link_id (int): Index of the link on the parent object. If the parent does not have links, use -1 parent_frame_pos (Optional[list[float]]): If the anchor is being affixed to a specific point on the parent object, pass in the location here. Defaults to None. add_geom (bool, optional): Whether or not to add a small sphere to visualize the positioning on the anchor. Defaults to False. geom_pos (Optional[npt.ArrayLike]): Position of the sphere in world frame, shape (3,). Defaults to None, (in which case add_geom must also be None) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: tuple[int, Optional[int]]: int: The Pybullet ID for the anchor Optional[int]: The Pybullet ID for the geometry (if add_geom is False, this is None) \"\"\" client : pybullet = pybullet if client is None else client anchor_id = client . createSoftBodyAnchor ( soft_body_id , vertex_id , parent_id , link_id , parent_frame_pos ) if add_geom : if geom_pos is None : raise ValueError ( \"If visualizing the anchor, the world-position of the anchor must be included\" ) # Create a collision-less sphere to visualize the anchor position geom_id = create_sphere ( geom_pos , 0.01 , 0.01 , False , [ 0 , 1 , 0 , 0.5 ], client ) # Then create a secondary anchor to make sure this sphere stays in the right place geom_anchor_id = client . createSoftBodyAnchor ( soft_body_id , vertex_id , geom_id , - 1 ) else : geom_id = None return anchor_id , geom_id def create_box ( pos : npt . ArrayLike , orn : npt . ArrayLike , mass : float , sidelengths : npt . ArrayLike , use_collision : bool , rgba : npt . ArrayLike = ( 1 , 1 , 1 , 1 ), client : Optional [ BulletClient ] = None , ) -> int : \"\"\"Creates a rigid box in the Pybullet simulation Args: pos (npt.ArrayLike): Position of the box in world frame, shape (3) orn (npt.ArrayLike): Orientation (XYZW quaternion) of the box in world frame, shape (4,) mass (float): Mass of the box. If set to 0, the box is fixed in space sidelengths (npt.ArrayLike): Sidelengths of the box along the local XYZ axes, shape (3,) use_collision (bool): Whether or not collision is enabled for the box rgba (npt.ArrayLike, optional): Color of the box, with each RGBA value being in [0, 1]. Defaults to (1, 1, 1, 1) (white) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: int: ID of the box in Pybullet \"\"\" client : pybullet = pybullet if client is None else client if len ( sidelengths ) != 3 : raise ValueError ( \"Must provide the dimensions of the three sides of the box\" ) half_extents = np . asarray ( sidelengths ) / 2 visual_id = client . createVisualShape ( pybullet . GEOM_BOX , halfExtents = half_extents , rgbaColor = rgba , ) if use_collision : collision_id = client . createCollisionShape ( pybullet . GEOM_BOX , halfExtents = half_extents , ) else : collision_id = - 1 box_id = client . createMultiBody ( baseMass = mass , basePosition = pos , baseOrientation = orn , baseCollisionShapeIndex = collision_id , baseVisualShapeIndex = visual_id , ) return box_id def read_log_file ( filename : str , verbose : bool = False ) -> list [ list [ Union [ int , float ]]]: \"\"\"Reads a Pybullet state log for generic robots and objects We assume that when generating the log: - The loggingType was set to STATE_LOGGING_GENERIC_ROBOT - No softbodies were included in the logged items - The maxLogDof is left at the default value (12) This code is modified from bullet3/examples/pybullet/examples/kuka_with_cube_playback.py Args: filename (str): Filename for the saved log verbose (bool, optional): Whether to print info about the log when reading. Defaults to False. Returns: list[list[Union[int, float]]]: The Pybullet log. Length is (number of timesteps) * (number of objects logged) If multiple objects are logged, there will be multiple consecutive log entries for the same timestep Each record in the log contains the following info: step_count = record[0] timestamp = record[1] unique_id = record[2] position = record[3:6] orientation = record[6:10] velocity = record[10:13] angular_velocity = record[13:16] num_joints = record[16] joint_positions = record[17 : 17 + max_log_dof] joint_torques = record[17 + max_log_dof :] \"\"\" with open ( filename , \"rb\" ) as f : keys = f . readline () . decode ( \"utf8\" ) . rstrip ( \" \\n \" ) . split ( \",\" ) fmt = f . readline () . decode ( \"utf8\" ) . rstrip ( \" \\n \" ) # The byte number of one record sz = struct . calcsize ( fmt ) # The type number of one record ncols = len ( fmt ) info = { \"filename\" : filename , \"keys\" : keys , \"format\" : fmt , \"size\" : sz , \"columns\" : ncols , } if verbose : print ( info ) # Read data whole_file = f . read () # split by alignment word chunks = whole_file . split ( b \" \\xaa\\xbb \" ) log = [] for chunk in chunks : if len ( chunk ) == sz : values = struct . unpack ( fmt , chunk ) record = [] for i in range ( ncols ): record . append ( values [ i ]) log . append ( record ) return log # TODO determine if this really is real time or if it's sim time during the original run... def playback_from_log ( log_file : str , real_time : bool = True , client : Optional [ BulletClient ] = None , ) -> None : \"\"\"Reads a log file and then replays that logged simulation We assume that the environment has been set up the same way as the original environment when the logging occurred. If this is not the case, it can lead to odd results The logs also contain a lot more info like velocities and torques, but we don't really need this information to play things back (simply resetting pose will appear correct) This code is modified from bullet3/examples/pybullet/examples/kuka_with_cube_playback.py Args: log_file (str): Filename for the saved log real_time (bool, optional): Whether to play back the log in real time (according to the timestamps saved in the log). Defaults to True. If False, things will be very speedy client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" client : pybullet = pybullet if client is None else client log = read_log_file ( log_file ) start_time = time . time () for record in log : timestamp = record [ 1 ] uid = record [ 2 ] pos = record [ 3 : 6 ] orn = record [ 6 : 10 ] client . resetBasePositionAndOrientation ( uid , pos , orn ) num_joints = client . getNumJoints ( uid ) for i in range ( num_joints ): joint_info = client . getJointInfo ( uid , i ) q_index = joint_info [ 3 ] if q_index > - 1 : client . resetJointState ( uid , i , record [ q_index - 7 + 17 ]) if real_time : time . sleep ( max ( 0 , timestamp - time . time () + start_time )) Functions add_texture_to_deformable def add_texture_to_deformable ( object_id : int , texture_filename : str , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> None Applies a texture to a deformable object Parameters: Name Type Description Default object_id int The ID of the deformable object in the pybullet simulation None texture_filename str Path to the texture file None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None View Source def add_texture_to_deformable ( object_id : int , texture_filename : str , client : Optional [ BulletClient ] = None , ) -> None : \"\"\"Applies a texture to a deformable object Args: object_id (int): The ID of the deformable object in the pybullet simulation texture_filename (str): Path to the texture file client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" client : pybullet = pybullet if client is None else client texture_id = client . loadTexture ( texture_filename ) kwargs = {} if hasattr ( pybullet , \"VISUAL_SHAPE_DOUBLE_SIDED\" ) : kwargs [ \"flags\" ] = pybullet . VISUAL_SHAPE_DOUBLE_SIDED client . changeVisualShape ( object_id , - 1 , rgbaColor =[ 1, 1, 1, 1 ] , textureUniqueId = texture_id , ** kwargs ) add_texture_to_rigid def add_texture_to_rigid ( object_id : int , texture_filename : str , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> None Applies a texture to a rigid object Parameters: Name Type Description Default object_id int The ID of the rigid object in the pybullet simulation None texture_filename str Path to the texture file None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None View Source def add_texture_to_rigid ( object_id : int , texture_filename : str , client : Optional [ BulletClient ] = None , ) -> None : \"\"\"Applies a texture to a rigid object Args: object_id (int): The ID of the rigid object in the pybullet simulation texture_filename (str): Path to the texture file client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" client : pybullet = pybullet if client is None else client texture_id = client . loadTexture ( texture_filename ) kwargs = {} if hasattr ( pybullet , \"VISUAL_SHAPE_DOUBLE_SIDED\" ) : kwargs [ \"flags\" ] = pybullet . VISUAL_SHAPE_DOUBLE_SIDED num_joints = client . getNumJoints ( object_id ) # TODO : check on the indexing here ( for now , assuming dedo is correct ) for i in range ( - 1 , num_joints ) : client . changeVisualShape ( object_id , i , rgbaColor =[ 1, 1, 1, 1 ] , textureUniqueId = texture_id , ** kwargs , ) configure_visualization def configure_visualization ( camera_params : Optional [ list [ float ]] = None , flags_to_enable : Optional [ list [ float ]] = None , flags_to_disable : Optional [ list [ float ]] = None , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None , ** kwargs ) -> None Configures the pybullet debug visualizer Parameters: Name Type Description Default camera_params list[float] Used to reset camera position. [dist, pitch, yaw, pos_x, pos_y, pos_z] where dist is the distance from eye to camera target, yaw is left/right angle, pitch is up/down angle, and the xyz positions are for the focus point. Defaults to None. None flags_to_enable list[float] A list of pybullet flags (for example, COV_ENABLE_WIREFRAME). Defaults to None. None flags_to_disable list[float] A list of pybullet flags (for example, COV_ENABLE_WIREFRAME). Defaults to None. None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None **kwargs None Any additional kwargs to set. See the pybullet configureDebugVisualizer documentation for more info None View Source def configure_visualization ( camera_params : Optional [ list[float ] ] = None , flags_to_enable : Optional [ list[float ] ] = None , flags_to_disable : Optional [ list[float ] ] = None , client : Optional [ BulletClient ] = None , ** kwargs , ) -> None : \"\"\"Configures the pybullet debug visualizer Args: camera_params (list[float], optional): Used to reset camera position. [dist, pitch, yaw, pos_x, pos_y, pos_z] where dist is the distance from eye to camera target, yaw is left/right angle, pitch is up/down angle, and the xyz positions are for the focus point. Defaults to None. flags_to_enable (list[float], optional): A list of pybullet flags (for example, COV_ENABLE_WIREFRAME). Defaults to None. flags_to_disable (list[float], optional): A list of pybullet flags (for example, COV_ENABLE_WIREFRAME). Defaults to None. client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) **kwargs: Any additional kwargs to set. See the pybullet configureDebugVisualizer documentation for more info \"\"\" client : pybullet = pybullet if client is None else client if camera_params : dist , pitch , yaw , pos_x , pos_y , pos_z = camera_params client . resetDebugVisualizerCamera ( cameraDistance = dist , cameraPitch = pitch , cameraYaw = yaw , cameraTargetPosition =[ pos_x, pos_y, pos_z ] , ) if flags_to_enable : for flag in flags_to_enable : client . configureDebugVisualizer ( flag , True ) if flags_to_disable : for flag in flags_to_disable : client . configureDebugVisualizer ( flag , False ) if kwargs : client . configureDebugVisualizer ( ** kwargs ) create_anchor def create_anchor ( soft_body_id : int , vertex_id : int , parent_id : int , link_id : int , parent_frame_pos : Optional [ list [ float ]] = None , add_geom : bool = False , geom_pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> tuple [ int , typing . Optional [ int ]] Creates an anchor between a softbody and another object (or the world) Parameters: Name Type Description Default soft_body_id int ID of the softbody in Pybullet None vertex_id int Index of the mesh vertex on the softbody we are anchoring to None parent_id int ID of the parent object in Pybullet. If anchoring to world, this will be -1 None link_id int Index of the link on the parent object. If the parent does not have links, use -1 None parent_frame_pos Optional[list[float]] If the anchor is being affixed to a specific point on the parent object, pass in the location here. Defaults to None. None add_geom bool Whether or not to add a small sphere to visualize the positioning on the anchor. Defaults to False. None geom_pos Optional[npt.ArrayLike] Position of the sphere in world frame, shape (3,). Defaults to None, (in which case add_geom must also be None) None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Returns: Type Description tuple[int, Optional[int]] int: The Pybullet ID for the anchor Optional[int]: The Pybullet ID for the geometry (if add_geom is False, this is None) View Source def create_anchor ( soft_body_id : int , vertex_id : int , parent_id : int , link_id : int , parent_frame_pos : Optional [ list[float ] ] = None , add_geom : bool = False , geom_pos : Optional [ npt.ArrayLike ] = None , client : Optional [ BulletClient ] = None , ) -> tuple [ int, Optional[int ] ]: \"\"\"Creates an anchor between a softbody and another object (or the world) Args: soft_body_id (int): ID of the softbody in Pybullet vertex_id (int): Index of the mesh vertex on the softbody we are anchoring to parent_id (int): ID of the parent object in Pybullet. If anchoring to world, this will be -1 link_id (int): Index of the link on the parent object. If the parent does not have links, use -1 parent_frame_pos (Optional[list[float]]): If the anchor is being affixed to a specific point on the parent object, pass in the location here. Defaults to None. add_geom (bool, optional): Whether or not to add a small sphere to visualize the positioning on the anchor. Defaults to False. geom_pos (Optional[npt.ArrayLike]): Position of the sphere in world frame, shape (3,). Defaults to None, (in which case add_geom must also be None) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: tuple[int, Optional[int]]: int: The Pybullet ID for the anchor Optional[int]: The Pybullet ID for the geometry (if add_geom is False, this is None) \"\"\" client : pybullet = pybullet if client is None else client anchor_id = client . createSoftBodyAnchor ( soft_body_id , vertex_id , parent_id , link_id , parent_frame_pos ) if add_geom : if geom_pos is None : raise ValueError ( \"If visualizing the anchor, the world-position of the anchor must be included\" ) # Create a collision - less sphere to visualize the anchor position geom_id = create_sphere ( geom_pos , 0.01 , 0.01 , False , [ 0, 1, 0, 0.5 ] , client ) # Then create a secondary anchor to make sure this sphere stays in the right place geom_anchor_id = client . createSoftBodyAnchor ( soft_body_id , vertex_id , geom_id , - 1 ) else : geom_id = None return anchor_id , geom_id create_box def create_box ( pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], mass : float , sidelengths : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], use_collision : bool , rgba : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 1 , 1 , 1 , 1 ), client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> int Creates a rigid box in the Pybullet simulation Parameters: Name Type Description Default pos npt.ArrayLike Position of the box in world frame, shape (3) None orn npt.ArrayLike Orientation (XYZW quaternion) of the box in world frame, shape (4,) None mass float Mass of the box. If set to 0, the box is fixed in space None sidelengths npt.ArrayLike Sidelengths of the box along the local XYZ axes, shape (3,) None use_collision bool Whether or not collision is enabled for the box None rgba npt.ArrayLike Color of the box, with each RGBA value being in [0, 1]. Defaults to (1, 1, 1, 1) (white) None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Returns: Type Description int ID of the box in Pybullet View Source def create_box ( pos : npt . ArrayLike , orn : npt . ArrayLike , mass : float , sidelengths : npt . ArrayLike , use_collision : bool , rgba : npt . ArrayLike = ( 1 , 1 , 1 , 1 ), client : Optional [ BulletClient ] = None , ) -> int : \"\"\"Creates a rigid box in the Pybullet simulation Args: pos (npt.ArrayLike): Position of the box in world frame, shape (3) orn (npt.ArrayLike): Orientation (XYZW quaternion) of the box in world frame, shape (4,) mass (float): Mass of the box. If set to 0, the box is fixed in space sidelengths (npt.ArrayLike): Sidelengths of the box along the local XYZ axes, shape (3,) use_collision (bool): Whether or not collision is enabled for the box rgba (npt.ArrayLike, optional): Color of the box, with each RGBA value being in [0, 1]. Defaults to (1, 1, 1, 1) (white) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: int: ID of the box in Pybullet \"\"\" client : pybullet = pybullet if client is None else client if len ( sidelengths ) != 3 : raise ValueError ( \"Must provide the dimensions of the three sides of the box\" ) half_extents = np . asarray ( sidelengths ) / 2 visual_id = client . createVisualShape ( pybullet . GEOM_BOX , halfExtents = half_extents , rgbaColor = rgba , ) if use_collision : collision_id = client . createCollisionShape ( pybullet . GEOM_BOX , halfExtents = half_extents , ) else : collision_id = - 1 box_id = client . createMultiBody ( baseMass = mass , basePosition = pos , baseOrientation = orn , baseCollisionShapeIndex = collision_id , baseVisualShapeIndex = visual_id , ) return box_id create_sphere def create_sphere ( pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], mass : float , radius : float , use_collision : bool , rgba : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 1 , 1 , 1 , 1 ), client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> int Creates a rigid sphere in the Pybullet simulation Parameters: Name Type Description Default pos npt.ArrayLike Position of the sphere in world frame, shape (3) None mass float Mass of the sphere. If set to 0, the sphere is fixed in space None radius float Radius of the sphere None use_collision bool Whether or not collision is enabled for the sphere None rgba npt.ArrayLike Color of the sphere, with each RGBA value being in [0, 1]. Defaults to (1, 1, 1, 1) (white) None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Returns: Type Description int ID of the sphere in Pybullet View Source def create_sphere ( pos : npt . ArrayLike , mass : float , radius : float , use_collision : bool , rgba : npt . ArrayLike = ( 1 , 1 , 1 , 1 ), client : Optional [ BulletClient ] = None , ) -> int : \"\"\"Creates a rigid sphere in the Pybullet simulation Args: pos (npt.ArrayLike): Position of the sphere in world frame, shape (3) mass (float): Mass of the sphere. If set to 0, the sphere is fixed in space radius (float): Radius of the sphere use_collision (bool): Whether or not collision is enabled for the sphere rgba (npt.ArrayLike, optional): Color of the sphere, with each RGBA value being in [0, 1]. Defaults to (1, 1, 1, 1) (white) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: int: ID of the sphere in Pybullet \"\"\" client : pybullet = pybullet if client is None else client visual_id = client . createVisualShape ( pybullet . GEOM_SPHERE , radius = radius , rgbaColor = rgba ) if use_collision : collision_id = client . createCollisionShape ( pybullet . GEOM_SPHERE , radius = radius ) else : collision_id = - 1 sphere_id = client . createMultiBody ( baseMass = mass , basePosition = pos , baseCollisionShapeIndex = collision_id , baseVisualShapeIndex = visual_id , ) return sphere_id initialize_pybullet def initialize_pybullet ( use_gui : bool = True , physics_freq : float = 350 , gravity : float = 0.0 , bg_color : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 0.0 , 0.0 , 0.0 ) ) -> < module 'pybullet' from '/home/dmorton/.pyenv/versions/3.10.8/envs/astrobee/lib/python3.10/site-packages/pybullet.cpython-310-x86_64-linux-gnu.so' > Starts a pybullet client with the required physics parameters we care about NOTE: the client object returned from this function should ALWAYS be assigned to a variable to keep the simulation in scope. i.e. don't just call initialize_pybullet(), use client = initialize_pybullet() even if you're not worrying about multiple physics simulations Parameters: Name Type Description Default use_gui bool Whether or not to use the GUI as opposed to headless. Defaults to True None physics_freq float Physics simulation frequency, in Hz. Defaults to 350. Note: Pybullet defaults to 240 Hz, but this seemed to be unstable for soft bodies 350 gravity float Z component of gravitational acceleration vector. Defaults to 0. 0 bg_color npt.ArrayLike RGB values for the GUI background, each in range [0, 1]. Defaults to (0.0, 0.0, 0.0) (black). Note: (1.0, 1.0, 1.0) is white None Returns: Type Description BulletClient Pybullet physics simulation client View Source def initialize_pybullet ( use_gui : bool = True , physics_freq : float = 350 , gravity : float = 0.0 , bg_color : npt . ArrayLike = ( 0.0 , 0.0 , 0.0 ), ) -> pybullet : \"\"\"Starts a pybullet client with the required physics parameters we care about NOTE: the client object returned from this function should ALWAYS be assigned to a variable to keep the simulation in scope. i.e. don't just call initialize_pybullet(), use client = initialize_pybullet() even if you're not worrying about multiple physics simulations Args: use_gui (bool, optional): Whether or not to use the GUI as opposed to headless. Defaults to True physics_freq (float, optional): Physics simulation frequency, in Hz. Defaults to 350. Note: Pybullet defaults to 240 Hz, but this seemed to be unstable for soft bodies gravity (float, optional): Z component of gravitational acceleration vector. Defaults to 0. bg_color (npt.ArrayLike, optional): RGB values for the GUI background, each in range [0, 1]. Defaults to (0.0, 0.0, 0.0) (black). Note: (1.0, 1.0, 1.0) is white Returns: BulletClient: Pybullet physics simulation client \"\"\" # Make sure we're in the right directory so filepaths work well with pybullet cwd = os . getcwd () if not cwd . endswith ( \"pyastrobee\" ) or cwd . endswith ( \"pyastrobee/pyastrobee\" ): raise ConnectionRefusedError ( f \"You are running scripts from {cwd}. \\n Ensure you're at the top-level pyastrobee directory.\" ) # Ensure that the background color values are within the proper range bg_color = np . array ( bg_color ) if len ( bg_color ) != 3 or not ( all ( bg_color >= 0 ) and all ( bg_color <= 1 )): raise ValueError ( f \"Invalid background color: {bg_color}\" ) bg_args = ( f \"--background_color_red={bg_color[0]} \" + f \"--background_color_green={bg_color[1]} \" + f \"--background_color_blue={bg_color[2]}\" ) # Connect to pybullet connection_mode = pybullet . GUI if use_gui else pybullet . DIRECT client : pybullet = BulletClient ( connection_mode , options = bg_args ) # Configure physics client . resetSimulation ( pybullet . RESET_USE_DEFORMABLE_WORLD ) client . setTimeStep ( 1.0 / physics_freq ) client . setGravity ( 0 , 0 , gravity ) # Configure search paths client . setAdditionalSearchPath ( pybullet_data . getDataPath ()) # client.setAdditionalSearchPath(os.path.join(os.getcwd(), \"pyastrobee/assets\")) client . setAdditionalSearchPath ( cwd ) # Remove the extra windows in PyBullet GUI (until we use them for cameras). client . configureDebugVisualizer ( pybullet . COV_ENABLE_GUI , False ) return client load_deformable_object def load_deformable_object ( filename : str , texture_filename : Optional [ str ] = None , scale : float = 1.0 , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 0.0 , 0.0 , 0.0 ), orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 0.0 , 0.0 , 0.0 , 1.0 ), mass : float = 1.0 , bending_stiffness : float = 50.0 , damping_stiffness : float = 0.1 , elastic_stiffness : float = 50.0 , friction_coeff : float = 0.1 , self_collision : bool = False , sim_file_name = '' , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> int Loads a deformable object from an OBJ file Notes: bending and elastic stiffness >90 cause instabilities. Parameters: Name Type Description Default filename str Path to the deformable object to load None texture_filename str Path to a texture file to apply. Defaults to None, in which case no texture will be applied None scale float Scaling factor for the loaded object. Defaults to 1.0. 1.0 pos npt.ArrayLike Initial position for the loaded object. Defaults to (0.0, 0.0, 0.0). (0.0, 0.0, 0.0) orn npt.ArrayLike Initial XYZW quaternion orientation. Defaults to (0, 0, 0, 1). (0, 0, 0, 1) mass float Mass of the loaded object. Defaults to 1.0 (Keeping at 1.0 is the most stable option). 1.0 (Keeping at 1.0 is the most stable option) bending_stiffness float Bending stiffness of the loaded object. Defaults to 1.0. 1.0 damping_stiffness float Damping stiffness of the loaded object. Defaults to 0.1. 0.1 elastic_stiffness float Elastic stiffness of the loaded object. Defaults to 1.0. 1.0 friction_coeff float Friction coefficient of the loaded object. Defaults to 0.1. 0.1 self_collision bool Whether or not to allow self-collisions for the object. Defaults to False. Note: setting this as True seemed to lead to mesh collapse False sim_file_name str This is an undocumented input to loadSoftBody, but it appears to allow you to load an OBJ in the filename (for texture purposes) and a corresponding VTK in the simFileName for volumetric softbody physics None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Returns: Type Description int ID number for the object View Source def load_deformable_object ( filename : str , texture_filename : Optional [ str ] = None , scale : float = 1.0 , pos : npt . ArrayLike = ( 0.0 , 0.0 , 0.0 ), orn : npt . ArrayLike = ( 0.0 , 0.0 , 0.0 , 1.0 ), mass : float = 1.0 , bending_stiffness : float = 50.0 , damping_stiffness : float = 0.1 , elastic_stiffness : float = 50.0 , friction_coeff : float = 0.1 , self_collision : bool = False , sim_file_name = \"\" , client : Optional [ BulletClient ] = None , ) -> int : \"\"\"Loads a deformable object from an OBJ file Notes: bending and elastic stiffness >90 cause instabilities. Args: filename (str): Path to the deformable object to load texture_filename (str, optional): Path to a texture file to apply. Defaults to None, in which case no texture will be applied scale (float, optional): Scaling factor for the loaded object. Defaults to 1.0. pos (npt.ArrayLike, optional): Initial position for the loaded object. Defaults to (0.0, 0.0, 0.0). orn (npt.ArrayLike, optional): Initial XYZW quaternion orientation. Defaults to (0, 0, 0, 1). mass (float, optional): Mass of the loaded object. Defaults to 1.0 (Keeping at 1.0 is the most stable option). bending_stiffness (float, optional): Bending stiffness of the loaded object. Defaults to 1.0. damping_stiffness (float, optional): Damping stiffness of the loaded object. Defaults to 0.1. elastic_stiffness (float, optional): Elastic stiffness of the loaded object. Defaults to 1.0. friction_coeff (float, optional): Friction coefficient of the loaded object. Defaults to 0.1. self_collision (bool, optional): Whether or not to allow self-collisions for the object. Defaults to False. Note: setting this as True seemed to lead to mesh collapse sim_file_name (str, optional): This is an undocumented input to loadSoftBody, but it appears to allow you to load an OBJ in the filename (for texture purposes) and a corresponding VTK in the simFileName for volumetric softbody physics client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: int: ID number for the object \"\"\" client : pybullet = pybullet if client is None else client if mass < 1.0 : print_red ( \"Warning: mass > 1 is the most stable for deformables. Small mass can cause instabilities\" ) # TODO : decide if some of these parameters should be included as inputs rather than hard - coded deform_id = client . loadSoftBody ( mass = mass , fileName = filename , scale = scale , basePosition = list ( pos ), baseOrientation = list ( orn ), springElasticStiffness = elastic_stiffness , springDampingStiffness = damping_stiffness , springBendingStiffness = bending_stiffness , frictionCoeff = friction_coeff , # collisionMargin = 0.003 , # how far apart do two objects begin interacting useSelfCollision = self_collision , springDampingAllDirections = 1 , useFaceContact = True , useNeoHookean = 0 , useMassSpring = True , useBendingSprings = True , # repulsionStiffness = 10000000 , simFileName = sim_file_name , ) # TODO figure out what this sparseSdfVoxelSize parameter actually does ( it ' s not documented ) # See pybullet examples / deformable_anchor . py for its usage there client . setPhysicsEngineParameter ( sparseSdfVoxelSize = 0.25 ) if texture_filename is not None : add_texture_to_deformable ( deform_id , texture_filename , client ) # Validate the size of the mesh to assure stability num_mesh_vertices = get_mesh_data ( deform_id , client ) [ 0 ] if num_mesh_vertices > 2 ** 13 : print_red ( f \"Warning: high number of mesh vertices: {num_mesh_vertices}. Consider a lower-res mesh\" ) return deform_id load_floor def load_floor ( texture_filename : Optional [ str ] = None , z_pos : float = 0.0 , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> int Loads a floor into the pybullet simulation Parameters: Name Type Description Default texture_filename str If adding a texture to the floor plane, pass in the filename. Defaults to None. None z_pos float Height (z-coordinate) of the floor in the world. Defaults to 0.0 0 client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Returns: Type Description int Pybullet ID corresponding to the floor View Source def load_floor ( texture_filename : Optional [ str ] = None , z_pos : float = 0.0 , client : Optional [ BulletClient ] = None , ) -> int : \"\"\"Loads a floor into the pybullet simulation Args: texture_filename (str, optional): If adding a texture to the floor plane, pass in the filename. Defaults to None. z_pos (float, optional): Height (z-coordinate) of the floor in the world. Defaults to 0.0 client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: int: Pybullet ID corresponding to the floor \"\"\" client : pybullet = pybullet if client is None else client client . setAdditionalSearchPath ( pybullet_data . getDataPath ()) floor_id = client . loadURDF ( \"plane.urdf\" , basePosition =[ 0, 0, z_pos ] ) if texture_filename is not None : texture_id = client . loadTexture ( texture_filename ) client . changeVisualShape ( floor_id , - 1 , rgbaColor =[ 1, 1, 1, 0 ] , textureUniqueId = texture_id , ) return floor_id load_rigid_object def load_rigid_object ( filename : str , texture_filename : Optional [ str ] = None , scale : float = 1.0 , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 0.0 , 0.0 , 0.0 ), orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 0.0 , 0.0 , 0.0 , 1.0 ), mass : float = 1.0 , fixed : bool = False , rgba : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 1.0 , 1.0 , 1.0 , 1.0 ), client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> int Loads a rigid object from an OBJ or URDF file Parameters: Name Type Description Default filename str Path to the OBJ/URDF file to load None texture_filename str Path to a texture file to apply. Defaults to None, in which case no texture will be applied None scale float Scaling factor for the loaded object. Defaults to 1.0. 1.0 pos npt.ArrayLike Initial position for the loaded object. Defaults to (0, 0, 0). (0, 0, 0) orn npt.ArrayLike Initial XYZW quaternion orientation. Defaults to (0, 0, 0, 1). (0, 0, 0, 1) mass float Mass of the loaded object. Defaults to 1.0. 1.0 fixed bool Whether or not to fix the object in space. Defaults to False. False rgba npt.ArrayLike Color of the object, expressed as RGBA, each within range [0, 1]. Defaults to (1.0, 1.0, 1.0, 1.0) (white). None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Returns: Type Description int ID number for the object Raises: Type Description ValueError If the filename is not a valid OBJ or URDF View Source def load_rigid_object ( filename : str , texture_filename : Optional [ str ] = None , scale : float = 1.0 , pos : npt . ArrayLike = ( 0.0 , 0.0 , 0.0 ), orn : npt . ArrayLike = ( 0.0 , 0.0 , 0.0 , 1.0 ), mass : float = 1.0 , fixed : bool = False , rgba : npt . ArrayLike = ( 1.0 , 1.0 , 1.0 , 1.0 ), client : Optional [ BulletClient ] = None , ) -> int : \"\"\"Loads a rigid object from an OBJ or URDF file Args: filename (str): Path to the OBJ/URDF file to load texture_filename (str, optional): Path to a texture file to apply. Defaults to None, in which case no texture will be applied scale (float, optional): Scaling factor for the loaded object. Defaults to 1.0. pos (npt.ArrayLike, optional): Initial position for the loaded object. Defaults to (0, 0, 0). orn (npt.ArrayLike, optional): Initial XYZW quaternion orientation. Defaults to (0, 0, 0, 1). mass (float, optional): Mass of the loaded object. Defaults to 1.0. fixed (bool, optional): Whether or not to fix the object in space. Defaults to False. rgba (npt.ArrayLike, optional): Color of the object, expressed as RGBA, each within range [0, 1]. Defaults to (1.0, 1.0, 1.0, 1.0) (white). client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Raises: ValueError: If the filename is not a valid OBJ or URDF Returns: int: ID number for the object \"\"\" client : pybullet = pybullet if client is None else client # Deal with pybullet 's weird handling of mass = 0 being fixed if mass < 0: raise ValueError(\"Mass should not be a negative value\") if mass == 0: print_red( f\"Warning: the mass of {filename} is 0, which will make it fixed. Use the ' fixed ' parameter instead \" ) if fixed: mass = 0.0 if filename.endswith(\" . obj \"): # mesh info xyz_scale = [scale, scale, scale] visual_id = client.createVisualShape( shapeType=pybullet.GEOM_MESH, rgbaColor=rgba, fileName=filename, meshScale=xyz_scale, ) collision_id = client.createCollisionShape( shapeType=pybullet.GEOM_MESH, fileName=filename, meshScale=xyz_scale ) rigid_id = client.createMultiBody( baseMass=mass, # mass==0 => fixed at position where it is loaded basePosition=pos, baseCollisionShapeIndex=collision_id, baseVisualShapeIndex=visual_id, baseOrientation=orn, ) elif filename.endswith(\" . urdf \"): # URDF file rigid_id = client.loadURDF( filename, pos, orn, useFixedBase=fixed, globalScaling=scale, ) else: raise ValueError( f\" Invalid filename : { filename } . Import either an OBJ or URDF file \" ) # TODO : decide if these parameters should be included as inputs rather than hard - coded client . changeDynamics ( rigid_id , - 1 , mass , lateralFriction = 1.0 , spinningFriction = 1.0 , rollingFriction = 1.0 , restitution = 0.0 , ) if texture_filename is not None : add_texture_to_rigid ( rigid_id , texture_filename , client ) return rigid_id playback_from_log def playback_from_log ( log_file : str , real_time : bool = True , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> None Reads a log file and then replays that logged simulation We assume that the environment has been set up the same way as the original environment when the logging occurred. If this is not the case, it can lead to odd results The logs also contain a lot more info like velocities and torques, but we don't really need this information to play things back (simply resetting pose will appear correct) This code is modified from bullet3/examples/pybullet/examples/kuka_with_cube_playback.py Parameters: Name Type Description Default log_file str Filename for the saved log None real_time bool Whether to play back the log in real time (according to the timestamps saved in the log). Defaults to True. If False, things will be very speedy None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None View Source def playback_from_log ( log_file : str , real_time : bool = True , client : Optional [ BulletClient ] = None , ) -> None : \"\"\"Reads a log file and then replays that logged simulation We assume that the environment has been set up the same way as the original environment when the logging occurred. If this is not the case, it can lead to odd results The logs also contain a lot more info like velocities and torques, but we don't really need this information to play things back (simply resetting pose will appear correct) This code is modified from bullet3/examples/pybullet/examples/kuka_with_cube_playback.py Args: log_file (str): Filename for the saved log real_time (bool, optional): Whether to play back the log in real time (according to the timestamps saved in the log). Defaults to True. If False, things will be very speedy client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" client : pybullet = pybullet if client is None else client log = read_log_file ( log_file ) start_time = time . time () for record in log : timestamp = record [ 1 ] uid = record [ 2 ] pos = record [ 3:6 ] orn = record [ 6:10 ] client . resetBasePositionAndOrientation ( uid , pos , orn ) num_joints = client . getNumJoints ( uid ) for i in range ( num_joints ) : joint_info = client . getJointInfo ( uid , i ) q_index = joint_info [ 3 ] if q_index > - 1 : client . resetJointState ( uid , i , record [ q_index - 7 + 17 ] ) if real_time : time . sleep ( max ( 0 , timestamp - time . time () + start_time )) read_log_file def read_log_file ( filename : str , verbose : bool = False ) -> list [ list [ typing . Union [ int , float ]]] Reads a Pybullet state log for generic robots and objects We assume that when generating the log: - The loggingType was set to STATE_LOGGING_GENERIC_ROBOT - No softbodies were included in the logged items - The maxLogDof is left at the default value (12) This code is modified from bullet3/examples/pybullet/examples/kuka_with_cube_playback.py Parameters: Name Type Description Default filename str Filename for the saved log None verbose bool Whether to print info about the log when reading. Defaults to False. False Returns: Type Description list[list[Union[int, float]]] The Pybullet log. Length is (number of timesteps) * (number of objects logged) If multiple objects are logged, there will be multiple consecutive log entries for the same timestep Each record in the log contains the following info: step_count = record[0] timestamp = record[1] unique_id = record[2] position = record[3:6] orientation = record[6:10] velocity = record[10:13] angular_velocity = record[13:16] num_joints = record[16] joint_positions = record[17 : 17 + max_log_dof] joint_torques = record[17 + max_log_dof :] View Source def read_log_file ( filename : str , verbose : bool = False ) -> list [ list[Union[int, float ] ]]: \"\"\"Reads a Pybullet state log for generic robots and objects We assume that when generating the log: - The loggingType was set to STATE_LOGGING_GENERIC_ROBOT - No softbodies were included in the logged items - The maxLogDof is left at the default value (12) This code is modified from bullet3/examples/pybullet/examples/kuka_with_cube_playback.py Args: filename (str): Filename for the saved log verbose (bool, optional): Whether to print info about the log when reading. Defaults to False. Returns: list[list[Union[int, float]]]: The Pybullet log. Length is (number of timesteps) * (number of objects logged) If multiple objects are logged, there will be multiple consecutive log entries for the same timestep Each record in the log contains the following info: step_count = record[0] timestamp = record[1] unique_id = record[2] position = record[3:6] orientation = record[6:10] velocity = record[10:13] angular_velocity = record[13:16] num_joints = record[16] joint_positions = record[17 : 17 + max_log_dof] joint_torques = record[17 + max_log_dof :] \"\"\" with open ( filename , \"rb\" ) as f : keys = f . readline (). decode ( \"utf8\" ). rstrip ( \"\\n\" ). split ( \",\" ) fmt = f . readline (). decode ( \"utf8\" ). rstrip ( \"\\n\" ) # The byte number of one record sz = struct . calcsize ( fmt ) # The type number of one record ncols = len ( fmt ) info = { \"filename\" : filename , \"keys\" : keys , \"format\" : fmt , \"size\" : sz , \"columns\" : ncols , } if verbose : print ( info ) # Read data whole_file = f . read () # split by alignment word chunks = whole_file . split ( b \"\\xaa\\xbb\" ) log = [] for chunk in chunks : if len ( chunk ) == sz : values = struct . unpack ( fmt , chunk ) record = [] for i in range ( ncols ) : record . append ( values [ i ] ) log . append ( record ) return log run_sim def run_sim ( viz_freq : float = 240 , timeout : Optional [ float ] = None , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) Runs the pybullet simulation Parameters: Name Type Description Default viz_freq float Frequency (Hz) to run the visualization (if connected via GUI). Defaults to 240. 240 timeout float Amount of time to run the simulation. Defaults to None, in which case the simulation will remain open until it is killed manually. None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Raises: Type Description ConnectionError If a pybullet client is not currently running ValueError If the visualization frequency is greater than the physics frequency View Source def run_sim ( viz_freq : float = 240 , timeout : Optional [ float ] = None , client : Optional [ BulletClient ] = None , ) : \"\"\"Runs the pybullet simulation Args: viz_freq (float, optional): Frequency (Hz) to run the visualization (if connected via GUI). Defaults to 240. timeout (float, optional): Amount of time to run the simulation. Defaults to None, in which case the simulation will remain open until it is killed manually. client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Raises: ConnectionError: If a pybullet client is not currently running ValueError: If the visualization frequency is greater than the physics frequency \"\"\" client : pybullet = pybullet if client is None else client connect_info : dict [ str, int ] = client . getConnectionInfo () if not connect_info [ \"isConnected\" ] : raise ConnectionError ( \"Connect to a pybullet client before running the sim\" ) connect_mode = \"GUI\" if connect_info [ \"connectionMethod\" ] == 1 else \"DIRECT\" phys_info = client . getPhysicsEngineParameters () phys_freq = 1.0 / phys_info [ \"fixedTimeStep\" ] if viz_freq > phys_freq : raise ValueError ( f \"Cannot visualize ({viz_freq} Hz) faster than the physics ({phys_freq} Hz)\" ) if timeout is None : timeout = float ( \"inf\" ) start_time = time . time () try : while ( time . time () - start_time < timeout ) and client . isConnected () : client . stepSimulation () if connect_mode == \"GUI\" : time . sleep ( 1.0 / viz_freq ) finally : client . disconnect ()","title":"Bullet Utils"},{"location":"reference/pyastrobee/utils/bullet_utils/#module-pyastrobeeutilsbullet_utils","text":"Pybullet-specific helper functions View Source \"\"\"Pybullet-specific helper functions\"\"\" import os import time from typing import Optional , Union import struct import numpy as np import numpy.typing as npt import pybullet import pybullet_data from pybullet_utils.bullet_client import BulletClient from pyastrobee.utils.mesh_utils import get_mesh_data from pyastrobee.utils.python_utils import print_red def load_rigid_object ( filename : str , texture_filename : Optional [ str ] = None , scale : float = 1.0 , pos : npt . ArrayLike = ( 0.0 , 0.0 , 0.0 ), orn : npt . ArrayLike = ( 0.0 , 0.0 , 0.0 , 1.0 ), mass : float = 1.0 , fixed : bool = False , rgba : npt . ArrayLike = ( 1.0 , 1.0 , 1.0 , 1.0 ), client : Optional [ BulletClient ] = None , ) -> int : \"\"\"Loads a rigid object from an OBJ or URDF file Args: filename (str): Path to the OBJ/URDF file to load texture_filename (str, optional): Path to a texture file to apply. Defaults to None, in which case no texture will be applied scale (float, optional): Scaling factor for the loaded object. Defaults to 1.0. pos (npt.ArrayLike, optional): Initial position for the loaded object. Defaults to (0, 0, 0). orn (npt.ArrayLike, optional): Initial XYZW quaternion orientation. Defaults to (0, 0, 0, 1). mass (float, optional): Mass of the loaded object. Defaults to 1.0. fixed (bool, optional): Whether or not to fix the object in space. Defaults to False. rgba (npt.ArrayLike, optional): Color of the object, expressed as RGBA, each within range [0, 1]. Defaults to (1.0, 1.0, 1.0, 1.0) (white). client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Raises: ValueError: If the filename is not a valid OBJ or URDF Returns: int: ID number for the object \"\"\" client : pybullet = pybullet if client is None else client # Deal with pybullet's weird handling of mass = 0 being fixed if mass < 0 : raise ValueError ( \"Mass should not be a negative value\" ) if mass == 0 : print_red ( f \"Warning: the mass of { filename } is 0, which will make it fixed. Use the 'fixed' parameter instead\" ) if fixed : mass = 0.0 if filename . endswith ( \".obj\" ): # mesh info xyz_scale = [ scale , scale , scale ] visual_id = client . createVisualShape ( shapeType = pybullet . GEOM_MESH , rgbaColor = rgba , fileName = filename , meshScale = xyz_scale , ) collision_id = client . createCollisionShape ( shapeType = pybullet . GEOM_MESH , fileName = filename , meshScale = xyz_scale ) rigid_id = client . createMultiBody ( baseMass = mass , # mass==0 => fixed at position where it is loaded basePosition = pos , baseCollisionShapeIndex = collision_id , baseVisualShapeIndex = visual_id , baseOrientation = orn , ) elif filename . endswith ( \".urdf\" ): # URDF file rigid_id = client . loadURDF ( filename , pos , orn , useFixedBase = fixed , globalScaling = scale , ) else : raise ValueError ( f \"Invalid filename: { filename } . Import either an OBJ or URDF file\" ) # TODO: decide if these parameters should be included as inputs rather than hard-coded client . changeDynamics ( rigid_id , - 1 , mass , lateralFriction = 1.0 , spinningFriction = 1.0 , rollingFriction = 1.0 , restitution = 0.0 , ) if texture_filename is not None : add_texture_to_rigid ( rigid_id , texture_filename , client ) return rigid_id def add_texture_to_rigid ( object_id : int , texture_filename : str , client : Optional [ BulletClient ] = None , ) -> None : \"\"\"Applies a texture to a rigid object Args: object_id (int): The ID of the rigid object in the pybullet simulation texture_filename (str): Path to the texture file client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" client : pybullet = pybullet if client is None else client texture_id = client . loadTexture ( texture_filename ) kwargs = {} if hasattr ( pybullet , \"VISUAL_SHAPE_DOUBLE_SIDED\" ): kwargs [ \"flags\" ] = pybullet . VISUAL_SHAPE_DOUBLE_SIDED num_joints = client . getNumJoints ( object_id ) # TODO: check on the indexing here (for now, assuming dedo is correct) for i in range ( - 1 , num_joints ): client . changeVisualShape ( object_id , i , rgbaColor = [ 1 , 1 , 1 , 1 ], textureUniqueId = texture_id , ** kwargs , ) def add_texture_to_deformable ( object_id : int , texture_filename : str , client : Optional [ BulletClient ] = None , ) -> None : \"\"\"Applies a texture to a deformable object Args: object_id (int): The ID of the deformable object in the pybullet simulation texture_filename (str): Path to the texture file client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" client : pybullet = pybullet if client is None else client texture_id = client . loadTexture ( texture_filename ) kwargs = {} if hasattr ( pybullet , \"VISUAL_SHAPE_DOUBLE_SIDED\" ): kwargs [ \"flags\" ] = pybullet . VISUAL_SHAPE_DOUBLE_SIDED client . changeVisualShape ( object_id , - 1 , rgbaColor = [ 1 , 1 , 1 , 1 ], textureUniqueId = texture_id , ** kwargs ) def load_deformable_object ( filename : str , texture_filename : Optional [ str ] = None , scale : float = 1.0 , pos : npt . ArrayLike = ( 0.0 , 0.0 , 0.0 ), orn : npt . ArrayLike = ( 0.0 , 0.0 , 0.0 , 1.0 ), mass : float = 1.0 , bending_stiffness : float = 50.0 , damping_stiffness : float = 0.1 , elastic_stiffness : float = 50.0 , friction_coeff : float = 0.1 , self_collision : bool = False , sim_file_name = \"\" , client : Optional [ BulletClient ] = None , ) -> int : \"\"\"Loads a deformable object from an OBJ file Notes: bending and elastic stiffness >90 cause instabilities. Args: filename (str): Path to the deformable object to load texture_filename (str, optional): Path to a texture file to apply. Defaults to None, in which case no texture will be applied scale (float, optional): Scaling factor for the loaded object. Defaults to 1.0. pos (npt.ArrayLike, optional): Initial position for the loaded object. Defaults to (0.0, 0.0, 0.0). orn (npt.ArrayLike, optional): Initial XYZW quaternion orientation. Defaults to (0, 0, 0, 1). mass (float, optional): Mass of the loaded object. Defaults to 1.0 (Keeping at 1.0 is the most stable option). bending_stiffness (float, optional): Bending stiffness of the loaded object. Defaults to 1.0. damping_stiffness (float, optional): Damping stiffness of the loaded object. Defaults to 0.1. elastic_stiffness (float, optional): Elastic stiffness of the loaded object. Defaults to 1.0. friction_coeff (float, optional): Friction coefficient of the loaded object. Defaults to 0.1. self_collision (bool, optional): Whether or not to allow self-collisions for the object. Defaults to False. Note: setting this as True seemed to lead to mesh collapse sim_file_name (str, optional): This is an undocumented input to loadSoftBody, but it appears to allow you to load an OBJ in the filename (for texture purposes) and a corresponding VTK in the simFileName for volumetric softbody physics client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: int: ID number for the object \"\"\" client : pybullet = pybullet if client is None else client if mass < 1.0 : print_red ( \"Warning: mass > 1 is the most stable for deformables. Small mass can cause instabilities\" ) # TODO: decide if some of these parameters should be included as inputs rather than hard-coded deform_id = client . loadSoftBody ( mass = mass , fileName = filename , scale = scale , basePosition = list ( pos ), baseOrientation = list ( orn ), springElasticStiffness = elastic_stiffness , springDampingStiffness = damping_stiffness , springBendingStiffness = bending_stiffness , frictionCoeff = friction_coeff , # collisionMargin=0.003, # how far apart do two objects begin interacting useSelfCollision = self_collision , springDampingAllDirections = 1 , useFaceContact = True , useNeoHookean = 0 , useMassSpring = True , useBendingSprings = True , # repulsionStiffness=10000000, simFileName = sim_file_name , ) # TODO figure out what this sparseSdfVoxelSize parameter actually does (it's not documented) # See pybullet examples/deformable_anchor.py for its usage there client . setPhysicsEngineParameter ( sparseSdfVoxelSize = 0.25 ) if texture_filename is not None : add_texture_to_deformable ( deform_id , texture_filename , client ) # Validate the size of the mesh to assure stability num_mesh_vertices = get_mesh_data ( deform_id , client )[ 0 ] if num_mesh_vertices > 2 ** 13 : print_red ( f \"Warning: high number of mesh vertices: { num_mesh_vertices } . Consider a lower-res mesh\" ) return deform_id def initialize_pybullet ( use_gui : bool = True , physics_freq : float = 350 , gravity : float = 0.0 , bg_color : npt . ArrayLike = ( 0.0 , 0.0 , 0.0 ), ) -> pybullet : \"\"\"Starts a pybullet client with the required physics parameters we care about NOTE: the client object returned from this function should ALWAYS be assigned to a variable to keep the simulation in scope. i.e. don't just call initialize_pybullet(), use client = initialize_pybullet() even if you're not worrying about multiple physics simulations Args: use_gui (bool, optional): Whether or not to use the GUI as opposed to headless. Defaults to True physics_freq (float, optional): Physics simulation frequency, in Hz. Defaults to 350. Note: Pybullet defaults to 240 Hz, but this seemed to be unstable for soft bodies gravity (float, optional): Z component of gravitational acceleration vector. Defaults to 0. bg_color (npt.ArrayLike, optional): RGB values for the GUI background, each in range [0, 1]. Defaults to (0.0, 0.0, 0.0) (black). Note: (1.0, 1.0, 1.0) is white Returns: BulletClient: Pybullet physics simulation client \"\"\" # Make sure we're in the right directory so filepaths work well with pybullet cwd = os . getcwd () if not cwd . endswith ( \"pyastrobee\" ) or cwd . endswith ( \"pyastrobee/pyastrobee\" ): raise ConnectionRefusedError ( f \"You are running scripts from { cwd } . \\n Ensure you're at the top-level pyastrobee directory.\" ) # Ensure that the background color values are within the proper range bg_color = np . array ( bg_color ) if len ( bg_color ) != 3 or not ( all ( bg_color >= 0 ) and all ( bg_color <= 1 )): raise ValueError ( f \"Invalid background color: { bg_color } \" ) bg_args = ( f \"--background_color_red= { bg_color [ 0 ] } \" + f \"--background_color_green= { bg_color [ 1 ] } \" + f \"--background_color_blue= { bg_color [ 2 ] } \" ) # Connect to pybullet connection_mode = pybullet . GUI if use_gui else pybullet . DIRECT client : pybullet = BulletClient ( connection_mode , options = bg_args ) # Configure physics client . resetSimulation ( pybullet . RESET_USE_DEFORMABLE_WORLD ) client . setTimeStep ( 1.0 / physics_freq ) client . setGravity ( 0 , 0 , gravity ) # Configure search paths client . setAdditionalSearchPath ( pybullet_data . getDataPath ()) # client.setAdditionalSearchPath(os.path.join(os.getcwd(), \"pyastrobee/assets\")) client . setAdditionalSearchPath ( cwd ) # Remove the extra windows in PyBullet GUI (until we use them for cameras). client . configureDebugVisualizer ( pybullet . COV_ENABLE_GUI , False ) return client def configure_visualization ( camera_params : Optional [ list [ float ]] = None , flags_to_enable : Optional [ list [ float ]] = None , flags_to_disable : Optional [ list [ float ]] = None , client : Optional [ BulletClient ] = None , ** kwargs , ) -> None : \"\"\"Configures the pybullet debug visualizer Args: camera_params (list[float], optional): Used to reset camera position. [dist, pitch, yaw, pos_x, pos_y, pos_z] where dist is the distance from eye to camera target, yaw is left/right angle, pitch is up/down angle, and the xyz positions are for the focus point. Defaults to None. flags_to_enable (list[float], optional): A list of pybullet flags (for example, COV_ENABLE_WIREFRAME). Defaults to None. flags_to_disable (list[float], optional): A list of pybullet flags (for example, COV_ENABLE_WIREFRAME). Defaults to None. client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) **kwargs: Any additional kwargs to set. See the pybullet configureDebugVisualizer documentation for more info \"\"\" client : pybullet = pybullet if client is None else client if camera_params : dist , pitch , yaw , pos_x , pos_y , pos_z = camera_params client . resetDebugVisualizerCamera ( cameraDistance = dist , cameraPitch = pitch , cameraYaw = yaw , cameraTargetPosition = [ pos_x , pos_y , pos_z ], ) if flags_to_enable : for flag in flags_to_enable : client . configureDebugVisualizer ( flag , True ) if flags_to_disable : for flag in flags_to_disable : client . configureDebugVisualizer ( flag , False ) if kwargs : client . configureDebugVisualizer ( ** kwargs ) def load_floor ( texture_filename : Optional [ str ] = None , z_pos : float = 0.0 , client : Optional [ BulletClient ] = None , ) -> int : \"\"\"Loads a floor into the pybullet simulation Args: texture_filename (str, optional): If adding a texture to the floor plane, pass in the filename. Defaults to None. z_pos (float, optional): Height (z-coordinate) of the floor in the world. Defaults to 0.0 client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: int: Pybullet ID corresponding to the floor \"\"\" client : pybullet = pybullet if client is None else client client . setAdditionalSearchPath ( pybullet_data . getDataPath ()) floor_id = client . loadURDF ( \"plane.urdf\" , basePosition = [ 0 , 0 , z_pos ]) if texture_filename is not None : texture_id = client . loadTexture ( texture_filename ) client . changeVisualShape ( floor_id , - 1 , rgbaColor = [ 1 , 1 , 1 , 0 ], textureUniqueId = texture_id , ) return floor_id def run_sim ( viz_freq : float = 240 , timeout : Optional [ float ] = None , client : Optional [ BulletClient ] = None , ): \"\"\"Runs the pybullet simulation Args: viz_freq (float, optional): Frequency (Hz) to run the visualization (if connected via GUI). Defaults to 240. timeout (float, optional): Amount of time to run the simulation. Defaults to None, in which case the simulation will remain open until it is killed manually. client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Raises: ConnectionError: If a pybullet client is not currently running ValueError: If the visualization frequency is greater than the physics frequency \"\"\" client : pybullet = pybullet if client is None else client connect_info : dict [ str , int ] = client . getConnectionInfo () if not connect_info [ \"isConnected\" ]: raise ConnectionError ( \"Connect to a pybullet client before running the sim\" ) connect_mode = \"GUI\" if connect_info [ \"connectionMethod\" ] == 1 else \"DIRECT\" phys_info = client . getPhysicsEngineParameters () phys_freq = 1.0 / phys_info [ \"fixedTimeStep\" ] if viz_freq > phys_freq : raise ValueError ( f \"Cannot visualize ( { viz_freq } Hz) faster than the physics ( { phys_freq } Hz)\" ) if timeout is None : timeout = float ( \"inf\" ) start_time = time . time () try : while ( time . time () - start_time < timeout ) and client . isConnected (): client . stepSimulation () if connect_mode == \"GUI\" : time . sleep ( 1.0 / viz_freq ) finally : client . disconnect () def create_sphere ( pos : npt . ArrayLike , mass : float , radius : float , use_collision : bool , rgba : npt . ArrayLike = ( 1 , 1 , 1 , 1 ), client : Optional [ BulletClient ] = None , ) -> int : \"\"\"Creates a rigid sphere in the Pybullet simulation Args: pos (npt.ArrayLike): Position of the sphere in world frame, shape (3) mass (float): Mass of the sphere. If set to 0, the sphere is fixed in space radius (float): Radius of the sphere use_collision (bool): Whether or not collision is enabled for the sphere rgba (npt.ArrayLike, optional): Color of the sphere, with each RGBA value being in [0, 1]. Defaults to (1, 1, 1, 1) (white) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: int: ID of the sphere in Pybullet \"\"\" client : pybullet = pybullet if client is None else client visual_id = client . createVisualShape ( pybullet . GEOM_SPHERE , radius = radius , rgbaColor = rgba ) if use_collision : collision_id = client . createCollisionShape ( pybullet . GEOM_SPHERE , radius = radius ) else : collision_id = - 1 sphere_id = client . createMultiBody ( baseMass = mass , basePosition = pos , baseCollisionShapeIndex = collision_id , baseVisualShapeIndex = visual_id , ) return sphere_id def create_anchor ( soft_body_id : int , vertex_id : int , parent_id : int , link_id : int , parent_frame_pos : Optional [ list [ float ]] = None , add_geom : bool = False , geom_pos : Optional [ npt . ArrayLike ] = None , client : Optional [ BulletClient ] = None , ) -> tuple [ int , Optional [ int ]]: \"\"\"Creates an anchor between a softbody and another object (or the world) Args: soft_body_id (int): ID of the softbody in Pybullet vertex_id (int): Index of the mesh vertex on the softbody we are anchoring to parent_id (int): ID of the parent object in Pybullet. If anchoring to world, this will be -1 link_id (int): Index of the link on the parent object. If the parent does not have links, use -1 parent_frame_pos (Optional[list[float]]): If the anchor is being affixed to a specific point on the parent object, pass in the location here. Defaults to None. add_geom (bool, optional): Whether or not to add a small sphere to visualize the positioning on the anchor. Defaults to False. geom_pos (Optional[npt.ArrayLike]): Position of the sphere in world frame, shape (3,). Defaults to None, (in which case add_geom must also be None) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: tuple[int, Optional[int]]: int: The Pybullet ID for the anchor Optional[int]: The Pybullet ID for the geometry (if add_geom is False, this is None) \"\"\" client : pybullet = pybullet if client is None else client anchor_id = client . createSoftBodyAnchor ( soft_body_id , vertex_id , parent_id , link_id , parent_frame_pos ) if add_geom : if geom_pos is None : raise ValueError ( \"If visualizing the anchor, the world-position of the anchor must be included\" ) # Create a collision-less sphere to visualize the anchor position geom_id = create_sphere ( geom_pos , 0.01 , 0.01 , False , [ 0 , 1 , 0 , 0.5 ], client ) # Then create a secondary anchor to make sure this sphere stays in the right place geom_anchor_id = client . createSoftBodyAnchor ( soft_body_id , vertex_id , geom_id , - 1 ) else : geom_id = None return anchor_id , geom_id def create_box ( pos : npt . ArrayLike , orn : npt . ArrayLike , mass : float , sidelengths : npt . ArrayLike , use_collision : bool , rgba : npt . ArrayLike = ( 1 , 1 , 1 , 1 ), client : Optional [ BulletClient ] = None , ) -> int : \"\"\"Creates a rigid box in the Pybullet simulation Args: pos (npt.ArrayLike): Position of the box in world frame, shape (3) orn (npt.ArrayLike): Orientation (XYZW quaternion) of the box in world frame, shape (4,) mass (float): Mass of the box. If set to 0, the box is fixed in space sidelengths (npt.ArrayLike): Sidelengths of the box along the local XYZ axes, shape (3,) use_collision (bool): Whether or not collision is enabled for the box rgba (npt.ArrayLike, optional): Color of the box, with each RGBA value being in [0, 1]. Defaults to (1, 1, 1, 1) (white) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: int: ID of the box in Pybullet \"\"\" client : pybullet = pybullet if client is None else client if len ( sidelengths ) != 3 : raise ValueError ( \"Must provide the dimensions of the three sides of the box\" ) half_extents = np . asarray ( sidelengths ) / 2 visual_id = client . createVisualShape ( pybullet . GEOM_BOX , halfExtents = half_extents , rgbaColor = rgba , ) if use_collision : collision_id = client . createCollisionShape ( pybullet . GEOM_BOX , halfExtents = half_extents , ) else : collision_id = - 1 box_id = client . createMultiBody ( baseMass = mass , basePosition = pos , baseOrientation = orn , baseCollisionShapeIndex = collision_id , baseVisualShapeIndex = visual_id , ) return box_id def read_log_file ( filename : str , verbose : bool = False ) -> list [ list [ Union [ int , float ]]]: \"\"\"Reads a Pybullet state log for generic robots and objects We assume that when generating the log: - The loggingType was set to STATE_LOGGING_GENERIC_ROBOT - No softbodies were included in the logged items - The maxLogDof is left at the default value (12) This code is modified from bullet3/examples/pybullet/examples/kuka_with_cube_playback.py Args: filename (str): Filename for the saved log verbose (bool, optional): Whether to print info about the log when reading. Defaults to False. Returns: list[list[Union[int, float]]]: The Pybullet log. Length is (number of timesteps) * (number of objects logged) If multiple objects are logged, there will be multiple consecutive log entries for the same timestep Each record in the log contains the following info: step_count = record[0] timestamp = record[1] unique_id = record[2] position = record[3:6] orientation = record[6:10] velocity = record[10:13] angular_velocity = record[13:16] num_joints = record[16] joint_positions = record[17 : 17 + max_log_dof] joint_torques = record[17 + max_log_dof :] \"\"\" with open ( filename , \"rb\" ) as f : keys = f . readline () . decode ( \"utf8\" ) . rstrip ( \" \\n \" ) . split ( \",\" ) fmt = f . readline () . decode ( \"utf8\" ) . rstrip ( \" \\n \" ) # The byte number of one record sz = struct . calcsize ( fmt ) # The type number of one record ncols = len ( fmt ) info = { \"filename\" : filename , \"keys\" : keys , \"format\" : fmt , \"size\" : sz , \"columns\" : ncols , } if verbose : print ( info ) # Read data whole_file = f . read () # split by alignment word chunks = whole_file . split ( b \" \\xaa\\xbb \" ) log = [] for chunk in chunks : if len ( chunk ) == sz : values = struct . unpack ( fmt , chunk ) record = [] for i in range ( ncols ): record . append ( values [ i ]) log . append ( record ) return log # TODO determine if this really is real time or if it's sim time during the original run... def playback_from_log ( log_file : str , real_time : bool = True , client : Optional [ BulletClient ] = None , ) -> None : \"\"\"Reads a log file and then replays that logged simulation We assume that the environment has been set up the same way as the original environment when the logging occurred. If this is not the case, it can lead to odd results The logs also contain a lot more info like velocities and torques, but we don't really need this information to play things back (simply resetting pose will appear correct) This code is modified from bullet3/examples/pybullet/examples/kuka_with_cube_playback.py Args: log_file (str): Filename for the saved log real_time (bool, optional): Whether to play back the log in real time (according to the timestamps saved in the log). Defaults to True. If False, things will be very speedy client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" client : pybullet = pybullet if client is None else client log = read_log_file ( log_file ) start_time = time . time () for record in log : timestamp = record [ 1 ] uid = record [ 2 ] pos = record [ 3 : 6 ] orn = record [ 6 : 10 ] client . resetBasePositionAndOrientation ( uid , pos , orn ) num_joints = client . getNumJoints ( uid ) for i in range ( num_joints ): joint_info = client . getJointInfo ( uid , i ) q_index = joint_info [ 3 ] if q_index > - 1 : client . resetJointState ( uid , i , record [ q_index - 7 + 17 ]) if real_time : time . sleep ( max ( 0 , timestamp - time . time () + start_time ))","title":"Module pyastrobee.utils.bullet_utils"},{"location":"reference/pyastrobee/utils/bullet_utils/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/utils/bullet_utils/#add_texture_to_deformable","text":"def add_texture_to_deformable ( object_id : int , texture_filename : str , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> None Applies a texture to a deformable object Parameters: Name Type Description Default object_id int The ID of the deformable object in the pybullet simulation None texture_filename str Path to the texture file None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None View Source def add_texture_to_deformable ( object_id : int , texture_filename : str , client : Optional [ BulletClient ] = None , ) -> None : \"\"\"Applies a texture to a deformable object Args: object_id (int): The ID of the deformable object in the pybullet simulation texture_filename (str): Path to the texture file client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" client : pybullet = pybullet if client is None else client texture_id = client . loadTexture ( texture_filename ) kwargs = {} if hasattr ( pybullet , \"VISUAL_SHAPE_DOUBLE_SIDED\" ) : kwargs [ \"flags\" ] = pybullet . VISUAL_SHAPE_DOUBLE_SIDED client . changeVisualShape ( object_id , - 1 , rgbaColor =[ 1, 1, 1, 1 ] , textureUniqueId = texture_id , ** kwargs )","title":"add_texture_to_deformable"},{"location":"reference/pyastrobee/utils/bullet_utils/#add_texture_to_rigid","text":"def add_texture_to_rigid ( object_id : int , texture_filename : str , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> None Applies a texture to a rigid object Parameters: Name Type Description Default object_id int The ID of the rigid object in the pybullet simulation None texture_filename str Path to the texture file None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None View Source def add_texture_to_rigid ( object_id : int , texture_filename : str , client : Optional [ BulletClient ] = None , ) -> None : \"\"\"Applies a texture to a rigid object Args: object_id (int): The ID of the rigid object in the pybullet simulation texture_filename (str): Path to the texture file client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" client : pybullet = pybullet if client is None else client texture_id = client . loadTexture ( texture_filename ) kwargs = {} if hasattr ( pybullet , \"VISUAL_SHAPE_DOUBLE_SIDED\" ) : kwargs [ \"flags\" ] = pybullet . VISUAL_SHAPE_DOUBLE_SIDED num_joints = client . getNumJoints ( object_id ) # TODO : check on the indexing here ( for now , assuming dedo is correct ) for i in range ( - 1 , num_joints ) : client . changeVisualShape ( object_id , i , rgbaColor =[ 1, 1, 1, 1 ] , textureUniqueId = texture_id , ** kwargs , )","title":"add_texture_to_rigid"},{"location":"reference/pyastrobee/utils/bullet_utils/#configure_visualization","text":"def configure_visualization ( camera_params : Optional [ list [ float ]] = None , flags_to_enable : Optional [ list [ float ]] = None , flags_to_disable : Optional [ list [ float ]] = None , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None , ** kwargs ) -> None Configures the pybullet debug visualizer Parameters: Name Type Description Default camera_params list[float] Used to reset camera position. [dist, pitch, yaw, pos_x, pos_y, pos_z] where dist is the distance from eye to camera target, yaw is left/right angle, pitch is up/down angle, and the xyz positions are for the focus point. Defaults to None. None flags_to_enable list[float] A list of pybullet flags (for example, COV_ENABLE_WIREFRAME). Defaults to None. None flags_to_disable list[float] A list of pybullet flags (for example, COV_ENABLE_WIREFRAME). Defaults to None. None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None **kwargs None Any additional kwargs to set. See the pybullet configureDebugVisualizer documentation for more info None View Source def configure_visualization ( camera_params : Optional [ list[float ] ] = None , flags_to_enable : Optional [ list[float ] ] = None , flags_to_disable : Optional [ list[float ] ] = None , client : Optional [ BulletClient ] = None , ** kwargs , ) -> None : \"\"\"Configures the pybullet debug visualizer Args: camera_params (list[float], optional): Used to reset camera position. [dist, pitch, yaw, pos_x, pos_y, pos_z] where dist is the distance from eye to camera target, yaw is left/right angle, pitch is up/down angle, and the xyz positions are for the focus point. Defaults to None. flags_to_enable (list[float], optional): A list of pybullet flags (for example, COV_ENABLE_WIREFRAME). Defaults to None. flags_to_disable (list[float], optional): A list of pybullet flags (for example, COV_ENABLE_WIREFRAME). Defaults to None. client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) **kwargs: Any additional kwargs to set. See the pybullet configureDebugVisualizer documentation for more info \"\"\" client : pybullet = pybullet if client is None else client if camera_params : dist , pitch , yaw , pos_x , pos_y , pos_z = camera_params client . resetDebugVisualizerCamera ( cameraDistance = dist , cameraPitch = pitch , cameraYaw = yaw , cameraTargetPosition =[ pos_x, pos_y, pos_z ] , ) if flags_to_enable : for flag in flags_to_enable : client . configureDebugVisualizer ( flag , True ) if flags_to_disable : for flag in flags_to_disable : client . configureDebugVisualizer ( flag , False ) if kwargs : client . configureDebugVisualizer ( ** kwargs )","title":"configure_visualization"},{"location":"reference/pyastrobee/utils/bullet_utils/#create_anchor","text":"def create_anchor ( soft_body_id : int , vertex_id : int , parent_id : int , link_id : int , parent_frame_pos : Optional [ list [ float ]] = None , add_geom : bool = False , geom_pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], NoneType ] = None , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> tuple [ int , typing . Optional [ int ]] Creates an anchor between a softbody and another object (or the world) Parameters: Name Type Description Default soft_body_id int ID of the softbody in Pybullet None vertex_id int Index of the mesh vertex on the softbody we are anchoring to None parent_id int ID of the parent object in Pybullet. If anchoring to world, this will be -1 None link_id int Index of the link on the parent object. If the parent does not have links, use -1 None parent_frame_pos Optional[list[float]] If the anchor is being affixed to a specific point on the parent object, pass in the location here. Defaults to None. None add_geom bool Whether or not to add a small sphere to visualize the positioning on the anchor. Defaults to False. None geom_pos Optional[npt.ArrayLike] Position of the sphere in world frame, shape (3,). Defaults to None, (in which case add_geom must also be None) None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Returns: Type Description tuple[int, Optional[int]] int: The Pybullet ID for the anchor Optional[int]: The Pybullet ID for the geometry (if add_geom is False, this is None) View Source def create_anchor ( soft_body_id : int , vertex_id : int , parent_id : int , link_id : int , parent_frame_pos : Optional [ list[float ] ] = None , add_geom : bool = False , geom_pos : Optional [ npt.ArrayLike ] = None , client : Optional [ BulletClient ] = None , ) -> tuple [ int, Optional[int ] ]: \"\"\"Creates an anchor between a softbody and another object (or the world) Args: soft_body_id (int): ID of the softbody in Pybullet vertex_id (int): Index of the mesh vertex on the softbody we are anchoring to parent_id (int): ID of the parent object in Pybullet. If anchoring to world, this will be -1 link_id (int): Index of the link on the parent object. If the parent does not have links, use -1 parent_frame_pos (Optional[list[float]]): If the anchor is being affixed to a specific point on the parent object, pass in the location here. Defaults to None. add_geom (bool, optional): Whether or not to add a small sphere to visualize the positioning on the anchor. Defaults to False. geom_pos (Optional[npt.ArrayLike]): Position of the sphere in world frame, shape (3,). Defaults to None, (in which case add_geom must also be None) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: tuple[int, Optional[int]]: int: The Pybullet ID for the anchor Optional[int]: The Pybullet ID for the geometry (if add_geom is False, this is None) \"\"\" client : pybullet = pybullet if client is None else client anchor_id = client . createSoftBodyAnchor ( soft_body_id , vertex_id , parent_id , link_id , parent_frame_pos ) if add_geom : if geom_pos is None : raise ValueError ( \"If visualizing the anchor, the world-position of the anchor must be included\" ) # Create a collision - less sphere to visualize the anchor position geom_id = create_sphere ( geom_pos , 0.01 , 0.01 , False , [ 0, 1, 0, 0.5 ] , client ) # Then create a secondary anchor to make sure this sphere stays in the right place geom_anchor_id = client . createSoftBodyAnchor ( soft_body_id , vertex_id , geom_id , - 1 ) else : geom_id = None return anchor_id , geom_id","title":"create_anchor"},{"location":"reference/pyastrobee/utils/bullet_utils/#create_box","text":"def create_box ( pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], mass : float , sidelengths : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], use_collision : bool , rgba : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 1 , 1 , 1 , 1 ), client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> int Creates a rigid box in the Pybullet simulation Parameters: Name Type Description Default pos npt.ArrayLike Position of the box in world frame, shape (3) None orn npt.ArrayLike Orientation (XYZW quaternion) of the box in world frame, shape (4,) None mass float Mass of the box. If set to 0, the box is fixed in space None sidelengths npt.ArrayLike Sidelengths of the box along the local XYZ axes, shape (3,) None use_collision bool Whether or not collision is enabled for the box None rgba npt.ArrayLike Color of the box, with each RGBA value being in [0, 1]. Defaults to (1, 1, 1, 1) (white) None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Returns: Type Description int ID of the box in Pybullet View Source def create_box ( pos : npt . ArrayLike , orn : npt . ArrayLike , mass : float , sidelengths : npt . ArrayLike , use_collision : bool , rgba : npt . ArrayLike = ( 1 , 1 , 1 , 1 ), client : Optional [ BulletClient ] = None , ) -> int : \"\"\"Creates a rigid box in the Pybullet simulation Args: pos (npt.ArrayLike): Position of the box in world frame, shape (3) orn (npt.ArrayLike): Orientation (XYZW quaternion) of the box in world frame, shape (4,) mass (float): Mass of the box. If set to 0, the box is fixed in space sidelengths (npt.ArrayLike): Sidelengths of the box along the local XYZ axes, shape (3,) use_collision (bool): Whether or not collision is enabled for the box rgba (npt.ArrayLike, optional): Color of the box, with each RGBA value being in [0, 1]. Defaults to (1, 1, 1, 1) (white) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: int: ID of the box in Pybullet \"\"\" client : pybullet = pybullet if client is None else client if len ( sidelengths ) != 3 : raise ValueError ( \"Must provide the dimensions of the three sides of the box\" ) half_extents = np . asarray ( sidelengths ) / 2 visual_id = client . createVisualShape ( pybullet . GEOM_BOX , halfExtents = half_extents , rgbaColor = rgba , ) if use_collision : collision_id = client . createCollisionShape ( pybullet . GEOM_BOX , halfExtents = half_extents , ) else : collision_id = - 1 box_id = client . createMultiBody ( baseMass = mass , basePosition = pos , baseOrientation = orn , baseCollisionShapeIndex = collision_id , baseVisualShapeIndex = visual_id , ) return box_id","title":"create_box"},{"location":"reference/pyastrobee/utils/bullet_utils/#create_sphere","text":"def create_sphere ( pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], mass : float , radius : float , use_collision : bool , rgba : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 1 , 1 , 1 , 1 ), client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> int Creates a rigid sphere in the Pybullet simulation Parameters: Name Type Description Default pos npt.ArrayLike Position of the sphere in world frame, shape (3) None mass float Mass of the sphere. If set to 0, the sphere is fixed in space None radius float Radius of the sphere None use_collision bool Whether or not collision is enabled for the sphere None rgba npt.ArrayLike Color of the sphere, with each RGBA value being in [0, 1]. Defaults to (1, 1, 1, 1) (white) None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Returns: Type Description int ID of the sphere in Pybullet View Source def create_sphere ( pos : npt . ArrayLike , mass : float , radius : float , use_collision : bool , rgba : npt . ArrayLike = ( 1 , 1 , 1 , 1 ), client : Optional [ BulletClient ] = None , ) -> int : \"\"\"Creates a rigid sphere in the Pybullet simulation Args: pos (npt.ArrayLike): Position of the sphere in world frame, shape (3) mass (float): Mass of the sphere. If set to 0, the sphere is fixed in space radius (float): Radius of the sphere use_collision (bool): Whether or not collision is enabled for the sphere rgba (npt.ArrayLike, optional): Color of the sphere, with each RGBA value being in [0, 1]. Defaults to (1, 1, 1, 1) (white) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: int: ID of the sphere in Pybullet \"\"\" client : pybullet = pybullet if client is None else client visual_id = client . createVisualShape ( pybullet . GEOM_SPHERE , radius = radius , rgbaColor = rgba ) if use_collision : collision_id = client . createCollisionShape ( pybullet . GEOM_SPHERE , radius = radius ) else : collision_id = - 1 sphere_id = client . createMultiBody ( baseMass = mass , basePosition = pos , baseCollisionShapeIndex = collision_id , baseVisualShapeIndex = visual_id , ) return sphere_id","title":"create_sphere"},{"location":"reference/pyastrobee/utils/bullet_utils/#initialize_pybullet","text":"def initialize_pybullet ( use_gui : bool = True , physics_freq : float = 350 , gravity : float = 0.0 , bg_color : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 0.0 , 0.0 , 0.0 ) ) -> < module 'pybullet' from '/home/dmorton/.pyenv/versions/3.10.8/envs/astrobee/lib/python3.10/site-packages/pybullet.cpython-310-x86_64-linux-gnu.so' > Starts a pybullet client with the required physics parameters we care about NOTE: the client object returned from this function should ALWAYS be assigned to a variable to keep the simulation in scope. i.e. don't just call initialize_pybullet(), use client = initialize_pybullet() even if you're not worrying about multiple physics simulations Parameters: Name Type Description Default use_gui bool Whether or not to use the GUI as opposed to headless. Defaults to True None physics_freq float Physics simulation frequency, in Hz. Defaults to 350. Note: Pybullet defaults to 240 Hz, but this seemed to be unstable for soft bodies 350 gravity float Z component of gravitational acceleration vector. Defaults to 0. 0 bg_color npt.ArrayLike RGB values for the GUI background, each in range [0, 1]. Defaults to (0.0, 0.0, 0.0) (black). Note: (1.0, 1.0, 1.0) is white None Returns: Type Description BulletClient Pybullet physics simulation client View Source def initialize_pybullet ( use_gui : bool = True , physics_freq : float = 350 , gravity : float = 0.0 , bg_color : npt . ArrayLike = ( 0.0 , 0.0 , 0.0 ), ) -> pybullet : \"\"\"Starts a pybullet client with the required physics parameters we care about NOTE: the client object returned from this function should ALWAYS be assigned to a variable to keep the simulation in scope. i.e. don't just call initialize_pybullet(), use client = initialize_pybullet() even if you're not worrying about multiple physics simulations Args: use_gui (bool, optional): Whether or not to use the GUI as opposed to headless. Defaults to True physics_freq (float, optional): Physics simulation frequency, in Hz. Defaults to 350. Note: Pybullet defaults to 240 Hz, but this seemed to be unstable for soft bodies gravity (float, optional): Z component of gravitational acceleration vector. Defaults to 0. bg_color (npt.ArrayLike, optional): RGB values for the GUI background, each in range [0, 1]. Defaults to (0.0, 0.0, 0.0) (black). Note: (1.0, 1.0, 1.0) is white Returns: BulletClient: Pybullet physics simulation client \"\"\" # Make sure we're in the right directory so filepaths work well with pybullet cwd = os . getcwd () if not cwd . endswith ( \"pyastrobee\" ) or cwd . endswith ( \"pyastrobee/pyastrobee\" ): raise ConnectionRefusedError ( f \"You are running scripts from {cwd}. \\n Ensure you're at the top-level pyastrobee directory.\" ) # Ensure that the background color values are within the proper range bg_color = np . array ( bg_color ) if len ( bg_color ) != 3 or not ( all ( bg_color >= 0 ) and all ( bg_color <= 1 )): raise ValueError ( f \"Invalid background color: {bg_color}\" ) bg_args = ( f \"--background_color_red={bg_color[0]} \" + f \"--background_color_green={bg_color[1]} \" + f \"--background_color_blue={bg_color[2]}\" ) # Connect to pybullet connection_mode = pybullet . GUI if use_gui else pybullet . DIRECT client : pybullet = BulletClient ( connection_mode , options = bg_args ) # Configure physics client . resetSimulation ( pybullet . RESET_USE_DEFORMABLE_WORLD ) client . setTimeStep ( 1.0 / physics_freq ) client . setGravity ( 0 , 0 , gravity ) # Configure search paths client . setAdditionalSearchPath ( pybullet_data . getDataPath ()) # client.setAdditionalSearchPath(os.path.join(os.getcwd(), \"pyastrobee/assets\")) client . setAdditionalSearchPath ( cwd ) # Remove the extra windows in PyBullet GUI (until we use them for cameras). client . configureDebugVisualizer ( pybullet . COV_ENABLE_GUI , False ) return client","title":"initialize_pybullet"},{"location":"reference/pyastrobee/utils/bullet_utils/#load_deformable_object","text":"def load_deformable_object ( filename : str , texture_filename : Optional [ str ] = None , scale : float = 1.0 , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 0.0 , 0.0 , 0.0 ), orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 0.0 , 0.0 , 0.0 , 1.0 ), mass : float = 1.0 , bending_stiffness : float = 50.0 , damping_stiffness : float = 0.1 , elastic_stiffness : float = 50.0 , friction_coeff : float = 0.1 , self_collision : bool = False , sim_file_name = '' , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> int Loads a deformable object from an OBJ file Notes: bending and elastic stiffness >90 cause instabilities. Parameters: Name Type Description Default filename str Path to the deformable object to load None texture_filename str Path to a texture file to apply. Defaults to None, in which case no texture will be applied None scale float Scaling factor for the loaded object. Defaults to 1.0. 1.0 pos npt.ArrayLike Initial position for the loaded object. Defaults to (0.0, 0.0, 0.0). (0.0, 0.0, 0.0) orn npt.ArrayLike Initial XYZW quaternion orientation. Defaults to (0, 0, 0, 1). (0, 0, 0, 1) mass float Mass of the loaded object. Defaults to 1.0 (Keeping at 1.0 is the most stable option). 1.0 (Keeping at 1.0 is the most stable option) bending_stiffness float Bending stiffness of the loaded object. Defaults to 1.0. 1.0 damping_stiffness float Damping stiffness of the loaded object. Defaults to 0.1. 0.1 elastic_stiffness float Elastic stiffness of the loaded object. Defaults to 1.0. 1.0 friction_coeff float Friction coefficient of the loaded object. Defaults to 0.1. 0.1 self_collision bool Whether or not to allow self-collisions for the object. Defaults to False. Note: setting this as True seemed to lead to mesh collapse False sim_file_name str This is an undocumented input to loadSoftBody, but it appears to allow you to load an OBJ in the filename (for texture purposes) and a corresponding VTK in the simFileName for volumetric softbody physics None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Returns: Type Description int ID number for the object View Source def load_deformable_object ( filename : str , texture_filename : Optional [ str ] = None , scale : float = 1.0 , pos : npt . ArrayLike = ( 0.0 , 0.0 , 0.0 ), orn : npt . ArrayLike = ( 0.0 , 0.0 , 0.0 , 1.0 ), mass : float = 1.0 , bending_stiffness : float = 50.0 , damping_stiffness : float = 0.1 , elastic_stiffness : float = 50.0 , friction_coeff : float = 0.1 , self_collision : bool = False , sim_file_name = \"\" , client : Optional [ BulletClient ] = None , ) -> int : \"\"\"Loads a deformable object from an OBJ file Notes: bending and elastic stiffness >90 cause instabilities. Args: filename (str): Path to the deformable object to load texture_filename (str, optional): Path to a texture file to apply. Defaults to None, in which case no texture will be applied scale (float, optional): Scaling factor for the loaded object. Defaults to 1.0. pos (npt.ArrayLike, optional): Initial position for the loaded object. Defaults to (0.0, 0.0, 0.0). orn (npt.ArrayLike, optional): Initial XYZW quaternion orientation. Defaults to (0, 0, 0, 1). mass (float, optional): Mass of the loaded object. Defaults to 1.0 (Keeping at 1.0 is the most stable option). bending_stiffness (float, optional): Bending stiffness of the loaded object. Defaults to 1.0. damping_stiffness (float, optional): Damping stiffness of the loaded object. Defaults to 0.1. elastic_stiffness (float, optional): Elastic stiffness of the loaded object. Defaults to 1.0. friction_coeff (float, optional): Friction coefficient of the loaded object. Defaults to 0.1. self_collision (bool, optional): Whether or not to allow self-collisions for the object. Defaults to False. Note: setting this as True seemed to lead to mesh collapse sim_file_name (str, optional): This is an undocumented input to loadSoftBody, but it appears to allow you to load an OBJ in the filename (for texture purposes) and a corresponding VTK in the simFileName for volumetric softbody physics client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: int: ID number for the object \"\"\" client : pybullet = pybullet if client is None else client if mass < 1.0 : print_red ( \"Warning: mass > 1 is the most stable for deformables. Small mass can cause instabilities\" ) # TODO : decide if some of these parameters should be included as inputs rather than hard - coded deform_id = client . loadSoftBody ( mass = mass , fileName = filename , scale = scale , basePosition = list ( pos ), baseOrientation = list ( orn ), springElasticStiffness = elastic_stiffness , springDampingStiffness = damping_stiffness , springBendingStiffness = bending_stiffness , frictionCoeff = friction_coeff , # collisionMargin = 0.003 , # how far apart do two objects begin interacting useSelfCollision = self_collision , springDampingAllDirections = 1 , useFaceContact = True , useNeoHookean = 0 , useMassSpring = True , useBendingSprings = True , # repulsionStiffness = 10000000 , simFileName = sim_file_name , ) # TODO figure out what this sparseSdfVoxelSize parameter actually does ( it ' s not documented ) # See pybullet examples / deformable_anchor . py for its usage there client . setPhysicsEngineParameter ( sparseSdfVoxelSize = 0.25 ) if texture_filename is not None : add_texture_to_deformable ( deform_id , texture_filename , client ) # Validate the size of the mesh to assure stability num_mesh_vertices = get_mesh_data ( deform_id , client ) [ 0 ] if num_mesh_vertices > 2 ** 13 : print_red ( f \"Warning: high number of mesh vertices: {num_mesh_vertices}. Consider a lower-res mesh\" ) return deform_id","title":"load_deformable_object"},{"location":"reference/pyastrobee/utils/bullet_utils/#load_floor","text":"def load_floor ( texture_filename : Optional [ str ] = None , z_pos : float = 0.0 , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> int Loads a floor into the pybullet simulation Parameters: Name Type Description Default texture_filename str If adding a texture to the floor plane, pass in the filename. Defaults to None. None z_pos float Height (z-coordinate) of the floor in the world. Defaults to 0.0 0 client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Returns: Type Description int Pybullet ID corresponding to the floor View Source def load_floor ( texture_filename : Optional [ str ] = None , z_pos : float = 0.0 , client : Optional [ BulletClient ] = None , ) -> int : \"\"\"Loads a floor into the pybullet simulation Args: texture_filename (str, optional): If adding a texture to the floor plane, pass in the filename. Defaults to None. z_pos (float, optional): Height (z-coordinate) of the floor in the world. Defaults to 0.0 client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: int: Pybullet ID corresponding to the floor \"\"\" client : pybullet = pybullet if client is None else client client . setAdditionalSearchPath ( pybullet_data . getDataPath ()) floor_id = client . loadURDF ( \"plane.urdf\" , basePosition =[ 0, 0, z_pos ] ) if texture_filename is not None : texture_id = client . loadTexture ( texture_filename ) client . changeVisualShape ( floor_id , - 1 , rgbaColor =[ 1, 1, 1, 0 ] , textureUniqueId = texture_id , ) return floor_id","title":"load_floor"},{"location":"reference/pyastrobee/utils/bullet_utils/#load_rigid_object","text":"def load_rigid_object ( filename : str , texture_filename : Optional [ str ] = None , scale : float = 1.0 , pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 0.0 , 0.0 , 0.0 ), orn : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 0.0 , 0.0 , 0.0 , 1.0 ), mass : float = 1.0 , fixed : bool = False , rgba : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 1.0 , 1.0 , 1.0 , 1.0 ), client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> int Loads a rigid object from an OBJ or URDF file Parameters: Name Type Description Default filename str Path to the OBJ/URDF file to load None texture_filename str Path to a texture file to apply. Defaults to None, in which case no texture will be applied None scale float Scaling factor for the loaded object. Defaults to 1.0. 1.0 pos npt.ArrayLike Initial position for the loaded object. Defaults to (0, 0, 0). (0, 0, 0) orn npt.ArrayLike Initial XYZW quaternion orientation. Defaults to (0, 0, 0, 1). (0, 0, 0, 1) mass float Mass of the loaded object. Defaults to 1.0. 1.0 fixed bool Whether or not to fix the object in space. Defaults to False. False rgba npt.ArrayLike Color of the object, expressed as RGBA, each within range [0, 1]. Defaults to (1.0, 1.0, 1.0, 1.0) (white). None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Returns: Type Description int ID number for the object Raises: Type Description ValueError If the filename is not a valid OBJ or URDF View Source def load_rigid_object ( filename : str , texture_filename : Optional [ str ] = None , scale : float = 1.0 , pos : npt . ArrayLike = ( 0.0 , 0.0 , 0.0 ), orn : npt . ArrayLike = ( 0.0 , 0.0 , 0.0 , 1.0 ), mass : float = 1.0 , fixed : bool = False , rgba : npt . ArrayLike = ( 1.0 , 1.0 , 1.0 , 1.0 ), client : Optional [ BulletClient ] = None , ) -> int : \"\"\"Loads a rigid object from an OBJ or URDF file Args: filename (str): Path to the OBJ/URDF file to load texture_filename (str, optional): Path to a texture file to apply. Defaults to None, in which case no texture will be applied scale (float, optional): Scaling factor for the loaded object. Defaults to 1.0. pos (npt.ArrayLike, optional): Initial position for the loaded object. Defaults to (0, 0, 0). orn (npt.ArrayLike, optional): Initial XYZW quaternion orientation. Defaults to (0, 0, 0, 1). mass (float, optional): Mass of the loaded object. Defaults to 1.0. fixed (bool, optional): Whether or not to fix the object in space. Defaults to False. rgba (npt.ArrayLike, optional): Color of the object, expressed as RGBA, each within range [0, 1]. Defaults to (1.0, 1.0, 1.0, 1.0) (white). client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Raises: ValueError: If the filename is not a valid OBJ or URDF Returns: int: ID number for the object \"\"\" client : pybullet = pybullet if client is None else client # Deal with pybullet 's weird handling of mass = 0 being fixed if mass < 0: raise ValueError(\"Mass should not be a negative value\") if mass == 0: print_red( f\"Warning: the mass of {filename} is 0, which will make it fixed. Use the ' fixed ' parameter instead \" ) if fixed: mass = 0.0 if filename.endswith(\" . obj \"): # mesh info xyz_scale = [scale, scale, scale] visual_id = client.createVisualShape( shapeType=pybullet.GEOM_MESH, rgbaColor=rgba, fileName=filename, meshScale=xyz_scale, ) collision_id = client.createCollisionShape( shapeType=pybullet.GEOM_MESH, fileName=filename, meshScale=xyz_scale ) rigid_id = client.createMultiBody( baseMass=mass, # mass==0 => fixed at position where it is loaded basePosition=pos, baseCollisionShapeIndex=collision_id, baseVisualShapeIndex=visual_id, baseOrientation=orn, ) elif filename.endswith(\" . urdf \"): # URDF file rigid_id = client.loadURDF( filename, pos, orn, useFixedBase=fixed, globalScaling=scale, ) else: raise ValueError( f\" Invalid filename : { filename } . Import either an OBJ or URDF file \" ) # TODO : decide if these parameters should be included as inputs rather than hard - coded client . changeDynamics ( rigid_id , - 1 , mass , lateralFriction = 1.0 , spinningFriction = 1.0 , rollingFriction = 1.0 , restitution = 0.0 , ) if texture_filename is not None : add_texture_to_rigid ( rigid_id , texture_filename , client ) return rigid_id","title":"load_rigid_object"},{"location":"reference/pyastrobee/utils/bullet_utils/#playback_from_log","text":"def playback_from_log ( log_file : str , real_time : bool = True , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> None Reads a log file and then replays that logged simulation We assume that the environment has been set up the same way as the original environment when the logging occurred. If this is not the case, it can lead to odd results The logs also contain a lot more info like velocities and torques, but we don't really need this information to play things back (simply resetting pose will appear correct) This code is modified from bullet3/examples/pybullet/examples/kuka_with_cube_playback.py Parameters: Name Type Description Default log_file str Filename for the saved log None real_time bool Whether to play back the log in real time (according to the timestamps saved in the log). Defaults to True. If False, things will be very speedy None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None View Source def playback_from_log ( log_file : str , real_time : bool = True , client : Optional [ BulletClient ] = None , ) -> None : \"\"\"Reads a log file and then replays that logged simulation We assume that the environment has been set up the same way as the original environment when the logging occurred. If this is not the case, it can lead to odd results The logs also contain a lot more info like velocities and torques, but we don't really need this information to play things back (simply resetting pose will appear correct) This code is modified from bullet3/examples/pybullet/examples/kuka_with_cube_playback.py Args: log_file (str): Filename for the saved log real_time (bool, optional): Whether to play back the log in real time (according to the timestamps saved in the log). Defaults to True. If False, things will be very speedy client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" client : pybullet = pybullet if client is None else client log = read_log_file ( log_file ) start_time = time . time () for record in log : timestamp = record [ 1 ] uid = record [ 2 ] pos = record [ 3:6 ] orn = record [ 6:10 ] client . resetBasePositionAndOrientation ( uid , pos , orn ) num_joints = client . getNumJoints ( uid ) for i in range ( num_joints ) : joint_info = client . getJointInfo ( uid , i ) q_index = joint_info [ 3 ] if q_index > - 1 : client . resetJointState ( uid , i , record [ q_index - 7 + 17 ] ) if real_time : time . sleep ( max ( 0 , timestamp - time . time () + start_time ))","title":"playback_from_log"},{"location":"reference/pyastrobee/utils/bullet_utils/#read_log_file","text":"def read_log_file ( filename : str , verbose : bool = False ) -> list [ list [ typing . Union [ int , float ]]] Reads a Pybullet state log for generic robots and objects We assume that when generating the log: - The loggingType was set to STATE_LOGGING_GENERIC_ROBOT - No softbodies were included in the logged items - The maxLogDof is left at the default value (12) This code is modified from bullet3/examples/pybullet/examples/kuka_with_cube_playback.py Parameters: Name Type Description Default filename str Filename for the saved log None verbose bool Whether to print info about the log when reading. Defaults to False. False Returns: Type Description list[list[Union[int, float]]] The Pybullet log. Length is (number of timesteps) * (number of objects logged) If multiple objects are logged, there will be multiple consecutive log entries for the same timestep Each record in the log contains the following info: step_count = record[0] timestamp = record[1] unique_id = record[2] position = record[3:6] orientation = record[6:10] velocity = record[10:13] angular_velocity = record[13:16] num_joints = record[16] joint_positions = record[17 : 17 + max_log_dof] joint_torques = record[17 + max_log_dof :] View Source def read_log_file ( filename : str , verbose : bool = False ) -> list [ list[Union[int, float ] ]]: \"\"\"Reads a Pybullet state log for generic robots and objects We assume that when generating the log: - The loggingType was set to STATE_LOGGING_GENERIC_ROBOT - No softbodies were included in the logged items - The maxLogDof is left at the default value (12) This code is modified from bullet3/examples/pybullet/examples/kuka_with_cube_playback.py Args: filename (str): Filename for the saved log verbose (bool, optional): Whether to print info about the log when reading. Defaults to False. Returns: list[list[Union[int, float]]]: The Pybullet log. Length is (number of timesteps) * (number of objects logged) If multiple objects are logged, there will be multiple consecutive log entries for the same timestep Each record in the log contains the following info: step_count = record[0] timestamp = record[1] unique_id = record[2] position = record[3:6] orientation = record[6:10] velocity = record[10:13] angular_velocity = record[13:16] num_joints = record[16] joint_positions = record[17 : 17 + max_log_dof] joint_torques = record[17 + max_log_dof :] \"\"\" with open ( filename , \"rb\" ) as f : keys = f . readline (). decode ( \"utf8\" ). rstrip ( \"\\n\" ). split ( \",\" ) fmt = f . readline (). decode ( \"utf8\" ). rstrip ( \"\\n\" ) # The byte number of one record sz = struct . calcsize ( fmt ) # The type number of one record ncols = len ( fmt ) info = { \"filename\" : filename , \"keys\" : keys , \"format\" : fmt , \"size\" : sz , \"columns\" : ncols , } if verbose : print ( info ) # Read data whole_file = f . read () # split by alignment word chunks = whole_file . split ( b \"\\xaa\\xbb\" ) log = [] for chunk in chunks : if len ( chunk ) == sz : values = struct . unpack ( fmt , chunk ) record = [] for i in range ( ncols ) : record . append ( values [ i ] ) log . append ( record ) return log","title":"read_log_file"},{"location":"reference/pyastrobee/utils/bullet_utils/#run_sim","text":"def run_sim ( viz_freq : float = 240 , timeout : Optional [ float ] = None , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) Runs the pybullet simulation Parameters: Name Type Description Default viz_freq float Frequency (Hz) to run the visualization (if connected via GUI). Defaults to 240. 240 timeout float Amount of time to run the simulation. Defaults to None, in which case the simulation will remain open until it is killed manually. None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Raises: Type Description ConnectionError If a pybullet client is not currently running ValueError If the visualization frequency is greater than the physics frequency View Source def run_sim ( viz_freq : float = 240 , timeout : Optional [ float ] = None , client : Optional [ BulletClient ] = None , ) : \"\"\"Runs the pybullet simulation Args: viz_freq (float, optional): Frequency (Hz) to run the visualization (if connected via GUI). Defaults to 240. timeout (float, optional): Amount of time to run the simulation. Defaults to None, in which case the simulation will remain open until it is killed manually. client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Raises: ConnectionError: If a pybullet client is not currently running ValueError: If the visualization frequency is greater than the physics frequency \"\"\" client : pybullet = pybullet if client is None else client connect_info : dict [ str, int ] = client . getConnectionInfo () if not connect_info [ \"isConnected\" ] : raise ConnectionError ( \"Connect to a pybullet client before running the sim\" ) connect_mode = \"GUI\" if connect_info [ \"connectionMethod\" ] == 1 else \"DIRECT\" phys_info = client . getPhysicsEngineParameters () phys_freq = 1.0 / phys_info [ \"fixedTimeStep\" ] if viz_freq > phys_freq : raise ValueError ( f \"Cannot visualize ({viz_freq} Hz) faster than the physics ({phys_freq} Hz)\" ) if timeout is None : timeout = float ( \"inf\" ) start_time = time . time () try : while ( time . time () - start_time < timeout ) and client . isConnected () : client . stepSimulation () if connect_mode == \"GUI\" : time . sleep ( 1.0 / viz_freq ) finally : client . disconnect ()","title":"run_sim"},{"location":"reference/pyastrobee/utils/debug_visualizer/","text":"Module pyastrobee.utils.debug_visualizer Functions associated with the Pybullet Debug Visualizer GUI NOTE - For the GUI camera parameters, since the debug visualizer only specifies yaw and pitch (no roll), this is an incomplete definition of rotation, so we can never actually fully change the rotation of the debug viz camera to match the robot's position - This is not a huge deal, it will just mean we will have at best a \"video game perspective\" of the robot View Source \"\"\"Functions associated with the Pybullet Debug Visualizer GUI NOTE - For the GUI camera parameters, since the debug visualizer only specifies yaw and pitch (no roll), this is an incomplete definition of rotation, so we can never actually fully change the rotation of the debug viz camera to match the robot's position - This is not a huge deal, it will just mean we will have at best a \"video game perspective\" of the robot \"\"\" import time from typing import Optional , Union import numpy as np import numpy.typing as npt import pybullet from pybullet_utils.bullet_client import BulletClient import pytransform3d.coordinates as pc from pyastrobee.core.astrobee import Astrobee from pyastrobee.utils.rotations import ( quat_to_fixed_xyz , fixed_xyz_to_quat , fixed_xyz_to_rmat , quat_to_rmat , ) from pyastrobee.utils.poses import pos_quat_to_tmat from pyastrobee.utils.transformations import make_transform_mat from pyastrobee.config.astrobee_transforms import OBSERVATION_CAM from pyastrobee.control.constraint_controller import ConstraintController from pyastrobee.utils.bullet_utils import create_box def visualize_points ( position : npt . ArrayLike , color : npt . ArrayLike , size : float = 20 , lifetime : float = 0 , client : Optional [ BulletClient ] = None , ) -> int : \"\"\"Adds square points to the GUI to visualize positions in the sim Args: position (npt.ArrayLike): 3D point(s) in the simulation to visualize. Shape (n, 3) color (npt.ArrayLike): RGB values, each in range [0, 1]. Shape (3,) if specifying the same color for all points, or (n, 3) to individually specify the colors per-point size (float): Size of the points on the GUI, in pixels. Defaults to 20 lifetime (float, optional): Amount of time to keep the points on the GUI, in seconds. Defaults to 0 (keep them on-screen permanently until deleted) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: int: Pybullet object ID for the point / point cloud \"\"\" client : pybullet = pybullet if client is None else client # Pybullet will crash if you try to visualize one point without packing it into a 2D array position = np . atleast_2d ( position ) color = np . atleast_2d ( color ) if position . shape [ - 1 ] != 3 : raise ValueError ( f \"Invalid shape of the point positions. Expected (n, 3), got: { position . shape } \" ) if color . shape [ - 1 ] != 3 : raise ValueError ( f \"Invalid shape of the colors. Expected (n, 3), got: { color . shape } \" ) n = position . shape [ 0 ] if color . shape [ 0 ] != n : if color . shape [ 0 ] == 1 : # Map the same color to all of the points color = color * np . ones_like ( position ) else : raise ValueError ( f \"Number of colors ( { color . shape [ 0 ] } ) does not match the number of points ( { n } ).\" ) return client . addUserDebugPoints ( position , color , size , lifetime ) def visualize_frame ( tmat : np . ndarray , length : float = 1 , width : float = 3 , lifetime : float = 0 , client : Optional [ BulletClient ] = None , ) -> tuple [ int , int , int ]: \"\"\"Adds RGB XYZ axes to the Pybullet GUI for a speficied transformation/frame/pose Args: tmat (np.ndarray): Transformation matrix specifying a pose w.r.t world frame, shape (4, 4) length (float, optional): Length of the axis lines. Defaults to 1. width (float, optional): Width of the axis lines. Defaults to 3. (units unknown, maybe mm?) lifetime (float, optional): Amount of time to keep the lines on the GUI, in seconds. Defaults to 0 (keep them on-screen permanently until deleted) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: tuple[int, int, int]: Pybullet IDs of the three axis lines added to the GUI \"\"\" client : pybullet = pybullet if client is None else client x_color = [ 1 , 0 , 0 ] # R y_color = [ 0 , 1 , 0 ] # G z_color = [ 0 , 0 , 1 ] # B origin = tmat [: 3 , 3 ] x_endpt = origin + tmat [: 3 , 0 ] * length y_endpt = origin + tmat [: 3 , 1 ] * length z_endpt = origin + tmat [: 3 , 2 ] * length x_ax_id = client . addUserDebugLine ( origin , x_endpt , x_color , width , lifetime ) y_ax_id = client . addUserDebugLine ( origin , y_endpt , y_color , width , lifetime ) z_ax_id = client . addUserDebugLine ( origin , z_endpt , z_color , width , lifetime ) return x_ax_id , y_ax_id , z_ax_id def visualize_link_frame ( robot_id : int , link_id : int , length : float = 1 , width : float = 3 , lifetime : float = 0 , client : Optional [ BulletClient ] = None , ) -> tuple [ int , int , int ]: \"\"\"Adds RGB XYZ axes to the Pybullet GUI for a specific link on the Astrobee Args: robot_id (int): Pybullet ID of the Astrobee link_id (int): ID of the link we want to look at length (float, optional): Length of the axis lines. Defaults to 1. width (float, optional): Width of the axis lines. Defaults to 3. (units unknown, maybe mm?) lifetime (float, optional): Amount of time to keep the lines on the GUI, in seconds. Defaults to 0 (keep them on-screen permanently until deleted) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: tuple[int, int, int]: Pybullet IDs of the three axis lines added to the GUI \"\"\" client : pybullet = pybullet if client is None else client x_color = [ 1 , 0 , 0 ] # R y_color = [ 0 , 1 , 0 ] # G z_color = [ 0 , 0 , 1 ] # B origin = [ 0 , 0 , 0 ] x_endpt = np . array ([ 1 , 0 , 0 ]) * length y_endpt = np . array ([ 0 , 1 , 0 ]) * length z_endpt = np . array ([ 0 , 0 , 1 ]) * length x_ax_id = client . addUserDebugLine ( origin , x_endpt , x_color , width , lifetime , robot_id , link_id ) y_ax_id = client . addUserDebugLine ( origin , y_endpt , y_color , width , lifetime , robot_id , link_id ) z_ax_id = client . addUserDebugLine ( origin , z_endpt , z_color , width , lifetime , robot_id , link_id ) return x_ax_id , y_ax_id , z_ax_id def visualize_quaternion ( quat : npt . ArrayLike , length : float = 1 , width : float = 3 , lifetime : float = 0 , client : Optional [ BulletClient ] = None , ) -> tuple [ int , int , int ]: \"\"\"Wrapper around visualize_frame specifically for debugging quaternions. Shows the rotated frame at the origin Args: quat (npt.ArrayLike): XYZW quaternion, shape (4,) length (float, optional): Length of the axis lines. Defaults to 1. width (float, optional): Width of the axis lines. Defaults to 3. (units unknown, maybe mm?) lifetime (float, optional): Amount of time to keep the lines on the GUI, in seconds. Defaults to 0 (keep them on-screen permanently until deleted) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: tuple[int, int, int]: Pybullet IDs of the three axis lines added to the GUI \"\"\" rmat = quat_to_rmat ( quat ) tmat = make_transform_mat ( rmat , [ 0 , 0 , 0 ]) return visualize_frame ( tmat , length , width , lifetime , client ) def visualize_path ( positions : npt . ArrayLike , n : Optional [ int ] = None , color : npt . ArrayLike = ( 1 , 0 , 0 ), width : float = 3 , lifetime : float = 0 , client : Optional [ BulletClient ] = None , ) -> list [ int ]: \"\"\"Visualize a sequence of positions on the Pybullet GUI Args: positions (npt.ArrayLike): Sequence of positions, shape (n, 3) n (Optional[int]): Number of lines to plot, if plotting the lines between all positions is not desired. Defaults to None (plot all lines between positions) color (npt.ArrayLike, optional): RGB color values. Defaults to (1, 0, 0) (red). width (float, optional): Width of the line. Defaults to 3 (pixels) lifetime (float, optional): Amount of time to keep the lines on the GUI, in seconds. Defaults to 0 (keep them on-screen permanently until deleted) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: list[int]: Pybullet IDs of the lines added to the GUI \"\"\" client : pybullet = pybullet if client is None else client positions = np . atleast_2d ( positions ) n_positions , dim = positions . shape assert dim == 3 # If desired, sample frames evenly across the trajectory to plot a subset if n is not None and n < n_positions : # This indexing ensures that the first and last frames are plotted idx = np . round ( np . linspace ( 0 , n_positions - 1 , n , endpoint = True )) . astype ( int ) positions = positions [ idx , :] ids = [] for i in range ( positions . shape [ 0 ] - 1 ): ids . append ( client . addUserDebugLine ( positions [ i ], positions [ i + 1 ], color , width , lifetime ) ) return ids def animate_path ( positions : npt . ArrayLike , duration : float , n : Optional [ int ] = None , color : npt . ArrayLike = ( 1 , 1 , 1 ), size : float = 20 , client : Optional [ BulletClient ] = None , ): \"\"\"Animates a point moving along a sequence of positions Args: positions (npt.ArrayLike): Path to animate, shape (n, 3) duration (float): Desired duration of the animation n (Optional[int]): Number of points to use in the animation, if using all of the provided positions will be too slow. Defaults to None (animate all points) color (npt.ArrayLike): RGB values, each in range [0, 1]. Shape (3,) if specifying the same color for all points, or (n, 3) to individually specify the colors per-point size (float): Size of the points on the GUI, in pixels. Defaults to 20 client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" client : pybullet = pybullet if client is None else client # Pybullet will crash if you try to visualize one point without packing it into a 2D array positions = np . atleast_2d ( positions ) n_positions , dim = positions . shape if dim != 3 : raise ValueError ( f \"Invalid shape of the point positions. Expected (n, 3), got: { positions . shape } \" ) color = np . atleast_2d ( color ) if color . shape [ - 1 ] != 3 : raise ValueError ( f \"Invalid shape of the colors. Expected (n, 3), got: { color . shape } \" ) if color . shape [ 0 ] != n_positions : if color . shape [ 0 ] == 1 : # Map the same color to all of the points color = color * np . ones_like ( positions ) else : raise ValueError ( f \"Number of colors ( { color . shape [ 0 ] } ) does not match the number of points ( { n_positions } ).\" ) # Downsample the points if desired if n is not None and n < n_positions : # This indexing ensures that the first and last frames are plotted idx = np . round ( np . linspace ( 0 , n_positions - 1 , n , endpoint = True )) . astype ( int ) positions = positions [ idx , :] color = color [ idx , :] n_positions = n uid = None for i in range ( n_positions ): start_time = time . time () if uid is None : uid = client . addUserDebugPoints ([ positions [ i ]], [ color [ i ]], size , 0 ) else : uid = client . addUserDebugPoints ( [ positions [ i ]], [ color [ i ]], size , 0 , replaceItemUniqueId = uid ) client . stepSimulation () elapsed_time = time . time () - start_time time . sleep ( max ( 0 , duration / n_positions - elapsed_time )) def animate_rotation ( quats : npt . ArrayLike , duration : float , object_id : Optional [ int ] = None , client : Optional [ BulletClient ] = None , ): \"\"\"Animates an object rotating via a sequence of quaternions Args: quats (npt.ArrayLike): Quaternions to animate, shape (n, 4) duration (float): Desired duration of the animation object_id (Optional[int]): If you would like to animate the rotation using a specific object, pass in its Pybullet ID here. Defaults to None (use a cube as the default object). client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" client : pybullet = pybullet if client is None else client if object_id is None : object_id = create_box ( ( 0 , 0 , 0 ), ( 0 , 0 , 0 , 1 ), 1 , ( 1 , 1 , 1 ), True , client = client ) pos = client . getBasePositionAndOrientation ( object_id )[ 0 ] quats = np . atleast_2d ( quats ) n = quats . shape [ 0 ] for quat in quats : start_time = time . time () pybullet . resetBasePositionAndOrientation ( object_id , pos , quat ) pybullet . stepSimulation () elapsed_time = time . time () - start_time time . sleep ( max ( 0 , duration / n - elapsed_time )) def remove_debug_objects ( ids : Union [ int , list [ int ], np . ndarray [ int ]], client : Optional [ BulletClient ] = None ) -> None : \"\"\"Removes user-created line(s)/point(s)/etc. from the Pybullet GUI Args: ids (int or list/array of ints): ID(s) of the objects loaded into Pybullet client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" client : pybullet = pybullet if client is None else client if np . ndim ( ids ) == 0 : # Scalar, not iterable client . removeUserDebugItem ( ids ) return for i in ids : client . removeUserDebugItem ( i ) def get_viz_camera_params ( T_R2W : np . ndarray , T_C2R : Optional [ np . ndarray ] = None ) -> tuple [ float , float , float , np . ndarray ]: \"\"\"Calculates the debug visualizer camera position for a specified robot-frame camera view Args: T_R2W (np.ndarray): Robot to World transformation matrix, shape (4,4). This input is equivalent to the current robot pose (just expressed in tmat form) T_C2R (np.ndarray, optional): Camera to Robot transformation matrix, shape (4, 4). This input dictates the perspective from which we observe the robot. Defaults to the OBSERVATION_CAM constant Returns: tuple[float, float, float, np.ndarray]: float: Distance: The distance to the camera's focus point float: Yaw: The rotation angle about the Z axis float: Pitch: The angle of the camera as measured above/below the XY plane np.ndarray: Target: The camera focus point in world coords. Shape (3,) \"\"\" if T_C2R is None : T_C2R = OBSERVATION_CAM R_R2W = T_R2W [: 3 , : 3 ] # Robot to world rotation matrix robot_to_cam_robot_pos = T_C2R [: 3 , 3 ] robot_to_cam_world_pos = R_R2W @ robot_to_cam_robot_pos cam_to_robot_world_pos = - 1 * robot_to_cam_world_pos # Determine the direction the camera points via the vector from camera -> robot origin in world frame dist , elevation , azimuth = cartesian_to_spherical ( cam_to_robot_world_pos ) # Elevation is measured w.r.t +Z, so we need to change this to w.r.t the XY plane # Pybullet also works with the camera angle definitions in degrees, not radians pitch = np . rad2deg ( np . pi / 2 - elevation ) # There seems to be a fixed -90 degree offset in how pybullet defines yaw (TODO test this) yaw = np . rad2deg ( azimuth ) - 90 robot_world_pos = T_R2W [: 3 , 3 ] target = robot_world_pos return dist , yaw , pitch , target def cartesian_to_spherical ( p : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts a cartesian (xyz) coordinate to spherical (radius, elevation, azimuth) - Note that the elevation angle is traditionally measured w.r.t the +Z axis - Radius >= 0 - Elevation is defined between 0 and pi - Azimuth is defined between -pi and pi Args: p (npt.ArrayLike): XYZ cartesian coordinate to translate into spherical, shape (3,) Returns: np.ndarray: Spherical coordinates (radius, elevation, azimuth), shape (3,) \"\"\" if len ( p ) != 3 : raise ValueError ( f \"Invalid coordinate size (should be 3). \\n Got: { p } \" ) # Convert to float to avoid a bug in pytransform3d with integer arrays return pc . spherical_from_cartesian ( np . float64 ( p )) def _main (): # Quick test if the debug visualizer camera parameters are able to track the robot motion pybullet . connect ( pybullet . GUI ) robot = Astrobee () controller = ConstraintController ( robot ) R = fixed_xyz_to_rmat ([ 0 , - np . pi / 4 , 0 ]) C2R = make_transform_mat ( R , [ - 0.7 , 0 , 0.5 ]) pos = np . array ([ 0.0 , 0.0 , 0.0 ]) orn = np . array ([ 0.0 , 0.0 , 0.0 , 1.0 ]) while True : R2W = pos_quat_to_tmat ( robot . pose ) d , y , p , t = get_viz_camera_params ( R2W , C2R ) # print(f\"Dist = {d}\") # print(f\"Yaw = {y}\") # print(f\"Pitch = {p}\") # print(f\"Target = {t}\") pos += np . array ([ 0.01 , 0 , 0 ]) orn = quat_to_fixed_xyz ( orn ) orn += np . array ([ 0.01 , 0.0 , 0.0 ]) orn = fixed_xyz_to_quat ( orn ) # orn += 0.1 * np.random.rand(4) + orn # orn = orn / np.linalg.norm(orn) pybullet . resetDebugVisualizerCamera ( d , y , p , t ) pybullet . changeConstraint ( controller . constraint_id , pos , orn ) pybullet . stepSimulation () time . sleep ( 1 / 20 ) if __name__ == \"__main__\" : _main () Variables OBSERVATION_CAM Functions animate_path def animate_path ( positions : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], duration : float , n : Optional [ int ] = None , color : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 1 , 1 , 1 ), size : float = 20 , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) Animates a point moving along a sequence of positions Parameters: Name Type Description Default positions npt.ArrayLike Path to animate, shape (n, 3) None duration float Desired duration of the animation None n Optional[int] Number of points to use in the animation, if using all of the provided positions will be too slow. Defaults to None (animate all points) None color npt.ArrayLike RGB values, each in range [0, 1]. Shape (3,) if specifying the same color for all points, or (n, 3) to individually specify the colors per-point None size float Size of the points on the GUI, in pixels. Defaults to 20 None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None View Source def animate_path ( positions : npt . ArrayLike , duration : float , n : Optional [ int ] = None , color : npt . ArrayLike = ( 1 , 1 , 1 ), size : float = 20 , client : Optional [ BulletClient ] = None , ) : \"\"\"Animates a point moving along a sequence of positions Args: positions (npt.ArrayLike): Path to animate, shape (n, 3) duration (float): Desired duration of the animation n (Optional[int]): Number of points to use in the animation, if using all of the provided positions will be too slow. Defaults to None (animate all points) color (npt.ArrayLike): RGB values, each in range [0, 1]. Shape (3,) if specifying the same color for all points, or (n, 3) to individually specify the colors per-point size (float): Size of the points on the GUI, in pixels. Defaults to 20 client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" client : pybullet = pybullet if client is None else client # Pybullet will crash if you try to visualize one point without packing it into a 2 D array positions = np . atleast_2d ( positions ) n_positions , dim = positions . shape if dim != 3 : raise ValueError ( f \"Invalid shape of the point positions. Expected (n, 3), got: {positions.shape}\" ) color = np . atleast_2d ( color ) if color . shape [ -1 ] != 3 : raise ValueError ( f \"Invalid shape of the colors. Expected (n, 3), got: {color.shape}\" ) if color . shape [ 0 ] != n_positions : if color . shape [ 0 ] == 1 : # Map the same color to all of the points color = color * np . ones_like ( positions ) else : raise ValueError ( f \"Number of colors ({color.shape[0]}) does not match the number of points ({n_positions}).\" ) # Downsample the points if desired if n is not None and n < n_positions : # This indexing ensures that the first and last frames are plotted idx = np . round ( np . linspace ( 0 , n_positions - 1 , n , endpoint = True )). astype ( int ) positions = positions [ idx, : ] color = color [ idx, : ] n_positions = n uid = None for i in range ( n_positions ) : start_time = time . time () if uid is None : uid = client . addUserDebugPoints ( [ positions[i ] ] , [ color[i ] ] , size , 0 ) else : uid = client . addUserDebugPoints ( [ positions[i ] ] , [ color[i ] ] , size , 0 , replaceItemUniqueId = uid ) client . stepSimulation () elapsed_time = time . time () - start_time time . sleep ( max ( 0 , duration / n_positions - elapsed_time )) animate_rotation def animate_rotation ( quats : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], duration : float , object_id : Optional [ int ] = None , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) Animates an object rotating via a sequence of quaternions Parameters: Name Type Description Default quats npt.ArrayLike Quaternions to animate, shape (n, 4) None duration float Desired duration of the animation None object_id Optional[int] If you would like to animate the rotation using a specific object, pass in its Pybullet ID here. Defaults to None (use a cube as the default object). None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None View Source def animate_rotation ( quats : npt . ArrayLike , duration : float , object_id : Optional [ int ] = None , client : Optional [ BulletClient ] = None , ) : \"\"\"Animates an object rotating via a sequence of quaternions Args: quats (npt.ArrayLike): Quaternions to animate, shape (n, 4) duration (float): Desired duration of the animation object_id (Optional[int]): If you would like to animate the rotation using a specific object, pass in its Pybullet ID here. Defaults to None (use a cube as the default object). client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" client : pybullet = pybullet if client is None else client if object_id is None : object_id = create_box ( ( 0 , 0 , 0 ), ( 0 , 0 , 0 , 1 ), 1 , ( 1 , 1 , 1 ), True , client = client ) pos = client . getBasePositionAndOrientation ( object_id ) [ 0 ] quats = np . atleast_2d ( quats ) n = quats . shape [ 0 ] for quat in quats : start_time = time . time () pybullet . resetBasePositionAndOrientation ( object_id , pos , quat ) pybullet . stepSimulation () elapsed_time = time . time () - start_time time . sleep ( max ( 0 , duration / n - elapsed_time )) cartesian_to_spherical def cartesian_to_spherical ( p : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Converts a cartesian (xyz) coordinate to spherical (radius, elevation, azimuth) Note that the elevation angle is traditionally measured w.r.t the +Z axis Radius >= 0 Elevation is defined between 0 and pi Azimuth is defined between -pi and pi Parameters: Name Type Description Default p npt.ArrayLike XYZ cartesian coordinate to translate into spherical, shape (3,) None Returns: Type Description np.ndarray Spherical coordinates (radius, elevation, azimuth), shape (3,) View Source def cartesian_to_spherical ( p : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts a cartesian (xyz) coordinate to spherical (radius, elevation, azimuth) - Note that the elevation angle is traditionally measured w.r.t the +Z axis - Radius >= 0 - Elevation is defined between 0 and pi - Azimuth is defined between -pi and pi Args: p (npt.ArrayLike): XYZ cartesian coordinate to translate into spherical, shape (3,) Returns: np.ndarray: Spherical coordinates (radius, elevation, azimuth), shape (3,) \"\"\" if len ( p ) != 3 : raise ValueError ( f \"Invalid coordinate size (should be 3).\\nGot:{p}\" ) # Convert to float to avoid a bug in pytransform3d with integer arrays return pc . spherical_from_cartesian ( np . float64 ( p )) get_viz_camera_params def get_viz_camera_params ( T_R2W : numpy . ndarray , T_C2R : Optional [ numpy . ndarray ] = None ) -> tuple [ float , float , float , numpy . ndarray ] Calculates the debug visualizer camera position for a specified robot-frame camera view Parameters: Name Type Description Default T_R2W np.ndarray Robot to World transformation matrix, shape (4,4). This input is equivalent to the current robot pose (just expressed in tmat form) None T_C2R np.ndarray Camera to Robot transformation matrix, shape (4, 4). This input dictates the perspective from which we observe the robot. Defaults to the OBSERVATION_CAM constant None Returns: Type Description tuple[float, float, float, np.ndarray] float: Distance: The distance to the camera's focus point float: Yaw: The rotation angle about the Z axis float: Pitch: The angle of the camera as measured above/below the XY plane np.ndarray: Target: The camera focus point in world coords. Shape (3,) View Source def get_viz_camera_params ( T_R2W : np . ndarray , T_C2R : Optional [ np . ndarray ] = None ) -> tuple [ float , float , float , np . ndarray ]: \"\"\"Calculates the debug visualizer camera position for a specified robot-frame camera view Args: T_R2W (np.ndarray): Robot to World transformation matrix, shape (4,4). This input is equivalent to the current robot pose (just expressed in tmat form) T_C2R (np.ndarray, optional): Camera to Robot transformation matrix, shape (4, 4). This input dictates the perspective from which we observe the robot. Defaults to the OBSERVATION_CAM constant Returns: tuple[float, float, float, np.ndarray]: float: Distance: The distance to the camera's focus point float: Yaw: The rotation angle about the Z axis float: Pitch: The angle of the camera as measured above/below the XY plane np.ndarray: Target: The camera focus point in world coords. Shape (3,) \"\"\" if T_C2R is None : T_C2R = OBSERVATION_CAM R_R2W = T_R2W [: 3 , : 3 ] # Robot to world rotation matrix robot_to_cam_robot_pos = T_C2R [: 3 , 3 ] robot_to_cam_world_pos = R_R2W @ robot_to_cam_robot_pos cam_to_robot_world_pos = - 1 * robot_to_cam_world_pos # Determine the direction the camera points via the vector from camera -> robot origin in world frame dist , elevation , azimuth = cartesian_to_spherical ( cam_to_robot_world_pos ) # Elevation is measured w.r.t +Z, so we need to change this to w.r.t the XY plane # Pybullet also works with the camera angle definitions in degrees, not radians pitch = np . rad2deg ( np . pi / 2 - elevation ) # There seems to be a fixed -90 degree offset in how pybullet defines yaw (TODO test this) yaw = np . rad2deg ( azimuth ) - 90 robot_world_pos = T_R2W [: 3 , 3 ] target = robot_world_pos return dist , yaw , pitch , target remove_debug_objects def remove_debug_objects ( ids : Union [ int , list [ int ], numpy . ndarray [ int ]], client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> None Removes user-created line(s)/point(s)/etc. from the Pybullet GUI Parameters: Name Type Description Default ids int or list/array of ints ID(s) of the objects loaded into Pybullet None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None View Source def remove_debug_objects ( ids : Union [ int, list[int ] , np . ndarray [ int ] ] , client : Optional [ BulletClient ] = None ) -> None : \"\"\"Removes user-created line(s)/point(s)/etc. from the Pybullet GUI Args: ids (int or list/array of ints): ID(s) of the objects loaded into Pybullet client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" client : pybullet = pybullet if client is None else client if np . ndim ( ids ) == 0 : # Scalar , not iterable client . removeUserDebugItem ( ids ) return for i in ids : client . removeUserDebugItem ( i ) visualize_frame def visualize_frame ( tmat : numpy . ndarray , length : float = 1 , width : float = 3 , lifetime : float = 0 , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> tuple [ int , int , int ] Adds RGB XYZ axes to the Pybullet GUI for a speficied transformation/frame/pose Parameters: Name Type Description Default tmat np.ndarray Transformation matrix specifying a pose w.r.t world frame, shape (4, 4) None length float Length of the axis lines. Defaults to 1. 1 width float Width of the axis lines. Defaults to 3. (units unknown, maybe mm?) 3 lifetime float Amount of time to keep the lines on the GUI, in seconds. Defaults to 0 (keep them on-screen permanently until deleted) None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Returns: Type Description tuple[int, int, int] Pybullet IDs of the three axis lines added to the GUI View Source def visualize_frame ( tmat : np . ndarray , length : float = 1 , width : float = 3 , lifetime : float = 0 , client : Optional [ BulletClient ] = None , ) -> tuple [ int, int, int ] : \"\"\"Adds RGB XYZ axes to the Pybullet GUI for a speficied transformation/frame/pose Args: tmat (np.ndarray): Transformation matrix specifying a pose w.r.t world frame, shape (4, 4) length (float, optional): Length of the axis lines. Defaults to 1. width (float, optional): Width of the axis lines. Defaults to 3. (units unknown, maybe mm?) lifetime (float, optional): Amount of time to keep the lines on the GUI, in seconds. Defaults to 0 (keep them on-screen permanently until deleted) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: tuple[int, int, int]: Pybullet IDs of the three axis lines added to the GUI \"\"\" client : pybullet = pybullet if client is None else client x_color = [ 1, 0, 0 ] # R y_color = [ 0, 1, 0 ] # G z_color = [ 0, 0, 1 ] # B origin = tmat [ :3, 3 ] x_endpt = origin + tmat [ :3, 0 ] * length y_endpt = origin + tmat [ :3, 1 ] * length z_endpt = origin + tmat [ :3, 2 ] * length x_ax_id = client . addUserDebugLine ( origin , x_endpt , x_color , width , lifetime ) y_ax_id = client . addUserDebugLine ( origin , y_endpt , y_color , width , lifetime ) z_ax_id = client . addUserDebugLine ( origin , z_endpt , z_color , width , lifetime ) return x_ax_id , y_ax_id , z_ax_id visualize_link_frame def visualize_link_frame ( robot_id : int , link_id : int , length : float = 1 , width : float = 3 , lifetime : float = 0 , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> tuple [ int , int , int ] Adds RGB XYZ axes to the Pybullet GUI for a specific link on the Astrobee Parameters: Name Type Description Default robot_id int Pybullet ID of the Astrobee None link_id int ID of the link we want to look at None length float Length of the axis lines. Defaults to 1. 1 width float Width of the axis lines. Defaults to 3. (units unknown, maybe mm?) 3 lifetime float Amount of time to keep the lines on the GUI, in seconds. Defaults to 0 (keep them on-screen permanently until deleted) None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Returns: Type Description tuple[int, int, int] Pybullet IDs of the three axis lines added to the GUI View Source def visualize_link_frame ( robot_id : int , link_id : int , length : float = 1 , width : float = 3 , lifetime : float = 0 , client : Optional [ BulletClient ] = None , ) -> tuple [ int, int, int ] : \"\"\"Adds RGB XYZ axes to the Pybullet GUI for a specific link on the Astrobee Args: robot_id (int): Pybullet ID of the Astrobee link_id (int): ID of the link we want to look at length (float, optional): Length of the axis lines. Defaults to 1. width (float, optional): Width of the axis lines. Defaults to 3. (units unknown, maybe mm?) lifetime (float, optional): Amount of time to keep the lines on the GUI, in seconds. Defaults to 0 (keep them on-screen permanently until deleted) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: tuple[int, int, int]: Pybullet IDs of the three axis lines added to the GUI \"\"\" client : pybullet = pybullet if client is None else client x_color = [ 1, 0, 0 ] # R y_color = [ 0, 1, 0 ] # G z_color = [ 0, 0, 1 ] # B origin = [ 0, 0, 0 ] x_endpt = np . array ( [ 1, 0, 0 ] ) * length y_endpt = np . array ( [ 0, 1, 0 ] ) * length z_endpt = np . array ( [ 0, 0, 1 ] ) * length x_ax_id = client . addUserDebugLine ( origin , x_endpt , x_color , width , lifetime , robot_id , link_id ) y_ax_id = client . addUserDebugLine ( origin , y_endpt , y_color , width , lifetime , robot_id , link_id ) z_ax_id = client . addUserDebugLine ( origin , z_endpt , z_color , width , lifetime , robot_id , link_id ) return x_ax_id , y_ax_id , z_ax_id visualize_path def visualize_path ( positions : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], n : Optional [ int ] = None , color : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 1 , 0 , 0 ), width : float = 3 , lifetime : float = 0 , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> list [ int ] Visualize a sequence of positions on the Pybullet GUI Parameters: Name Type Description Default positions npt.ArrayLike Sequence of positions, shape (n, 3) None n Optional[int] Number of lines to plot, if plotting the lines between all positions is not desired. Defaults to None (plot all lines between positions) None color npt.ArrayLike RGB color values. Defaults to (1, 0, 0) (red). (1, 0, 0) (red) width float Width of the line. Defaults to 3 (pixels) None lifetime float Amount of time to keep the lines on the GUI, in seconds. Defaults to 0 (keep them on-screen permanently until deleted) None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Returns: Type Description list[int] Pybullet IDs of the lines added to the GUI View Source def visualize_path ( positions : npt . ArrayLike , n : Optional [ int ] = None , color : npt . ArrayLike = ( 1 , 0 , 0 ), width : float = 3 , lifetime : float = 0 , client : Optional [ BulletClient ] = None , ) -> list [ int ] : \"\"\"Visualize a sequence of positions on the Pybullet GUI Args: positions (npt.ArrayLike): Sequence of positions, shape (n, 3) n (Optional[int]): Number of lines to plot, if plotting the lines between all positions is not desired. Defaults to None (plot all lines between positions) color (npt.ArrayLike, optional): RGB color values. Defaults to (1, 0, 0) (red). width (float, optional): Width of the line. Defaults to 3 (pixels) lifetime (float, optional): Amount of time to keep the lines on the GUI, in seconds. Defaults to 0 (keep them on-screen permanently until deleted) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: list[int]: Pybullet IDs of the lines added to the GUI \"\"\" client : pybullet = pybullet if client is None else client positions = np . atleast_2d ( positions ) n_positions , dim = positions . shape assert dim == 3 # If desired , sample frames evenly across the trajectory to plot a subset if n is not None and n < n_positions : # This indexing ensures that the first and last frames are plotted idx = np . round ( np . linspace ( 0 , n_positions - 1 , n , endpoint = True )). astype ( int ) positions = positions [ idx, : ] ids = [] for i in range ( positions . shape [ 0 ] - 1 ) : ids . append ( client . addUserDebugLine ( positions [ i ] , positions [ i + 1 ] , color , width , lifetime ) ) return ids visualize_points def visualize_points ( position : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], color : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], size : float = 20 , lifetime : float = 0 , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> int Adds square points to the GUI to visualize positions in the sim Parameters: Name Type Description Default position npt.ArrayLike 3D point(s) in the simulation to visualize. Shape (n, 3) None color npt.ArrayLike RGB values, each in range [0, 1]. Shape (3,) if specifying the same color for all points, or (n, 3) to individually specify the colors per-point None size float Size of the points on the GUI, in pixels. Defaults to 20 None lifetime float Amount of time to keep the points on the GUI, in seconds. Defaults to 0 (keep them on-screen permanently until deleted) None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Returns: Type Description int Pybullet object ID for the point / point cloud View Source def visualize_points ( position : npt . ArrayLike , color : npt . ArrayLike , size : float = 20 , lifetime : float = 0 , client : Optional [ BulletClient ] = None , ) -> int : \"\"\"Adds square points to the GUI to visualize positions in the sim Args: position (npt.ArrayLike): 3D point(s) in the simulation to visualize. Shape (n, 3) color (npt.ArrayLike): RGB values, each in range [0, 1]. Shape (3,) if specifying the same color for all points, or (n, 3) to individually specify the colors per-point size (float): Size of the points on the GUI, in pixels. Defaults to 20 lifetime (float, optional): Amount of time to keep the points on the GUI, in seconds. Defaults to 0 (keep them on-screen permanently until deleted) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: int: Pybullet object ID for the point / point cloud \"\"\" client : pybullet = pybullet if client is None else client # Pybullet will crash if you try to visualize one point without packing it into a 2 D array position = np . atleast_2d ( position ) color = np . atleast_2d ( color ) if position . shape [ -1 ] != 3 : raise ValueError ( f \"Invalid shape of the point positions. Expected (n, 3), got: {position.shape}\" ) if color . shape [ -1 ] != 3 : raise ValueError ( f \"Invalid shape of the colors. Expected (n, 3), got: {color.shape}\" ) n = position . shape [ 0 ] if color . shape [ 0 ] != n : if color . shape [ 0 ] == 1 : # Map the same color to all of the points color = color * np . ones_like ( position ) else : raise ValueError ( f \"Number of colors ({color.shape[0]}) does not match the number of points ({n}).\" ) return client . addUserDebugPoints ( position , color , size , lifetime ) visualize_quaternion def visualize_quaternion ( quat : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], length : float = 1 , width : float = 3 , lifetime : float = 0 , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> tuple [ int , int , int ] Wrapper around visualize_frame specifically for debugging quaternions. Shows the rotated frame at the origin Parameters: Name Type Description Default quat npt.ArrayLike XYZW quaternion, shape (4,) None length float Length of the axis lines. Defaults to 1. 1 width float Width of the axis lines. Defaults to 3. (units unknown, maybe mm?) 3 lifetime float Amount of time to keep the lines on the GUI, in seconds. Defaults to 0 (keep them on-screen permanently until deleted) None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Returns: Type Description tuple[int, int, int] Pybullet IDs of the three axis lines added to the GUI View Source def visualize_quaternion ( quat : npt . ArrayLike , length : float = 1 , width : float = 3 , lifetime : float = 0 , client : Optional [ BulletClient ] = None , ) -> tuple [ int, int, int ] : \"\"\"Wrapper around visualize_frame specifically for debugging quaternions. Shows the rotated frame at the origin Args: quat (npt.ArrayLike): XYZW quaternion, shape (4,) length (float, optional): Length of the axis lines. Defaults to 1. width (float, optional): Width of the axis lines. Defaults to 3. (units unknown, maybe mm?) lifetime (float, optional): Amount of time to keep the lines on the GUI, in seconds. Defaults to 0 (keep them on-screen permanently until deleted) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: tuple[int, int, int]: Pybullet IDs of the three axis lines added to the GUI \"\"\" rmat = quat_to_rmat ( quat ) tmat = make_transform_mat ( rmat , [ 0, 0, 0 ] ) return visualize_frame ( tmat , length , width , lifetime , client )","title":"Debug Visualizer"},{"location":"reference/pyastrobee/utils/debug_visualizer/#module-pyastrobeeutilsdebug_visualizer","text":"Functions associated with the Pybullet Debug Visualizer GUI NOTE - For the GUI camera parameters, since the debug visualizer only specifies yaw and pitch (no roll), this is an incomplete definition of rotation, so we can never actually fully change the rotation of the debug viz camera to match the robot's position - This is not a huge deal, it will just mean we will have at best a \"video game perspective\" of the robot View Source \"\"\"Functions associated with the Pybullet Debug Visualizer GUI NOTE - For the GUI camera parameters, since the debug visualizer only specifies yaw and pitch (no roll), this is an incomplete definition of rotation, so we can never actually fully change the rotation of the debug viz camera to match the robot's position - This is not a huge deal, it will just mean we will have at best a \"video game perspective\" of the robot \"\"\" import time from typing import Optional , Union import numpy as np import numpy.typing as npt import pybullet from pybullet_utils.bullet_client import BulletClient import pytransform3d.coordinates as pc from pyastrobee.core.astrobee import Astrobee from pyastrobee.utils.rotations import ( quat_to_fixed_xyz , fixed_xyz_to_quat , fixed_xyz_to_rmat , quat_to_rmat , ) from pyastrobee.utils.poses import pos_quat_to_tmat from pyastrobee.utils.transformations import make_transform_mat from pyastrobee.config.astrobee_transforms import OBSERVATION_CAM from pyastrobee.control.constraint_controller import ConstraintController from pyastrobee.utils.bullet_utils import create_box def visualize_points ( position : npt . ArrayLike , color : npt . ArrayLike , size : float = 20 , lifetime : float = 0 , client : Optional [ BulletClient ] = None , ) -> int : \"\"\"Adds square points to the GUI to visualize positions in the sim Args: position (npt.ArrayLike): 3D point(s) in the simulation to visualize. Shape (n, 3) color (npt.ArrayLike): RGB values, each in range [0, 1]. Shape (3,) if specifying the same color for all points, or (n, 3) to individually specify the colors per-point size (float): Size of the points on the GUI, in pixels. Defaults to 20 lifetime (float, optional): Amount of time to keep the points on the GUI, in seconds. Defaults to 0 (keep them on-screen permanently until deleted) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: int: Pybullet object ID for the point / point cloud \"\"\" client : pybullet = pybullet if client is None else client # Pybullet will crash if you try to visualize one point without packing it into a 2D array position = np . atleast_2d ( position ) color = np . atleast_2d ( color ) if position . shape [ - 1 ] != 3 : raise ValueError ( f \"Invalid shape of the point positions. Expected (n, 3), got: { position . shape } \" ) if color . shape [ - 1 ] != 3 : raise ValueError ( f \"Invalid shape of the colors. Expected (n, 3), got: { color . shape } \" ) n = position . shape [ 0 ] if color . shape [ 0 ] != n : if color . shape [ 0 ] == 1 : # Map the same color to all of the points color = color * np . ones_like ( position ) else : raise ValueError ( f \"Number of colors ( { color . shape [ 0 ] } ) does not match the number of points ( { n } ).\" ) return client . addUserDebugPoints ( position , color , size , lifetime ) def visualize_frame ( tmat : np . ndarray , length : float = 1 , width : float = 3 , lifetime : float = 0 , client : Optional [ BulletClient ] = None , ) -> tuple [ int , int , int ]: \"\"\"Adds RGB XYZ axes to the Pybullet GUI for a speficied transformation/frame/pose Args: tmat (np.ndarray): Transformation matrix specifying a pose w.r.t world frame, shape (4, 4) length (float, optional): Length of the axis lines. Defaults to 1. width (float, optional): Width of the axis lines. Defaults to 3. (units unknown, maybe mm?) lifetime (float, optional): Amount of time to keep the lines on the GUI, in seconds. Defaults to 0 (keep them on-screen permanently until deleted) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: tuple[int, int, int]: Pybullet IDs of the three axis lines added to the GUI \"\"\" client : pybullet = pybullet if client is None else client x_color = [ 1 , 0 , 0 ] # R y_color = [ 0 , 1 , 0 ] # G z_color = [ 0 , 0 , 1 ] # B origin = tmat [: 3 , 3 ] x_endpt = origin + tmat [: 3 , 0 ] * length y_endpt = origin + tmat [: 3 , 1 ] * length z_endpt = origin + tmat [: 3 , 2 ] * length x_ax_id = client . addUserDebugLine ( origin , x_endpt , x_color , width , lifetime ) y_ax_id = client . addUserDebugLine ( origin , y_endpt , y_color , width , lifetime ) z_ax_id = client . addUserDebugLine ( origin , z_endpt , z_color , width , lifetime ) return x_ax_id , y_ax_id , z_ax_id def visualize_link_frame ( robot_id : int , link_id : int , length : float = 1 , width : float = 3 , lifetime : float = 0 , client : Optional [ BulletClient ] = None , ) -> tuple [ int , int , int ]: \"\"\"Adds RGB XYZ axes to the Pybullet GUI for a specific link on the Astrobee Args: robot_id (int): Pybullet ID of the Astrobee link_id (int): ID of the link we want to look at length (float, optional): Length of the axis lines. Defaults to 1. width (float, optional): Width of the axis lines. Defaults to 3. (units unknown, maybe mm?) lifetime (float, optional): Amount of time to keep the lines on the GUI, in seconds. Defaults to 0 (keep them on-screen permanently until deleted) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: tuple[int, int, int]: Pybullet IDs of the three axis lines added to the GUI \"\"\" client : pybullet = pybullet if client is None else client x_color = [ 1 , 0 , 0 ] # R y_color = [ 0 , 1 , 0 ] # G z_color = [ 0 , 0 , 1 ] # B origin = [ 0 , 0 , 0 ] x_endpt = np . array ([ 1 , 0 , 0 ]) * length y_endpt = np . array ([ 0 , 1 , 0 ]) * length z_endpt = np . array ([ 0 , 0 , 1 ]) * length x_ax_id = client . addUserDebugLine ( origin , x_endpt , x_color , width , lifetime , robot_id , link_id ) y_ax_id = client . addUserDebugLine ( origin , y_endpt , y_color , width , lifetime , robot_id , link_id ) z_ax_id = client . addUserDebugLine ( origin , z_endpt , z_color , width , lifetime , robot_id , link_id ) return x_ax_id , y_ax_id , z_ax_id def visualize_quaternion ( quat : npt . ArrayLike , length : float = 1 , width : float = 3 , lifetime : float = 0 , client : Optional [ BulletClient ] = None , ) -> tuple [ int , int , int ]: \"\"\"Wrapper around visualize_frame specifically for debugging quaternions. Shows the rotated frame at the origin Args: quat (npt.ArrayLike): XYZW quaternion, shape (4,) length (float, optional): Length of the axis lines. Defaults to 1. width (float, optional): Width of the axis lines. Defaults to 3. (units unknown, maybe mm?) lifetime (float, optional): Amount of time to keep the lines on the GUI, in seconds. Defaults to 0 (keep them on-screen permanently until deleted) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: tuple[int, int, int]: Pybullet IDs of the three axis lines added to the GUI \"\"\" rmat = quat_to_rmat ( quat ) tmat = make_transform_mat ( rmat , [ 0 , 0 , 0 ]) return visualize_frame ( tmat , length , width , lifetime , client ) def visualize_path ( positions : npt . ArrayLike , n : Optional [ int ] = None , color : npt . ArrayLike = ( 1 , 0 , 0 ), width : float = 3 , lifetime : float = 0 , client : Optional [ BulletClient ] = None , ) -> list [ int ]: \"\"\"Visualize a sequence of positions on the Pybullet GUI Args: positions (npt.ArrayLike): Sequence of positions, shape (n, 3) n (Optional[int]): Number of lines to plot, if plotting the lines between all positions is not desired. Defaults to None (plot all lines between positions) color (npt.ArrayLike, optional): RGB color values. Defaults to (1, 0, 0) (red). width (float, optional): Width of the line. Defaults to 3 (pixels) lifetime (float, optional): Amount of time to keep the lines on the GUI, in seconds. Defaults to 0 (keep them on-screen permanently until deleted) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: list[int]: Pybullet IDs of the lines added to the GUI \"\"\" client : pybullet = pybullet if client is None else client positions = np . atleast_2d ( positions ) n_positions , dim = positions . shape assert dim == 3 # If desired, sample frames evenly across the trajectory to plot a subset if n is not None and n < n_positions : # This indexing ensures that the first and last frames are plotted idx = np . round ( np . linspace ( 0 , n_positions - 1 , n , endpoint = True )) . astype ( int ) positions = positions [ idx , :] ids = [] for i in range ( positions . shape [ 0 ] - 1 ): ids . append ( client . addUserDebugLine ( positions [ i ], positions [ i + 1 ], color , width , lifetime ) ) return ids def animate_path ( positions : npt . ArrayLike , duration : float , n : Optional [ int ] = None , color : npt . ArrayLike = ( 1 , 1 , 1 ), size : float = 20 , client : Optional [ BulletClient ] = None , ): \"\"\"Animates a point moving along a sequence of positions Args: positions (npt.ArrayLike): Path to animate, shape (n, 3) duration (float): Desired duration of the animation n (Optional[int]): Number of points to use in the animation, if using all of the provided positions will be too slow. Defaults to None (animate all points) color (npt.ArrayLike): RGB values, each in range [0, 1]. Shape (3,) if specifying the same color for all points, or (n, 3) to individually specify the colors per-point size (float): Size of the points on the GUI, in pixels. Defaults to 20 client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" client : pybullet = pybullet if client is None else client # Pybullet will crash if you try to visualize one point without packing it into a 2D array positions = np . atleast_2d ( positions ) n_positions , dim = positions . shape if dim != 3 : raise ValueError ( f \"Invalid shape of the point positions. Expected (n, 3), got: { positions . shape } \" ) color = np . atleast_2d ( color ) if color . shape [ - 1 ] != 3 : raise ValueError ( f \"Invalid shape of the colors. Expected (n, 3), got: { color . shape } \" ) if color . shape [ 0 ] != n_positions : if color . shape [ 0 ] == 1 : # Map the same color to all of the points color = color * np . ones_like ( positions ) else : raise ValueError ( f \"Number of colors ( { color . shape [ 0 ] } ) does not match the number of points ( { n_positions } ).\" ) # Downsample the points if desired if n is not None and n < n_positions : # This indexing ensures that the first and last frames are plotted idx = np . round ( np . linspace ( 0 , n_positions - 1 , n , endpoint = True )) . astype ( int ) positions = positions [ idx , :] color = color [ idx , :] n_positions = n uid = None for i in range ( n_positions ): start_time = time . time () if uid is None : uid = client . addUserDebugPoints ([ positions [ i ]], [ color [ i ]], size , 0 ) else : uid = client . addUserDebugPoints ( [ positions [ i ]], [ color [ i ]], size , 0 , replaceItemUniqueId = uid ) client . stepSimulation () elapsed_time = time . time () - start_time time . sleep ( max ( 0 , duration / n_positions - elapsed_time )) def animate_rotation ( quats : npt . ArrayLike , duration : float , object_id : Optional [ int ] = None , client : Optional [ BulletClient ] = None , ): \"\"\"Animates an object rotating via a sequence of quaternions Args: quats (npt.ArrayLike): Quaternions to animate, shape (n, 4) duration (float): Desired duration of the animation object_id (Optional[int]): If you would like to animate the rotation using a specific object, pass in its Pybullet ID here. Defaults to None (use a cube as the default object). client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" client : pybullet = pybullet if client is None else client if object_id is None : object_id = create_box ( ( 0 , 0 , 0 ), ( 0 , 0 , 0 , 1 ), 1 , ( 1 , 1 , 1 ), True , client = client ) pos = client . getBasePositionAndOrientation ( object_id )[ 0 ] quats = np . atleast_2d ( quats ) n = quats . shape [ 0 ] for quat in quats : start_time = time . time () pybullet . resetBasePositionAndOrientation ( object_id , pos , quat ) pybullet . stepSimulation () elapsed_time = time . time () - start_time time . sleep ( max ( 0 , duration / n - elapsed_time )) def remove_debug_objects ( ids : Union [ int , list [ int ], np . ndarray [ int ]], client : Optional [ BulletClient ] = None ) -> None : \"\"\"Removes user-created line(s)/point(s)/etc. from the Pybullet GUI Args: ids (int or list/array of ints): ID(s) of the objects loaded into Pybullet client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" client : pybullet = pybullet if client is None else client if np . ndim ( ids ) == 0 : # Scalar, not iterable client . removeUserDebugItem ( ids ) return for i in ids : client . removeUserDebugItem ( i ) def get_viz_camera_params ( T_R2W : np . ndarray , T_C2R : Optional [ np . ndarray ] = None ) -> tuple [ float , float , float , np . ndarray ]: \"\"\"Calculates the debug visualizer camera position for a specified robot-frame camera view Args: T_R2W (np.ndarray): Robot to World transformation matrix, shape (4,4). This input is equivalent to the current robot pose (just expressed in tmat form) T_C2R (np.ndarray, optional): Camera to Robot transformation matrix, shape (4, 4). This input dictates the perspective from which we observe the robot. Defaults to the OBSERVATION_CAM constant Returns: tuple[float, float, float, np.ndarray]: float: Distance: The distance to the camera's focus point float: Yaw: The rotation angle about the Z axis float: Pitch: The angle of the camera as measured above/below the XY plane np.ndarray: Target: The camera focus point in world coords. Shape (3,) \"\"\" if T_C2R is None : T_C2R = OBSERVATION_CAM R_R2W = T_R2W [: 3 , : 3 ] # Robot to world rotation matrix robot_to_cam_robot_pos = T_C2R [: 3 , 3 ] robot_to_cam_world_pos = R_R2W @ robot_to_cam_robot_pos cam_to_robot_world_pos = - 1 * robot_to_cam_world_pos # Determine the direction the camera points via the vector from camera -> robot origin in world frame dist , elevation , azimuth = cartesian_to_spherical ( cam_to_robot_world_pos ) # Elevation is measured w.r.t +Z, so we need to change this to w.r.t the XY plane # Pybullet also works with the camera angle definitions in degrees, not radians pitch = np . rad2deg ( np . pi / 2 - elevation ) # There seems to be a fixed -90 degree offset in how pybullet defines yaw (TODO test this) yaw = np . rad2deg ( azimuth ) - 90 robot_world_pos = T_R2W [: 3 , 3 ] target = robot_world_pos return dist , yaw , pitch , target def cartesian_to_spherical ( p : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts a cartesian (xyz) coordinate to spherical (radius, elevation, azimuth) - Note that the elevation angle is traditionally measured w.r.t the +Z axis - Radius >= 0 - Elevation is defined between 0 and pi - Azimuth is defined between -pi and pi Args: p (npt.ArrayLike): XYZ cartesian coordinate to translate into spherical, shape (3,) Returns: np.ndarray: Spherical coordinates (radius, elevation, azimuth), shape (3,) \"\"\" if len ( p ) != 3 : raise ValueError ( f \"Invalid coordinate size (should be 3). \\n Got: { p } \" ) # Convert to float to avoid a bug in pytransform3d with integer arrays return pc . spherical_from_cartesian ( np . float64 ( p )) def _main (): # Quick test if the debug visualizer camera parameters are able to track the robot motion pybullet . connect ( pybullet . GUI ) robot = Astrobee () controller = ConstraintController ( robot ) R = fixed_xyz_to_rmat ([ 0 , - np . pi / 4 , 0 ]) C2R = make_transform_mat ( R , [ - 0.7 , 0 , 0.5 ]) pos = np . array ([ 0.0 , 0.0 , 0.0 ]) orn = np . array ([ 0.0 , 0.0 , 0.0 , 1.0 ]) while True : R2W = pos_quat_to_tmat ( robot . pose ) d , y , p , t = get_viz_camera_params ( R2W , C2R ) # print(f\"Dist = {d}\") # print(f\"Yaw = {y}\") # print(f\"Pitch = {p}\") # print(f\"Target = {t}\") pos += np . array ([ 0.01 , 0 , 0 ]) orn = quat_to_fixed_xyz ( orn ) orn += np . array ([ 0.01 , 0.0 , 0.0 ]) orn = fixed_xyz_to_quat ( orn ) # orn += 0.1 * np.random.rand(4) + orn # orn = orn / np.linalg.norm(orn) pybullet . resetDebugVisualizerCamera ( d , y , p , t ) pybullet . changeConstraint ( controller . constraint_id , pos , orn ) pybullet . stepSimulation () time . sleep ( 1 / 20 ) if __name__ == \"__main__\" : _main ()","title":"Module pyastrobee.utils.debug_visualizer"},{"location":"reference/pyastrobee/utils/debug_visualizer/#variables","text":"OBSERVATION_CAM","title":"Variables"},{"location":"reference/pyastrobee/utils/debug_visualizer/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/utils/debug_visualizer/#animate_path","text":"def animate_path ( positions : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], duration : float , n : Optional [ int ] = None , color : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 1 , 1 , 1 ), size : float = 20 , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) Animates a point moving along a sequence of positions Parameters: Name Type Description Default positions npt.ArrayLike Path to animate, shape (n, 3) None duration float Desired duration of the animation None n Optional[int] Number of points to use in the animation, if using all of the provided positions will be too slow. Defaults to None (animate all points) None color npt.ArrayLike RGB values, each in range [0, 1]. Shape (3,) if specifying the same color for all points, or (n, 3) to individually specify the colors per-point None size float Size of the points on the GUI, in pixels. Defaults to 20 None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None View Source def animate_path ( positions : npt . ArrayLike , duration : float , n : Optional [ int ] = None , color : npt . ArrayLike = ( 1 , 1 , 1 ), size : float = 20 , client : Optional [ BulletClient ] = None , ) : \"\"\"Animates a point moving along a sequence of positions Args: positions (npt.ArrayLike): Path to animate, shape (n, 3) duration (float): Desired duration of the animation n (Optional[int]): Number of points to use in the animation, if using all of the provided positions will be too slow. Defaults to None (animate all points) color (npt.ArrayLike): RGB values, each in range [0, 1]. Shape (3,) if specifying the same color for all points, or (n, 3) to individually specify the colors per-point size (float): Size of the points on the GUI, in pixels. Defaults to 20 client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" client : pybullet = pybullet if client is None else client # Pybullet will crash if you try to visualize one point without packing it into a 2 D array positions = np . atleast_2d ( positions ) n_positions , dim = positions . shape if dim != 3 : raise ValueError ( f \"Invalid shape of the point positions. Expected (n, 3), got: {positions.shape}\" ) color = np . atleast_2d ( color ) if color . shape [ -1 ] != 3 : raise ValueError ( f \"Invalid shape of the colors. Expected (n, 3), got: {color.shape}\" ) if color . shape [ 0 ] != n_positions : if color . shape [ 0 ] == 1 : # Map the same color to all of the points color = color * np . ones_like ( positions ) else : raise ValueError ( f \"Number of colors ({color.shape[0]}) does not match the number of points ({n_positions}).\" ) # Downsample the points if desired if n is not None and n < n_positions : # This indexing ensures that the first and last frames are plotted idx = np . round ( np . linspace ( 0 , n_positions - 1 , n , endpoint = True )). astype ( int ) positions = positions [ idx, : ] color = color [ idx, : ] n_positions = n uid = None for i in range ( n_positions ) : start_time = time . time () if uid is None : uid = client . addUserDebugPoints ( [ positions[i ] ] , [ color[i ] ] , size , 0 ) else : uid = client . addUserDebugPoints ( [ positions[i ] ] , [ color[i ] ] , size , 0 , replaceItemUniqueId = uid ) client . stepSimulation () elapsed_time = time . time () - start_time time . sleep ( max ( 0 , duration / n_positions - elapsed_time ))","title":"animate_path"},{"location":"reference/pyastrobee/utils/debug_visualizer/#animate_rotation","text":"def animate_rotation ( quats : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], duration : float , object_id : Optional [ int ] = None , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) Animates an object rotating via a sequence of quaternions Parameters: Name Type Description Default quats npt.ArrayLike Quaternions to animate, shape (n, 4) None duration float Desired duration of the animation None object_id Optional[int] If you would like to animate the rotation using a specific object, pass in its Pybullet ID here. Defaults to None (use a cube as the default object). None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None View Source def animate_rotation ( quats : npt . ArrayLike , duration : float , object_id : Optional [ int ] = None , client : Optional [ BulletClient ] = None , ) : \"\"\"Animates an object rotating via a sequence of quaternions Args: quats (npt.ArrayLike): Quaternions to animate, shape (n, 4) duration (float): Desired duration of the animation object_id (Optional[int]): If you would like to animate the rotation using a specific object, pass in its Pybullet ID here. Defaults to None (use a cube as the default object). client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" client : pybullet = pybullet if client is None else client if object_id is None : object_id = create_box ( ( 0 , 0 , 0 ), ( 0 , 0 , 0 , 1 ), 1 , ( 1 , 1 , 1 ), True , client = client ) pos = client . getBasePositionAndOrientation ( object_id ) [ 0 ] quats = np . atleast_2d ( quats ) n = quats . shape [ 0 ] for quat in quats : start_time = time . time () pybullet . resetBasePositionAndOrientation ( object_id , pos , quat ) pybullet . stepSimulation () elapsed_time = time . time () - start_time time . sleep ( max ( 0 , duration / n - elapsed_time ))","title":"animate_rotation"},{"location":"reference/pyastrobee/utils/debug_visualizer/#cartesian_to_spherical","text":"def cartesian_to_spherical ( p : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Converts a cartesian (xyz) coordinate to spherical (radius, elevation, azimuth) Note that the elevation angle is traditionally measured w.r.t the +Z axis Radius >= 0 Elevation is defined between 0 and pi Azimuth is defined between -pi and pi Parameters: Name Type Description Default p npt.ArrayLike XYZ cartesian coordinate to translate into spherical, shape (3,) None Returns: Type Description np.ndarray Spherical coordinates (radius, elevation, azimuth), shape (3,) View Source def cartesian_to_spherical ( p : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts a cartesian (xyz) coordinate to spherical (radius, elevation, azimuth) - Note that the elevation angle is traditionally measured w.r.t the +Z axis - Radius >= 0 - Elevation is defined between 0 and pi - Azimuth is defined between -pi and pi Args: p (npt.ArrayLike): XYZ cartesian coordinate to translate into spherical, shape (3,) Returns: np.ndarray: Spherical coordinates (radius, elevation, azimuth), shape (3,) \"\"\" if len ( p ) != 3 : raise ValueError ( f \"Invalid coordinate size (should be 3).\\nGot:{p}\" ) # Convert to float to avoid a bug in pytransform3d with integer arrays return pc . spherical_from_cartesian ( np . float64 ( p ))","title":"cartesian_to_spherical"},{"location":"reference/pyastrobee/utils/debug_visualizer/#get_viz_camera_params","text":"def get_viz_camera_params ( T_R2W : numpy . ndarray , T_C2R : Optional [ numpy . ndarray ] = None ) -> tuple [ float , float , float , numpy . ndarray ] Calculates the debug visualizer camera position for a specified robot-frame camera view Parameters: Name Type Description Default T_R2W np.ndarray Robot to World transformation matrix, shape (4,4). This input is equivalent to the current robot pose (just expressed in tmat form) None T_C2R np.ndarray Camera to Robot transformation matrix, shape (4, 4). This input dictates the perspective from which we observe the robot. Defaults to the OBSERVATION_CAM constant None Returns: Type Description tuple[float, float, float, np.ndarray] float: Distance: The distance to the camera's focus point float: Yaw: The rotation angle about the Z axis float: Pitch: The angle of the camera as measured above/below the XY plane np.ndarray: Target: The camera focus point in world coords. Shape (3,) View Source def get_viz_camera_params ( T_R2W : np . ndarray , T_C2R : Optional [ np . ndarray ] = None ) -> tuple [ float , float , float , np . ndarray ]: \"\"\"Calculates the debug visualizer camera position for a specified robot-frame camera view Args: T_R2W (np.ndarray): Robot to World transformation matrix, shape (4,4). This input is equivalent to the current robot pose (just expressed in tmat form) T_C2R (np.ndarray, optional): Camera to Robot transformation matrix, shape (4, 4). This input dictates the perspective from which we observe the robot. Defaults to the OBSERVATION_CAM constant Returns: tuple[float, float, float, np.ndarray]: float: Distance: The distance to the camera's focus point float: Yaw: The rotation angle about the Z axis float: Pitch: The angle of the camera as measured above/below the XY plane np.ndarray: Target: The camera focus point in world coords. Shape (3,) \"\"\" if T_C2R is None : T_C2R = OBSERVATION_CAM R_R2W = T_R2W [: 3 , : 3 ] # Robot to world rotation matrix robot_to_cam_robot_pos = T_C2R [: 3 , 3 ] robot_to_cam_world_pos = R_R2W @ robot_to_cam_robot_pos cam_to_robot_world_pos = - 1 * robot_to_cam_world_pos # Determine the direction the camera points via the vector from camera -> robot origin in world frame dist , elevation , azimuth = cartesian_to_spherical ( cam_to_robot_world_pos ) # Elevation is measured w.r.t +Z, so we need to change this to w.r.t the XY plane # Pybullet also works with the camera angle definitions in degrees, not radians pitch = np . rad2deg ( np . pi / 2 - elevation ) # There seems to be a fixed -90 degree offset in how pybullet defines yaw (TODO test this) yaw = np . rad2deg ( azimuth ) - 90 robot_world_pos = T_R2W [: 3 , 3 ] target = robot_world_pos return dist , yaw , pitch , target","title":"get_viz_camera_params"},{"location":"reference/pyastrobee/utils/debug_visualizer/#remove_debug_objects","text":"def remove_debug_objects ( ids : Union [ int , list [ int ], numpy . ndarray [ int ]], client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> None Removes user-created line(s)/point(s)/etc. from the Pybullet GUI Parameters: Name Type Description Default ids int or list/array of ints ID(s) of the objects loaded into Pybullet None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None View Source def remove_debug_objects ( ids : Union [ int, list[int ] , np . ndarray [ int ] ] , client : Optional [ BulletClient ] = None ) -> None : \"\"\"Removes user-created line(s)/point(s)/etc. from the Pybullet GUI Args: ids (int or list/array of ints): ID(s) of the objects loaded into Pybullet client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) \"\"\" client : pybullet = pybullet if client is None else client if np . ndim ( ids ) == 0 : # Scalar , not iterable client . removeUserDebugItem ( ids ) return for i in ids : client . removeUserDebugItem ( i )","title":"remove_debug_objects"},{"location":"reference/pyastrobee/utils/debug_visualizer/#visualize_frame","text":"def visualize_frame ( tmat : numpy . ndarray , length : float = 1 , width : float = 3 , lifetime : float = 0 , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> tuple [ int , int , int ] Adds RGB XYZ axes to the Pybullet GUI for a speficied transformation/frame/pose Parameters: Name Type Description Default tmat np.ndarray Transformation matrix specifying a pose w.r.t world frame, shape (4, 4) None length float Length of the axis lines. Defaults to 1. 1 width float Width of the axis lines. Defaults to 3. (units unknown, maybe mm?) 3 lifetime float Amount of time to keep the lines on the GUI, in seconds. Defaults to 0 (keep them on-screen permanently until deleted) None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Returns: Type Description tuple[int, int, int] Pybullet IDs of the three axis lines added to the GUI View Source def visualize_frame ( tmat : np . ndarray , length : float = 1 , width : float = 3 , lifetime : float = 0 , client : Optional [ BulletClient ] = None , ) -> tuple [ int, int, int ] : \"\"\"Adds RGB XYZ axes to the Pybullet GUI for a speficied transformation/frame/pose Args: tmat (np.ndarray): Transformation matrix specifying a pose w.r.t world frame, shape (4, 4) length (float, optional): Length of the axis lines. Defaults to 1. width (float, optional): Width of the axis lines. Defaults to 3. (units unknown, maybe mm?) lifetime (float, optional): Amount of time to keep the lines on the GUI, in seconds. Defaults to 0 (keep them on-screen permanently until deleted) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: tuple[int, int, int]: Pybullet IDs of the three axis lines added to the GUI \"\"\" client : pybullet = pybullet if client is None else client x_color = [ 1, 0, 0 ] # R y_color = [ 0, 1, 0 ] # G z_color = [ 0, 0, 1 ] # B origin = tmat [ :3, 3 ] x_endpt = origin + tmat [ :3, 0 ] * length y_endpt = origin + tmat [ :3, 1 ] * length z_endpt = origin + tmat [ :3, 2 ] * length x_ax_id = client . addUserDebugLine ( origin , x_endpt , x_color , width , lifetime ) y_ax_id = client . addUserDebugLine ( origin , y_endpt , y_color , width , lifetime ) z_ax_id = client . addUserDebugLine ( origin , z_endpt , z_color , width , lifetime ) return x_ax_id , y_ax_id , z_ax_id","title":"visualize_frame"},{"location":"reference/pyastrobee/utils/debug_visualizer/#visualize_link_frame","text":"def visualize_link_frame ( robot_id : int , link_id : int , length : float = 1 , width : float = 3 , lifetime : float = 0 , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> tuple [ int , int , int ] Adds RGB XYZ axes to the Pybullet GUI for a specific link on the Astrobee Parameters: Name Type Description Default robot_id int Pybullet ID of the Astrobee None link_id int ID of the link we want to look at None length float Length of the axis lines. Defaults to 1. 1 width float Width of the axis lines. Defaults to 3. (units unknown, maybe mm?) 3 lifetime float Amount of time to keep the lines on the GUI, in seconds. Defaults to 0 (keep them on-screen permanently until deleted) None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Returns: Type Description tuple[int, int, int] Pybullet IDs of the three axis lines added to the GUI View Source def visualize_link_frame ( robot_id : int , link_id : int , length : float = 1 , width : float = 3 , lifetime : float = 0 , client : Optional [ BulletClient ] = None , ) -> tuple [ int, int, int ] : \"\"\"Adds RGB XYZ axes to the Pybullet GUI for a specific link on the Astrobee Args: robot_id (int): Pybullet ID of the Astrobee link_id (int): ID of the link we want to look at length (float, optional): Length of the axis lines. Defaults to 1. width (float, optional): Width of the axis lines. Defaults to 3. (units unknown, maybe mm?) lifetime (float, optional): Amount of time to keep the lines on the GUI, in seconds. Defaults to 0 (keep them on-screen permanently until deleted) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: tuple[int, int, int]: Pybullet IDs of the three axis lines added to the GUI \"\"\" client : pybullet = pybullet if client is None else client x_color = [ 1, 0, 0 ] # R y_color = [ 0, 1, 0 ] # G z_color = [ 0, 0, 1 ] # B origin = [ 0, 0, 0 ] x_endpt = np . array ( [ 1, 0, 0 ] ) * length y_endpt = np . array ( [ 0, 1, 0 ] ) * length z_endpt = np . array ( [ 0, 0, 1 ] ) * length x_ax_id = client . addUserDebugLine ( origin , x_endpt , x_color , width , lifetime , robot_id , link_id ) y_ax_id = client . addUserDebugLine ( origin , y_endpt , y_color , width , lifetime , robot_id , link_id ) z_ax_id = client . addUserDebugLine ( origin , z_endpt , z_color , width , lifetime , robot_id , link_id ) return x_ax_id , y_ax_id , z_ax_id","title":"visualize_link_frame"},{"location":"reference/pyastrobee/utils/debug_visualizer/#visualize_path","text":"def visualize_path ( positions : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], n : Optional [ int ] = None , color : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] = ( 1 , 0 , 0 ), width : float = 3 , lifetime : float = 0 , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> list [ int ] Visualize a sequence of positions on the Pybullet GUI Parameters: Name Type Description Default positions npt.ArrayLike Sequence of positions, shape (n, 3) None n Optional[int] Number of lines to plot, if plotting the lines between all positions is not desired. Defaults to None (plot all lines between positions) None color npt.ArrayLike RGB color values. Defaults to (1, 0, 0) (red). (1, 0, 0) (red) width float Width of the line. Defaults to 3 (pixels) None lifetime float Amount of time to keep the lines on the GUI, in seconds. Defaults to 0 (keep them on-screen permanently until deleted) None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Returns: Type Description list[int] Pybullet IDs of the lines added to the GUI View Source def visualize_path ( positions : npt . ArrayLike , n : Optional [ int ] = None , color : npt . ArrayLike = ( 1 , 0 , 0 ), width : float = 3 , lifetime : float = 0 , client : Optional [ BulletClient ] = None , ) -> list [ int ] : \"\"\"Visualize a sequence of positions on the Pybullet GUI Args: positions (npt.ArrayLike): Sequence of positions, shape (n, 3) n (Optional[int]): Number of lines to plot, if plotting the lines between all positions is not desired. Defaults to None (plot all lines between positions) color (npt.ArrayLike, optional): RGB color values. Defaults to (1, 0, 0) (red). width (float, optional): Width of the line. Defaults to 3 (pixels) lifetime (float, optional): Amount of time to keep the lines on the GUI, in seconds. Defaults to 0 (keep them on-screen permanently until deleted) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: list[int]: Pybullet IDs of the lines added to the GUI \"\"\" client : pybullet = pybullet if client is None else client positions = np . atleast_2d ( positions ) n_positions , dim = positions . shape assert dim == 3 # If desired , sample frames evenly across the trajectory to plot a subset if n is not None and n < n_positions : # This indexing ensures that the first and last frames are plotted idx = np . round ( np . linspace ( 0 , n_positions - 1 , n , endpoint = True )). astype ( int ) positions = positions [ idx, : ] ids = [] for i in range ( positions . shape [ 0 ] - 1 ) : ids . append ( client . addUserDebugLine ( positions [ i ] , positions [ i + 1 ] , color , width , lifetime ) ) return ids","title":"visualize_path"},{"location":"reference/pyastrobee/utils/debug_visualizer/#visualize_points","text":"def visualize_points ( position : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], color : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], size : float = 20 , lifetime : float = 0 , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> int Adds square points to the GUI to visualize positions in the sim Parameters: Name Type Description Default position npt.ArrayLike 3D point(s) in the simulation to visualize. Shape (n, 3) None color npt.ArrayLike RGB values, each in range [0, 1]. Shape (3,) if specifying the same color for all points, or (n, 3) to individually specify the colors per-point None size float Size of the points on the GUI, in pixels. Defaults to 20 None lifetime float Amount of time to keep the points on the GUI, in seconds. Defaults to 0 (keep them on-screen permanently until deleted) None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Returns: Type Description int Pybullet object ID for the point / point cloud View Source def visualize_points ( position : npt . ArrayLike , color : npt . ArrayLike , size : float = 20 , lifetime : float = 0 , client : Optional [ BulletClient ] = None , ) -> int : \"\"\"Adds square points to the GUI to visualize positions in the sim Args: position (npt.ArrayLike): 3D point(s) in the simulation to visualize. Shape (n, 3) color (npt.ArrayLike): RGB values, each in range [0, 1]. Shape (3,) if specifying the same color for all points, or (n, 3) to individually specify the colors per-point size (float): Size of the points on the GUI, in pixels. Defaults to 20 lifetime (float, optional): Amount of time to keep the points on the GUI, in seconds. Defaults to 0 (keep them on-screen permanently until deleted) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: int: Pybullet object ID for the point / point cloud \"\"\" client : pybullet = pybullet if client is None else client # Pybullet will crash if you try to visualize one point without packing it into a 2 D array position = np . atleast_2d ( position ) color = np . atleast_2d ( color ) if position . shape [ -1 ] != 3 : raise ValueError ( f \"Invalid shape of the point positions. Expected (n, 3), got: {position.shape}\" ) if color . shape [ -1 ] != 3 : raise ValueError ( f \"Invalid shape of the colors. Expected (n, 3), got: {color.shape}\" ) n = position . shape [ 0 ] if color . shape [ 0 ] != n : if color . shape [ 0 ] == 1 : # Map the same color to all of the points color = color * np . ones_like ( position ) else : raise ValueError ( f \"Number of colors ({color.shape[0]}) does not match the number of points ({n}).\" ) return client . addUserDebugPoints ( position , color , size , lifetime )","title":"visualize_points"},{"location":"reference/pyastrobee/utils/debug_visualizer/#visualize_quaternion","text":"def visualize_quaternion ( quat : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], length : float = 1 , width : float = 3 , lifetime : float = 0 , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> tuple [ int , int , int ] Wrapper around visualize_frame specifically for debugging quaternions. Shows the rotated frame at the origin Parameters: Name Type Description Default quat npt.ArrayLike XYZW quaternion, shape (4,) None length float Length of the axis lines. Defaults to 1. 1 width float Width of the axis lines. Defaults to 3. (units unknown, maybe mm?) 3 lifetime float Amount of time to keep the lines on the GUI, in seconds. Defaults to 0 (keep them on-screen permanently until deleted) None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Returns: Type Description tuple[int, int, int] Pybullet IDs of the three axis lines added to the GUI View Source def visualize_quaternion ( quat : npt . ArrayLike , length : float = 1 , width : float = 3 , lifetime : float = 0 , client : Optional [ BulletClient ] = None , ) -> tuple [ int, int, int ] : \"\"\"Wrapper around visualize_frame specifically for debugging quaternions. Shows the rotated frame at the origin Args: quat (npt.ArrayLike): XYZW quaternion, shape (4,) length (float, optional): Length of the axis lines. Defaults to 1. width (float, optional): Width of the axis lines. Defaults to 3. (units unknown, maybe mm?) lifetime (float, optional): Amount of time to keep the lines on the GUI, in seconds. Defaults to 0 (keep them on-screen permanently until deleted) client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: tuple[int, int, int]: Pybullet IDs of the three axis lines added to the GUI \"\"\" rmat = quat_to_rmat ( quat ) tmat = make_transform_mat ( rmat , [ 0, 0, 0 ] ) return visualize_frame ( tmat , length , width , lifetime , client )","title":"visualize_quaternion"},{"location":"reference/pyastrobee/utils/dynamics/","text":"Module pyastrobee.utils.dynamics Functions for free-body dynamics, state-space control, and other tools Note that any equations involving quaternions or angular velocity use our convention of XYZW quaternions and world-frame angular velocity definition (to match Pybullet) Key equations: F = m * a T = I * alpha + omega x (I * omega) + m * r x a Notation: F: Force, in world frame m: Mass a: Linear acceleration of the body's center of mass, in world frame T = Torque, in world frame I = Inertia tensor of the body, in world frame alpha: Angular acceleration of the body, in world frame omega: Angular velocity of the body, in world frame r: Position of the body's center of mass w.r.t the point of interest on the body, in world frame Notes: - If the point of interest is the center of mass of the body, the third term in the torque expression is 0 - For Astrobee, this point (the base frame) is sightly different from the center of mass, but they are close enough that the errors are minimal View Source \"\"\"Functions for free-body dynamics, state-space control, and other tools Note that any equations involving quaternions or angular velocity use our convention of XYZW quaternions and world-frame angular velocity definition (to match Pybullet) Key equations: F = m * a T = I * alpha + omega x (I * omega) + m * r x a Notation: F: Force, in world frame m: Mass a: Linear acceleration of the body's center of mass, in world frame T = Torque, in world frame I = Inertia tensor of the body, in world frame alpha: Angular acceleration of the body, in world frame omega: Angular velocity of the body, in world frame r: Position of the body's center of mass w.r.t the point of interest on the body, in world frame Notes: - If the point of interest is the center of mass of the body, the third term in the torque expression is 0 - For Astrobee, this point (the base frame) is sightly different from the center of mass, but they are close enough that the errors are minimal \"\"\" import numpy as np import numpy.typing as npt def inertial_transformation ( mass : float , inertia : np . ndarray , transform : np . ndarray ) -> np . ndarray : \"\"\"Transform an inertia tensor defined for a local reference frame into a new reference frame Reference: Stanford ME320 Intro to Robotics course reader, chapter 5 Args: mass (float): Mass of the object inertia (np.ndarray): Inertia tensor of the object, determined for its local frame. Shape (3, 3) transform (np.ndarray): \"Local to desired\" transformation matrix, shape (4, 4) Returns: np.ndarray: Transformed inertia tensor \"\"\" p = transform [: 3 , 3 ] R = transform [: 3 , : 3 ] # Parallel axis theorem for the translation component I = inertia + mass * ( np . dot ( p , p ) * np . eye ( 3 ) - np . outer ( p , p )) # Similarity transform for the rotation component return R @ I @ R . T def state_matrix ( q : npt . ArrayLike , w : npt . ArrayLike , inertia : np . ndarray , inv_inertia : np . ndarray , ) -> np . ndarray : \"\"\"The A matrix, such that x_dot = Ax + Bu We assume that the state x = [position, velocity, quaternion, angular velocity] \u2208 R13 and that the control u = [force, torque] \u2208 R6 This is dependent on the current quaternion/angular velocity due to the nonlinearities in the orientation representation Args: q (npt.ArrayLike): XYZW quaternion, shape (4,) w (npt.ArrayLike): Angular velocity, shape (3,) inertia (np.ndarray): Inertia tensor (world frame), shape (3, 3) inv_inertia (np.ndarray): Inverse of the inertia tensor (world frame), shape (3, 3). Returns: np.ndarray: The A (state) matrix \"\"\" if inv_inertia is None : inv_inertia = np . linalg . inv ( inertia ) A = np . zeros (( 13 , 13 )) qx , qy , qz , qw = q w1 , w2 , w3 = w # Relationship between velocity / acceleration and current position / velocity A [: 6 , : 6 ] = np . kron ([[ 0 , 1 ], [ 0 , 0 ]], np . eye ( 3 )) # Relationship between quaternion derivative and current quaternion / angular velocity # NOTE: this is effectively a concatenation of the standard quaternion derivative matrices, HOWEVER, we multiply by # an extra factor of 1/2 here because of the way that this matrix multiplication A @ x will \"double count\" the # quaternion derivative effect, since we will have q_dot = f(w) @ q + f(q) @ w A [ 6 : 10 , 6 :] = ( 1 / 2 ) * np . array ( [ [ 0 , - w3 / 2 , w2 / 2 , w1 / 2 , qw / 2 , qz / 2 , - qy / 2 ], [ w3 / 2 , 0 , - w1 / 2 , w2 / 2 , - qz / 2 , qw / 2 , qx / 2 ], [ - w2 / 2 , w1 / 2 , 0 , w3 / 2 , qy / 2 , - qx / 2 , qw / 2 ], [ - w1 / 2 , - w2 / 2 , - w3 / 2 , 0 , - qx / 2 , - qy / 2 , - qz / 2 ], ] ) # Relationship between angular acceleration and angular velocity A [ 10 :, 10 :] = - 1 * inv_inertia @ _jac_w_of_wxIw ( inertia , w ) return A def control_matrix ( mass : float , inv_inertia : np . ndarray ) -> np . ndarray : \"\"\"The B matrix, such that x_dot = Ax + Bu We assume that the state x = [position, velocity, quaternion, angular velocity] \u2208 R13 and that the control u = [force, torque] \u2208 R6 Args: mass (float): Mass of the system inv_inertia (np.ndarray): Inverse of the inertia tensor (world frame), shape (3, 3) Returns: np.ndarray: The B (control) matrix \"\"\" B = np . zeros (( 13 , 6 )) B [ 3 : 6 , : 3 ] = ( 1 / mass ) * np . eye ( 3 ) B [ 10 :, 3 :] = inv_inertia return B def _jac_w_of_wxIw ( I : np . ndarray , w : npt . ArrayLike ) -> np . ndarray : \"\"\"Helper function. Computes the Jacobian of the expression (w x I w) with respect to w Derivation is via the MATLAB symbolic toolbox. e.g. jacobian(cross(w, I*w), [w]) with w and I defined symbolically w.r.t their components Args: I (np.ndarray): Inertia tensor (world frame). Symmetric, positive semidefinite. Shape (3, 3) w (npt.ArrayLike): Angular velocity vector, shape (3,) Returns: np.ndarray: Jacobian matrix, shape (3, 3) \"\"\" Ixx , Iyy , Izz = np . diag ( I ) Ixy = I [ 0 , 1 ] Ixz = I [ 0 , 2 ] Iyz = I [ 1 , 2 ] w1 , w2 , w3 = w return np . array ( [ [ Ixz * w2 - Ixy * w3 , Ixz * w1 - Iyy * w3 + 2 * Iyz * w2 + Izz * w3 , Izz * w2 - Iyy * w2 - 2 * Iyz * w3 - Ixy * w1 , ], [ Ixx * w3 - 2 * Ixz * w1 - Iyz * w2 - Izz * w3 , Ixy * w3 - Iyz * w1 , Ixx * w1 + Ixy * w2 + 2 * Ixz * w3 - Izz * w1 , ], [ 2 * Ixy * w1 - Ixx * w2 + Iyy * w2 + Iyz * w3 , Iyy * w1 - 2 * Ixy * w2 - Ixz * w3 - Ixx * w1 , Iyz * w1 - Ixz * w2 , ], ] ) def box_inertia ( m : float , l : float , w : float , h : float ) -> np . ndarray : \"\"\"Inertia tensor for a solid, uniform-material box Args: m (float): Mass, kg l (float): Length (x-axis dimension), meters w (float): Width (y-axis dimension), meters h (float): Height (z-axis dimension), meters Returns: np.ndarray: Inertia tensor, shape (3, 3) \"\"\" return ( 1 / 12 ) * m * np . diag ([ w ** 2 + h ** 2 , l ** 2 + h ** 2 , l ** 2 + w ** 2 ]) Functions box_inertia def box_inertia ( m : float , l : float , w : float , h : float ) -> numpy . ndarray Inertia tensor for a solid, uniform-material box Parameters: Name Type Description Default m float Mass, kg None l float Length (x-axis dimension), meters None w float Width (y-axis dimension), meters None h float Height (z-axis dimension), meters None Returns: Type Description np.ndarray Inertia tensor, shape (3, 3) View Source def box_inertia(m: float, l: float, w: float, h: float) -> np.ndarray: \"\"\"Inertia tensor for a solid, uniform-material box Args: m (float): Mass, kg l (float): Length (x-axis dimension), meters w (float): Width (y-axis dimension), meters h (float): Height (z-axis dimension), meters Returns: np.ndarray: Inertia tensor, shape (3, 3) \"\"\" return (1 / 12) * m * np.diag([w**2 + h**2, l**2 + h**2, l**2 + w**2]) control_matrix def control_matrix ( mass : float , inv_inertia : numpy . ndarray ) -> numpy . ndarray The B matrix, such that x_dot = Ax + Bu We assume that the state x = [position, velocity, quaternion, angular velocity] \u2208 R13 and that the control u = [force, torque] \u2208 R6 Parameters: Name Type Description Default mass float Mass of the system None inv_inertia np.ndarray Inverse of the inertia tensor (world frame), shape (3, 3) None Returns: Type Description np.ndarray The B (control) matrix View Source def control_matrix(mass: float, inv_inertia: np.ndarray) -> np.ndarray: \"\"\"The B matrix, such that x_dot = Ax + Bu We assume that the state x = [position, velocity, quaternion, angular velocity] \u2208 R13 and that the control u = [force, torque] \u2208 R6 Args: mass (float): Mass of the system inv_inertia (np.ndarray): Inverse of the inertia tensor (world frame), shape (3, 3) Returns: np.ndarray: The B (control) matrix \"\"\" B = np.zeros((13, 6)) B[3:6, :3] = (1 / mass) * np.eye(3) B[10:, 3:] = inv_inertia return B inertial_transformation def inertial_transformation ( mass : float , inertia : numpy . ndarray , transform : numpy . ndarray ) -> numpy . ndarray Transform an inertia tensor defined for a local reference frame into a new reference frame Reference: Stanford ME320 Intro to Robotics course reader, chapter 5 Parameters: Name Type Description Default mass float Mass of the object None inertia np.ndarray Inertia tensor of the object, determined for its local frame. Shape (3, 3) None transform np.ndarray \"Local to desired\" transformation matrix, shape (4, 4) None Returns: Type Description np.ndarray Transformed inertia tensor View Source def inertial_transformation( mass: float, inertia: np.ndarray, transform: np.ndarray ) -> np.ndarray: \"\"\"Transform an inertia tensor defined for a local reference frame into a new reference frame Reference: Stanford ME320 Intro to Robotics course reader, chapter 5 Args: mass (float): Mass of the object inertia (np.ndarray): Inertia tensor of the object, determined for its local frame. Shape (3, 3) transform (np.ndarray): \"Local to desired\" transformation matrix, shape (4, 4) Returns: np.ndarray: Transformed inertia tensor \"\"\" p = transform[:3, 3] R = transform[:3, :3] # Parallel axis theorem for the translation component I = inertia + mass * (np.dot(p, p) * np.eye(3) - np.outer(p, p)) # Similarity transform for the rotation component return R @ I @ R.T state_matrix def state_matrix ( q : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], w : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], inertia : numpy . ndarray , inv_inertia : numpy . ndarray ) -> numpy . ndarray The A matrix, such that x_dot = Ax + Bu We assume that the state x = [position, velocity, quaternion, angular velocity] \u2208 R13 and that the control u = [force, torque] \u2208 R6 This is dependent on the current quaternion/angular velocity due to the nonlinearities in the orientation representation Parameters: Name Type Description Default q npt.ArrayLike XYZW quaternion, shape (4,) None w npt.ArrayLike Angular velocity, shape (3,) None inertia np.ndarray Inertia tensor (world frame), shape (3, 3) None inv_inertia np.ndarray Inverse of the inertia tensor (world frame), shape (3, 3). None Returns: Type Description np.ndarray The A (state) matrix View Source def state_matrix( q: npt.ArrayLike, w: npt.ArrayLike, inertia: np.ndarray, inv_inertia: np.ndarray, ) -> np.ndarray: \"\"\"The A matrix, such that x_dot = Ax + Bu We assume that the state x = [position, velocity, quaternion, angular velocity] \u2208 R13 and that the control u = [force, torque] \u2208 R6 This is dependent on the current quaternion/angular velocity due to the nonlinearities in the orientation representation Args: q (npt.ArrayLike): XYZW quaternion, shape (4,) w (npt.ArrayLike): Angular velocity, shape (3,) inertia (np.ndarray): Inertia tensor (world frame), shape (3, 3) inv_inertia (np.ndarray): Inverse of the inertia tensor (world frame), shape (3, 3). Returns: np.ndarray: The A (state) matrix \"\"\" if inv_inertia is None: inv_inertia = np.linalg.inv(inertia) A = np.zeros((13, 13)) qx, qy, qz, qw = q w1, w2, w3 = w # Relationship between velocity / acceleration and current position / velocity A[:6, :6] = np.kron([[0, 1], [0, 0]], np.eye(3)) # Relationship between quaternion derivative and current quaternion / angular velocity # NOTE: this is effectively a concatenation of the standard quaternion derivative matrices, HOWEVER, we multiply by # an extra factor of 1/2 here because of the way that this matrix multiplication A @ x will \"double count\" the # quaternion derivative effect, since we will have q_dot = f(w) @ q + f(q) @ w A[6:10, 6:] = (1 / 2) * np.array( [ [0, -w3 / 2, w2 / 2, w1 / 2, qw / 2, qz / 2, -qy / 2], [w3 / 2, 0, -w1 / 2, w2 / 2, -qz / 2, qw / 2, qx / 2], [-w2 / 2, w1 / 2, 0, w3 / 2, qy / 2, -qx / 2, qw / 2], [-w1 / 2, -w2 / 2, -w3 / 2, 0, -qx / 2, -qy / 2, -qz / 2], ] ) # Relationship between angular acceleration and angular velocity A[10:, 10:] = -1 * inv_inertia @ _jac_w_of_wxIw(inertia, w) return A","title":"Dynamics"},{"location":"reference/pyastrobee/utils/dynamics/#module-pyastrobeeutilsdynamics","text":"Functions for free-body dynamics, state-space control, and other tools Note that any equations involving quaternions or angular velocity use our convention of XYZW quaternions and world-frame angular velocity definition (to match Pybullet) Key equations: F = m * a T = I * alpha + omega x (I * omega) + m * r x a Notation: F: Force, in world frame m: Mass a: Linear acceleration of the body's center of mass, in world frame T = Torque, in world frame I = Inertia tensor of the body, in world frame alpha: Angular acceleration of the body, in world frame omega: Angular velocity of the body, in world frame r: Position of the body's center of mass w.r.t the point of interest on the body, in world frame Notes: - If the point of interest is the center of mass of the body, the third term in the torque expression is 0 - For Astrobee, this point (the base frame) is sightly different from the center of mass, but they are close enough that the errors are minimal View Source \"\"\"Functions for free-body dynamics, state-space control, and other tools Note that any equations involving quaternions or angular velocity use our convention of XYZW quaternions and world-frame angular velocity definition (to match Pybullet) Key equations: F = m * a T = I * alpha + omega x (I * omega) + m * r x a Notation: F: Force, in world frame m: Mass a: Linear acceleration of the body's center of mass, in world frame T = Torque, in world frame I = Inertia tensor of the body, in world frame alpha: Angular acceleration of the body, in world frame omega: Angular velocity of the body, in world frame r: Position of the body's center of mass w.r.t the point of interest on the body, in world frame Notes: - If the point of interest is the center of mass of the body, the third term in the torque expression is 0 - For Astrobee, this point (the base frame) is sightly different from the center of mass, but they are close enough that the errors are minimal \"\"\" import numpy as np import numpy.typing as npt def inertial_transformation ( mass : float , inertia : np . ndarray , transform : np . ndarray ) -> np . ndarray : \"\"\"Transform an inertia tensor defined for a local reference frame into a new reference frame Reference: Stanford ME320 Intro to Robotics course reader, chapter 5 Args: mass (float): Mass of the object inertia (np.ndarray): Inertia tensor of the object, determined for its local frame. Shape (3, 3) transform (np.ndarray): \"Local to desired\" transformation matrix, shape (4, 4) Returns: np.ndarray: Transformed inertia tensor \"\"\" p = transform [: 3 , 3 ] R = transform [: 3 , : 3 ] # Parallel axis theorem for the translation component I = inertia + mass * ( np . dot ( p , p ) * np . eye ( 3 ) - np . outer ( p , p )) # Similarity transform for the rotation component return R @ I @ R . T def state_matrix ( q : npt . ArrayLike , w : npt . ArrayLike , inertia : np . ndarray , inv_inertia : np . ndarray , ) -> np . ndarray : \"\"\"The A matrix, such that x_dot = Ax + Bu We assume that the state x = [position, velocity, quaternion, angular velocity] \u2208 R13 and that the control u = [force, torque] \u2208 R6 This is dependent on the current quaternion/angular velocity due to the nonlinearities in the orientation representation Args: q (npt.ArrayLike): XYZW quaternion, shape (4,) w (npt.ArrayLike): Angular velocity, shape (3,) inertia (np.ndarray): Inertia tensor (world frame), shape (3, 3) inv_inertia (np.ndarray): Inverse of the inertia tensor (world frame), shape (3, 3). Returns: np.ndarray: The A (state) matrix \"\"\" if inv_inertia is None : inv_inertia = np . linalg . inv ( inertia ) A = np . zeros (( 13 , 13 )) qx , qy , qz , qw = q w1 , w2 , w3 = w # Relationship between velocity / acceleration and current position / velocity A [: 6 , : 6 ] = np . kron ([[ 0 , 1 ], [ 0 , 0 ]], np . eye ( 3 )) # Relationship between quaternion derivative and current quaternion / angular velocity # NOTE: this is effectively a concatenation of the standard quaternion derivative matrices, HOWEVER, we multiply by # an extra factor of 1/2 here because of the way that this matrix multiplication A @ x will \"double count\" the # quaternion derivative effect, since we will have q_dot = f(w) @ q + f(q) @ w A [ 6 : 10 , 6 :] = ( 1 / 2 ) * np . array ( [ [ 0 , - w3 / 2 , w2 / 2 , w1 / 2 , qw / 2 , qz / 2 , - qy / 2 ], [ w3 / 2 , 0 , - w1 / 2 , w2 / 2 , - qz / 2 , qw / 2 , qx / 2 ], [ - w2 / 2 , w1 / 2 , 0 , w3 / 2 , qy / 2 , - qx / 2 , qw / 2 ], [ - w1 / 2 , - w2 / 2 , - w3 / 2 , 0 , - qx / 2 , - qy / 2 , - qz / 2 ], ] ) # Relationship between angular acceleration and angular velocity A [ 10 :, 10 :] = - 1 * inv_inertia @ _jac_w_of_wxIw ( inertia , w ) return A def control_matrix ( mass : float , inv_inertia : np . ndarray ) -> np . ndarray : \"\"\"The B matrix, such that x_dot = Ax + Bu We assume that the state x = [position, velocity, quaternion, angular velocity] \u2208 R13 and that the control u = [force, torque] \u2208 R6 Args: mass (float): Mass of the system inv_inertia (np.ndarray): Inverse of the inertia tensor (world frame), shape (3, 3) Returns: np.ndarray: The B (control) matrix \"\"\" B = np . zeros (( 13 , 6 )) B [ 3 : 6 , : 3 ] = ( 1 / mass ) * np . eye ( 3 ) B [ 10 :, 3 :] = inv_inertia return B def _jac_w_of_wxIw ( I : np . ndarray , w : npt . ArrayLike ) -> np . ndarray : \"\"\"Helper function. Computes the Jacobian of the expression (w x I w) with respect to w Derivation is via the MATLAB symbolic toolbox. e.g. jacobian(cross(w, I*w), [w]) with w and I defined symbolically w.r.t their components Args: I (np.ndarray): Inertia tensor (world frame). Symmetric, positive semidefinite. Shape (3, 3) w (npt.ArrayLike): Angular velocity vector, shape (3,) Returns: np.ndarray: Jacobian matrix, shape (3, 3) \"\"\" Ixx , Iyy , Izz = np . diag ( I ) Ixy = I [ 0 , 1 ] Ixz = I [ 0 , 2 ] Iyz = I [ 1 , 2 ] w1 , w2 , w3 = w return np . array ( [ [ Ixz * w2 - Ixy * w3 , Ixz * w1 - Iyy * w3 + 2 * Iyz * w2 + Izz * w3 , Izz * w2 - Iyy * w2 - 2 * Iyz * w3 - Ixy * w1 , ], [ Ixx * w3 - 2 * Ixz * w1 - Iyz * w2 - Izz * w3 , Ixy * w3 - Iyz * w1 , Ixx * w1 + Ixy * w2 + 2 * Ixz * w3 - Izz * w1 , ], [ 2 * Ixy * w1 - Ixx * w2 + Iyy * w2 + Iyz * w3 , Iyy * w1 - 2 * Ixy * w2 - Ixz * w3 - Ixx * w1 , Iyz * w1 - Ixz * w2 , ], ] ) def box_inertia ( m : float , l : float , w : float , h : float ) -> np . ndarray : \"\"\"Inertia tensor for a solid, uniform-material box Args: m (float): Mass, kg l (float): Length (x-axis dimension), meters w (float): Width (y-axis dimension), meters h (float): Height (z-axis dimension), meters Returns: np.ndarray: Inertia tensor, shape (3, 3) \"\"\" return ( 1 / 12 ) * m * np . diag ([ w ** 2 + h ** 2 , l ** 2 + h ** 2 , l ** 2 + w ** 2 ])","title":"Module pyastrobee.utils.dynamics"},{"location":"reference/pyastrobee/utils/dynamics/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/utils/dynamics/#box_inertia","text":"def box_inertia ( m : float , l : float , w : float , h : float ) -> numpy . ndarray Inertia tensor for a solid, uniform-material box Parameters: Name Type Description Default m float Mass, kg None l float Length (x-axis dimension), meters None w float Width (y-axis dimension), meters None h float Height (z-axis dimension), meters None Returns: Type Description np.ndarray Inertia tensor, shape (3, 3) View Source def box_inertia(m: float, l: float, w: float, h: float) -> np.ndarray: \"\"\"Inertia tensor for a solid, uniform-material box Args: m (float): Mass, kg l (float): Length (x-axis dimension), meters w (float): Width (y-axis dimension), meters h (float): Height (z-axis dimension), meters Returns: np.ndarray: Inertia tensor, shape (3, 3) \"\"\" return (1 / 12) * m * np.diag([w**2 + h**2, l**2 + h**2, l**2 + w**2])","title":"box_inertia"},{"location":"reference/pyastrobee/utils/dynamics/#control_matrix","text":"def control_matrix ( mass : float , inv_inertia : numpy . ndarray ) -> numpy . ndarray The B matrix, such that x_dot = Ax + Bu We assume that the state x = [position, velocity, quaternion, angular velocity] \u2208 R13 and that the control u = [force, torque] \u2208 R6 Parameters: Name Type Description Default mass float Mass of the system None inv_inertia np.ndarray Inverse of the inertia tensor (world frame), shape (3, 3) None Returns: Type Description np.ndarray The B (control) matrix View Source def control_matrix(mass: float, inv_inertia: np.ndarray) -> np.ndarray: \"\"\"The B matrix, such that x_dot = Ax + Bu We assume that the state x = [position, velocity, quaternion, angular velocity] \u2208 R13 and that the control u = [force, torque] \u2208 R6 Args: mass (float): Mass of the system inv_inertia (np.ndarray): Inverse of the inertia tensor (world frame), shape (3, 3) Returns: np.ndarray: The B (control) matrix \"\"\" B = np.zeros((13, 6)) B[3:6, :3] = (1 / mass) * np.eye(3) B[10:, 3:] = inv_inertia return B","title":"control_matrix"},{"location":"reference/pyastrobee/utils/dynamics/#inertial_transformation","text":"def inertial_transformation ( mass : float , inertia : numpy . ndarray , transform : numpy . ndarray ) -> numpy . ndarray Transform an inertia tensor defined for a local reference frame into a new reference frame Reference: Stanford ME320 Intro to Robotics course reader, chapter 5 Parameters: Name Type Description Default mass float Mass of the object None inertia np.ndarray Inertia tensor of the object, determined for its local frame. Shape (3, 3) None transform np.ndarray \"Local to desired\" transformation matrix, shape (4, 4) None Returns: Type Description np.ndarray Transformed inertia tensor View Source def inertial_transformation( mass: float, inertia: np.ndarray, transform: np.ndarray ) -> np.ndarray: \"\"\"Transform an inertia tensor defined for a local reference frame into a new reference frame Reference: Stanford ME320 Intro to Robotics course reader, chapter 5 Args: mass (float): Mass of the object inertia (np.ndarray): Inertia tensor of the object, determined for its local frame. Shape (3, 3) transform (np.ndarray): \"Local to desired\" transformation matrix, shape (4, 4) Returns: np.ndarray: Transformed inertia tensor \"\"\" p = transform[:3, 3] R = transform[:3, :3] # Parallel axis theorem for the translation component I = inertia + mass * (np.dot(p, p) * np.eye(3) - np.outer(p, p)) # Similarity transform for the rotation component return R @ I @ R.T","title":"inertial_transformation"},{"location":"reference/pyastrobee/utils/dynamics/#state_matrix","text":"def state_matrix ( q : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], w : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], inertia : numpy . ndarray , inv_inertia : numpy . ndarray ) -> numpy . ndarray The A matrix, such that x_dot = Ax + Bu We assume that the state x = [position, velocity, quaternion, angular velocity] \u2208 R13 and that the control u = [force, torque] \u2208 R6 This is dependent on the current quaternion/angular velocity due to the nonlinearities in the orientation representation Parameters: Name Type Description Default q npt.ArrayLike XYZW quaternion, shape (4,) None w npt.ArrayLike Angular velocity, shape (3,) None inertia np.ndarray Inertia tensor (world frame), shape (3, 3) None inv_inertia np.ndarray Inverse of the inertia tensor (world frame), shape (3, 3). None Returns: Type Description np.ndarray The A (state) matrix View Source def state_matrix( q: npt.ArrayLike, w: npt.ArrayLike, inertia: np.ndarray, inv_inertia: np.ndarray, ) -> np.ndarray: \"\"\"The A matrix, such that x_dot = Ax + Bu We assume that the state x = [position, velocity, quaternion, angular velocity] \u2208 R13 and that the control u = [force, torque] \u2208 R6 This is dependent on the current quaternion/angular velocity due to the nonlinearities in the orientation representation Args: q (npt.ArrayLike): XYZW quaternion, shape (4,) w (npt.ArrayLike): Angular velocity, shape (3,) inertia (np.ndarray): Inertia tensor (world frame), shape (3, 3) inv_inertia (np.ndarray): Inverse of the inertia tensor (world frame), shape (3, 3). Returns: np.ndarray: The A (state) matrix \"\"\" if inv_inertia is None: inv_inertia = np.linalg.inv(inertia) A = np.zeros((13, 13)) qx, qy, qz, qw = q w1, w2, w3 = w # Relationship between velocity / acceleration and current position / velocity A[:6, :6] = np.kron([[0, 1], [0, 0]], np.eye(3)) # Relationship between quaternion derivative and current quaternion / angular velocity # NOTE: this is effectively a concatenation of the standard quaternion derivative matrices, HOWEVER, we multiply by # an extra factor of 1/2 here because of the way that this matrix multiplication A @ x will \"double count\" the # quaternion derivative effect, since we will have q_dot = f(w) @ q + f(q) @ w A[6:10, 6:] = (1 / 2) * np.array( [ [0, -w3 / 2, w2 / 2, w1 / 2, qw / 2, qz / 2, -qy / 2], [w3 / 2, 0, -w1 / 2, w2 / 2, -qz / 2, qw / 2, qx / 2], [-w2 / 2, w1 / 2, 0, w3 / 2, qy / 2, -qx / 2, qw / 2], [-w1 / 2, -w2 / 2, -w3 / 2, 0, -qx / 2, -qy / 2, -qz / 2], ] ) # Relationship between angular acceleration and angular velocity A[10:, 10:] = -1 * inv_inertia @ _jac_w_of_wxIw(inertia, w) return A","title":"state_matrix"},{"location":"reference/pyastrobee/utils/errors/","text":"Module pyastrobee.utils.errors Custom exceptions View Source \"\"\"Custom exceptions\"\"\" from typing import Optional class PybulletError ( Exception ): \"\"\"Custom exception type for dealing with Pybullet-related issues Args: message (str): Info to display about the error code (int, optional): A pybullet return value indicating that an error occurred. Defaults to None. \"\"\" def __init__ ( self , message : str , code : Optional [ int ] = None ): # Store as class attribute to access the code and handle programmatically if needed self . code = code if code is not None : message += f \" \\n Pybullet return value: { code } \" super () . __init__ ( message ) class OptimizationError ( Exception ): pass Classes OptimizationError class OptimizationError ( / , * args , ** kwargs ) Common base class for all non-exit exceptions. View Source class OptimizationError ( Exception ): pass Ancestors (in MRO) builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. PybulletError class PybulletError ( message : str , code : Optional [ int ] = None ) Custom exception type for dealing with Pybullet-related issues Attributes Name Type Description Default message str Info to display about the error None code int A pybullet return value indicating that an error occurred. Defaults to None. None View Source class PybulletError ( Exception ) : \"\"\"Custom exception type for dealing with Pybullet-related issues Args: message (str): Info to display about the error code (int, optional): A pybullet return value indicating that an error occurred. Defaults to None. \"\"\" def __init__ ( self , message : str , code : Optional [ int ] = None ) : # Store as class attribute to access the code and handle programmatically if needed self . code = code if code is not None : message += f \"\\nPybullet return value: {code}\" super (). __init__ ( message ) Ancestors (in MRO) builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Errors"},{"location":"reference/pyastrobee/utils/errors/#module-pyastrobeeutilserrors","text":"Custom exceptions View Source \"\"\"Custom exceptions\"\"\" from typing import Optional class PybulletError ( Exception ): \"\"\"Custom exception type for dealing with Pybullet-related issues Args: message (str): Info to display about the error code (int, optional): A pybullet return value indicating that an error occurred. Defaults to None. \"\"\" def __init__ ( self , message : str , code : Optional [ int ] = None ): # Store as class attribute to access the code and handle programmatically if needed self . code = code if code is not None : message += f \" \\n Pybullet return value: { code } \" super () . __init__ ( message ) class OptimizationError ( Exception ): pass","title":"Module pyastrobee.utils.errors"},{"location":"reference/pyastrobee/utils/errors/#classes","text":"","title":"Classes"},{"location":"reference/pyastrobee/utils/errors/#optimizationerror","text":"class OptimizationError ( / , * args , ** kwargs ) Common base class for all non-exit exceptions. View Source class OptimizationError ( Exception ): pass","title":"OptimizationError"},{"location":"reference/pyastrobee/utils/errors/#ancestors-in-mro","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/pyastrobee/utils/errors/#class-variables","text":"args","title":"Class variables"},{"location":"reference/pyastrobee/utils/errors/#methods","text":"","title":"Methods"},{"location":"reference/pyastrobee/utils/errors/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/pyastrobee/utils/errors/#pybulleterror","text":"class PybulletError ( message : str , code : Optional [ int ] = None ) Custom exception type for dealing with Pybullet-related issues","title":"PybulletError"},{"location":"reference/pyastrobee/utils/errors/#attributes","text":"Name Type Description Default message str Info to display about the error None code int A pybullet return value indicating that an error occurred. Defaults to None. None View Source class PybulletError ( Exception ) : \"\"\"Custom exception type for dealing with Pybullet-related issues Args: message (str): Info to display about the error code (int, optional): A pybullet return value indicating that an error occurred. Defaults to None. \"\"\" def __init__ ( self , message : str , code : Optional [ int ] = None ) : # Store as class attribute to access the code and handle programmatically if needed self . code = code if code is not None : message += f \"\\nPybullet return value: {code}\" super (). __init__ ( message )","title":"Attributes"},{"location":"reference/pyastrobee/utils/errors/#ancestors-in-mro_1","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/pyastrobee/utils/errors/#class-variables_1","text":"args","title":"Class variables"},{"location":"reference/pyastrobee/utils/errors/#methods_1","text":"","title":"Methods"},{"location":"reference/pyastrobee/utils/errors/#with_traceback_1","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/pyastrobee/utils/math_utils/","text":"Module pyastrobee.utils.math_utils Assorted helper functions related to math operations / linear algebra View Source \"\"\"Assorted helper functions related to math operations / linear algebra\"\"\" from typing import Union import numpy as np import numpy.typing as npt def normalize ( vec : npt . ArrayLike ) -> np . ndarray : \"\"\"Normalizes a vector to have magnitude 1 Args: vec (npt.ArrayLike): Input vector Returns: np.ndarray: A unit vector in the same direction as the input \"\"\" norm = np . linalg . norm ( vec ) if abs ( norm ) < 1e-12 : raise ZeroDivisionError ( \"Cannot normalize the vector, it has norm 0\" ) return np . array ( vec ) / norm def is_diagonal ( array : npt . ArrayLike ) -> bool : \"\"\"Checks if an array is diagonal or not Args: array (npt.ArrayLike): The array to check Returns: bool: True if the array is diagonal, False otherwise \"\"\" return np . array_equal ( array , np . diag ( np . diag ( array ))) def skew ( v : npt . ArrayLike ) -> np . ndarray : \"\"\"Skew-symmetric matrix form of a vector in R3 Args: v (npt.ArrayLike): Vector to convert, shape (3,) Returns: np.ndarray: (3, 3) skew-symmetric matrix \"\"\" v = np . ravel ( v ) if len ( v ) != 3 : raise ValueError ( f \"Vector needs to be of length 3. \\n Got: { v } \" ) return np . array ([[ 0 , - v [ 2 ], v [ 1 ]], [ v [ 2 ], 0 , - v [ 0 ]], [ - v [ 1 ], v [ 0 ], 0 ]]) def unskew ( S : npt . ArrayLike ) -> np . ndarray : \"\"\"Gives the vector associated with a skew-symmetric matrix S such that skew(vec) = S Args: S (npt.ArrayLike): Skew-symmetric 3x3 matrix Returns: np.ndarray: \"Unskewed\" vector, shape (3,) \"\"\" S = np . asarray ( S ) if S . shape != ( 3 , 3 ): raise ValueError ( f \"S must be a 3x3 matrix. Got shape: { S . shape } \" ) return np . array ([ S [ 2 , 1 ], S [ 0 , 2 ], S [ 1 , 0 ]]) def is_skew ( S : np . ndarray ) -> bool : \"\"\"Checks that a square matrix is skew-symmetric Args: S (np.ndarray): Matrix to check Returns: bool: True if skew-symmetric, False otherwise \"\"\" return np . allclose ( S , - S . T ) def is_special_orthogonal ( R : np . ndarray ) -> bool : \"\"\"Checks that a square matrix is in the special orthogonal group Args: R (np.ndarray): Matrix to check Returns: bool: True if special orthogonal (such as a rotation matrix), False otherwise \"\"\" m , n = R . shape if m != n : return False return np . allclose ( R @ R . T , np . eye ( n )) and np . isclose ( np . linalg . det ( R ), 1 ) def spherical_vonmises_sampling ( mu : npt . ArrayLike , kappa : Union [ float , npt . ArrayLike ], n_pts : int ) -> np . ndarray : \"\"\"Samples points on a (generalized) sphere based on the von Mises distribution This is slightly more relevant to sampling on a sphere than a Gaussian because the distribution is circular in nature. Technically, the von Mises-Fisher distribution is for a sphere but Numpy doesn't seem to distinguish between these. Args: mu (npt.ArrayLike): Mean. Length defines the dimension of the sphere. Should be normalized kappa (Union[float, npt.ArrayLike]): Concentration parameter. This can be thought of as the \"inverse of variance\". Large kappa results in a distribution that approaches a gaussian; small kappa approaches a uniform distribution. As a quick not-at-all precise measure, kappa = 0: Uniform distribution around the sphere kappa = 5: Angular dispersion of ~90 degrees from the mean kappa = 10: Angular dispersion of ~60 degrees from the mean kappa = 50: Angular dispersion of ~15 degrees from the mean n_pts (int): Number of points to sample Returns: np.ndarray: Sampled points, shape (n_pts, dimension) \"\"\" mu = np . atleast_1d ( mu ) kappa = np . atleast_1d ( kappa ) sampled = np . random . vonmises ( mu , kappa , size = ( n_pts , len ( mu ))) return sampled / np . linalg . norm ( sampled , axis = 1 ) . reshape ( - 1 , 1 ) Functions is_diagonal def is_diagonal ( array : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> bool Checks if an array is diagonal or not Parameters: Name Type Description Default array npt.ArrayLike The array to check None Returns: Type Description bool True if the array is diagonal, False otherwise View Source def is_diagonal ( array : npt . ArrayLike ) -> bool : \"\"\"Checks if an array is diagonal or not Args: array (npt.ArrayLike): The array to check Returns: bool: True if the array is diagonal, False otherwise \"\"\" return np . array_equal ( array , np . diag ( np . diag ( array ))) is_skew def is_skew ( S : numpy . ndarray ) -> bool Checks that a square matrix is skew-symmetric Parameters: Name Type Description Default S np.ndarray Matrix to check None Returns: Type Description bool True if skew-symmetric, False otherwise View Source def is_skew ( S : np . ndarray ) -> bool : \"\"\"Checks that a square matrix is skew-symmetric Args: S (np.ndarray): Matrix to check Returns: bool: True if skew-symmetric, False otherwise \"\"\" return np . allclose ( S , - S . T ) is_special_orthogonal def is_special_orthogonal ( R : numpy . ndarray ) -> bool Checks that a square matrix is in the special orthogonal group Parameters: Name Type Description Default R np.ndarray Matrix to check None Returns: Type Description bool True if special orthogonal (such as a rotation matrix), False otherwise View Source def is_special_orthogonal ( R : np . ndarray ) -> bool : \"\"\"Checks that a square matrix is in the special orthogonal group Args: R (np.ndarray): Matrix to check Returns: bool: True if special orthogonal (such as a rotation matrix), False otherwise \"\"\" m , n = R . shape if m != n : return False return np . allclose ( R @ R . T , np . eye ( n )) and np . isclose ( np . linalg . det ( R ), 1 ) normalize def normalize ( vec : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Normalizes a vector to have magnitude 1 Parameters: Name Type Description Default vec npt.ArrayLike Input vector None Returns: Type Description np.ndarray A unit vector in the same direction as the input View Source def normalize ( vec : npt . ArrayLike ) -> np . ndarray : \"\"\"Normalizes a vector to have magnitude 1 Args: vec (npt.ArrayLike): Input vector Returns: np.ndarray: A unit vector in the same direction as the input \"\"\" norm = np . linalg . norm ( vec ) if abs ( norm ) < 1e-12 : raise ZeroDivisionError ( \"Cannot normalize the vector, it has norm 0\" ) return np . array ( vec ) / norm skew def skew ( v : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Skew-symmetric matrix form of a vector in R3 Parameters: Name Type Description Default v npt.ArrayLike Vector to convert, shape (3,) None Returns: Type Description np.ndarray (3, 3) skew-symmetric matrix View Source def skew ( v : npt . ArrayLike ) -> np . ndarray : \"\"\"Skew-symmetric matrix form of a vector in R3 Args: v (npt.ArrayLike): Vector to convert, shape (3,) Returns: np.ndarray: (3, 3) skew-symmetric matrix \"\"\" v = np . ravel ( v ) if len ( v ) != 3 : raise ValueError ( f \"Vector needs to be of length 3.\\nGot: {v}\" ) return np . array ([[ 0 , - v [ 2 ], v [ 1 ]], [ v [ 2 ], 0 , - v [ 0 ]], [ - v [ 1 ], v [ 0 ], 0 ]]) spherical_vonmises_sampling def spherical_vonmises_sampling ( mu : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], kappa : Union [ float , numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], n_pts : int ) -> numpy . ndarray Samples points on a (generalized) sphere based on the von Mises distribution This is slightly more relevant to sampling on a sphere than a Gaussian because the distribution is circular in nature. Technically, the von Mises-Fisher distribution is for a sphere but Numpy doesn't seem to distinguish between these. Parameters: Name Type Description Default mu npt.ArrayLike Mean. Length defines the dimension of the sphere. Should be normalized None kappa Union[float, npt.ArrayLike] Concentration parameter. This can be thought of as the \"inverse of variance\". Large kappa results in a distribution that approaches a gaussian; small kappa approaches a uniform distribution. As a quick not-at-all precise measure, kappa = 0: Uniform distribution around the sphere kappa = 5: Angular dispersion of ~90 degrees from the mean kappa = 10: Angular dispersion of ~60 degrees from the mean kappa = 50: Angular dispersion of ~15 degrees from the mean None n_pts int Number of points to sample None Returns: Type Description np.ndarray Sampled points, shape (n_pts, dimension) View Source def spherical_vonmises_sampling ( mu : npt . ArrayLike , kappa : Union [ float , npt . ArrayLike ], n_pts : int ) -> np . ndarray : \"\"\"Samples points on a (generalized) sphere based on the von Mises distribution This is slightly more relevant to sampling on a sphere than a Gaussian because the distribution is circular in nature. Technically, the von Mises-Fisher distribution is for a sphere but Numpy doesn't seem to distinguish between these. Args: mu (npt.ArrayLike): Mean. Length defines the dimension of the sphere. Should be normalized kappa (Union[float, npt.ArrayLike]): Concentration parameter. This can be thought of as the \"inverse of variance\". Large kappa results in a distribution that approaches a gaussian; small kappa approaches a uniform distribution. As a quick not-at-all precise measure, kappa = 0: Uniform distribution around the sphere kappa = 5: Angular dispersion of ~90 degrees from the mean kappa = 10: Angular dispersion of ~60 degrees from the mean kappa = 50: Angular dispersion of ~15 degrees from the mean n_pts (int): Number of points to sample Returns: np.ndarray: Sampled points, shape (n_pts, dimension) \"\"\" mu = np . atleast_1d ( mu ) kappa = np . atleast_1d ( kappa ) sampled = np . random . vonmises ( mu , kappa , size = ( n_pts , len ( mu ))) return sampled / np . linalg . norm ( sampled , axis = 1 ) . reshape ( - 1 , 1 ) unskew def unskew ( S : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Gives the vector associated with a skew-symmetric matrix S such that skew(vec) = S Parameters: Name Type Description Default S npt.ArrayLike Skew-symmetric 3x3 matrix None Returns: Type Description np.ndarray \"Unskewed\" vector, shape (3,) View Source def unskew ( S : npt . ArrayLike ) -> np . ndarray : \"\"\"Gives the vector associated with a skew-symmetric matrix S such that skew(vec) = S Args: S (npt.ArrayLike): Skew-symmetric 3x3 matrix Returns: np.ndarray: \" Unskewed \" vector, shape (3,) \"\"\" S = np . asarray ( S ) if S . shape != ( 3 , 3 ) : raise ValueError ( f \"S must be a 3x3 matrix. Got shape: {S.shape}\" ) return np . array ([ S [ 2 , 1 ], S [ 0 , 2 ], S [ 1 , 0 ]])","title":"Math Utils"},{"location":"reference/pyastrobee/utils/math_utils/#module-pyastrobeeutilsmath_utils","text":"Assorted helper functions related to math operations / linear algebra View Source \"\"\"Assorted helper functions related to math operations / linear algebra\"\"\" from typing import Union import numpy as np import numpy.typing as npt def normalize ( vec : npt . ArrayLike ) -> np . ndarray : \"\"\"Normalizes a vector to have magnitude 1 Args: vec (npt.ArrayLike): Input vector Returns: np.ndarray: A unit vector in the same direction as the input \"\"\" norm = np . linalg . norm ( vec ) if abs ( norm ) < 1e-12 : raise ZeroDivisionError ( \"Cannot normalize the vector, it has norm 0\" ) return np . array ( vec ) / norm def is_diagonal ( array : npt . ArrayLike ) -> bool : \"\"\"Checks if an array is diagonal or not Args: array (npt.ArrayLike): The array to check Returns: bool: True if the array is diagonal, False otherwise \"\"\" return np . array_equal ( array , np . diag ( np . diag ( array ))) def skew ( v : npt . ArrayLike ) -> np . ndarray : \"\"\"Skew-symmetric matrix form of a vector in R3 Args: v (npt.ArrayLike): Vector to convert, shape (3,) Returns: np.ndarray: (3, 3) skew-symmetric matrix \"\"\" v = np . ravel ( v ) if len ( v ) != 3 : raise ValueError ( f \"Vector needs to be of length 3. \\n Got: { v } \" ) return np . array ([[ 0 , - v [ 2 ], v [ 1 ]], [ v [ 2 ], 0 , - v [ 0 ]], [ - v [ 1 ], v [ 0 ], 0 ]]) def unskew ( S : npt . ArrayLike ) -> np . ndarray : \"\"\"Gives the vector associated with a skew-symmetric matrix S such that skew(vec) = S Args: S (npt.ArrayLike): Skew-symmetric 3x3 matrix Returns: np.ndarray: \"Unskewed\" vector, shape (3,) \"\"\" S = np . asarray ( S ) if S . shape != ( 3 , 3 ): raise ValueError ( f \"S must be a 3x3 matrix. Got shape: { S . shape } \" ) return np . array ([ S [ 2 , 1 ], S [ 0 , 2 ], S [ 1 , 0 ]]) def is_skew ( S : np . ndarray ) -> bool : \"\"\"Checks that a square matrix is skew-symmetric Args: S (np.ndarray): Matrix to check Returns: bool: True if skew-symmetric, False otherwise \"\"\" return np . allclose ( S , - S . T ) def is_special_orthogonal ( R : np . ndarray ) -> bool : \"\"\"Checks that a square matrix is in the special orthogonal group Args: R (np.ndarray): Matrix to check Returns: bool: True if special orthogonal (such as a rotation matrix), False otherwise \"\"\" m , n = R . shape if m != n : return False return np . allclose ( R @ R . T , np . eye ( n )) and np . isclose ( np . linalg . det ( R ), 1 ) def spherical_vonmises_sampling ( mu : npt . ArrayLike , kappa : Union [ float , npt . ArrayLike ], n_pts : int ) -> np . ndarray : \"\"\"Samples points on a (generalized) sphere based on the von Mises distribution This is slightly more relevant to sampling on a sphere than a Gaussian because the distribution is circular in nature. Technically, the von Mises-Fisher distribution is for a sphere but Numpy doesn't seem to distinguish between these. Args: mu (npt.ArrayLike): Mean. Length defines the dimension of the sphere. Should be normalized kappa (Union[float, npt.ArrayLike]): Concentration parameter. This can be thought of as the \"inverse of variance\". Large kappa results in a distribution that approaches a gaussian; small kappa approaches a uniform distribution. As a quick not-at-all precise measure, kappa = 0: Uniform distribution around the sphere kappa = 5: Angular dispersion of ~90 degrees from the mean kappa = 10: Angular dispersion of ~60 degrees from the mean kappa = 50: Angular dispersion of ~15 degrees from the mean n_pts (int): Number of points to sample Returns: np.ndarray: Sampled points, shape (n_pts, dimension) \"\"\" mu = np . atleast_1d ( mu ) kappa = np . atleast_1d ( kappa ) sampled = np . random . vonmises ( mu , kappa , size = ( n_pts , len ( mu ))) return sampled / np . linalg . norm ( sampled , axis = 1 ) . reshape ( - 1 , 1 )","title":"Module pyastrobee.utils.math_utils"},{"location":"reference/pyastrobee/utils/math_utils/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/utils/math_utils/#is_diagonal","text":"def is_diagonal ( array : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> bool Checks if an array is diagonal or not Parameters: Name Type Description Default array npt.ArrayLike The array to check None Returns: Type Description bool True if the array is diagonal, False otherwise View Source def is_diagonal ( array : npt . ArrayLike ) -> bool : \"\"\"Checks if an array is diagonal or not Args: array (npt.ArrayLike): The array to check Returns: bool: True if the array is diagonal, False otherwise \"\"\" return np . array_equal ( array , np . diag ( np . diag ( array )))","title":"is_diagonal"},{"location":"reference/pyastrobee/utils/math_utils/#is_skew","text":"def is_skew ( S : numpy . ndarray ) -> bool Checks that a square matrix is skew-symmetric Parameters: Name Type Description Default S np.ndarray Matrix to check None Returns: Type Description bool True if skew-symmetric, False otherwise View Source def is_skew ( S : np . ndarray ) -> bool : \"\"\"Checks that a square matrix is skew-symmetric Args: S (np.ndarray): Matrix to check Returns: bool: True if skew-symmetric, False otherwise \"\"\" return np . allclose ( S , - S . T )","title":"is_skew"},{"location":"reference/pyastrobee/utils/math_utils/#is_special_orthogonal","text":"def is_special_orthogonal ( R : numpy . ndarray ) -> bool Checks that a square matrix is in the special orthogonal group Parameters: Name Type Description Default R np.ndarray Matrix to check None Returns: Type Description bool True if special orthogonal (such as a rotation matrix), False otherwise View Source def is_special_orthogonal ( R : np . ndarray ) -> bool : \"\"\"Checks that a square matrix is in the special orthogonal group Args: R (np.ndarray): Matrix to check Returns: bool: True if special orthogonal (such as a rotation matrix), False otherwise \"\"\" m , n = R . shape if m != n : return False return np . allclose ( R @ R . T , np . eye ( n )) and np . isclose ( np . linalg . det ( R ), 1 )","title":"is_special_orthogonal"},{"location":"reference/pyastrobee/utils/math_utils/#normalize","text":"def normalize ( vec : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Normalizes a vector to have magnitude 1 Parameters: Name Type Description Default vec npt.ArrayLike Input vector None Returns: Type Description np.ndarray A unit vector in the same direction as the input View Source def normalize ( vec : npt . ArrayLike ) -> np . ndarray : \"\"\"Normalizes a vector to have magnitude 1 Args: vec (npt.ArrayLike): Input vector Returns: np.ndarray: A unit vector in the same direction as the input \"\"\" norm = np . linalg . norm ( vec ) if abs ( norm ) < 1e-12 : raise ZeroDivisionError ( \"Cannot normalize the vector, it has norm 0\" ) return np . array ( vec ) / norm","title":"normalize"},{"location":"reference/pyastrobee/utils/math_utils/#skew","text":"def skew ( v : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Skew-symmetric matrix form of a vector in R3 Parameters: Name Type Description Default v npt.ArrayLike Vector to convert, shape (3,) None Returns: Type Description np.ndarray (3, 3) skew-symmetric matrix View Source def skew ( v : npt . ArrayLike ) -> np . ndarray : \"\"\"Skew-symmetric matrix form of a vector in R3 Args: v (npt.ArrayLike): Vector to convert, shape (3,) Returns: np.ndarray: (3, 3) skew-symmetric matrix \"\"\" v = np . ravel ( v ) if len ( v ) != 3 : raise ValueError ( f \"Vector needs to be of length 3.\\nGot: {v}\" ) return np . array ([[ 0 , - v [ 2 ], v [ 1 ]], [ v [ 2 ], 0 , - v [ 0 ]], [ - v [ 1 ], v [ 0 ], 0 ]])","title":"skew"},{"location":"reference/pyastrobee/utils/math_utils/#spherical_vonmises_sampling","text":"def spherical_vonmises_sampling ( mu : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], kappa : Union [ float , numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], n_pts : int ) -> numpy . ndarray Samples points on a (generalized) sphere based on the von Mises distribution This is slightly more relevant to sampling on a sphere than a Gaussian because the distribution is circular in nature. Technically, the von Mises-Fisher distribution is for a sphere but Numpy doesn't seem to distinguish between these. Parameters: Name Type Description Default mu npt.ArrayLike Mean. Length defines the dimension of the sphere. Should be normalized None kappa Union[float, npt.ArrayLike] Concentration parameter. This can be thought of as the \"inverse of variance\". Large kappa results in a distribution that approaches a gaussian; small kappa approaches a uniform distribution. As a quick not-at-all precise measure, kappa = 0: Uniform distribution around the sphere kappa = 5: Angular dispersion of ~90 degrees from the mean kappa = 10: Angular dispersion of ~60 degrees from the mean kappa = 50: Angular dispersion of ~15 degrees from the mean None n_pts int Number of points to sample None Returns: Type Description np.ndarray Sampled points, shape (n_pts, dimension) View Source def spherical_vonmises_sampling ( mu : npt . ArrayLike , kappa : Union [ float , npt . ArrayLike ], n_pts : int ) -> np . ndarray : \"\"\"Samples points on a (generalized) sphere based on the von Mises distribution This is slightly more relevant to sampling on a sphere than a Gaussian because the distribution is circular in nature. Technically, the von Mises-Fisher distribution is for a sphere but Numpy doesn't seem to distinguish between these. Args: mu (npt.ArrayLike): Mean. Length defines the dimension of the sphere. Should be normalized kappa (Union[float, npt.ArrayLike]): Concentration parameter. This can be thought of as the \"inverse of variance\". Large kappa results in a distribution that approaches a gaussian; small kappa approaches a uniform distribution. As a quick not-at-all precise measure, kappa = 0: Uniform distribution around the sphere kappa = 5: Angular dispersion of ~90 degrees from the mean kappa = 10: Angular dispersion of ~60 degrees from the mean kappa = 50: Angular dispersion of ~15 degrees from the mean n_pts (int): Number of points to sample Returns: np.ndarray: Sampled points, shape (n_pts, dimension) \"\"\" mu = np . atleast_1d ( mu ) kappa = np . atleast_1d ( kappa ) sampled = np . random . vonmises ( mu , kappa , size = ( n_pts , len ( mu ))) return sampled / np . linalg . norm ( sampled , axis = 1 ) . reshape ( - 1 , 1 )","title":"spherical_vonmises_sampling"},{"location":"reference/pyastrobee/utils/math_utils/#unskew","text":"def unskew ( S : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Gives the vector associated with a skew-symmetric matrix S such that skew(vec) = S Parameters: Name Type Description Default S npt.ArrayLike Skew-symmetric 3x3 matrix None Returns: Type Description np.ndarray \"Unskewed\" vector, shape (3,) View Source def unskew ( S : npt . ArrayLike ) -> np . ndarray : \"\"\"Gives the vector associated with a skew-symmetric matrix S such that skew(vec) = S Args: S (npt.ArrayLike): Skew-symmetric 3x3 matrix Returns: np.ndarray: \" Unskewed \" vector, shape (3,) \"\"\" S = np . asarray ( S ) if S . shape != ( 3 , 3 ) : raise ValueError ( f \"S must be a 3x3 matrix. Got shape: {S.shape}\" ) return np . array ([ S [ 2 , 1 ], S [ 0 , 2 ], S [ 1 , 0 ]])","title":"unskew"},{"location":"reference/pyastrobee/utils/mesh_utils/","text":"Module pyastrobee.utils.mesh_utils Mesh utilities for deformable simulation in PyBullet. Reference: mesh_utils and anchor_utils in contactrika/dedo View Source \"\"\"Mesh utilities for deformable simulation in PyBullet. Reference: mesh_utils and anchor_utils in contactrika/dedo \"\"\" from typing import Optional , Union import numpy as np import numpy.typing as npt import pybullet from pybullet_utils.bullet_client import BulletClient def get_mesh_data ( object_id : int , client : Optional [ BulletClient ] = None ) -> tuple [ int , np . ndarray ]: \"\"\"Determines the number of vertices and their locations of a given mesh object in Pybullet Args: object_id (int): ID of the mesh loaded into Pybullet client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: tuple[int, np.ndarray]: int: Number of vertices in the mesh np.ndarray: Mesh vertex positions, shape (num_verts, 3) \"\"\" client : pybullet = pybullet if client is None else client kwargs = {} if hasattr ( pybullet , \"MESH_DATA_SIMULATION_MESH\" ): kwargs [ \"flags\" ] = pybullet . MESH_DATA_SIMULATION_MESH num_verts , mesh_vert_positions = client . getMeshData ( object_id , ** kwargs ) # Mesh vertices are originally stored in a tuple of tuples, so convert to numpy for ease of use return num_verts , np . array ( mesh_vert_positions ) # TODO: If we need to average over multiple vertices, revert to the version in dedo/anchor_utils. # But, if the new pybullet works best with 1 vertex per anchor, this is a simpler implementation def get_closest_mesh_vertex ( pos : npt . ArrayLike , mesh : Union [ npt . ArrayLike , tuple [ tuple [ float , float , float ], ... ]], ) -> tuple [ np . ndarray , int ]: \"\"\"Finds the vertex in a mesh closest to the given point Args: pos (npt.ArrayLike): The given XYZ position to search for nearby mesh vertices, shape (3,) mesh (npt.ArrayLike): Mesh vertices, stored in a (num_verts, 3) array, or a tuple of tuples. See get_mesh_data() for more details Returns: tuple[np.ndarray, int]: np.ndarray: The world-frame position of the closest vertex, shape (3,) int: The index of the closest vertex in the mesh \"\"\" pos = np . array ( pos ) . reshape ( 1 , - 1 ) mesh = np . array ( mesh ) dists = np . linalg . norm ( mesh - pos , axis = 1 ) closest_vert = np . argmin ( dists ) return mesh [ closest_vert ], closest_vert def get_tet_mesh_data ( object_id : int , client : Optional [ BulletClient ] = None ) -> tuple [ int , np . ndarray ]: \"\"\"Determines the state of all of the tetrahedral elements in a tet mesh Args: object_id (int): ID of the tet mesh loaded into Pybullet client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Raises: AttributeError: If the Pybullet version does not support this functionality Returns: tuple[int, np.ndarray]: int: Number of tetrahedrons in the mesh np.ndarray: The xyz positions of all of the vertices of the tetrahedrons, shape (num_tets, 4, 3) \"\"\" client : pybullet = pybullet if client is None else client try : data = client . getTetraMeshData ( object_id ) except AttributeError as e : raise AttributeError ( \"Cannot get tet mesh data. Check that you are using the most recent \" + \"locally-built version of Pybullet, as this is a recent feature\" ) from e n , verts = data n_tets = n // 4 verts = np . reshape ( verts , ( n_tets , 4 , 3 )) return n_tets , verts Functions get_closest_mesh_vertex def get_closest_mesh_vertex ( pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], mesh : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], tuple [ tuple [ float , float , float ], ... ]] ) -> tuple [ numpy . ndarray , int ] Finds the vertex in a mesh closest to the given point Parameters: Name Type Description Default pos npt.ArrayLike The given XYZ position to search for nearby mesh vertices, shape (3,) None mesh npt.ArrayLike Mesh vertices, stored in a (num_verts, 3) array, or a tuple of tuples. See get_mesh_data() for more details None Returns: Type Description tuple[np.ndarray, int] np.ndarray: The world-frame position of the closest vertex, shape (3,) int: The index of the closest vertex in the mesh View Source def get_closest_mesh_vertex ( pos : npt . ArrayLike , mesh : Union [ npt.ArrayLike, tuple[tuple[float, float, float ] , ... ]] , ) -> tuple [ np.ndarray, int ] : \"\"\"Finds the vertex in a mesh closest to the given point Args: pos (npt.ArrayLike): The given XYZ position to search for nearby mesh vertices, shape (3,) mesh (npt.ArrayLike): Mesh vertices, stored in a (num_verts, 3) array, or a tuple of tuples. See get_mesh_data() for more details Returns: tuple[np.ndarray, int]: np.ndarray: The world-frame position of the closest vertex, shape (3,) int: The index of the closest vertex in the mesh \"\"\" pos = np . array ( pos ). reshape ( 1 , - 1 ) mesh = np . array ( mesh ) dists = np . linalg . norm ( mesh - pos , axis = 1 ) closest_vert = np . argmin ( dists ) return mesh [ closest_vert ] , closest_vert get_mesh_data def get_mesh_data ( object_id : int , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> tuple [ int , numpy . ndarray ] Determines the number of vertices and their locations of a given mesh object in Pybullet Parameters: Name Type Description Default object_id int ID of the mesh loaded into Pybullet None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Returns: Type Description tuple[int, np.ndarray] int: Number of vertices in the mesh np.ndarray: Mesh vertex positions, shape (num_verts, 3) View Source def get_mesh_data ( object_id : int , client : Optional [ BulletClient ] = None ) -> tuple [ int, np.ndarray ] : \"\"\"Determines the number of vertices and their locations of a given mesh object in Pybullet Args: object_id (int): ID of the mesh loaded into Pybullet client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: tuple[int, np.ndarray]: int: Number of vertices in the mesh np.ndarray: Mesh vertex positions, shape (num_verts, 3) \"\"\" client : pybullet = pybullet if client is None else client kwargs = {} if hasattr ( pybullet , \"MESH_DATA_SIMULATION_MESH\" ) : kwargs [ \"flags\" ] = pybullet . MESH_DATA_SIMULATION_MESH num_verts , mesh_vert_positions = client . getMeshData ( object_id , ** kwargs ) # Mesh vertices are originally stored in a tuple of tuples , so convert to numpy for ease of use return num_verts , np . array ( mesh_vert_positions ) get_tet_mesh_data def get_tet_mesh_data ( object_id : int , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> tuple [ int , numpy . ndarray ] Determines the state of all of the tetrahedral elements in a tet mesh Parameters: Name Type Description Default object_id int ID of the tet mesh loaded into Pybullet None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Returns: Type Description tuple[int, np.ndarray] int: Number of tetrahedrons in the mesh np.ndarray: The xyz positions of all of the vertices of the tetrahedrons, shape (num_tets, 4, 3) Raises: Type Description AttributeError If the Pybullet version does not support this functionality View Source def get_tet_mesh_data ( object_id : int , client : Optional [ BulletClient ] = None ) -> tuple [ int, np.ndarray ] : \"\"\"Determines the state of all of the tetrahedral elements in a tet mesh Args: object_id (int): ID of the tet mesh loaded into Pybullet client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Raises: AttributeError: If the Pybullet version does not support this functionality Returns: tuple[int, np.ndarray]: int: Number of tetrahedrons in the mesh np.ndarray: The xyz positions of all of the vertices of the tetrahedrons, shape (num_tets, 4, 3) \"\"\" client : pybullet = pybullet if client is None else client try : data = client . getTetraMeshData ( object_id ) except AttributeError as e : raise AttributeError ( \"Cannot get tet mesh data. Check that you are using the most recent \" + \"locally-built version of Pybullet, as this is a recent feature\" ) from e n , verts = data n_tets = n // 4 verts = np . reshape ( verts , ( n_tets , 4 , 3 )) return n_tets , verts","title":"Mesh Utils"},{"location":"reference/pyastrobee/utils/mesh_utils/#module-pyastrobeeutilsmesh_utils","text":"Mesh utilities for deformable simulation in PyBullet. Reference: mesh_utils and anchor_utils in contactrika/dedo View Source \"\"\"Mesh utilities for deformable simulation in PyBullet. Reference: mesh_utils and anchor_utils in contactrika/dedo \"\"\" from typing import Optional , Union import numpy as np import numpy.typing as npt import pybullet from pybullet_utils.bullet_client import BulletClient def get_mesh_data ( object_id : int , client : Optional [ BulletClient ] = None ) -> tuple [ int , np . ndarray ]: \"\"\"Determines the number of vertices and their locations of a given mesh object in Pybullet Args: object_id (int): ID of the mesh loaded into Pybullet client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: tuple[int, np.ndarray]: int: Number of vertices in the mesh np.ndarray: Mesh vertex positions, shape (num_verts, 3) \"\"\" client : pybullet = pybullet if client is None else client kwargs = {} if hasattr ( pybullet , \"MESH_DATA_SIMULATION_MESH\" ): kwargs [ \"flags\" ] = pybullet . MESH_DATA_SIMULATION_MESH num_verts , mesh_vert_positions = client . getMeshData ( object_id , ** kwargs ) # Mesh vertices are originally stored in a tuple of tuples, so convert to numpy for ease of use return num_verts , np . array ( mesh_vert_positions ) # TODO: If we need to average over multiple vertices, revert to the version in dedo/anchor_utils. # But, if the new pybullet works best with 1 vertex per anchor, this is a simpler implementation def get_closest_mesh_vertex ( pos : npt . ArrayLike , mesh : Union [ npt . ArrayLike , tuple [ tuple [ float , float , float ], ... ]], ) -> tuple [ np . ndarray , int ]: \"\"\"Finds the vertex in a mesh closest to the given point Args: pos (npt.ArrayLike): The given XYZ position to search for nearby mesh vertices, shape (3,) mesh (npt.ArrayLike): Mesh vertices, stored in a (num_verts, 3) array, or a tuple of tuples. See get_mesh_data() for more details Returns: tuple[np.ndarray, int]: np.ndarray: The world-frame position of the closest vertex, shape (3,) int: The index of the closest vertex in the mesh \"\"\" pos = np . array ( pos ) . reshape ( 1 , - 1 ) mesh = np . array ( mesh ) dists = np . linalg . norm ( mesh - pos , axis = 1 ) closest_vert = np . argmin ( dists ) return mesh [ closest_vert ], closest_vert def get_tet_mesh_data ( object_id : int , client : Optional [ BulletClient ] = None ) -> tuple [ int , np . ndarray ]: \"\"\"Determines the state of all of the tetrahedral elements in a tet mesh Args: object_id (int): ID of the tet mesh loaded into Pybullet client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Raises: AttributeError: If the Pybullet version does not support this functionality Returns: tuple[int, np.ndarray]: int: Number of tetrahedrons in the mesh np.ndarray: The xyz positions of all of the vertices of the tetrahedrons, shape (num_tets, 4, 3) \"\"\" client : pybullet = pybullet if client is None else client try : data = client . getTetraMeshData ( object_id ) except AttributeError as e : raise AttributeError ( \"Cannot get tet mesh data. Check that you are using the most recent \" + \"locally-built version of Pybullet, as this is a recent feature\" ) from e n , verts = data n_tets = n // 4 verts = np . reshape ( verts , ( n_tets , 4 , 3 )) return n_tets , verts","title":"Module pyastrobee.utils.mesh_utils"},{"location":"reference/pyastrobee/utils/mesh_utils/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/utils/mesh_utils/#get_closest_mesh_vertex","text":"def get_closest_mesh_vertex ( pos : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], mesh : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]], tuple [ tuple [ float , float , float ], ... ]] ) -> tuple [ numpy . ndarray , int ] Finds the vertex in a mesh closest to the given point Parameters: Name Type Description Default pos npt.ArrayLike The given XYZ position to search for nearby mesh vertices, shape (3,) None mesh npt.ArrayLike Mesh vertices, stored in a (num_verts, 3) array, or a tuple of tuples. See get_mesh_data() for more details None Returns: Type Description tuple[np.ndarray, int] np.ndarray: The world-frame position of the closest vertex, shape (3,) int: The index of the closest vertex in the mesh View Source def get_closest_mesh_vertex ( pos : npt . ArrayLike , mesh : Union [ npt.ArrayLike, tuple[tuple[float, float, float ] , ... ]] , ) -> tuple [ np.ndarray, int ] : \"\"\"Finds the vertex in a mesh closest to the given point Args: pos (npt.ArrayLike): The given XYZ position to search for nearby mesh vertices, shape (3,) mesh (npt.ArrayLike): Mesh vertices, stored in a (num_verts, 3) array, or a tuple of tuples. See get_mesh_data() for more details Returns: tuple[np.ndarray, int]: np.ndarray: The world-frame position of the closest vertex, shape (3,) int: The index of the closest vertex in the mesh \"\"\" pos = np . array ( pos ). reshape ( 1 , - 1 ) mesh = np . array ( mesh ) dists = np . linalg . norm ( mesh - pos , axis = 1 ) closest_vert = np . argmin ( dists ) return mesh [ closest_vert ] , closest_vert","title":"get_closest_mesh_vertex"},{"location":"reference/pyastrobee/utils/mesh_utils/#get_mesh_data","text":"def get_mesh_data ( object_id : int , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> tuple [ int , numpy . ndarray ] Determines the number of vertices and their locations of a given mesh object in Pybullet Parameters: Name Type Description Default object_id int ID of the mesh loaded into Pybullet None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Returns: Type Description tuple[int, np.ndarray] int: Number of vertices in the mesh np.ndarray: Mesh vertex positions, shape (num_verts, 3) View Source def get_mesh_data ( object_id : int , client : Optional [ BulletClient ] = None ) -> tuple [ int, np.ndarray ] : \"\"\"Determines the number of vertices and their locations of a given mesh object in Pybullet Args: object_id (int): ID of the mesh loaded into Pybullet client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Returns: tuple[int, np.ndarray]: int: Number of vertices in the mesh np.ndarray: Mesh vertex positions, shape (num_verts, 3) \"\"\" client : pybullet = pybullet if client is None else client kwargs = {} if hasattr ( pybullet , \"MESH_DATA_SIMULATION_MESH\" ) : kwargs [ \"flags\" ] = pybullet . MESH_DATA_SIMULATION_MESH num_verts , mesh_vert_positions = client . getMeshData ( object_id , ** kwargs ) # Mesh vertices are originally stored in a tuple of tuples , so convert to numpy for ease of use return num_verts , np . array ( mesh_vert_positions )","title":"get_mesh_data"},{"location":"reference/pyastrobee/utils/mesh_utils/#get_tet_mesh_data","text":"def get_tet_mesh_data ( object_id : int , client : Optional [ pybullet_utils . bullet_client . BulletClient ] = None ) -> tuple [ int , numpy . ndarray ] Determines the state of all of the tetrahedral elements in a tet mesh Parameters: Name Type Description Default object_id int ID of the tet mesh loaded into Pybullet None client BulletClient If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) None Returns: Type Description tuple[int, np.ndarray] int: Number of tetrahedrons in the mesh np.ndarray: The xyz positions of all of the vertices of the tetrahedrons, shape (num_tets, 4, 3) Raises: Type Description AttributeError If the Pybullet version does not support this functionality View Source def get_tet_mesh_data ( object_id : int , client : Optional [ BulletClient ] = None ) -> tuple [ int, np.ndarray ] : \"\"\"Determines the state of all of the tetrahedral elements in a tet mesh Args: object_id (int): ID of the tet mesh loaded into Pybullet client (BulletClient, optional): If connecting to multiple physics servers, include the client (the class instance, not just the ID) here. Defaults to None (use default connected client) Raises: AttributeError: If the Pybullet version does not support this functionality Returns: tuple[int, np.ndarray]: int: Number of tetrahedrons in the mesh np.ndarray: The xyz positions of all of the vertices of the tetrahedrons, shape (num_tets, 4, 3) \"\"\" client : pybullet = pybullet if client is None else client try : data = client . getTetraMeshData ( object_id ) except AttributeError as e : raise AttributeError ( \"Cannot get tet mesh data. Check that you are using the most recent \" + \"locally-built version of Pybullet, as this is a recent feature\" ) from e n , verts = data n_tets = n // 4 verts = np . reshape ( verts , ( n_tets , 4 , 3 )) return n_tets , verts","title":"get_tet_mesh_data"},{"location":"reference/pyastrobee/utils/poses/","text":"Module pyastrobee.utils.poses Class/functions for managing poses and conversions between different representations Our default representation of a pose will be position (xyz) + quaternion (xyzw) View Source \"\"\"Class/functions for managing poses and conversions between different representations Our default representation of a pose will be position (xyz) + quaternion (xyzw) \"\"\" import numpy as np import numpy.typing as npt import pytransform3d.trajectories as pt from pyastrobee.utils import rotations as rts from pyastrobee.utils import transformations as tfs from pyastrobee.utils import quaternions as qts def check_pos_euler_xyz ( pose : npt . ArrayLike ) -> bool : \"\"\"Checks to see if a position + Euler XYZ pose is valid Args: pose (npt.ArrayLike): Position + Euler XYZ pose, shape = (6,) Returns: bool: Whether or not the pose is valid \"\"\" return len ( pose ) == 6 def check_pos_quat ( pose : npt . ArrayLike ) -> bool : \"\"\"Checks to see if a position + XYZW quaternion pose is valid Args: pose (npt.ArrayLike): Position + XYZW quaternion pose Returns: bool: Whether or not the pose is valid \"\"\" return len ( pose ) == 7 def pos_euler_xyz_to_tmat ( pose : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts a position + Euler pose to a transformation matrix Args: pose (npt.ArrayLike): Position + Euler XYZ pose, shape = (6,) Returns: np.ndarray: Transformation matrix, shape (4,4) \"\"\" if not check_pos_euler_xyz ( pose ): raise ValueError ( f \"Invalid position + euler pose. \\n Got: { pose } \" ) pos = pose [: 3 ] orn = pose [ 3 :] rmat = rts . euler_xyz_to_rmat ( orn ) return tfs . make_transform_mat ( rmat , pos ) def pos_euler_xyz_to_pos_quat ( pose : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts a position + Euler pose to a position + XYZW quaternion pose Args: pose (npt.ArrayLike): Position + Euler XYZ pose, shape = (6,) Returns: np.ndarray: Position + XYZW quaternion pose, shape = (7,) \"\"\" if not check_pos_euler_xyz ( pose ): raise ValueError ( f \"Invalid position + euler pose. \\n Got: { pose } \" ) pos = pose [: 3 ] orn = pose [ 3 :] quat = rts . euler_xyz_to_quat ( orn ) return np . array ([ * pos , * quat ]) def tmat_to_pos_euler_xyz ( tmat : np . ndarray ) -> np . ndarray : \"\"\"Converts a transformation matrix to a position + Euler pose Args: pose (npt.ArrayLike): Transformation matrix, shape (4,4) Returns: np.ndarray: Position + Euler XYZ pose, shape = (6,) \"\"\" if not tfs . check_transform_mat ( tmat ): raise ValueError ( f \"Invalid transformation matrix. \\n Got: { tmat } \" ) rmat = tmat [: 3 , : 3 ] pos = tmat [: 3 , 3 ] orn = rts . rmat_to_euler_xyz ( rmat ) return np . array ([ * pos , * orn ]) def tmat_to_pos_quat ( tmat : np . ndarray ) -> np . ndarray : \"\"\"Converts a transformation matrix to a position + XYZW quaternion pose Args: pose (npt.ArrayLike): Transformation matrix, shape (4,4) Returns: np.ndarray: Position + XYZW quaternion pose, shape = (7,) \"\"\" if not tfs . check_transform_mat ( tmat ): raise ValueError ( f \"Invalid transformation matrix. \\n Got: { tmat } \" ) rmat = tmat [: 3 , : 3 ] pos = tmat [: 3 , 3 ] quat = rts . rmat_to_quat ( rmat ) return np . array ([ * pos , * quat ]) def pos_quat_to_tmat ( pose : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts a position + XYZW quaternion pose to a transformation matrix Args: pose (npt.ArrayLike): Position + XYZW quaternion pose, shape = (7,) Returns: np.ndarray: Transformation matrix, shape (4,4) \"\"\" if not check_pos_quat ( pose ): raise ValueError ( f \"Invalid position + quaternion pose. \\n Got: { pose } \" ) pos = pose [: 3 ] quat = pose [ 3 :] rmat = rts . quat_to_rmat ( quat ) return tfs . make_transform_mat ( rmat , pos ) def batched_pos_quats_to_tmats ( poses : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts a array of position + quaternion poses to an array of transformation matrices Args: poses (npt.ArrayLike): Position + quaternion poses, shape (n, 7) Returns: np.ndarray: Transformation matrices, shape (n, 4, 4) \"\"\" # Assume poses is of shape (n, 7). If not, see if we can fix it, or raise an error poses = np . atleast_2d ( poses ) n_rows , n_cols = poses . shape if n_cols != 7 and n_rows == 7 : print ( \"Warning: you might have passed in the transpose of the pose array\" ) poses = poses . T elif n_cols != 7 and n_rows != 7 : raise ValueError ( f \"Invalid input shape: { poses . shape } Must be an array of position/quaternion poses\" ) # Convert XYZW poses to WXYZ for pytransform3d's quaternion convention wxyz_pqs = np . zeros_like ( poses ) wxyz_pqs [:, : 3 ] = poses [:, : 3 ] # x, y, z wxyz_pqs [:, 3 ] = poses [:, - 1 ] # qw wxyz_pqs [:, 4 :] = poses [:, 3 : - 1 ] # qx, qy, qz # Use the batched conversion from pytransform3d since this is more efficient than a loop return pt . transforms_from_pqs ( wxyz_pqs ) def pos_quat_to_pos_euler_xyz ( pose : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts a position + XYZW quaternion pose to a position + Euler pose Args: pose (npt.ArrayLike): Position + XYZW quaternion pose, shape = (7,) Returns: np.ndarray: Position + Euler XYZ pose, shape = (6,) \"\"\" if not check_pos_quat ( pose ): raise ValueError ( f \"Invalid position + quaternion pose. \\n Got: { pose } \" ) pos = pose [: 3 ] quat = pose [ 3 :] orn = rts . quat_to_euler_xyz ( quat ) return np . array ([ * pos , * orn ]) def add_global_pose_delta ( pose : npt . ArrayLike , pose_delta : npt . ArrayLike ) -> np . ndarray : \"\"\"Adds a world-frame \"delta\" to a pose Args: pose (npt.ArrayLike): Original reference pose (position + quaternion), shape (7,) pose_delta (npt.ArrayLike): Delta to add to the pose (position + quaternion), shape (7,) Returns: np.ndarray: Position + quaternion pose with the delta applied, shape (7,) \"\"\" if not check_pos_quat ( pose ) or not check_pos_quat ( pose_delta ): raise ValueError ( f \"Invalid inputs: Not position/quaternion form. \\n Got: { pose } \\n And: { pose_delta } \" ) new_pos = pose [: 3 ] + pose_delta [: 3 ] new_orn = qts . combine_quaternions ( pose [ 3 :], pose_delta [ 3 :]) return np . array ([ * new_pos , * new_orn ]) def add_local_pose_delta ( pose : npt . ArrayLike , pose_delta : npt . ArrayLike ) -> np . ndarray : \"\"\"Adds a local (robot)-frame \"delta\" to a pose Args: pose (npt.ArrayLike): Original reference pose (position + quaternion), shape (7,) pose_delta (npt.ArrayLike): Delta to add to the pose (position + quaternion), shape (7,) Returns: np.ndarray: Position + quaternion pose with the delta applied, shape (7,) \"\"\" if not check_pos_quat ( pose ) or not check_pos_quat ( pose_delta ): raise ValueError ( f \"Invalid inputs: Not position/quaternion form. \\n Got: { pose } \\n And: { pose_delta } \" ) T_R2W = pos_quat_to_tmat ( pose ) # Robot to world T_D2R = pos_quat_to_tmat ( pose_delta ) # Delta to robot T_D2W = T_R2W @ T_D2R # Delta to world return tmat_to_pos_quat ( T_D2W ) def pose_derivatives ( poses : np . ndarray , dt : float ) -> tuple [ np . ndarray , np . ndarray , np . ndarray , np . ndarray ]: \"\"\"Calculates the linear/angular first and second derivatives of a sequence of poses Args: poses (np.ndarray): Sequence of position + XYZW quaternion poses, shape (n, 7) dt (float): Timestep between poses, in seconds Returns: tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: np.ndarray: Linear velocities, shape (n, 3) np.ndarray: Angular velocities, shape (n, 3) np.ndarray: Linear accelerations, shape (n, 3) np.ndarray: Angular accelerations, shape (n, 3) \"\"\" if poses . shape [ - 1 ] != 7 : raise ValueError ( f \"Invalid pose array: must be shape (n, 7). Got: { poses . shape } \" ) positions = poses [:, : 3 ] quaternions = poses [:, 3 :] velocities = np . gradient ( positions , dt , axis = 0 ) accels = np . gradient ( velocities , dt , axis = 0 ) omegas = qts . quats_to_angular_velocities ( quaternions , dt ) alphas = np . gradient ( omegas , dt , axis = 0 ) return velocities , omegas , accels , alphas Functions add_global_pose_delta def add_global_pose_delta ( pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pose_delta : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Adds a world-frame \"delta\" to a pose Parameters: Name Type Description Default pose npt.ArrayLike Original reference pose (position + quaternion), shape (7,) None pose_delta npt.ArrayLike Delta to add to the pose (position + quaternion), shape (7,) None Returns: Type Description np.ndarray Position + quaternion pose with the delta applied, shape (7,) View Source def add_global_pose_delta(pose: npt.ArrayLike, pose_delta: npt.ArrayLike) -> np.ndarray: \"\"\"Adds a world-frame \"delta\" to a pose Args: pose (npt.ArrayLike): Original reference pose (position + quaternion), shape (7,) pose_delta (npt.ArrayLike): Delta to add to the pose (position + quaternion), shape (7,) Returns: np.ndarray: Position + quaternion pose with the delta applied, shape (7,) \"\"\" if not check_pos_quat(pose) or not check_pos_quat(pose_delta): raise ValueError( f\"Invalid inputs: Not position/quaternion form.\\nGot: {pose}\\nAnd: {pose_delta}\" ) new_pos = pose[:3] + pose_delta[:3] new_orn = qts.combine_quaternions(pose[3:], pose_delta[3:]) return np.array([*new_pos, *new_orn]) add_local_pose_delta def add_local_pose_delta ( pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pose_delta : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Adds a local (robot)-frame \"delta\" to a pose Parameters: Name Type Description Default pose npt.ArrayLike Original reference pose (position + quaternion), shape (7,) None pose_delta npt.ArrayLike Delta to add to the pose (position + quaternion), shape (7,) None Returns: Type Description np.ndarray Position + quaternion pose with the delta applied, shape (7,) View Source def add_local_pose_delta ( pose : npt . ArrayLike , pose_delta : npt . ArrayLike ) -> np . ndarray : \"\"\"Adds a local (robot)-frame \" delta \" to a pose Args: pose (npt.ArrayLike): Original reference pose (position + quaternion), shape (7,) pose_delta (npt.ArrayLike): Delta to add to the pose (position + quaternion), shape (7,) Returns: np.ndarray: Position + quaternion pose with the delta applied, shape (7,) \"\"\" if not check_pos_quat ( pose ) or not check_pos_quat ( pose_delta ) : raise ValueError ( f \"Invalid inputs: Not position/quaternion form.\\nGot: {pose}\\nAnd: {pose_delta}\" ) T_R2W = pos_quat_to_tmat ( pose ) # Robot to world T_D2R = pos_quat_to_tmat ( pose_delta ) # Delta to robot T_D2W = T_R2W @ T_D2R # Delta to world return tmat_to_pos_quat ( T_D2W ) batched_pos_quats_to_tmats def batched_pos_quats_to_tmats ( poses : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Converts a array of position + quaternion poses to an array of transformation matrices Parameters: Name Type Description Default poses npt.ArrayLike Position + quaternion poses, shape (n, 7) None Returns: Type Description np.ndarray Transformation matrices, shape (n, 4, 4) View Source def batched_pos_quats_to_tmats ( poses : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts a array of position + quaternion poses to an array of transformation matrices Args: poses (npt.ArrayLike): Position + quaternion poses, shape (n, 7) Returns: np.ndarray: Transformation matrices, shape (n, 4, 4) \"\"\" # Assume poses is of shape ( n , 7 ). If not , see if we can fix it , or raise an error poses = np . atleast_2d ( poses ) n_rows , n_cols = poses . shape if n_cols ! = 7 and n_rows == 7 : print ( \"Warning: you might have passed in the transpose of the pose array\" ) poses = poses . T elif n_cols ! = 7 and n_rows ! = 7 : raise ValueError ( f \"Invalid input shape: {poses.shape} Must be an array of position/quaternion poses\" ) # Convert XYZW poses to WXYZ for pytransform3d ' s quaternion convention wxyz_pqs = np . zeros_like ( poses ) wxyz_pqs [ : , : 3 ] = poses [ : , : 3 ] # x , y , z wxyz_pqs [ : , 3 ] = poses [ : , - 1 ] # qw wxyz_pqs [ : , 4 : ] = poses [ : , 3 :- 1 ] # qx , qy , qz # Use the batched conversion from pytransform3d since this is more efficient than a loop return pt . transforms_from_pqs ( wxyz_pqs ) check_pos_euler_xyz def check_pos_euler_xyz ( pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> bool Checks to see if a position + Euler XYZ pose is valid Parameters: Name Type Description Default pose npt.ArrayLike Position + Euler XYZ pose, shape = (6,) None Returns: Type Description bool Whether or not the pose is valid View Source def check_pos_euler_xyz ( pose : npt . ArrayLike ) -> bool : \"\"\"Checks to see if a position + Euler XYZ pose is valid Args: pose (npt.ArrayLike): Position + Euler XYZ pose, shape = (6,) Returns: bool: Whether or not the pose is valid \"\"\" return len ( pose ) == 6 check_pos_quat def check_pos_quat ( pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> bool Checks to see if a position + XYZW quaternion pose is valid Parameters: Name Type Description Default pose npt.ArrayLike Position + XYZW quaternion pose None Returns: Type Description bool Whether or not the pose is valid View Source def check_pos_quat ( pose : npt . ArrayLike ) -> bool : \"\"\"Checks to see if a position + XYZW quaternion pose is valid Args: pose (npt.ArrayLike): Position + XYZW quaternion pose Returns: bool: Whether or not the pose is valid \"\"\" return len ( pose ) == 7 pos_euler_xyz_to_pos_quat def pos_euler_xyz_to_pos_quat ( pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Converts a position + Euler pose to a position + XYZW quaternion pose Parameters: Name Type Description Default pose npt.ArrayLike Position + Euler XYZ pose, shape = (6,) None Returns: Type Description np.ndarray Position + XYZW quaternion pose, shape = (7,) View Source def pos_euler_xyz_to_pos_quat(pose: npt.ArrayLike) -> np.ndarray: \"\"\"Converts a position + Euler pose to a position + XYZW quaternion pose Args: pose (npt.ArrayLike): Position + Euler XYZ pose, shape = (6,) Returns: np.ndarray: Position + XYZW quaternion pose, shape = (7,) \"\"\" if not check_pos_euler_xyz(pose): raise ValueError(f\"Invalid position + euler pose.\\nGot: {pose}\") pos = pose[:3] orn = pose[3:] quat = rts.euler_xyz_to_quat(orn) return np.array([*pos, *quat]) pos_euler_xyz_to_tmat def pos_euler_xyz_to_tmat ( pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Converts a position + Euler pose to a transformation matrix Parameters: Name Type Description Default pose npt.ArrayLike Position + Euler XYZ pose, shape = (6,) None Returns: Type Description np.ndarray Transformation matrix, shape (4,4) View Source def pos_euler_xyz_to_tmat ( pose : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts a position + Euler pose to a transformation matrix Args: pose (npt.ArrayLike): Position + Euler XYZ pose, shape = (6,) Returns: np.ndarray: Transformation matrix, shape (4,4) \"\"\" if not check_pos_euler_xyz ( pose ) : raise ValueError ( f \"Invalid position + euler pose.\\nGot: {pose}\" ) pos = pose [ : 3 ] orn = pose [ 3 : ] rmat = rts . euler_xyz_to_rmat ( orn ) return tfs . make_transform_mat ( rmat , pos ) pos_quat_to_pos_euler_xyz def pos_quat_to_pos_euler_xyz ( pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Converts a position + XYZW quaternion pose to a position + Euler pose Parameters: Name Type Description Default pose npt.ArrayLike Position + XYZW quaternion pose, shape = (7,) None Returns: Type Description np.ndarray Position + Euler XYZ pose, shape = (6,) View Source def pos_quat_to_pos_euler_xyz(pose: npt.ArrayLike) -> np.ndarray: \"\"\"Converts a position + XYZW quaternion pose to a position + Euler pose Args: pose (npt.ArrayLike): Position + XYZW quaternion pose, shape = (7,) Returns: np.ndarray: Position + Euler XYZ pose, shape = (6,) \"\"\" if not check_pos_quat(pose): raise ValueError(f\"Invalid position + quaternion pose.\\nGot: {pose}\") pos = pose[:3] quat = pose[3:] orn = rts.quat_to_euler_xyz(quat) return np.array([*pos, *orn]) pos_quat_to_tmat def pos_quat_to_tmat ( pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Converts a position + XYZW quaternion pose to a transformation matrix Parameters: Name Type Description Default pose npt.ArrayLike Position + XYZW quaternion pose, shape = (7,) None Returns: Type Description np.ndarray Transformation matrix, shape (4,4) View Source def pos_quat_to_tmat ( pose : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts a position + XYZW quaternion pose to a transformation matrix Args: pose (npt.ArrayLike): Position + XYZW quaternion pose, shape = (7,) Returns: np.ndarray: Transformation matrix, shape (4,4) \"\"\" if not check_pos_quat ( pose ) : raise ValueError ( f \"Invalid position + quaternion pose.\\nGot: {pose}\" ) pos = pose [ : 3 ] quat = pose [ 3 : ] rmat = rts . quat_to_rmat ( quat ) return tfs . make_transform_mat ( rmat , pos ) pose_derivatives def pose_derivatives ( poses : numpy . ndarray , dt : float ) -> tuple [ numpy . ndarray , numpy . ndarray , numpy . ndarray , numpy . ndarray ] Calculates the linear/angular first and second derivatives of a sequence of poses Parameters: Name Type Description Default poses np.ndarray Sequence of position + XYZW quaternion poses, shape (n, 7) None dt float Timestep between poses, in seconds None Returns: Type Description tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray] np.ndarray: Linear velocities, shape (n, 3) np.ndarray: Angular velocities, shape (n, 3) np.ndarray: Linear accelerations, shape (n, 3) np.ndarray: Angular accelerations, shape (n, 3) View Source def pose_derivatives ( poses : np . ndarray , dt : float ) -> tuple [ np . ndarray , np . ndarray , np . ndarray , np . ndarray ] : \"\"\"Calculates the linear/angular first and second derivatives of a sequence of poses Args: poses (np.ndarray): Sequence of position + XYZW quaternion poses, shape (n, 7) dt (float): Timestep between poses, in seconds Returns: tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: np.ndarray: Linear velocities, shape (n, 3) np.ndarray: Angular velocities, shape (n, 3) np.ndarray: Linear accelerations, shape (n, 3) np.ndarray: Angular accelerations, shape (n, 3) \"\"\" if poses . shape [ - 1 ] != 7 : raise ValueError ( f \"Invalid pose array: must be shape (n, 7). Got: {poses.shape}\" ) positions = poses [ : , : 3 ] quaternions = poses [ : , 3 : ] velocities = np . gradient ( positions , dt , axis = 0 ) accels = np . gradient ( velocities , dt , axis = 0 ) omegas = qts . quats_to_angular_velocities ( quaternions , dt ) alphas = np . gradient ( omegas , dt , axis = 0 ) return velocities , omegas , accels , alphas tmat_to_pos_euler_xyz def tmat_to_pos_euler_xyz ( tmat : numpy . ndarray ) -> numpy . ndarray Converts a transformation matrix to a position + Euler pose Parameters: Name Type Description Default pose npt.ArrayLike Transformation matrix, shape (4,4) None Returns: Type Description np.ndarray Position + Euler XYZ pose, shape = (6,) View Source def tmat_to_pos_euler_xyz(tmat: np.ndarray) -> np.ndarray: \"\"\"Converts a transformation matrix to a position + Euler pose Args: pose (npt.ArrayLike): Transformation matrix, shape (4,4) Returns: np.ndarray: Position + Euler XYZ pose, shape = (6,) \"\"\" if not tfs.check_transform_mat(tmat): raise ValueError(f\"Invalid transformation matrix.\\nGot: {tmat}\") rmat = tmat[:3, :3] pos = tmat[:3, 3] orn = rts.rmat_to_euler_xyz(rmat) return np.array([*pos, *orn]) tmat_to_pos_quat def tmat_to_pos_quat ( tmat : numpy . ndarray ) -> numpy . ndarray Converts a transformation matrix to a position + XYZW quaternion pose Parameters: Name Type Description Default pose npt.ArrayLike Transformation matrix, shape (4,4) None Returns: Type Description np.ndarray Position + XYZW quaternion pose, shape = (7,) View Source def tmat_to_pos_quat(tmat: np.ndarray) -> np.ndarray: \"\"\"Converts a transformation matrix to a position + XYZW quaternion pose Args: pose (npt.ArrayLike): Transformation matrix, shape (4,4) Returns: np.ndarray: Position + XYZW quaternion pose, shape = (7,) \"\"\" if not tfs.check_transform_mat(tmat): raise ValueError(f\"Invalid transformation matrix.\\nGot: {tmat}\") rmat = tmat[:3, :3] pos = tmat[:3, 3] quat = rts.rmat_to_quat(rmat) return np.array([*pos, *quat])","title":"Poses"},{"location":"reference/pyastrobee/utils/poses/#module-pyastrobeeutilsposes","text":"Class/functions for managing poses and conversions between different representations Our default representation of a pose will be position (xyz) + quaternion (xyzw) View Source \"\"\"Class/functions for managing poses and conversions between different representations Our default representation of a pose will be position (xyz) + quaternion (xyzw) \"\"\" import numpy as np import numpy.typing as npt import pytransform3d.trajectories as pt from pyastrobee.utils import rotations as rts from pyastrobee.utils import transformations as tfs from pyastrobee.utils import quaternions as qts def check_pos_euler_xyz ( pose : npt . ArrayLike ) -> bool : \"\"\"Checks to see if a position + Euler XYZ pose is valid Args: pose (npt.ArrayLike): Position + Euler XYZ pose, shape = (6,) Returns: bool: Whether or not the pose is valid \"\"\" return len ( pose ) == 6 def check_pos_quat ( pose : npt . ArrayLike ) -> bool : \"\"\"Checks to see if a position + XYZW quaternion pose is valid Args: pose (npt.ArrayLike): Position + XYZW quaternion pose Returns: bool: Whether or not the pose is valid \"\"\" return len ( pose ) == 7 def pos_euler_xyz_to_tmat ( pose : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts a position + Euler pose to a transformation matrix Args: pose (npt.ArrayLike): Position + Euler XYZ pose, shape = (6,) Returns: np.ndarray: Transformation matrix, shape (4,4) \"\"\" if not check_pos_euler_xyz ( pose ): raise ValueError ( f \"Invalid position + euler pose. \\n Got: { pose } \" ) pos = pose [: 3 ] orn = pose [ 3 :] rmat = rts . euler_xyz_to_rmat ( orn ) return tfs . make_transform_mat ( rmat , pos ) def pos_euler_xyz_to_pos_quat ( pose : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts a position + Euler pose to a position + XYZW quaternion pose Args: pose (npt.ArrayLike): Position + Euler XYZ pose, shape = (6,) Returns: np.ndarray: Position + XYZW quaternion pose, shape = (7,) \"\"\" if not check_pos_euler_xyz ( pose ): raise ValueError ( f \"Invalid position + euler pose. \\n Got: { pose } \" ) pos = pose [: 3 ] orn = pose [ 3 :] quat = rts . euler_xyz_to_quat ( orn ) return np . array ([ * pos , * quat ]) def tmat_to_pos_euler_xyz ( tmat : np . ndarray ) -> np . ndarray : \"\"\"Converts a transformation matrix to a position + Euler pose Args: pose (npt.ArrayLike): Transformation matrix, shape (4,4) Returns: np.ndarray: Position + Euler XYZ pose, shape = (6,) \"\"\" if not tfs . check_transform_mat ( tmat ): raise ValueError ( f \"Invalid transformation matrix. \\n Got: { tmat } \" ) rmat = tmat [: 3 , : 3 ] pos = tmat [: 3 , 3 ] orn = rts . rmat_to_euler_xyz ( rmat ) return np . array ([ * pos , * orn ]) def tmat_to_pos_quat ( tmat : np . ndarray ) -> np . ndarray : \"\"\"Converts a transformation matrix to a position + XYZW quaternion pose Args: pose (npt.ArrayLike): Transformation matrix, shape (4,4) Returns: np.ndarray: Position + XYZW quaternion pose, shape = (7,) \"\"\" if not tfs . check_transform_mat ( tmat ): raise ValueError ( f \"Invalid transformation matrix. \\n Got: { tmat } \" ) rmat = tmat [: 3 , : 3 ] pos = tmat [: 3 , 3 ] quat = rts . rmat_to_quat ( rmat ) return np . array ([ * pos , * quat ]) def pos_quat_to_tmat ( pose : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts a position + XYZW quaternion pose to a transformation matrix Args: pose (npt.ArrayLike): Position + XYZW quaternion pose, shape = (7,) Returns: np.ndarray: Transformation matrix, shape (4,4) \"\"\" if not check_pos_quat ( pose ): raise ValueError ( f \"Invalid position + quaternion pose. \\n Got: { pose } \" ) pos = pose [: 3 ] quat = pose [ 3 :] rmat = rts . quat_to_rmat ( quat ) return tfs . make_transform_mat ( rmat , pos ) def batched_pos_quats_to_tmats ( poses : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts a array of position + quaternion poses to an array of transformation matrices Args: poses (npt.ArrayLike): Position + quaternion poses, shape (n, 7) Returns: np.ndarray: Transformation matrices, shape (n, 4, 4) \"\"\" # Assume poses is of shape (n, 7). If not, see if we can fix it, or raise an error poses = np . atleast_2d ( poses ) n_rows , n_cols = poses . shape if n_cols != 7 and n_rows == 7 : print ( \"Warning: you might have passed in the transpose of the pose array\" ) poses = poses . T elif n_cols != 7 and n_rows != 7 : raise ValueError ( f \"Invalid input shape: { poses . shape } Must be an array of position/quaternion poses\" ) # Convert XYZW poses to WXYZ for pytransform3d's quaternion convention wxyz_pqs = np . zeros_like ( poses ) wxyz_pqs [:, : 3 ] = poses [:, : 3 ] # x, y, z wxyz_pqs [:, 3 ] = poses [:, - 1 ] # qw wxyz_pqs [:, 4 :] = poses [:, 3 : - 1 ] # qx, qy, qz # Use the batched conversion from pytransform3d since this is more efficient than a loop return pt . transforms_from_pqs ( wxyz_pqs ) def pos_quat_to_pos_euler_xyz ( pose : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts a position + XYZW quaternion pose to a position + Euler pose Args: pose (npt.ArrayLike): Position + XYZW quaternion pose, shape = (7,) Returns: np.ndarray: Position + Euler XYZ pose, shape = (6,) \"\"\" if not check_pos_quat ( pose ): raise ValueError ( f \"Invalid position + quaternion pose. \\n Got: { pose } \" ) pos = pose [: 3 ] quat = pose [ 3 :] orn = rts . quat_to_euler_xyz ( quat ) return np . array ([ * pos , * orn ]) def add_global_pose_delta ( pose : npt . ArrayLike , pose_delta : npt . ArrayLike ) -> np . ndarray : \"\"\"Adds a world-frame \"delta\" to a pose Args: pose (npt.ArrayLike): Original reference pose (position + quaternion), shape (7,) pose_delta (npt.ArrayLike): Delta to add to the pose (position + quaternion), shape (7,) Returns: np.ndarray: Position + quaternion pose with the delta applied, shape (7,) \"\"\" if not check_pos_quat ( pose ) or not check_pos_quat ( pose_delta ): raise ValueError ( f \"Invalid inputs: Not position/quaternion form. \\n Got: { pose } \\n And: { pose_delta } \" ) new_pos = pose [: 3 ] + pose_delta [: 3 ] new_orn = qts . combine_quaternions ( pose [ 3 :], pose_delta [ 3 :]) return np . array ([ * new_pos , * new_orn ]) def add_local_pose_delta ( pose : npt . ArrayLike , pose_delta : npt . ArrayLike ) -> np . ndarray : \"\"\"Adds a local (robot)-frame \"delta\" to a pose Args: pose (npt.ArrayLike): Original reference pose (position + quaternion), shape (7,) pose_delta (npt.ArrayLike): Delta to add to the pose (position + quaternion), shape (7,) Returns: np.ndarray: Position + quaternion pose with the delta applied, shape (7,) \"\"\" if not check_pos_quat ( pose ) or not check_pos_quat ( pose_delta ): raise ValueError ( f \"Invalid inputs: Not position/quaternion form. \\n Got: { pose } \\n And: { pose_delta } \" ) T_R2W = pos_quat_to_tmat ( pose ) # Robot to world T_D2R = pos_quat_to_tmat ( pose_delta ) # Delta to robot T_D2W = T_R2W @ T_D2R # Delta to world return tmat_to_pos_quat ( T_D2W ) def pose_derivatives ( poses : np . ndarray , dt : float ) -> tuple [ np . ndarray , np . ndarray , np . ndarray , np . ndarray ]: \"\"\"Calculates the linear/angular first and second derivatives of a sequence of poses Args: poses (np.ndarray): Sequence of position + XYZW quaternion poses, shape (n, 7) dt (float): Timestep between poses, in seconds Returns: tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: np.ndarray: Linear velocities, shape (n, 3) np.ndarray: Angular velocities, shape (n, 3) np.ndarray: Linear accelerations, shape (n, 3) np.ndarray: Angular accelerations, shape (n, 3) \"\"\" if poses . shape [ - 1 ] != 7 : raise ValueError ( f \"Invalid pose array: must be shape (n, 7). Got: { poses . shape } \" ) positions = poses [:, : 3 ] quaternions = poses [:, 3 :] velocities = np . gradient ( positions , dt , axis = 0 ) accels = np . gradient ( velocities , dt , axis = 0 ) omegas = qts . quats_to_angular_velocities ( quaternions , dt ) alphas = np . gradient ( omegas , dt , axis = 0 ) return velocities , omegas , accels , alphas","title":"Module pyastrobee.utils.poses"},{"location":"reference/pyastrobee/utils/poses/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/utils/poses/#add_global_pose_delta","text":"def add_global_pose_delta ( pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pose_delta : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Adds a world-frame \"delta\" to a pose Parameters: Name Type Description Default pose npt.ArrayLike Original reference pose (position + quaternion), shape (7,) None pose_delta npt.ArrayLike Delta to add to the pose (position + quaternion), shape (7,) None Returns: Type Description np.ndarray Position + quaternion pose with the delta applied, shape (7,) View Source def add_global_pose_delta(pose: npt.ArrayLike, pose_delta: npt.ArrayLike) -> np.ndarray: \"\"\"Adds a world-frame \"delta\" to a pose Args: pose (npt.ArrayLike): Original reference pose (position + quaternion), shape (7,) pose_delta (npt.ArrayLike): Delta to add to the pose (position + quaternion), shape (7,) Returns: np.ndarray: Position + quaternion pose with the delta applied, shape (7,) \"\"\" if not check_pos_quat(pose) or not check_pos_quat(pose_delta): raise ValueError( f\"Invalid inputs: Not position/quaternion form.\\nGot: {pose}\\nAnd: {pose_delta}\" ) new_pos = pose[:3] + pose_delta[:3] new_orn = qts.combine_quaternions(pose[3:], pose_delta[3:]) return np.array([*new_pos, *new_orn])","title":"add_global_pose_delta"},{"location":"reference/pyastrobee/utils/poses/#add_local_pose_delta","text":"def add_local_pose_delta ( pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pose_delta : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Adds a local (robot)-frame \"delta\" to a pose Parameters: Name Type Description Default pose npt.ArrayLike Original reference pose (position + quaternion), shape (7,) None pose_delta npt.ArrayLike Delta to add to the pose (position + quaternion), shape (7,) None Returns: Type Description np.ndarray Position + quaternion pose with the delta applied, shape (7,) View Source def add_local_pose_delta ( pose : npt . ArrayLike , pose_delta : npt . ArrayLike ) -> np . ndarray : \"\"\"Adds a local (robot)-frame \" delta \" to a pose Args: pose (npt.ArrayLike): Original reference pose (position + quaternion), shape (7,) pose_delta (npt.ArrayLike): Delta to add to the pose (position + quaternion), shape (7,) Returns: np.ndarray: Position + quaternion pose with the delta applied, shape (7,) \"\"\" if not check_pos_quat ( pose ) or not check_pos_quat ( pose_delta ) : raise ValueError ( f \"Invalid inputs: Not position/quaternion form.\\nGot: {pose}\\nAnd: {pose_delta}\" ) T_R2W = pos_quat_to_tmat ( pose ) # Robot to world T_D2R = pos_quat_to_tmat ( pose_delta ) # Delta to robot T_D2W = T_R2W @ T_D2R # Delta to world return tmat_to_pos_quat ( T_D2W )","title":"add_local_pose_delta"},{"location":"reference/pyastrobee/utils/poses/#batched_pos_quats_to_tmats","text":"def batched_pos_quats_to_tmats ( poses : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Converts a array of position + quaternion poses to an array of transformation matrices Parameters: Name Type Description Default poses npt.ArrayLike Position + quaternion poses, shape (n, 7) None Returns: Type Description np.ndarray Transformation matrices, shape (n, 4, 4) View Source def batched_pos_quats_to_tmats ( poses : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts a array of position + quaternion poses to an array of transformation matrices Args: poses (npt.ArrayLike): Position + quaternion poses, shape (n, 7) Returns: np.ndarray: Transformation matrices, shape (n, 4, 4) \"\"\" # Assume poses is of shape ( n , 7 ). If not , see if we can fix it , or raise an error poses = np . atleast_2d ( poses ) n_rows , n_cols = poses . shape if n_cols ! = 7 and n_rows == 7 : print ( \"Warning: you might have passed in the transpose of the pose array\" ) poses = poses . T elif n_cols ! = 7 and n_rows ! = 7 : raise ValueError ( f \"Invalid input shape: {poses.shape} Must be an array of position/quaternion poses\" ) # Convert XYZW poses to WXYZ for pytransform3d ' s quaternion convention wxyz_pqs = np . zeros_like ( poses ) wxyz_pqs [ : , : 3 ] = poses [ : , : 3 ] # x , y , z wxyz_pqs [ : , 3 ] = poses [ : , - 1 ] # qw wxyz_pqs [ : , 4 : ] = poses [ : , 3 :- 1 ] # qx , qy , qz # Use the batched conversion from pytransform3d since this is more efficient than a loop return pt . transforms_from_pqs ( wxyz_pqs )","title":"batched_pos_quats_to_tmats"},{"location":"reference/pyastrobee/utils/poses/#check_pos_euler_xyz","text":"def check_pos_euler_xyz ( pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> bool Checks to see if a position + Euler XYZ pose is valid Parameters: Name Type Description Default pose npt.ArrayLike Position + Euler XYZ pose, shape = (6,) None Returns: Type Description bool Whether or not the pose is valid View Source def check_pos_euler_xyz ( pose : npt . ArrayLike ) -> bool : \"\"\"Checks to see if a position + Euler XYZ pose is valid Args: pose (npt.ArrayLike): Position + Euler XYZ pose, shape = (6,) Returns: bool: Whether or not the pose is valid \"\"\" return len ( pose ) == 6","title":"check_pos_euler_xyz"},{"location":"reference/pyastrobee/utils/poses/#check_pos_quat","text":"def check_pos_quat ( pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> bool Checks to see if a position + XYZW quaternion pose is valid Parameters: Name Type Description Default pose npt.ArrayLike Position + XYZW quaternion pose None Returns: Type Description bool Whether or not the pose is valid View Source def check_pos_quat ( pose : npt . ArrayLike ) -> bool : \"\"\"Checks to see if a position + XYZW quaternion pose is valid Args: pose (npt.ArrayLike): Position + XYZW quaternion pose Returns: bool: Whether or not the pose is valid \"\"\" return len ( pose ) == 7","title":"check_pos_quat"},{"location":"reference/pyastrobee/utils/poses/#pos_euler_xyz_to_pos_quat","text":"def pos_euler_xyz_to_pos_quat ( pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Converts a position + Euler pose to a position + XYZW quaternion pose Parameters: Name Type Description Default pose npt.ArrayLike Position + Euler XYZ pose, shape = (6,) None Returns: Type Description np.ndarray Position + XYZW quaternion pose, shape = (7,) View Source def pos_euler_xyz_to_pos_quat(pose: npt.ArrayLike) -> np.ndarray: \"\"\"Converts a position + Euler pose to a position + XYZW quaternion pose Args: pose (npt.ArrayLike): Position + Euler XYZ pose, shape = (6,) Returns: np.ndarray: Position + XYZW quaternion pose, shape = (7,) \"\"\" if not check_pos_euler_xyz(pose): raise ValueError(f\"Invalid position + euler pose.\\nGot: {pose}\") pos = pose[:3] orn = pose[3:] quat = rts.euler_xyz_to_quat(orn) return np.array([*pos, *quat])","title":"pos_euler_xyz_to_pos_quat"},{"location":"reference/pyastrobee/utils/poses/#pos_euler_xyz_to_tmat","text":"def pos_euler_xyz_to_tmat ( pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Converts a position + Euler pose to a transformation matrix Parameters: Name Type Description Default pose npt.ArrayLike Position + Euler XYZ pose, shape = (6,) None Returns: Type Description np.ndarray Transformation matrix, shape (4,4) View Source def pos_euler_xyz_to_tmat ( pose : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts a position + Euler pose to a transformation matrix Args: pose (npt.ArrayLike): Position + Euler XYZ pose, shape = (6,) Returns: np.ndarray: Transformation matrix, shape (4,4) \"\"\" if not check_pos_euler_xyz ( pose ) : raise ValueError ( f \"Invalid position + euler pose.\\nGot: {pose}\" ) pos = pose [ : 3 ] orn = pose [ 3 : ] rmat = rts . euler_xyz_to_rmat ( orn ) return tfs . make_transform_mat ( rmat , pos )","title":"pos_euler_xyz_to_tmat"},{"location":"reference/pyastrobee/utils/poses/#pos_quat_to_pos_euler_xyz","text":"def pos_quat_to_pos_euler_xyz ( pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Converts a position + XYZW quaternion pose to a position + Euler pose Parameters: Name Type Description Default pose npt.ArrayLike Position + XYZW quaternion pose, shape = (7,) None Returns: Type Description np.ndarray Position + Euler XYZ pose, shape = (6,) View Source def pos_quat_to_pos_euler_xyz(pose: npt.ArrayLike) -> np.ndarray: \"\"\"Converts a position + XYZW quaternion pose to a position + Euler pose Args: pose (npt.ArrayLike): Position + XYZW quaternion pose, shape = (7,) Returns: np.ndarray: Position + Euler XYZ pose, shape = (6,) \"\"\" if not check_pos_quat(pose): raise ValueError(f\"Invalid position + quaternion pose.\\nGot: {pose}\") pos = pose[:3] quat = pose[3:] orn = rts.quat_to_euler_xyz(quat) return np.array([*pos, *orn])","title":"pos_quat_to_pos_euler_xyz"},{"location":"reference/pyastrobee/utils/poses/#pos_quat_to_tmat","text":"def pos_quat_to_tmat ( pose : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Converts a position + XYZW quaternion pose to a transformation matrix Parameters: Name Type Description Default pose npt.ArrayLike Position + XYZW quaternion pose, shape = (7,) None Returns: Type Description np.ndarray Transformation matrix, shape (4,4) View Source def pos_quat_to_tmat ( pose : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts a position + XYZW quaternion pose to a transformation matrix Args: pose (npt.ArrayLike): Position + XYZW quaternion pose, shape = (7,) Returns: np.ndarray: Transformation matrix, shape (4,4) \"\"\" if not check_pos_quat ( pose ) : raise ValueError ( f \"Invalid position + quaternion pose.\\nGot: {pose}\" ) pos = pose [ : 3 ] quat = pose [ 3 : ] rmat = rts . quat_to_rmat ( quat ) return tfs . make_transform_mat ( rmat , pos )","title":"pos_quat_to_tmat"},{"location":"reference/pyastrobee/utils/poses/#pose_derivatives","text":"def pose_derivatives ( poses : numpy . ndarray , dt : float ) -> tuple [ numpy . ndarray , numpy . ndarray , numpy . ndarray , numpy . ndarray ] Calculates the linear/angular first and second derivatives of a sequence of poses Parameters: Name Type Description Default poses np.ndarray Sequence of position + XYZW quaternion poses, shape (n, 7) None dt float Timestep between poses, in seconds None Returns: Type Description tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray] np.ndarray: Linear velocities, shape (n, 3) np.ndarray: Angular velocities, shape (n, 3) np.ndarray: Linear accelerations, shape (n, 3) np.ndarray: Angular accelerations, shape (n, 3) View Source def pose_derivatives ( poses : np . ndarray , dt : float ) -> tuple [ np . ndarray , np . ndarray , np . ndarray , np . ndarray ] : \"\"\"Calculates the linear/angular first and second derivatives of a sequence of poses Args: poses (np.ndarray): Sequence of position + XYZW quaternion poses, shape (n, 7) dt (float): Timestep between poses, in seconds Returns: tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: np.ndarray: Linear velocities, shape (n, 3) np.ndarray: Angular velocities, shape (n, 3) np.ndarray: Linear accelerations, shape (n, 3) np.ndarray: Angular accelerations, shape (n, 3) \"\"\" if poses . shape [ - 1 ] != 7 : raise ValueError ( f \"Invalid pose array: must be shape (n, 7). Got: {poses.shape}\" ) positions = poses [ : , : 3 ] quaternions = poses [ : , 3 : ] velocities = np . gradient ( positions , dt , axis = 0 ) accels = np . gradient ( velocities , dt , axis = 0 ) omegas = qts . quats_to_angular_velocities ( quaternions , dt ) alphas = np . gradient ( omegas , dt , axis = 0 ) return velocities , omegas , accels , alphas","title":"pose_derivatives"},{"location":"reference/pyastrobee/utils/poses/#tmat_to_pos_euler_xyz","text":"def tmat_to_pos_euler_xyz ( tmat : numpy . ndarray ) -> numpy . ndarray Converts a transformation matrix to a position + Euler pose Parameters: Name Type Description Default pose npt.ArrayLike Transformation matrix, shape (4,4) None Returns: Type Description np.ndarray Position + Euler XYZ pose, shape = (6,) View Source def tmat_to_pos_euler_xyz(tmat: np.ndarray) -> np.ndarray: \"\"\"Converts a transformation matrix to a position + Euler pose Args: pose (npt.ArrayLike): Transformation matrix, shape (4,4) Returns: np.ndarray: Position + Euler XYZ pose, shape = (6,) \"\"\" if not tfs.check_transform_mat(tmat): raise ValueError(f\"Invalid transformation matrix.\\nGot: {tmat}\") rmat = tmat[:3, :3] pos = tmat[:3, 3] orn = rts.rmat_to_euler_xyz(rmat) return np.array([*pos, *orn])","title":"tmat_to_pos_euler_xyz"},{"location":"reference/pyastrobee/utils/poses/#tmat_to_pos_quat","text":"def tmat_to_pos_quat ( tmat : numpy . ndarray ) -> numpy . ndarray Converts a transformation matrix to a position + XYZW quaternion pose Parameters: Name Type Description Default pose npt.ArrayLike Transformation matrix, shape (4,4) None Returns: Type Description np.ndarray Position + XYZW quaternion pose, shape = (7,) View Source def tmat_to_pos_quat(tmat: np.ndarray) -> np.ndarray: \"\"\"Converts a transformation matrix to a position + XYZW quaternion pose Args: pose (npt.ArrayLike): Transformation matrix, shape (4,4) Returns: np.ndarray: Position + XYZW quaternion pose, shape = (7,) \"\"\" if not tfs.check_transform_mat(tmat): raise ValueError(f\"Invalid transformation matrix.\\nGot: {tmat}\") rmat = tmat[:3, :3] pos = tmat[:3, 3] quat = rts.rmat_to_quat(rmat) return np.array([*pos, *quat])","title":"tmat_to_pos_quat"},{"location":"reference/pyastrobee/utils/python_utils/","text":"Module pyastrobee.utils.python_utils Utility functions broadly related to python as a whole View Source \"\"\"Utility functions broadly related to python as a whole\"\"\" from typing import Any def print_red ( message : Any ): \"\"\"Helper function for printing in red text Args: message (Any): The message to print out in red \"\"\" print ( f \" \\033 [31m { message } \\033 [0m\" ) def print_green ( message : Any ): \"\"\"Helper function for printing in green text Args: message (Any): The message to print out in green \"\"\" print ( f \" \\033 [32m { message } \\033 [0m\" ) def flatten ( l : list [ list ]) -> list : \"\"\"Flatten a list of lists into a single list Args: l (list[list]): List of lists to flaten Returns: list: Flattened list \"\"\" return [ item for sublist in l for item in sublist ] Functions flatten def flatten ( l : list [ list ] ) -> list Flatten a list of lists into a single list Parameters: Name Type Description Default l list[list] List of lists to flaten None Returns: Type Description list Flattened list View Source def flatten ( l : list [ list ] ) -> list : \"\"\"Flatten a list of lists into a single list Args: l (list[list]): List of lists to flaten Returns: list: Flattened list \"\"\" return [ item for sublist in l for item in sublist ] print_green def print_green ( message : Any ) Helper function for printing in green text Parameters: Name Type Description Default message Any The message to print out in green None View Source def print_green(message: Any): \"\"\"Helper function for printing in green text Args: message (Any): The message to print out in green \"\"\" print(f\"\\033[32m{message}\\033[0m\") print_red def print_red ( message : Any ) Helper function for printing in red text Parameters: Name Type Description Default message Any The message to print out in red None View Source def print_red(message: Any): \"\"\"Helper function for printing in red text Args: message (Any): The message to print out in red \"\"\" print(f\"\\033[31m{message}\\033[0m\")","title":"Python Utils"},{"location":"reference/pyastrobee/utils/python_utils/#module-pyastrobeeutilspython_utils","text":"Utility functions broadly related to python as a whole View Source \"\"\"Utility functions broadly related to python as a whole\"\"\" from typing import Any def print_red ( message : Any ): \"\"\"Helper function for printing in red text Args: message (Any): The message to print out in red \"\"\" print ( f \" \\033 [31m { message } \\033 [0m\" ) def print_green ( message : Any ): \"\"\"Helper function for printing in green text Args: message (Any): The message to print out in green \"\"\" print ( f \" \\033 [32m { message } \\033 [0m\" ) def flatten ( l : list [ list ]) -> list : \"\"\"Flatten a list of lists into a single list Args: l (list[list]): List of lists to flaten Returns: list: Flattened list \"\"\" return [ item for sublist in l for item in sublist ]","title":"Module pyastrobee.utils.python_utils"},{"location":"reference/pyastrobee/utils/python_utils/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/utils/python_utils/#flatten","text":"def flatten ( l : list [ list ] ) -> list Flatten a list of lists into a single list Parameters: Name Type Description Default l list[list] List of lists to flaten None Returns: Type Description list Flattened list View Source def flatten ( l : list [ list ] ) -> list : \"\"\"Flatten a list of lists into a single list Args: l (list[list]): List of lists to flaten Returns: list: Flattened list \"\"\" return [ item for sublist in l for item in sublist ]","title":"flatten"},{"location":"reference/pyastrobee/utils/python_utils/#print_green","text":"def print_green ( message : Any ) Helper function for printing in green text Parameters: Name Type Description Default message Any The message to print out in green None View Source def print_green(message: Any): \"\"\"Helper function for printing in green text Args: message (Any): The message to print out in green \"\"\" print(f\"\\033[32m{message}\\033[0m\")","title":"print_green"},{"location":"reference/pyastrobee/utils/python_utils/#print_red","text":"def print_red ( message : Any ) Helper function for printing in red text Parameters: Name Type Description Default message Any The message to print out in red None View Source def print_red(message: Any): \"\"\"Helper function for printing in red text Args: message (Any): The message to print out in red \"\"\" print(f\"\\033[31m{message}\\033[0m\")","title":"print_red"},{"location":"reference/pyastrobee/utils/quaternion_derivatives/","text":"Module pyastrobee.utils.quaternion_derivatives Relationships between quaternions and angular velocity Our quaternion / angular velocity conventions (currently) are: - XYZW quaternions - World-frame angular velocities The matrices used by other sources differ because they might be using WXYZ quaternions or they might define angular velocity in the body-fixed frame. For instance, Shuster uses XYZW quaternions but defines angular velocity in body frame, and Khatib uses WXYZ quaternions with angular velocities in world frame In case we decide to use body-frame angular velocities in the future, the relevant equations are included below (with the global frame equations as well for reference) View Source \"\"\"Relationships between quaternions and angular velocity Our quaternion / angular velocity conventions (currently) are: - XYZW quaternions - World-frame angular velocities The matrices used by other sources differ because they might be using WXYZ quaternions or they might define angular velocity in the body-fixed frame. For instance, Shuster uses XYZW quaternions but defines angular velocity in body frame, and Khatib uses WXYZ quaternions with angular velocities in world frame In case we decide to use body-frame angular velocities in the future, the relevant equations are included below (with the global frame equations as well for reference) \"\"\" from typing import Union import numpy as np import numpy.typing as npt def world_frame_quat_deriv ( q : npt . ArrayLike , omega_world : npt . ArrayLike ) -> np . ndarray : \"\"\"Quaternion derivative for a rotating body with a known WORLD-FRAME angular velocity Args: q (npt.ArrayLike): Current XYZW quaternion, shape (4,) omega_world (npt.ArrayLike): World-frame angular velocity (wx, wy, wz), shape (3,) Returns: np.ndarray: Quaternion derivative, shape (4,) \"\"\" x , y , z , w = q GT = np . array ([[ w , z , - y ], [ - z , w , x ], [ y , - x , w ], [ - x , - y , - z ]]) return ( 1 / 2 ) * GT @ omega_world def body_frame_quat_deriv ( q : npt . ArrayLike , omega_body : npt . ArrayLike ) -> np . ndarray : \"\"\"Quaternion derivative for a rotating body with a known BODY-FRAME angular velocity Args: q (npt.ArrayLike): Current XYZW quaternion, shape (4,) omega_body (npt.ArrayLike): Body-frame angular velocity (w1, w2, w3), shape (3,) Returns: np.ndarray: Quaternion derivative, shape (4,) \"\"\" x , y , z , w = q LT = np . array ([[ w , - z , y ], [ z , w , - x ], [ - y , x , w ], [ - x , - y , - z ]]) return ( 1 / 2 ) * LT @ omega_body def world_frame_angular_error ( q : npt . ArrayLike , q_des : npt . ArrayLike ) -> np . ndarray : \"\"\"Angular error vector between two orientations, defined in WORLD frame Args: q (npt.ArrayLike): Current XYZW quaternion, shape (4,) q_des (npt.ArrayLike): Desired XYZW quaternion, shape (4,) Returns: np.ndarray: Angular error, shape (3,) \"\"\" x , y , z , w = q return 2 * np . array ([[ - w , z , - y , x ], [ - z , - w , x , y ], [ y , - x , - w , z ]]) @ q_des def body_frame_angular_error ( q : npt . ArrayLike , q_des : npt . ArrayLike ) -> np . ndarray : \"\"\"Angular error vector between two orientations, defined in BODY frame Args: q (npt.ArrayLike): Current XYZW quaternion, shape (4,) q_des (npt.ArrayLike): Desired XYZW quaternion, shape (4,) Returns: np.ndarray: Angular error, shape (3,) \"\"\" xd , yd , zd , wd = q_des return ( 2 * np . array ([[ wd , zd , - yd , - xd ], [ - zd , wd , xd , - yd ], [ yd , - xd , wd , - zd ]]) @ q ) # Note about the angular velocities: The pytransform3d method seems more numerically stable, so I'm using that # In some edge cases, this method below will result in a large erronrous \"spike\" in the angular velocity # In reality this \"spike\" is somehow all of the angular velocities flipping briefly to all negative values # Perhaps there is an ambiguity in the angular velocity vector and its negative at certain points (an artifact of # quaternion double-cover?) Anyways, the pytransform3d method does not have these spikes def body_frame_angular_velocities ( quats : np . ndarray , dt : Union [ float , npt . ArrayLike ] ) -> np . ndarray : \"\"\"Determines the BODY-frame angular velocities of a sequence of quaternions, for a given sampling time Args: quats (np.ndarray): Sequence of XYZW quaternions, shape (n, 4) dt (Union[float, np.ndarray]): Sampling time(s). If passing in an array of sampling times, this must be of length n Returns: np.ndarray: Body-frame angular velocities (w1, w2, w3), shape (n, 3) \"\"\" xs = quats [:, 0 ] ys = quats [:, 1 ] zs = quats [:, 2 ] ws = quats [:, 3 ] n = quats . shape [ 0 ] # Number of quaternions # If passing in an array if dts, check its shape first if np . ndim ( dt ) != 0 and len ( dt ) != n : raise ValueError ( f \"Invalid dt array length: { len ( dt ) } . Must be of length { n } \" ) # This uses a new central differencing method to improve handling at start/end points dw = np . zeros (( n , 3 )) # Handle the start dw [ 0 , :] = np . array ( [ ws [ 0 ] * xs [ 1 ] - xs [ 0 ] * ws [ 1 ] - ys [ 0 ] * zs [ 1 ] + zs [ 0 ] * ys [ 1 ], ws [ 0 ] * ys [ 1 ] + xs [ 0 ] * zs [ 1 ] - ys [ 0 ] * ws [ 1 ] - zs [ 0 ] * xs [ 1 ], ws [ 0 ] * zs [ 1 ] - xs [ 0 ] * ys [ 1 ] + ys [ 0 ] * xs [ 1 ] - zs [ 0 ] * ws [ 1 ], ] ) # Handle the end dw [ - 1 , :] = np . array ( [ ws [ - 2 ] * xs [ - 1 ] - xs [ - 2 ] * ws [ - 1 ] - ys [ - 2 ] * zs [ - 1 ] + zs [ - 2 ] * ys [ - 1 ], ws [ - 2 ] * ys [ - 1 ] + xs [ - 2 ] * zs [ - 1 ] - ys [ - 2 ] * ws [ - 1 ] - zs [ - 2 ] * xs [ - 1 ], ws [ - 2 ] * zs [ - 1 ] - xs [ - 2 ] * ys [ - 1 ] + ys [ - 2 ] * xs [ - 1 ] - zs [ - 2 ] * ws [ - 1 ], ] ) # Handle the middle range of quaternions # Multiply by a factor of 1/2 since the central difference covers 2 timesteps dw [ 1 : - 1 , :] = ( 1 / 2 ) * np . column_stack ( [ ws [: - 2 ] * xs [ 2 :] - xs [: - 2 ] * ws [ 2 :] - ys [: - 2 ] * zs [ 2 :] + zs [: - 2 ] * ys [ 2 :], ws [: - 2 ] * ys [ 2 :] + xs [: - 2 ] * zs [ 2 :] - ys [: - 2 ] * ws [ 2 :] - zs [: - 2 ] * xs [ 2 :], ws [: - 2 ] * zs [ 2 :] - xs [: - 2 ] * ys [ 2 :] + ys [: - 2 ] * xs [ 2 :] - zs [: - 2 ] * ws [ 2 :], ] ) # If dt is scalar, broadcasting is simple. If dt is an array of time deltas, adjust shape for broadcasting if np . ndim ( dt ) == 0 : return 2.0 * dw / dt else : return 2.0 / ( np . reshape ( dt , ( - 1 , 1 )) * dw ) def world_frame_angular_velocities ( quats : np . ndarray , dt : Union [ float , npt . ArrayLike ] ) -> np . ndarray : \"\"\"Determines the WORLD-frame angular velocities of a sequence of quaternions, for a given sampling time Args: quats (np.ndarray): Sequence of XYZW quaternions, shape (n, 4) dt (Union[float, np.ndarray]): Sampling time(s). If passing in an array of sampling times, this must be of length n Returns: np.ndarray: World-frame angular velocities (w1, w2, w3), shape (n, 3) \"\"\" xs = quats [:, 0 ] ys = quats [:, 1 ] zs = quats [:, 2 ] ws = quats [:, 3 ] n = quats . shape [ 0 ] # Number of quaternions # If passing in an array if dts, check its shape first if np . ndim ( dt ) != 0 and len ( dt ) != n : raise ValueError ( f \"Invalid dt array length: { len ( dt ) } . Must be of length { n } \" ) # This uses a new central differencing method to improve handling at start/end points dw = np . zeros (( n , 3 )) # Handle the start dw [ 0 , :] = np . array ( [ - ws [ 1 ] * xs [ 0 ] + xs [ 1 ] * ws [ 0 ] - ys [ 1 ] * zs [ 0 ] + zs [ 1 ] * ys [ 0 ], - ws [ 1 ] * ys [ 0 ] + xs [ 1 ] * zs [ 0 ] + ys [ 1 ] * ws [ 0 ] - zs [ 1 ] * xs [ 0 ], - ws [ 1 ] * zs [ 0 ] - xs [ 1 ] * ys [ 0 ] + ys [ 1 ] * xs [ 0 ] + zs [ 1 ] * ws [ 0 ], ] ) # Handle the end dw [ - 1 , :] = np . array ( [ - ws [ - 1 ] * xs [ - 2 ] + xs [ - 1 ] * ws [ - 2 ] - ys [ - 1 ] * zs [ - 2 ] + zs [ - 1 ] * ys [ - 2 ], - ws [ - 1 ] * ys [ - 2 ] + xs [ - 1 ] * zs [ - 2 ] + ys [ - 1 ] * ws [ - 2 ] - zs [ - 1 ] * xs [ - 2 ], - ws [ - 1 ] * zs [ - 2 ] - xs [ - 1 ] * ys [ - 2 ] + ys [ - 1 ] * xs [ - 2 ] + zs [ - 1 ] * ws [ - 2 ], ] ) # Handle the middle range of quaternions # Multiply by a factor of 1/2 since the central difference covers 2 timesteps dw [ 1 : - 1 , :] = ( 1 / 2 ) * np . column_stack ( [ - ws [ 2 :] * xs [: - 2 ] + xs [ 2 :] * ws [: - 2 ] - ys [ 2 :] * zs [: - 2 ] + zs [ 2 :] * ys [: - 2 ], - ws [ 2 :] * ys [: - 2 ] + xs [ 2 :] * zs [: - 2 ] + ys [ 2 :] * ws [: - 2 ] - zs [ 2 :] * xs [: - 2 ], - ws [ 2 :] * zs [: - 2 ] - xs [ 2 :] * ys [: - 2 ] + ys [ 2 :] * xs [: - 2 ] + zs [ 2 :] * ws [: - 2 ], ] ) # If dt is scalar, broadcasting is simple. If dt is an array of time deltas, adjust shape for broadcasting if np . ndim ( dt ) == 0 : return 2.0 * dw / dt else : return 2.0 / ( np . reshape ( dt , ( - 1 , 1 )) * dw ) Functions body_frame_angular_error def body_frame_angular_error ( q : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], q_des : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Angular error vector between two orientations, defined in BODY frame Parameters: Name Type Description Default q npt.ArrayLike Current XYZW quaternion, shape (4,) None q_des npt.ArrayLike Desired XYZW quaternion, shape (4,) None Returns: Type Description np.ndarray Angular error, shape (3,) View Source def body_frame_angular_error(q: npt.ArrayLike, q_des: npt.ArrayLike) -> np.ndarray: \"\"\"Angular error vector between two orientations, defined in BODY frame Args: q (npt.ArrayLike): Current XYZW quaternion, shape (4,) q_des (npt.ArrayLike): Desired XYZW quaternion, shape (4,) Returns: np.ndarray: Angular error, shape (3,) \"\"\" xd, yd, zd, wd = q_des return ( 2 * np.array([[wd, zd, -yd, -xd], [-zd, wd, xd, -yd], [yd, -xd, wd, -zd]]) @ q ) body_frame_angular_velocities def body_frame_angular_velocities ( quats : numpy . ndarray , dt : Union [ float , numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Determines the BODY-frame angular velocities of a sequence of quaternions, for a given sampling time Parameters: Name Type Description Default quats np.ndarray Sequence of XYZW quaternions, shape (n, 4) None dt Union[float, np.ndarray] Sampling time(s). If passing in an array of sampling times, this must be of length n None Returns: Type Description np.ndarray Body-frame angular velocities (w1, w2, w3), shape (n, 3) View Source def body_frame_angular_velocities ( quats : np . ndarray , dt : Union [ float , npt . ArrayLike ] ) -> np . ndarray : \"\"\"Determines the BODY-frame angular velocities of a sequence of quaternions, for a given sampling time Args: quats (np.ndarray): Sequence of XYZW quaternions, shape (n, 4) dt (Union[float, np.ndarray]): Sampling time(s). If passing in an array of sampling times, this must be of length n Returns: np.ndarray: Body-frame angular velocities (w1, w2, w3), shape (n, 3) \"\"\" xs = quats [ : , 0 ] ys = quats [ : , 1 ] zs = quats [ : , 2 ] ws = quats [ : , 3 ] n = quats . shape [ 0 ] # Number of quaternions # If passing in an array if dts , check its shape first if np . ndim ( dt ) ! = 0 and len ( dt ) ! = n : raise ValueError ( f \"Invalid dt array length: {len(dt)}. Must be of length {n}\" ) # This uses a new central differencing method to improve handling at start / end points dw = np . zeros (( n , 3 )) # Handle the start dw [ 0 , : ] = np . array ( [ ws [ 0 ] * xs [ 1 ] - xs [ 0 ] * ws [ 1 ] - ys [ 0 ] * zs [ 1 ] + zs [ 0 ] * ys [ 1 ], ws [ 0 ] * ys [ 1 ] + xs [ 0 ] * zs [ 1 ] - ys [ 0 ] * ws [ 1 ] - zs [ 0 ] * xs [ 1 ], ws [ 0 ] * zs [ 1 ] - xs [ 0 ] * ys [ 1 ] + ys [ 0 ] * xs [ 1 ] - zs [ 0 ] * ws [ 1 ], ] ) # Handle the end dw [ - 1 , : ] = np . array ( [ ws [ - 2 ] * xs [ - 1 ] - xs [ - 2 ] * ws [ - 1 ] - ys [ - 2 ] * zs [ - 1 ] + zs [ - 2 ] * ys [ - 1 ], ws [ - 2 ] * ys [ - 1 ] + xs [ - 2 ] * zs [ - 1 ] - ys [ - 2 ] * ws [ - 1 ] - zs [ - 2 ] * xs [ - 1 ], ws [ - 2 ] * zs [ - 1 ] - xs [ - 2 ] * ys [ - 1 ] + ys [ - 2 ] * xs [ - 1 ] - zs [ - 2 ] * ws [ - 1 ], ] ) # Handle the middle range of quaternions # Multiply by a factor of 1 / 2 since the central difference covers 2 timesteps dw [ 1 :- 1 , : ] = ( 1 / 2 ) * np . column_stack ( [ ws [ :- 2 ] * xs [ 2 : ] - xs [ :- 2 ] * ws [ 2 : ] - ys [ :- 2 ] * zs [ 2 : ] + zs [ :- 2 ] * ys [ 2 : ], ws [ :- 2 ] * ys [ 2 : ] + xs [ :- 2 ] * zs [ 2 : ] - ys [ :- 2 ] * ws [ 2 : ] - zs [ :- 2 ] * xs [ 2 : ], ws [ :- 2 ] * zs [ 2 : ] - xs [ :- 2 ] * ys [ 2 : ] + ys [ :- 2 ] * xs [ 2 : ] - zs [ :- 2 ] * ws [ 2 : ], ] ) # If dt is scalar , broadcasting is simple . If dt is an array of time deltas , adjust shape for broadcasting if np . ndim ( dt ) == 0 : return 2.0 * dw / dt else : return 2.0 / ( np . reshape ( dt , ( - 1 , 1 )) * dw ) body_frame_quat_deriv def body_frame_quat_deriv ( q : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], omega_body : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Quaternion derivative for a rotating body with a known BODY-FRAME angular velocity Parameters: Name Type Description Default q npt.ArrayLike Current XYZW quaternion, shape (4,) None omega_body npt.ArrayLike Body-frame angular velocity (w1, w2, w3), shape (3,) None Returns: Type Description np.ndarray Quaternion derivative, shape (4,) View Source def body_frame_quat_deriv(q: npt.ArrayLike, omega_body: npt.ArrayLike) -> np.ndarray: \"\"\"Quaternion derivative for a rotating body with a known BODY-FRAME angular velocity Args: q (npt.ArrayLike): Current XYZW quaternion, shape (4,) omega_body (npt.ArrayLike): Body-frame angular velocity (w1, w2, w3), shape (3,) Returns: np.ndarray: Quaternion derivative, shape (4,) \"\"\" x, y, z, w = q LT = np.array([[w, -z, y], [z, w, -x], [-y, x, w], [-x, -y, -z]]) return (1 / 2) * LT @ omega_body world_frame_angular_error def world_frame_angular_error ( q : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], q_des : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Angular error vector between two orientations, defined in WORLD frame Parameters: Name Type Description Default q npt.ArrayLike Current XYZW quaternion, shape (4,) None q_des npt.ArrayLike Desired XYZW quaternion, shape (4,) None Returns: Type Description np.ndarray Angular error, shape (3,) View Source def world_frame_angular_error(q: npt.ArrayLike, q_des: npt.ArrayLike) -> np.ndarray: \"\"\"Angular error vector between two orientations, defined in WORLD frame Args: q (npt.ArrayLike): Current XYZW quaternion, shape (4,) q_des (npt.ArrayLike): Desired XYZW quaternion, shape (4,) Returns: np.ndarray: Angular error, shape (3,) \"\"\" x, y, z, w = q return 2 * np.array([[-w, z, -y, x], [-z, -w, x, y], [y, -x, -w, z]]) @ q_des world_frame_angular_velocities def world_frame_angular_velocities ( quats : numpy . ndarray , dt : Union [ float , numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Determines the WORLD-frame angular velocities of a sequence of quaternions, for a given sampling time Parameters: Name Type Description Default quats np.ndarray Sequence of XYZW quaternions, shape (n, 4) None dt Union[float, np.ndarray] Sampling time(s). If passing in an array of sampling times, this must be of length n None Returns: Type Description np.ndarray World-frame angular velocities (w1, w2, w3), shape (n, 3) View Source def world_frame_angular_velocities ( quats : np . ndarray , dt : Union [ float , npt . ArrayLike ] ) -> np . ndarray : \"\"\"Determines the WORLD-frame angular velocities of a sequence of quaternions, for a given sampling time Args: quats (np.ndarray): Sequence of XYZW quaternions, shape (n, 4) dt (Union[float, np.ndarray]): Sampling time(s). If passing in an array of sampling times, this must be of length n Returns: np.ndarray: World-frame angular velocities (w1, w2, w3), shape (n, 3) \"\"\" xs = quats [ : , 0 ] ys = quats [ : , 1 ] zs = quats [ : , 2 ] ws = quats [ : , 3 ] n = quats . shape [ 0 ] # Number of quaternions # If passing in an array if dts , check its shape first if np . ndim ( dt ) ! = 0 and len ( dt ) ! = n : raise ValueError ( f \"Invalid dt array length: {len(dt)}. Must be of length {n}\" ) # This uses a new central differencing method to improve handling at start / end points dw = np . zeros (( n , 3 )) # Handle the start dw [ 0 , : ] = np . array ( [ - ws [ 1 ] * xs [ 0 ] + xs [ 1 ] * ws [ 0 ] - ys [ 1 ] * zs [ 0 ] + zs [ 1 ] * ys [ 0 ], - ws [ 1 ] * ys [ 0 ] + xs [ 1 ] * zs [ 0 ] + ys [ 1 ] * ws [ 0 ] - zs [ 1 ] * xs [ 0 ], - ws [ 1 ] * zs [ 0 ] - xs [ 1 ] * ys [ 0 ] + ys [ 1 ] * xs [ 0 ] + zs [ 1 ] * ws [ 0 ], ] ) # Handle the end dw [ - 1 , : ] = np . array ( [ - ws [ - 1 ] * xs [ - 2 ] + xs [ - 1 ] * ws [ - 2 ] - ys [ - 1 ] * zs [ - 2 ] + zs [ - 1 ] * ys [ - 2 ], - ws [ - 1 ] * ys [ - 2 ] + xs [ - 1 ] * zs [ - 2 ] + ys [ - 1 ] * ws [ - 2 ] - zs [ - 1 ] * xs [ - 2 ], - ws [ - 1 ] * zs [ - 2 ] - xs [ - 1 ] * ys [ - 2 ] + ys [ - 1 ] * xs [ - 2 ] + zs [ - 1 ] * ws [ - 2 ], ] ) # Handle the middle range of quaternions # Multiply by a factor of 1 / 2 since the central difference covers 2 timesteps dw [ 1 :- 1 , : ] = ( 1 / 2 ) * np . column_stack ( [ - ws [ 2 : ] * xs [ :- 2 ] + xs [ 2 : ] * ws [ :- 2 ] - ys [ 2 : ] * zs [ :- 2 ] + zs [ 2 : ] * ys [ :- 2 ], - ws [ 2 : ] * ys [ :- 2 ] + xs [ 2 : ] * zs [ :- 2 ] + ys [ 2 : ] * ws [ :- 2 ] - zs [ 2 : ] * xs [ :- 2 ], - ws [ 2 : ] * zs [ :- 2 ] - xs [ 2 : ] * ys [ :- 2 ] + ys [ 2 : ] * xs [ :- 2 ] + zs [ 2 : ] * ws [ :- 2 ], ] ) # If dt is scalar , broadcasting is simple . If dt is an array of time deltas , adjust shape for broadcasting if np . ndim ( dt ) == 0 : return 2.0 * dw / dt else : return 2.0 / ( np . reshape ( dt , ( - 1 , 1 )) * dw ) world_frame_quat_deriv def world_frame_quat_deriv ( q : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], omega_world : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Quaternion derivative for a rotating body with a known WORLD-FRAME angular velocity Parameters: Name Type Description Default q npt.ArrayLike Current XYZW quaternion, shape (4,) None omega_world npt.ArrayLike World-frame angular velocity (wx, wy, wz), shape (3,) None Returns: Type Description np.ndarray Quaternion derivative, shape (4,) View Source def world_frame_quat_deriv(q: npt.ArrayLike, omega_world: npt.ArrayLike) -> np.ndarray: \"\"\"Quaternion derivative for a rotating body with a known WORLD-FRAME angular velocity Args: q (npt.ArrayLike): Current XYZW quaternion, shape (4,) omega_world (npt.ArrayLike): World-frame angular velocity (wx, wy, wz), shape (3,) Returns: np.ndarray: Quaternion derivative, shape (4,) \"\"\" x, y, z, w = q GT = np.array([[w, z, -y], [-z, w, x], [y, -x, w], [-x, -y, -z]]) return (1 / 2) * GT @ omega_world","title":"Quaternion Derivatives"},{"location":"reference/pyastrobee/utils/quaternion_derivatives/#module-pyastrobeeutilsquaternion_derivatives","text":"Relationships between quaternions and angular velocity Our quaternion / angular velocity conventions (currently) are: - XYZW quaternions - World-frame angular velocities The matrices used by other sources differ because they might be using WXYZ quaternions or they might define angular velocity in the body-fixed frame. For instance, Shuster uses XYZW quaternions but defines angular velocity in body frame, and Khatib uses WXYZ quaternions with angular velocities in world frame In case we decide to use body-frame angular velocities in the future, the relevant equations are included below (with the global frame equations as well for reference) View Source \"\"\"Relationships between quaternions and angular velocity Our quaternion / angular velocity conventions (currently) are: - XYZW quaternions - World-frame angular velocities The matrices used by other sources differ because they might be using WXYZ quaternions or they might define angular velocity in the body-fixed frame. For instance, Shuster uses XYZW quaternions but defines angular velocity in body frame, and Khatib uses WXYZ quaternions with angular velocities in world frame In case we decide to use body-frame angular velocities in the future, the relevant equations are included below (with the global frame equations as well for reference) \"\"\" from typing import Union import numpy as np import numpy.typing as npt def world_frame_quat_deriv ( q : npt . ArrayLike , omega_world : npt . ArrayLike ) -> np . ndarray : \"\"\"Quaternion derivative for a rotating body with a known WORLD-FRAME angular velocity Args: q (npt.ArrayLike): Current XYZW quaternion, shape (4,) omega_world (npt.ArrayLike): World-frame angular velocity (wx, wy, wz), shape (3,) Returns: np.ndarray: Quaternion derivative, shape (4,) \"\"\" x , y , z , w = q GT = np . array ([[ w , z , - y ], [ - z , w , x ], [ y , - x , w ], [ - x , - y , - z ]]) return ( 1 / 2 ) * GT @ omega_world def body_frame_quat_deriv ( q : npt . ArrayLike , omega_body : npt . ArrayLike ) -> np . ndarray : \"\"\"Quaternion derivative for a rotating body with a known BODY-FRAME angular velocity Args: q (npt.ArrayLike): Current XYZW quaternion, shape (4,) omega_body (npt.ArrayLike): Body-frame angular velocity (w1, w2, w3), shape (3,) Returns: np.ndarray: Quaternion derivative, shape (4,) \"\"\" x , y , z , w = q LT = np . array ([[ w , - z , y ], [ z , w , - x ], [ - y , x , w ], [ - x , - y , - z ]]) return ( 1 / 2 ) * LT @ omega_body def world_frame_angular_error ( q : npt . ArrayLike , q_des : npt . ArrayLike ) -> np . ndarray : \"\"\"Angular error vector between two orientations, defined in WORLD frame Args: q (npt.ArrayLike): Current XYZW quaternion, shape (4,) q_des (npt.ArrayLike): Desired XYZW quaternion, shape (4,) Returns: np.ndarray: Angular error, shape (3,) \"\"\" x , y , z , w = q return 2 * np . array ([[ - w , z , - y , x ], [ - z , - w , x , y ], [ y , - x , - w , z ]]) @ q_des def body_frame_angular_error ( q : npt . ArrayLike , q_des : npt . ArrayLike ) -> np . ndarray : \"\"\"Angular error vector between two orientations, defined in BODY frame Args: q (npt.ArrayLike): Current XYZW quaternion, shape (4,) q_des (npt.ArrayLike): Desired XYZW quaternion, shape (4,) Returns: np.ndarray: Angular error, shape (3,) \"\"\" xd , yd , zd , wd = q_des return ( 2 * np . array ([[ wd , zd , - yd , - xd ], [ - zd , wd , xd , - yd ], [ yd , - xd , wd , - zd ]]) @ q ) # Note about the angular velocities: The pytransform3d method seems more numerically stable, so I'm using that # In some edge cases, this method below will result in a large erronrous \"spike\" in the angular velocity # In reality this \"spike\" is somehow all of the angular velocities flipping briefly to all negative values # Perhaps there is an ambiguity in the angular velocity vector and its negative at certain points (an artifact of # quaternion double-cover?) Anyways, the pytransform3d method does not have these spikes def body_frame_angular_velocities ( quats : np . ndarray , dt : Union [ float , npt . ArrayLike ] ) -> np . ndarray : \"\"\"Determines the BODY-frame angular velocities of a sequence of quaternions, for a given sampling time Args: quats (np.ndarray): Sequence of XYZW quaternions, shape (n, 4) dt (Union[float, np.ndarray]): Sampling time(s). If passing in an array of sampling times, this must be of length n Returns: np.ndarray: Body-frame angular velocities (w1, w2, w3), shape (n, 3) \"\"\" xs = quats [:, 0 ] ys = quats [:, 1 ] zs = quats [:, 2 ] ws = quats [:, 3 ] n = quats . shape [ 0 ] # Number of quaternions # If passing in an array if dts, check its shape first if np . ndim ( dt ) != 0 and len ( dt ) != n : raise ValueError ( f \"Invalid dt array length: { len ( dt ) } . Must be of length { n } \" ) # This uses a new central differencing method to improve handling at start/end points dw = np . zeros (( n , 3 )) # Handle the start dw [ 0 , :] = np . array ( [ ws [ 0 ] * xs [ 1 ] - xs [ 0 ] * ws [ 1 ] - ys [ 0 ] * zs [ 1 ] + zs [ 0 ] * ys [ 1 ], ws [ 0 ] * ys [ 1 ] + xs [ 0 ] * zs [ 1 ] - ys [ 0 ] * ws [ 1 ] - zs [ 0 ] * xs [ 1 ], ws [ 0 ] * zs [ 1 ] - xs [ 0 ] * ys [ 1 ] + ys [ 0 ] * xs [ 1 ] - zs [ 0 ] * ws [ 1 ], ] ) # Handle the end dw [ - 1 , :] = np . array ( [ ws [ - 2 ] * xs [ - 1 ] - xs [ - 2 ] * ws [ - 1 ] - ys [ - 2 ] * zs [ - 1 ] + zs [ - 2 ] * ys [ - 1 ], ws [ - 2 ] * ys [ - 1 ] + xs [ - 2 ] * zs [ - 1 ] - ys [ - 2 ] * ws [ - 1 ] - zs [ - 2 ] * xs [ - 1 ], ws [ - 2 ] * zs [ - 1 ] - xs [ - 2 ] * ys [ - 1 ] + ys [ - 2 ] * xs [ - 1 ] - zs [ - 2 ] * ws [ - 1 ], ] ) # Handle the middle range of quaternions # Multiply by a factor of 1/2 since the central difference covers 2 timesteps dw [ 1 : - 1 , :] = ( 1 / 2 ) * np . column_stack ( [ ws [: - 2 ] * xs [ 2 :] - xs [: - 2 ] * ws [ 2 :] - ys [: - 2 ] * zs [ 2 :] + zs [: - 2 ] * ys [ 2 :], ws [: - 2 ] * ys [ 2 :] + xs [: - 2 ] * zs [ 2 :] - ys [: - 2 ] * ws [ 2 :] - zs [: - 2 ] * xs [ 2 :], ws [: - 2 ] * zs [ 2 :] - xs [: - 2 ] * ys [ 2 :] + ys [: - 2 ] * xs [ 2 :] - zs [: - 2 ] * ws [ 2 :], ] ) # If dt is scalar, broadcasting is simple. If dt is an array of time deltas, adjust shape for broadcasting if np . ndim ( dt ) == 0 : return 2.0 * dw / dt else : return 2.0 / ( np . reshape ( dt , ( - 1 , 1 )) * dw ) def world_frame_angular_velocities ( quats : np . ndarray , dt : Union [ float , npt . ArrayLike ] ) -> np . ndarray : \"\"\"Determines the WORLD-frame angular velocities of a sequence of quaternions, for a given sampling time Args: quats (np.ndarray): Sequence of XYZW quaternions, shape (n, 4) dt (Union[float, np.ndarray]): Sampling time(s). If passing in an array of sampling times, this must be of length n Returns: np.ndarray: World-frame angular velocities (w1, w2, w3), shape (n, 3) \"\"\" xs = quats [:, 0 ] ys = quats [:, 1 ] zs = quats [:, 2 ] ws = quats [:, 3 ] n = quats . shape [ 0 ] # Number of quaternions # If passing in an array if dts, check its shape first if np . ndim ( dt ) != 0 and len ( dt ) != n : raise ValueError ( f \"Invalid dt array length: { len ( dt ) } . Must be of length { n } \" ) # This uses a new central differencing method to improve handling at start/end points dw = np . zeros (( n , 3 )) # Handle the start dw [ 0 , :] = np . array ( [ - ws [ 1 ] * xs [ 0 ] + xs [ 1 ] * ws [ 0 ] - ys [ 1 ] * zs [ 0 ] + zs [ 1 ] * ys [ 0 ], - ws [ 1 ] * ys [ 0 ] + xs [ 1 ] * zs [ 0 ] + ys [ 1 ] * ws [ 0 ] - zs [ 1 ] * xs [ 0 ], - ws [ 1 ] * zs [ 0 ] - xs [ 1 ] * ys [ 0 ] + ys [ 1 ] * xs [ 0 ] + zs [ 1 ] * ws [ 0 ], ] ) # Handle the end dw [ - 1 , :] = np . array ( [ - ws [ - 1 ] * xs [ - 2 ] + xs [ - 1 ] * ws [ - 2 ] - ys [ - 1 ] * zs [ - 2 ] + zs [ - 1 ] * ys [ - 2 ], - ws [ - 1 ] * ys [ - 2 ] + xs [ - 1 ] * zs [ - 2 ] + ys [ - 1 ] * ws [ - 2 ] - zs [ - 1 ] * xs [ - 2 ], - ws [ - 1 ] * zs [ - 2 ] - xs [ - 1 ] * ys [ - 2 ] + ys [ - 1 ] * xs [ - 2 ] + zs [ - 1 ] * ws [ - 2 ], ] ) # Handle the middle range of quaternions # Multiply by a factor of 1/2 since the central difference covers 2 timesteps dw [ 1 : - 1 , :] = ( 1 / 2 ) * np . column_stack ( [ - ws [ 2 :] * xs [: - 2 ] + xs [ 2 :] * ws [: - 2 ] - ys [ 2 :] * zs [: - 2 ] + zs [ 2 :] * ys [: - 2 ], - ws [ 2 :] * ys [: - 2 ] + xs [ 2 :] * zs [: - 2 ] + ys [ 2 :] * ws [: - 2 ] - zs [ 2 :] * xs [: - 2 ], - ws [ 2 :] * zs [: - 2 ] - xs [ 2 :] * ys [: - 2 ] + ys [ 2 :] * xs [: - 2 ] + zs [ 2 :] * ws [: - 2 ], ] ) # If dt is scalar, broadcasting is simple. If dt is an array of time deltas, adjust shape for broadcasting if np . ndim ( dt ) == 0 : return 2.0 * dw / dt else : return 2.0 / ( np . reshape ( dt , ( - 1 , 1 )) * dw )","title":"Module pyastrobee.utils.quaternion_derivatives"},{"location":"reference/pyastrobee/utils/quaternion_derivatives/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/utils/quaternion_derivatives/#body_frame_angular_error","text":"def body_frame_angular_error ( q : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], q_des : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Angular error vector between two orientations, defined in BODY frame Parameters: Name Type Description Default q npt.ArrayLike Current XYZW quaternion, shape (4,) None q_des npt.ArrayLike Desired XYZW quaternion, shape (4,) None Returns: Type Description np.ndarray Angular error, shape (3,) View Source def body_frame_angular_error(q: npt.ArrayLike, q_des: npt.ArrayLike) -> np.ndarray: \"\"\"Angular error vector between two orientations, defined in BODY frame Args: q (npt.ArrayLike): Current XYZW quaternion, shape (4,) q_des (npt.ArrayLike): Desired XYZW quaternion, shape (4,) Returns: np.ndarray: Angular error, shape (3,) \"\"\" xd, yd, zd, wd = q_des return ( 2 * np.array([[wd, zd, -yd, -xd], [-zd, wd, xd, -yd], [yd, -xd, wd, -zd]]) @ q )","title":"body_frame_angular_error"},{"location":"reference/pyastrobee/utils/quaternion_derivatives/#body_frame_angular_velocities","text":"def body_frame_angular_velocities ( quats : numpy . ndarray , dt : Union [ float , numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Determines the BODY-frame angular velocities of a sequence of quaternions, for a given sampling time Parameters: Name Type Description Default quats np.ndarray Sequence of XYZW quaternions, shape (n, 4) None dt Union[float, np.ndarray] Sampling time(s). If passing in an array of sampling times, this must be of length n None Returns: Type Description np.ndarray Body-frame angular velocities (w1, w2, w3), shape (n, 3) View Source def body_frame_angular_velocities ( quats : np . ndarray , dt : Union [ float , npt . ArrayLike ] ) -> np . ndarray : \"\"\"Determines the BODY-frame angular velocities of a sequence of quaternions, for a given sampling time Args: quats (np.ndarray): Sequence of XYZW quaternions, shape (n, 4) dt (Union[float, np.ndarray]): Sampling time(s). If passing in an array of sampling times, this must be of length n Returns: np.ndarray: Body-frame angular velocities (w1, w2, w3), shape (n, 3) \"\"\" xs = quats [ : , 0 ] ys = quats [ : , 1 ] zs = quats [ : , 2 ] ws = quats [ : , 3 ] n = quats . shape [ 0 ] # Number of quaternions # If passing in an array if dts , check its shape first if np . ndim ( dt ) ! = 0 and len ( dt ) ! = n : raise ValueError ( f \"Invalid dt array length: {len(dt)}. Must be of length {n}\" ) # This uses a new central differencing method to improve handling at start / end points dw = np . zeros (( n , 3 )) # Handle the start dw [ 0 , : ] = np . array ( [ ws [ 0 ] * xs [ 1 ] - xs [ 0 ] * ws [ 1 ] - ys [ 0 ] * zs [ 1 ] + zs [ 0 ] * ys [ 1 ], ws [ 0 ] * ys [ 1 ] + xs [ 0 ] * zs [ 1 ] - ys [ 0 ] * ws [ 1 ] - zs [ 0 ] * xs [ 1 ], ws [ 0 ] * zs [ 1 ] - xs [ 0 ] * ys [ 1 ] + ys [ 0 ] * xs [ 1 ] - zs [ 0 ] * ws [ 1 ], ] ) # Handle the end dw [ - 1 , : ] = np . array ( [ ws [ - 2 ] * xs [ - 1 ] - xs [ - 2 ] * ws [ - 1 ] - ys [ - 2 ] * zs [ - 1 ] + zs [ - 2 ] * ys [ - 1 ], ws [ - 2 ] * ys [ - 1 ] + xs [ - 2 ] * zs [ - 1 ] - ys [ - 2 ] * ws [ - 1 ] - zs [ - 2 ] * xs [ - 1 ], ws [ - 2 ] * zs [ - 1 ] - xs [ - 2 ] * ys [ - 1 ] + ys [ - 2 ] * xs [ - 1 ] - zs [ - 2 ] * ws [ - 1 ], ] ) # Handle the middle range of quaternions # Multiply by a factor of 1 / 2 since the central difference covers 2 timesteps dw [ 1 :- 1 , : ] = ( 1 / 2 ) * np . column_stack ( [ ws [ :- 2 ] * xs [ 2 : ] - xs [ :- 2 ] * ws [ 2 : ] - ys [ :- 2 ] * zs [ 2 : ] + zs [ :- 2 ] * ys [ 2 : ], ws [ :- 2 ] * ys [ 2 : ] + xs [ :- 2 ] * zs [ 2 : ] - ys [ :- 2 ] * ws [ 2 : ] - zs [ :- 2 ] * xs [ 2 : ], ws [ :- 2 ] * zs [ 2 : ] - xs [ :- 2 ] * ys [ 2 : ] + ys [ :- 2 ] * xs [ 2 : ] - zs [ :- 2 ] * ws [ 2 : ], ] ) # If dt is scalar , broadcasting is simple . If dt is an array of time deltas , adjust shape for broadcasting if np . ndim ( dt ) == 0 : return 2.0 * dw / dt else : return 2.0 / ( np . reshape ( dt , ( - 1 , 1 )) * dw )","title":"body_frame_angular_velocities"},{"location":"reference/pyastrobee/utils/quaternion_derivatives/#body_frame_quat_deriv","text":"def body_frame_quat_deriv ( q : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], omega_body : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Quaternion derivative for a rotating body with a known BODY-FRAME angular velocity Parameters: Name Type Description Default q npt.ArrayLike Current XYZW quaternion, shape (4,) None omega_body npt.ArrayLike Body-frame angular velocity (w1, w2, w3), shape (3,) None Returns: Type Description np.ndarray Quaternion derivative, shape (4,) View Source def body_frame_quat_deriv(q: npt.ArrayLike, omega_body: npt.ArrayLike) -> np.ndarray: \"\"\"Quaternion derivative for a rotating body with a known BODY-FRAME angular velocity Args: q (npt.ArrayLike): Current XYZW quaternion, shape (4,) omega_body (npt.ArrayLike): Body-frame angular velocity (w1, w2, w3), shape (3,) Returns: np.ndarray: Quaternion derivative, shape (4,) \"\"\" x, y, z, w = q LT = np.array([[w, -z, y], [z, w, -x], [-y, x, w], [-x, -y, -z]]) return (1 / 2) * LT @ omega_body","title":"body_frame_quat_deriv"},{"location":"reference/pyastrobee/utils/quaternion_derivatives/#world_frame_angular_error","text":"def world_frame_angular_error ( q : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], q_des : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Angular error vector between two orientations, defined in WORLD frame Parameters: Name Type Description Default q npt.ArrayLike Current XYZW quaternion, shape (4,) None q_des npt.ArrayLike Desired XYZW quaternion, shape (4,) None Returns: Type Description np.ndarray Angular error, shape (3,) View Source def world_frame_angular_error(q: npt.ArrayLike, q_des: npt.ArrayLike) -> np.ndarray: \"\"\"Angular error vector between two orientations, defined in WORLD frame Args: q (npt.ArrayLike): Current XYZW quaternion, shape (4,) q_des (npt.ArrayLike): Desired XYZW quaternion, shape (4,) Returns: np.ndarray: Angular error, shape (3,) \"\"\" x, y, z, w = q return 2 * np.array([[-w, z, -y, x], [-z, -w, x, y], [y, -x, -w, z]]) @ q_des","title":"world_frame_angular_error"},{"location":"reference/pyastrobee/utils/quaternion_derivatives/#world_frame_angular_velocities","text":"def world_frame_angular_velocities ( quats : numpy . ndarray , dt : Union [ float , numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Determines the WORLD-frame angular velocities of a sequence of quaternions, for a given sampling time Parameters: Name Type Description Default quats np.ndarray Sequence of XYZW quaternions, shape (n, 4) None dt Union[float, np.ndarray] Sampling time(s). If passing in an array of sampling times, this must be of length n None Returns: Type Description np.ndarray World-frame angular velocities (w1, w2, w3), shape (n, 3) View Source def world_frame_angular_velocities ( quats : np . ndarray , dt : Union [ float , npt . ArrayLike ] ) -> np . ndarray : \"\"\"Determines the WORLD-frame angular velocities of a sequence of quaternions, for a given sampling time Args: quats (np.ndarray): Sequence of XYZW quaternions, shape (n, 4) dt (Union[float, np.ndarray]): Sampling time(s). If passing in an array of sampling times, this must be of length n Returns: np.ndarray: World-frame angular velocities (w1, w2, w3), shape (n, 3) \"\"\" xs = quats [ : , 0 ] ys = quats [ : , 1 ] zs = quats [ : , 2 ] ws = quats [ : , 3 ] n = quats . shape [ 0 ] # Number of quaternions # If passing in an array if dts , check its shape first if np . ndim ( dt ) ! = 0 and len ( dt ) ! = n : raise ValueError ( f \"Invalid dt array length: {len(dt)}. Must be of length {n}\" ) # This uses a new central differencing method to improve handling at start / end points dw = np . zeros (( n , 3 )) # Handle the start dw [ 0 , : ] = np . array ( [ - ws [ 1 ] * xs [ 0 ] + xs [ 1 ] * ws [ 0 ] - ys [ 1 ] * zs [ 0 ] + zs [ 1 ] * ys [ 0 ], - ws [ 1 ] * ys [ 0 ] + xs [ 1 ] * zs [ 0 ] + ys [ 1 ] * ws [ 0 ] - zs [ 1 ] * xs [ 0 ], - ws [ 1 ] * zs [ 0 ] - xs [ 1 ] * ys [ 0 ] + ys [ 1 ] * xs [ 0 ] + zs [ 1 ] * ws [ 0 ], ] ) # Handle the end dw [ - 1 , : ] = np . array ( [ - ws [ - 1 ] * xs [ - 2 ] + xs [ - 1 ] * ws [ - 2 ] - ys [ - 1 ] * zs [ - 2 ] + zs [ - 1 ] * ys [ - 2 ], - ws [ - 1 ] * ys [ - 2 ] + xs [ - 1 ] * zs [ - 2 ] + ys [ - 1 ] * ws [ - 2 ] - zs [ - 1 ] * xs [ - 2 ], - ws [ - 1 ] * zs [ - 2 ] - xs [ - 1 ] * ys [ - 2 ] + ys [ - 1 ] * xs [ - 2 ] + zs [ - 1 ] * ws [ - 2 ], ] ) # Handle the middle range of quaternions # Multiply by a factor of 1 / 2 since the central difference covers 2 timesteps dw [ 1 :- 1 , : ] = ( 1 / 2 ) * np . column_stack ( [ - ws [ 2 : ] * xs [ :- 2 ] + xs [ 2 : ] * ws [ :- 2 ] - ys [ 2 : ] * zs [ :- 2 ] + zs [ 2 : ] * ys [ :- 2 ], - ws [ 2 : ] * ys [ :- 2 ] + xs [ 2 : ] * zs [ :- 2 ] + ys [ 2 : ] * ws [ :- 2 ] - zs [ 2 : ] * xs [ :- 2 ], - ws [ 2 : ] * zs [ :- 2 ] - xs [ 2 : ] * ys [ :- 2 ] + ys [ 2 : ] * xs [ :- 2 ] + zs [ 2 : ] * ws [ :- 2 ], ] ) # If dt is scalar , broadcasting is simple . If dt is an array of time deltas , adjust shape for broadcasting if np . ndim ( dt ) == 0 : return 2.0 * dw / dt else : return 2.0 / ( np . reshape ( dt , ( - 1 , 1 )) * dw )","title":"world_frame_angular_velocities"},{"location":"reference/pyastrobee/utils/quaternion_derivatives/#world_frame_quat_deriv","text":"def world_frame_quat_deriv ( q : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], omega_world : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Quaternion derivative for a rotating body with a known WORLD-FRAME angular velocity Parameters: Name Type Description Default q npt.ArrayLike Current XYZW quaternion, shape (4,) None omega_world npt.ArrayLike World-frame angular velocity (wx, wy, wz), shape (3,) None Returns: Type Description np.ndarray Quaternion derivative, shape (4,) View Source def world_frame_quat_deriv(q: npt.ArrayLike, omega_world: npt.ArrayLike) -> np.ndarray: \"\"\"Quaternion derivative for a rotating body with a known WORLD-FRAME angular velocity Args: q (npt.ArrayLike): Current XYZW quaternion, shape (4,) omega_world (npt.ArrayLike): World-frame angular velocity (wx, wy, wz), shape (3,) Returns: np.ndarray: Quaternion derivative, shape (4,) \"\"\" x, y, z, w = q GT = np.array([[w, z, -y], [-z, w, x], [y, -x, w], [-x, -y, -z]]) return (1 / 2) * GT @ omega_world","title":"world_frame_quat_deriv"},{"location":"reference/pyastrobee/utils/quaternions/","text":"Module pyastrobee.utils.quaternions Quaternion utilities We will always default to using XYZW convention View Source \"\"\"Quaternion utilities We will always default to using XYZW convention \"\"\" from typing import Union import numpy as np import numpy.typing as npt import pytransform3d.rotations as rt import pytransform3d.batch_rotations as brt from pyastrobee.utils.math_utils import normalize from pyastrobee.utils.rotations import ( axis_angle_between_two_vectors , axis_angle_to_quat , quat_to_rmat , ) def check_quaternion ( quat : npt . ArrayLike ) -> np . ndarray : \"\"\"Checks that a quaternion is of the correct shape and returns a normalized quat Args: quat (npt.ArrayLike): Quaternion (XYZW or WXYZ), shape (4,) Raises: ValueError: If the input is not a valid quaternion Returns: np.ndarray: Normalized quaternion, shape (4,) \"\"\" quat = np . ravel ( quat ) if len ( quat ) != 4 : raise ValueError ( f \"Invalid quaternion ( { quat } ): \\n Not of length 4!\" ) return normalize ( quat ) def random_quaternion () -> np . ndarray : \"\"\"Generate a random, normalized quaternion Returns: np.ndarray: XYZW quaternion, shape (4,) \"\"\" q = np . random . rand ( 4 ) return q / np . linalg . norm ( q ) def conjugate ( quat : npt . ArrayLike ) -> np . ndarray : \"\"\"Conjugate of an XYZW quaternion (same scalar part but flipped imaginary components) Args: quat (npt.ArrayLike): XYZW quaternion, shape (4,) Returns: np.ndarray: Conjugate XYZW quaternion, shape (4,) \"\"\" x , y , z , w = quat return np . array ([ - x , - y , - z , w ]) def quats_to_angular_velocities ( quats : np . ndarray , dt : Union [ float , npt . ArrayLike ] ) -> np . ndarray : \"\"\"Determines the angular velocities of a sequence of quaternions, for a given sampling time - These angular velocities are defined in WORLD frame, not the robot's body-fixed frame - For more info on frames, refer to https://github.com/dfki-ric/pytransform3d/discussions/249 Args: quats (np.ndarray): Sequence of XYZW quaternions, shape (n, 4) dt (Union[float, np.ndarray]): Sampling time(s). If passing in an array of sampling times, this must be of length n Returns: np.ndarray: Angular velocities (wx, wy, wz), shape (n, 3) \"\"\" # Convert XYZW to WXYZ for pytransform3d compatibility wxyz_quats = xyzw_to_wxyz ( quats ) # Determine gradients based on timestep format (fixed timestep vs variable array) if np . ndim ( dt ) == 0 : grads = rt . quaternion_gradient ( wxyz_quats , dt ) else : grads = rt . quaternion_gradient ( wxyz_quats , 1 ) grads = grads / np . reshape ( dt , ( - 1 , 1 )) return grads def xyzw_to_wxyz ( quats : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts a XYZW quaternion or array of quaternions to WXYZ Args: quats (npt.ArrayLike): XYZW quaternion(s), shape (4,) or (n, 4) Returns: np.ndarray: WXYZ quaternions, shape (4,) or (n, 4) (same shape as input) \"\"\" quats = np . asarray ( quats ) if quats . shape [ - 1 ] != 4 : raise ValueError ( \"Invalid quaternion array: Must be of shape (4,) or (n, 4)\" ) idx = np . array ([ 3 , 0 , 1 , 2 ]) if np . ndim ( quats ) == 1 : return quats [ idx ] else : return quats [:, idx ] def wxyz_to_xyzw ( quats : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts a WXYZ quaternion or array of quaternions to XYZW Args: quats (npt.ArrayLike): WXYZ quaternion(s), shape (4,) or (n, 4) Returns: np.ndarray: XYZW quaternions, shape (4,) or (n, 4) (same shape as input) \"\"\" quats = np . asarray ( quats ) if quats . shape [ - 1 ] != 4 : raise ValueError ( \"Invalid quaternion array: Must be of shape (4,) or (n, 4)\" ) idx = np . array ([ 1 , 2 , 3 , 0 ]) if np . ndim ( quats ) == 1 : return quats [ idx ] else : return quats [:, idx ] def quaternion_derivative ( q : npt . ArrayLike , omega : npt . ArrayLike ) -> np . ndarray : \"\"\"Quaternion derivative for a given world-frame angular velocity Args: q (npt.ArrayLike): XYZW quaternion, shape (4,) omega (npt.ArrayLike): Angular velocity (wx, wy, wz) in world frame, shape (3,) Returns: np.ndarray: Quaternion derivative, shape (4,) \"\"\" q = check_quaternion ( q ) x , y , z , w = q GT = np . array ([[ w , z , - y ], [ - z , w , x ], [ y , - x , w ], [ - x , - y , - z ]]) return ( 1 / 2 ) * GT @ omega def quaternion_integration ( q : npt . ArrayLike , w : npt . ArrayLike , dt : float ) -> np . ndarray : \"\"\"Propagate a quaternion forward one timestep based on the current angular velocity Args: q (npt.ArrayLike): Initial XYZW quaternion, shape (4,) w (npt.ArrayLike): Angular velocity (wx, wy, wz), shape (3,) dt (float): Timestep duration (seconds) Returns: np.ndarray: Next XYZW quaternion, q(t + dt), shape (4,) \"\"\" q = check_quaternion ( q ) return normalize ( q + dt * quaternion_derivative ( q , w )) def combine_quaternions ( q1 : npt . ArrayLike , q2 : npt . ArrayLike ) -> np . ndarray : \"\"\"Combines the angular representation of two quaternions Args: q1 (npt.ArrayLike): First XYZW quaternion, shape (4,) if passing in an array q2 (npt.ArrayLike): Second XYZW quaternion, shape (4,) if passing in an array Returns: np.ndarray: Combined XYZW quaternion, shape (4,) \"\"\" wxyz = rt . concatenate_quaternions ( xyzw_to_wxyz ( q1 ), xyzw_to_wxyz ( q2 )) return wxyz_to_xyzw ( wxyz ) def quaternion_between_two_vectors ( v1 : npt . ArrayLike , v2 : npt . ArrayLike ) -> np . ndarray : \"\"\"Gives the quaternion rotation that would rotate vector v1 to align with v2 (magnitude-independent) Args: v1 (npt.ArrayLike): (3,) Starting vector/direction v2 (npt.ArrayLike): (3,) Ending vector/direction Returns: np.ndarray: (4,) XYZW quaternion \"\"\" axis , angle = axis_angle_between_two_vectors ( v1 , v2 ) return axis_angle_to_quat ( axis , angle ) def get_closest_heading_quat ( q0 : npt . ArrayLike , heading : npt . ArrayLike ) -> np . ndarray : \"\"\"Gives the quaternion closest to q0 that has its x-axis aligned with the heading Args: q0 (npt.ArrayLike): Initial (reference) XYZW quaternion, shape (4,) heading (npt.ArrayLike): Desired XYZ vector parallel to the new frame's x-axis, shape (3,) Returns: np.ndarray: XYZW quaternion, shape (4,) \"\"\" # We want the x axis to point along the heading axis # So, a rotation between these two axes can be defined by an axis-angle rotation # We can then apply this rotation transformation via quaternion concatenation rmat1 = quat_to_rmat ( q0 ) orig_x_axis = rmat1 [:, 0 ] rotation_quat = quaternion_between_two_vectors ( orig_x_axis , heading ) return combine_quaternions ( rotation_quat , q0 ) def quaternion_slerp ( q1 : npt . ArrayLike , q2 : npt . ArrayLike , pct : Union [ float , npt . ArrayLike ], ) -> np . ndarray : \"\"\"Interpolates between two quaternions via SLERP (spherical linear interpolation) To interpolate at multiple points, pass in pcts as an array of interpolation percentages Args: q1 (npt.ArrayLike): Starting XYZW quaternion, shape (4,) q2 (npt.ArrayLike): Ending XYZW quaternion, shape (4,) pct (Union[float, npt.ArrayLike]): Percent(s) between start -> end, expressed as float(s) in [0, 1] Returns: np.ndarray: The interpolated XYZW quaternion(s), shape = (4,) or (n, 4) if interpolating at multiple points \"\"\" pct = np . atleast_1d ( pct ) n = len ( pct ) # Number of interpolation points if not ( np . all ( pct >= 0 ) and np . all ( pct <= 1 )): raise ValueError ( f \"Interpolation percentage(s) must be between 0 and 1. \\n Got: { pct } \" ) q1_wxyz = xyzw_to_wxyz ( q1 ) q2_wxyz = xyzw_to_wxyz ( q2 ) # The shortest path parameter does not add too much extra computation and should handle quaternion ambiguity well shortest_path = True # Simple conversion for one interpolation point, otherwise use batched process if n == 1 : wxyz_interp = rt . quaternion_slerp ( q1_wxyz , q2_wxyz , pct [ 0 ], shortest_path ) return wxyz_to_xyzw ( wxyz_interp ) else : wxyz_quats = brt . quaternion_slerp_batch ( q1_wxyz , q2_wxyz , pct , shortest_path ) xyzw_quats = np . zeros_like ( wxyz_quats ) xyzw_quats [:, : 3 ] = wxyz_quats [:, 1 :] # qx, qy, qz xyzw_quats [:, - 1 ] = wxyz_quats [:, 0 ] # qw return xyzw_quats # (n, 4) def quaternion_dist ( q1 : npt . ArrayLike , q2 : npt . ArrayLike ) -> float : \"\"\"Computes the distance between two quaternions Args: q1 (npt.ArrayLike): XYZW quaternion, shape (4,) q2 (npt.ArrayLike): A second XYZW quaternion, shape (4,) Returns: float: Distance between the two quaternions \"\"\" wxyz_1 = xyzw_to_wxyz ( q1 ) wxyz_2 = xyzw_to_wxyz ( q2 ) return rt . quaternion_dist ( wxyz_1 , wxyz_2 ) def quaternion_diff ( q1 : npt . ArrayLike , q2 : npt . ArrayLike ) -> np . ndarray : \"\"\"Gives the quaternion representing the rotation from q1 -> q2 Args: q1 (npt.ArrayLike): Starting XYZW quaternion, shape (4,) q2 (npt.ArrayLike): Ending XYZW quaternion, shape (4,) Returns: np.ndarray: XYZW quaternion, shape (4,) \"\"\" return combine_quaternions ( q2 , conjugate ( q1 )) def quaternion_angular_error ( q : npt . ArrayLike , q_des : npt . ArrayLike ) -> np . ndarray : \"\"\"Gives the instantaneous angular error between two quaternions (q w.r.t q_des) - This is similar (but not the same) as a difference between fixed-XYZ conventions (for small angles, these are very close). - This error is defined in WORLD frame, not the robot's body-fixed frame Args: q (npt.ArrayLike): Current XYZW quaternion, shape (4,) q_des (npt.ArrayLike): Desired XYZW quaternion, shape (4,) Returns: np.ndarray: Instantaneous angular error, shape (3,) \"\"\" q = check_quaternion ( q ) q_des = check_quaternion ( q_des ) x , y , z , w = q return 2 * np . array ([[ - w , z , - y , x ], [ - z , - w , x , y ], [ y , - x , - w , z ]]) @ q_des def exponential_map ( v : npt . ArrayLike ) -> np . ndarray : \"\"\"Exponential map: Lie algebra to quaternion Args: v (npt.ArrayLike): Vector on the Lie algebra, shape (3,) Returns: np.ndarray: XYZW quaternion, shape (4,) \"\"\" wxyz = rt . quaternion_from_compact_axis_angle ( v ) return wxyz_to_xyzw ( wxyz ) def log_map ( q : npt . ArrayLike ) -> np . ndarray : \"\"\"Logarithmic map: XYZW quaternion to Lie algebra Args: q (npt.ArrayLike): XYZW quaternion to map Returns: np.ndarray: Vector on the Lie algebra, shape (3,) \"\"\" return rt . compact_axis_angle_from_quaternion ( xyzw_to_wxyz ( q )) def pure ( v : npt . ArrayLike ) -> np . ndarray : \"\"\"Convert a vector component into a pure XYZW quaternion (no scalar component) NOTE: The quaternion returned WILL NOT be normalized in general. But, it is often useful to use this construction so that we can compose multiplications with angular velocity, for instance Args: v (npt.ArrayLike): Vector component, shape (3,) Returns: np.ndarray: XYZW quaternion (NOT NORMALIZED), shape (4,) \"\"\" if len ( v ) != 3 : raise ValueError ( \"Invalid vector component of pure quaternion. Must be shape (3,)\" ) return np . array ([ * v , 0 ]) # Alternatively, can implement this with pytransform's concatenate_quaternions function def multiply ( q1 : npt . ArrayLike , q2 : npt . ArrayLike ) -> np . ndarray : \"\"\"Multiply two XYZW quaternions Args: q1 (npt.ArrayLike): First XYZW quaternion q2 (npt.ArrayLike): Second XYZW quaternion Returns: np.ndarray: XYZW quaternion, shape (4,) \"\"\" x1 , y1 , z1 , w1 = q1 x2 , y2 , z2 , w2 = q2 return np . array ( [ w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2 , w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2 , w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2 , w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2 , ] ) def rotate ( p : npt . ArrayLike , q : npt . ArrayLike ) -> np . ndarray : \"\"\"Rotates a point p by a quaternion q, using p' = qpq* Args: p (npt.ArrayLike): Point to rotate, shape (3,) q (npt.ArrayLike): XYZW quaternion describing the rotation, shape (4,) Returns: np.ndarray: Rotated point, shape (3,) \"\"\" return ( multiply ( multiply ( q , pure ( p )), conjugate ( q )))[: 3 ] Functions check_quaternion def check_quaternion ( quat : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Checks that a quaternion is of the correct shape and returns a normalized quat Parameters: Name Type Description Default quat npt.ArrayLike Quaternion (XYZW or WXYZ), shape (4,) None Returns: Type Description np.ndarray Normalized quaternion, shape (4,) Raises: Type Description ValueError If the input is not a valid quaternion View Source def check_quaternion ( quat : npt . ArrayLike ) -> np . ndarray : \"\"\"Checks that a quaternion is of the correct shape and returns a normalized quat Args: quat (npt.ArrayLike): Quaternion (XYZW or WXYZ), shape (4,) Raises: ValueError: If the input is not a valid quaternion Returns: np.ndarray: Normalized quaternion, shape (4,) \"\"\" quat = np . ravel ( quat ) if len ( quat ) != 4 : raise ValueError ( f \"Invalid quaternion ({quat}):\\nNot of length 4!\" ) return normalize ( quat ) combine_quaternions def combine_quaternions ( q1 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], q2 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Combines the angular representation of two quaternions Parameters: Name Type Description Default q1 npt.ArrayLike First XYZW quaternion, shape (4,) if passing in an array None q2 npt.ArrayLike Second XYZW quaternion, shape (4,) if passing in an array None Returns: Type Description np.ndarray Combined XYZW quaternion, shape (4,) View Source def combine_quaternions ( q1 : npt . ArrayLike , q2 : npt . ArrayLike ) -> np . ndarray : \"\"\"Combines the angular representation of two quaternions Args: q1 (npt.ArrayLike): First XYZW quaternion, shape (4,) if passing in an array q2 (npt.ArrayLike): Second XYZW quaternion, shape (4,) if passing in an array Returns: np.ndarray: Combined XYZW quaternion, shape (4,) \"\"\" wxyz = rt . concatenate_quaternions ( xyzw_to_wxyz ( q1 ), xyzw_to_wxyz ( q2 )) return wxyz_to_xyzw ( wxyz ) conjugate def conjugate ( quat : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Conjugate of an XYZW quaternion (same scalar part but flipped imaginary components) Parameters: Name Type Description Default quat npt.ArrayLike XYZW quaternion, shape (4,) None Returns: Type Description np.ndarray Conjugate XYZW quaternion, shape (4,) View Source def conjugate ( quat : npt . ArrayLike ) -> np . ndarray : \"\"\"Conjugate of an XYZW quaternion (same scalar part but flipped imaginary components) Args: quat (npt.ArrayLike): XYZW quaternion, shape (4,) Returns: np.ndarray: Conjugate XYZW quaternion, shape (4,) \"\"\" x , y , z , w = quat return np . array ([ - x , - y , - z , w ]) exponential_map def exponential_map ( v : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Exponential map: Lie algebra to quaternion Parameters: Name Type Description Default v npt.ArrayLike Vector on the Lie algebra, shape (3,) None Returns: Type Description np.ndarray XYZW quaternion, shape (4,) View Source def exponential_map ( v : npt . ArrayLike ) -> np . ndarray : \"\"\"Exponential map: Lie algebra to quaternion Args: v (npt.ArrayLike): Vector on the Lie algebra, shape (3,) Returns: np.ndarray: XYZW quaternion, shape (4,) \"\"\" wxyz = rt . quaternion_from_compact_axis_angle ( v ) return wxyz_to_xyzw ( wxyz ) get_closest_heading_quat def get_closest_heading_quat ( q0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], heading : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Gives the quaternion closest to q0 that has its x-axis aligned with the heading Parameters: Name Type Description Default q0 npt.ArrayLike Initial (reference) XYZW quaternion, shape (4,) None heading npt.ArrayLike Desired XYZ vector parallel to the new frame's x-axis, shape (3,) None Returns: Type Description np.ndarray XYZW quaternion, shape (4,) View Source def get_closest_heading_quat ( q0 : npt . ArrayLike , heading : npt . ArrayLike ) -> np . ndarray : \"\"\"Gives the quaternion closest to q0 that has its x-axis aligned with the heading Args: q0 (npt.ArrayLike): Initial (reference) XYZW quaternion, shape (4,) heading (npt.ArrayLike): Desired XYZ vector parallel to the new frame' s x - axis , shape ( 3 ,) Returns : np . ndarray : XYZW quaternion , shape ( 4 ,) \"\"\" # We want the x axis to point along the heading axis # So, a rotation between these two axes can be defined by an axis-angle rotation # We can then apply this rotation transformation via quaternion concatenation rmat1 = quat_to_rmat(q0) orig_x_axis = rmat1[:, 0] rotation_quat = quaternion_between_two_vectors(orig_x_axis, heading) return combine_quaternions(rotation_quat, q0) log_map def log_map ( q : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Logarithmic map: XYZW quaternion to Lie algebra Parameters: Name Type Description Default q npt.ArrayLike XYZW quaternion to map None Returns: Type Description np.ndarray Vector on the Lie algebra, shape (3,) View Source def log_map ( q : npt . ArrayLike ) -> np . ndarray : \"\"\"Logarithmic map: XYZW quaternion to Lie algebra Args: q (npt.ArrayLike): XYZW quaternion to map Returns: np.ndarray: Vector on the Lie algebra, shape (3,) \"\"\" return rt . compact_axis_angle_from_quaternion ( xyzw_to_wxyz ( q )) multiply def multiply ( q1 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], q2 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Multiply two XYZW quaternions Parameters: Name Type Description Default q1 npt.ArrayLike First XYZW quaternion None q2 npt.ArrayLike Second XYZW quaternion None Returns: Type Description np.ndarray XYZW quaternion, shape (4,) View Source def multiply ( q1 : npt . ArrayLike , q2 : npt . ArrayLike ) -> np . ndarray : \"\"\"Multiply two XYZW quaternions Args: q1 (npt.ArrayLike): First XYZW quaternion q2 (npt.ArrayLike): Second XYZW quaternion Returns: np.ndarray: XYZW quaternion, shape (4,) \"\"\" x1 , y1 , z1 , w1 = q1 x2 , y2 , z2 , w2 = q2 return np . array ( [ w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2 , w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2 , w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2 , w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2 , ] ) pure def pure ( v : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Convert a vector component into a pure XYZW quaternion (no scalar component) NOTE: The quaternion returned WILL NOT be normalized in general. But, it is often useful to use this construction so that we can compose multiplications with angular velocity, for instance Parameters: Name Type Description Default v npt.ArrayLike Vector component, shape (3,) None Returns: Type Description np.ndarray XYZW quaternion (NOT NORMALIZED), shape (4,) View Source def pure ( v : npt . ArrayLike ) -> np . ndarray : \"\"\"Convert a vector component into a pure XYZW quaternion (no scalar component) NOTE: The quaternion returned WILL NOT be normalized in general. But, it is often useful to use this construction so that we can compose multiplications with angular velocity, for instance Args: v (npt.ArrayLike): Vector component, shape (3,) Returns: np.ndarray: XYZW quaternion (NOT NORMALIZED), shape (4,) \"\"\" if len ( v ) != 3 : raise ValueError ( \"Invalid vector component of pure quaternion. Must be shape (3,)\" ) return np . array ([ * v , 0 ]) quaternion_angular_error def quaternion_angular_error ( q : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], q_des : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Gives the instantaneous angular error between two quaternions (q w.r.t q_des) This is similar (but not the same) as a difference between fixed-XYZ conventions (for small angles, these are very close). This error is defined in WORLD frame, not the robot's body-fixed frame Parameters: Name Type Description Default q npt.ArrayLike Current XYZW quaternion, shape (4,) None q_des npt.ArrayLike Desired XYZW quaternion, shape (4,) None Returns: Type Description np.ndarray Instantaneous angular error, shape (3,) View Source def quaternion_angular_error(q: npt.ArrayLike, q_des: npt.ArrayLike) -> np.ndarray: \"\"\"Gives the instantaneous angular error between two quaternions (q w.r.t q_des) - This is similar (but not the same) as a difference between fixed-XYZ conventions (for small angles, these are very close). - This error is defined in WORLD frame, not the robot's body-fixed frame Args: q (npt.ArrayLike): Current XYZW quaternion, shape (4,) q_des (npt.ArrayLike): Desired XYZW quaternion, shape (4,) Returns: np.ndarray: Instantaneous angular error, shape (3,) \"\"\" q = check_quaternion(q) q_des = check_quaternion(q_des) x, y, z, w = q return 2 * np.array([[-w, z, -y, x], [-z, -w, x, y], [y, -x, -w, z]]) @ q_des quaternion_between_two_vectors def quaternion_between_two_vectors ( v1 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], v2 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Gives the quaternion rotation that would rotate vector v1 to align with v2 (magnitude-independent) Parameters: Name Type Description Default v1 npt.ArrayLike (3,) Starting vector/direction None v2 npt.ArrayLike (3,) Ending vector/direction None Returns: Type Description np.ndarray (4,) XYZW quaternion View Source def quaternion_between_two_vectors ( v1 : npt . ArrayLike , v2 : npt . ArrayLike ) -> np . ndarray : \"\"\"Gives the quaternion rotation that would rotate vector v1 to align with v2 (magnitude-independent) Args: v1 (npt.ArrayLike): (3,) Starting vector/direction v2 (npt.ArrayLike): (3,) Ending vector/direction Returns: np.ndarray: (4,) XYZW quaternion \"\"\" axis , angle = axis_angle_between_two_vectors ( v1 , v2 ) return axis_angle_to_quat ( axis , angle ) quaternion_derivative def quaternion_derivative ( q : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], omega : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Quaternion derivative for a given world-frame angular velocity Parameters: Name Type Description Default q npt.ArrayLike XYZW quaternion, shape (4,) None omega npt.ArrayLike Angular velocity (wx, wy, wz) in world frame, shape (3,) None Returns: Type Description np.ndarray Quaternion derivative, shape (4,) View Source def quaternion_derivative(q: npt.ArrayLike, omega: npt.ArrayLike) -> np.ndarray: \"\"\"Quaternion derivative for a given world-frame angular velocity Args: q (npt.ArrayLike): XYZW quaternion, shape (4,) omega (npt.ArrayLike): Angular velocity (wx, wy, wz) in world frame, shape (3,) Returns: np.ndarray: Quaternion derivative, shape (4,) \"\"\" q = check_quaternion(q) x, y, z, w = q GT = np.array([[w, z, -y], [-z, w, x], [y, -x, w], [-x, -y, -z]]) return (1 / 2) * GT @ omega quaternion_diff def quaternion_diff ( q1 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], q2 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Gives the quaternion representing the rotation from q1 -> q2 Parameters: Name Type Description Default q1 npt.ArrayLike Starting XYZW quaternion, shape (4,) None q2 npt.ArrayLike Ending XYZW quaternion, shape (4,) None Returns: Type Description np.ndarray XYZW quaternion, shape (4,) View Source def quaternion_diff ( q1 : npt . ArrayLike , q2 : npt . ArrayLike ) -> np . ndarray : \"\"\"Gives the quaternion representing the rotation from q1 -> q2 Args: q1 (npt.ArrayLike): Starting XYZW quaternion, shape (4,) q2 (npt.ArrayLike): Ending XYZW quaternion, shape (4,) Returns: np.ndarray: XYZW quaternion, shape (4,) \"\"\" return combine_quaternions ( q2 , conjugate ( q1 )) quaternion_dist def quaternion_dist ( q1 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], q2 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> float Computes the distance between two quaternions Parameters: Name Type Description Default q1 npt.ArrayLike XYZW quaternion, shape (4,) None q2 npt.ArrayLike A second XYZW quaternion, shape (4,) None Returns: Type Description float Distance between the two quaternions View Source def quaternion_dist ( q1 : npt . ArrayLike , q2 : npt . ArrayLike ) -> float : \"\"\"Computes the distance between two quaternions Args: q1 (npt.ArrayLike): XYZW quaternion, shape (4,) q2 (npt.ArrayLike): A second XYZW quaternion, shape (4,) Returns: float: Distance between the two quaternions \"\"\" wxyz_1 = xyzw_to_wxyz ( q1 ) wxyz_2 = xyzw_to_wxyz ( q2 ) return rt . quaternion_dist ( wxyz_1 , wxyz_2 ) quaternion_integration def quaternion_integration ( q : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], w : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], dt : float ) -> numpy . ndarray Propagate a quaternion forward one timestep based on the current angular velocity Parameters: Name Type Description Default q npt.ArrayLike Initial XYZW quaternion, shape (4,) None w npt.ArrayLike Angular velocity (wx, wy, wz), shape (3,) None dt float Timestep duration (seconds) None Returns: Type Description np.ndarray Next XYZW quaternion, q(t + dt), shape (4,) View Source def quaternion_integration(q: npt.ArrayLike, w: npt.ArrayLike, dt: float) -> np.ndarray: \"\"\"Propagate a quaternion forward one timestep based on the current angular velocity Args: q (npt.ArrayLike): Initial XYZW quaternion, shape (4,) w (npt.ArrayLike): Angular velocity (wx, wy, wz), shape (3,) dt (float): Timestep duration (seconds) Returns: np.ndarray: Next XYZW quaternion, q(t + dt), shape (4,) \"\"\" q = check_quaternion(q) return normalize(q + dt * quaternion_derivative(q, w)) quaternion_slerp def quaternion_slerp ( q1 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], q2 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pct : Union [ float , numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Interpolates between two quaternions via SLERP (spherical linear interpolation) To interpolate at multiple points, pass in pcts as an array of interpolation percentages Parameters: Name Type Description Default q1 npt.ArrayLike Starting XYZW quaternion, shape (4,) None q2 npt.ArrayLike Ending XYZW quaternion, shape (4,) None pct Union[float, npt.ArrayLike] Percent(s) between start -> end, expressed as float(s) in [0, 1] None Returns: Type Description np.ndarray The interpolated XYZW quaternion(s), shape = (4,) or (n, 4) if interpolating at multiple points View Source def quaternion_slerp ( q1 : npt . ArrayLike , q2 : npt . ArrayLike , pct : Union [ float , npt . ArrayLike ], ) -> np . ndarray : \"\"\"Interpolates between two quaternions via SLERP (spherical linear interpolation) To interpolate at multiple points, pass in pcts as an array of interpolation percentages Args: q1 (npt.ArrayLike): Starting XYZW quaternion, shape (4,) q2 (npt.ArrayLike): Ending XYZW quaternion, shape (4,) pct (Union[float, npt.ArrayLike]): Percent(s) between start -> end, expressed as float(s) in [0, 1] Returns: np.ndarray: The interpolated XYZW quaternion(s), shape = (4,) or (n, 4) if interpolating at multiple points \"\"\" pct = np . atleast_1d ( pct ) n = len ( pct ) # Number of interpolation points if not ( np . all ( pct >= 0 ) and np . all ( pct <= 1 )): raise ValueError ( f \"Interpolation percentage(s) must be between 0 and 1.\\nGot: {pct}\" ) q1_wxyz = xyzw_to_wxyz ( q1 ) q2_wxyz = xyzw_to_wxyz ( q2 ) # The shortest path parameter does not add too much extra computation and should handle quaternion ambiguity well shortest_path = True # Simple conversion for one interpolation point , otherwise use batched process if n == 1 : wxyz_interp = rt . quaternion_slerp ( q1_wxyz , q2_wxyz , pct [ 0 ], shortest_path ) return wxyz_to_xyzw ( wxyz_interp ) else : wxyz_quats = brt . quaternion_slerp_batch ( q1_wxyz , q2_wxyz , pct , shortest_path ) xyzw_quats = np . zeros_like ( wxyz_quats ) xyzw_quats [:, : 3 ] = wxyz_quats [:, 1 :] # qx , qy , qz xyzw_quats [:, - 1 ] = wxyz_quats [:, 0 ] # qw return xyzw_quats # ( n , 4 ) quats_to_angular_velocities def quats_to_angular_velocities ( quats : numpy . ndarray , dt : Union [ float , numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Determines the angular velocities of a sequence of quaternions, for a given sampling time These angular velocities are defined in WORLD frame, not the robot's body-fixed frame For more info on frames, refer to https://github.com/dfki-ric/pytransform3d/discussions/249 Parameters: Name Type Description Default quats np.ndarray Sequence of XYZW quaternions, shape (n, 4) None dt Union[float, np.ndarray] Sampling time(s). If passing in an array of sampling times, this must be of length n None Returns: Type Description np.ndarray Angular velocities (wx, wy, wz), shape (n, 3) View Source def quats_to_angular_velocities ( quats : np . ndarray , dt : Union [ float , npt . ArrayLike ] ) -> np . ndarray : \"\"\"Determines the angular velocities of a sequence of quaternions, for a given sampling time - These angular velocities are defined in WORLD frame, not the robot's body-fixed frame - For more info on frames, refer to https://github.com/dfki-ric/pytransform3d/discussions/249 Args: quats (np.ndarray): Sequence of XYZW quaternions, shape (n, 4) dt (Union[float, np.ndarray]): Sampling time(s). If passing in an array of sampling times, this must be of length n Returns: np.ndarray: Angular velocities (wx, wy, wz), shape (n, 3) \"\"\" # Convert XYZW to WXYZ for pytransform3d compatibility wxyz_quats = xyzw_to_wxyz ( quats ) # Determine gradients based on timestep format (fixed timestep vs variable array) if np . ndim ( dt ) == 0 : grads = rt . quaternion_gradient ( wxyz_quats , dt ) else : grads = rt . quaternion_gradient ( wxyz_quats , 1 ) grads = grads / np . reshape ( dt , ( - 1 , 1 )) return grads random_quaternion def random_quaternion ( ) -> numpy . ndarray Generate a random, normalized quaternion Returns: Type Description np.ndarray XYZW quaternion, shape (4,) View Source def random_quaternion () -> np . ndarray : \"\"\"Generate a random, normalized quaternion Returns: np.ndarray: XYZW quaternion, shape (4,) \"\"\" q = np . random . rand ( 4 ) return q / np . linalg . norm ( q ) rotate def rotate ( p : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], q : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Rotates a point p by a quaternion q, using p' = qpq* Parameters: Name Type Description Default p npt.ArrayLike Point to rotate, shape (3,) None q npt.ArrayLike XYZW quaternion describing the rotation, shape (4,) None Returns: Type Description np.ndarray Rotated point, shape (3,) View Source def rotate ( p : npt . ArrayLike , q : npt . ArrayLike ) -> np . ndarray : \"\"\"Rotates a point p by a quaternion q, using p' = qpq * Args : p ( npt . ArrayLike ) : Point to rotate , shape ( 3 ,) q ( npt . ArrayLike ) : XYZW quaternion describing the rotation , shape ( 4 ,) Returns : np . ndarray : Rotated point , shape ( 3 ,) \"\"\" return (multiply(multiply(q, pure(p)), conjugate(q)))[:3] wxyz_to_xyzw def wxyz_to_xyzw ( quats : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Converts a WXYZ quaternion or array of quaternions to XYZW Parameters: Name Type Description Default quats npt.ArrayLike WXYZ quaternion(s), shape (4,) or (n, 4) None Returns: Type Description np.ndarray XYZW quaternions, shape (4,) or (n, 4) (same shape as input) View Source def wxyz_to_xyzw ( quats : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts a WXYZ quaternion or array of quaternions to XYZW Args: quats (npt.ArrayLike): WXYZ quaternion(s), shape (4,) or (n, 4) Returns: np.ndarray: XYZW quaternions, shape (4,) or (n, 4) (same shape as input) \"\"\" quats = np . asarray ( quats ) if quats . shape [ -1 ] != 4 : raise ValueError ( \"Invalid quaternion array: Must be of shape (4,) or (n, 4)\" ) idx = np . array ( [ 1, 2, 3, 0 ] ) if np . ndim ( quats ) == 1 : return quats [ idx ] else : return quats [ :, idx ] xyzw_to_wxyz def xyzw_to_wxyz ( quats : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Converts a XYZW quaternion or array of quaternions to WXYZ Parameters: Name Type Description Default quats npt.ArrayLike XYZW quaternion(s), shape (4,) or (n, 4) None Returns: Type Description np.ndarray WXYZ quaternions, shape (4,) or (n, 4) (same shape as input) View Source def xyzw_to_wxyz ( quats : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts a XYZW quaternion or array of quaternions to WXYZ Args: quats (npt.ArrayLike): XYZW quaternion(s), shape (4,) or (n, 4) Returns: np.ndarray: WXYZ quaternions, shape (4,) or (n, 4) (same shape as input) \"\"\" quats = np . asarray ( quats ) if quats . shape [ -1 ] != 4 : raise ValueError ( \"Invalid quaternion array: Must be of shape (4,) or (n, 4)\" ) idx = np . array ( [ 3, 0, 1, 2 ] ) if np . ndim ( quats ) == 1 : return quats [ idx ] else : return quats [ :, idx ]","title":"Quaternions"},{"location":"reference/pyastrobee/utils/quaternions/#module-pyastrobeeutilsquaternions","text":"Quaternion utilities We will always default to using XYZW convention View Source \"\"\"Quaternion utilities We will always default to using XYZW convention \"\"\" from typing import Union import numpy as np import numpy.typing as npt import pytransform3d.rotations as rt import pytransform3d.batch_rotations as brt from pyastrobee.utils.math_utils import normalize from pyastrobee.utils.rotations import ( axis_angle_between_two_vectors , axis_angle_to_quat , quat_to_rmat , ) def check_quaternion ( quat : npt . ArrayLike ) -> np . ndarray : \"\"\"Checks that a quaternion is of the correct shape and returns a normalized quat Args: quat (npt.ArrayLike): Quaternion (XYZW or WXYZ), shape (4,) Raises: ValueError: If the input is not a valid quaternion Returns: np.ndarray: Normalized quaternion, shape (4,) \"\"\" quat = np . ravel ( quat ) if len ( quat ) != 4 : raise ValueError ( f \"Invalid quaternion ( { quat } ): \\n Not of length 4!\" ) return normalize ( quat ) def random_quaternion () -> np . ndarray : \"\"\"Generate a random, normalized quaternion Returns: np.ndarray: XYZW quaternion, shape (4,) \"\"\" q = np . random . rand ( 4 ) return q / np . linalg . norm ( q ) def conjugate ( quat : npt . ArrayLike ) -> np . ndarray : \"\"\"Conjugate of an XYZW quaternion (same scalar part but flipped imaginary components) Args: quat (npt.ArrayLike): XYZW quaternion, shape (4,) Returns: np.ndarray: Conjugate XYZW quaternion, shape (4,) \"\"\" x , y , z , w = quat return np . array ([ - x , - y , - z , w ]) def quats_to_angular_velocities ( quats : np . ndarray , dt : Union [ float , npt . ArrayLike ] ) -> np . ndarray : \"\"\"Determines the angular velocities of a sequence of quaternions, for a given sampling time - These angular velocities are defined in WORLD frame, not the robot's body-fixed frame - For more info on frames, refer to https://github.com/dfki-ric/pytransform3d/discussions/249 Args: quats (np.ndarray): Sequence of XYZW quaternions, shape (n, 4) dt (Union[float, np.ndarray]): Sampling time(s). If passing in an array of sampling times, this must be of length n Returns: np.ndarray: Angular velocities (wx, wy, wz), shape (n, 3) \"\"\" # Convert XYZW to WXYZ for pytransform3d compatibility wxyz_quats = xyzw_to_wxyz ( quats ) # Determine gradients based on timestep format (fixed timestep vs variable array) if np . ndim ( dt ) == 0 : grads = rt . quaternion_gradient ( wxyz_quats , dt ) else : grads = rt . quaternion_gradient ( wxyz_quats , 1 ) grads = grads / np . reshape ( dt , ( - 1 , 1 )) return grads def xyzw_to_wxyz ( quats : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts a XYZW quaternion or array of quaternions to WXYZ Args: quats (npt.ArrayLike): XYZW quaternion(s), shape (4,) or (n, 4) Returns: np.ndarray: WXYZ quaternions, shape (4,) or (n, 4) (same shape as input) \"\"\" quats = np . asarray ( quats ) if quats . shape [ - 1 ] != 4 : raise ValueError ( \"Invalid quaternion array: Must be of shape (4,) or (n, 4)\" ) idx = np . array ([ 3 , 0 , 1 , 2 ]) if np . ndim ( quats ) == 1 : return quats [ idx ] else : return quats [:, idx ] def wxyz_to_xyzw ( quats : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts a WXYZ quaternion or array of quaternions to XYZW Args: quats (npt.ArrayLike): WXYZ quaternion(s), shape (4,) or (n, 4) Returns: np.ndarray: XYZW quaternions, shape (4,) or (n, 4) (same shape as input) \"\"\" quats = np . asarray ( quats ) if quats . shape [ - 1 ] != 4 : raise ValueError ( \"Invalid quaternion array: Must be of shape (4,) or (n, 4)\" ) idx = np . array ([ 1 , 2 , 3 , 0 ]) if np . ndim ( quats ) == 1 : return quats [ idx ] else : return quats [:, idx ] def quaternion_derivative ( q : npt . ArrayLike , omega : npt . ArrayLike ) -> np . ndarray : \"\"\"Quaternion derivative for a given world-frame angular velocity Args: q (npt.ArrayLike): XYZW quaternion, shape (4,) omega (npt.ArrayLike): Angular velocity (wx, wy, wz) in world frame, shape (3,) Returns: np.ndarray: Quaternion derivative, shape (4,) \"\"\" q = check_quaternion ( q ) x , y , z , w = q GT = np . array ([[ w , z , - y ], [ - z , w , x ], [ y , - x , w ], [ - x , - y , - z ]]) return ( 1 / 2 ) * GT @ omega def quaternion_integration ( q : npt . ArrayLike , w : npt . ArrayLike , dt : float ) -> np . ndarray : \"\"\"Propagate a quaternion forward one timestep based on the current angular velocity Args: q (npt.ArrayLike): Initial XYZW quaternion, shape (4,) w (npt.ArrayLike): Angular velocity (wx, wy, wz), shape (3,) dt (float): Timestep duration (seconds) Returns: np.ndarray: Next XYZW quaternion, q(t + dt), shape (4,) \"\"\" q = check_quaternion ( q ) return normalize ( q + dt * quaternion_derivative ( q , w )) def combine_quaternions ( q1 : npt . ArrayLike , q2 : npt . ArrayLike ) -> np . ndarray : \"\"\"Combines the angular representation of two quaternions Args: q1 (npt.ArrayLike): First XYZW quaternion, shape (4,) if passing in an array q2 (npt.ArrayLike): Second XYZW quaternion, shape (4,) if passing in an array Returns: np.ndarray: Combined XYZW quaternion, shape (4,) \"\"\" wxyz = rt . concatenate_quaternions ( xyzw_to_wxyz ( q1 ), xyzw_to_wxyz ( q2 )) return wxyz_to_xyzw ( wxyz ) def quaternion_between_two_vectors ( v1 : npt . ArrayLike , v2 : npt . ArrayLike ) -> np . ndarray : \"\"\"Gives the quaternion rotation that would rotate vector v1 to align with v2 (magnitude-independent) Args: v1 (npt.ArrayLike): (3,) Starting vector/direction v2 (npt.ArrayLike): (3,) Ending vector/direction Returns: np.ndarray: (4,) XYZW quaternion \"\"\" axis , angle = axis_angle_between_two_vectors ( v1 , v2 ) return axis_angle_to_quat ( axis , angle ) def get_closest_heading_quat ( q0 : npt . ArrayLike , heading : npt . ArrayLike ) -> np . ndarray : \"\"\"Gives the quaternion closest to q0 that has its x-axis aligned with the heading Args: q0 (npt.ArrayLike): Initial (reference) XYZW quaternion, shape (4,) heading (npt.ArrayLike): Desired XYZ vector parallel to the new frame's x-axis, shape (3,) Returns: np.ndarray: XYZW quaternion, shape (4,) \"\"\" # We want the x axis to point along the heading axis # So, a rotation between these two axes can be defined by an axis-angle rotation # We can then apply this rotation transformation via quaternion concatenation rmat1 = quat_to_rmat ( q0 ) orig_x_axis = rmat1 [:, 0 ] rotation_quat = quaternion_between_two_vectors ( orig_x_axis , heading ) return combine_quaternions ( rotation_quat , q0 ) def quaternion_slerp ( q1 : npt . ArrayLike , q2 : npt . ArrayLike , pct : Union [ float , npt . ArrayLike ], ) -> np . ndarray : \"\"\"Interpolates between two quaternions via SLERP (spherical linear interpolation) To interpolate at multiple points, pass in pcts as an array of interpolation percentages Args: q1 (npt.ArrayLike): Starting XYZW quaternion, shape (4,) q2 (npt.ArrayLike): Ending XYZW quaternion, shape (4,) pct (Union[float, npt.ArrayLike]): Percent(s) between start -> end, expressed as float(s) in [0, 1] Returns: np.ndarray: The interpolated XYZW quaternion(s), shape = (4,) or (n, 4) if interpolating at multiple points \"\"\" pct = np . atleast_1d ( pct ) n = len ( pct ) # Number of interpolation points if not ( np . all ( pct >= 0 ) and np . all ( pct <= 1 )): raise ValueError ( f \"Interpolation percentage(s) must be between 0 and 1. \\n Got: { pct } \" ) q1_wxyz = xyzw_to_wxyz ( q1 ) q2_wxyz = xyzw_to_wxyz ( q2 ) # The shortest path parameter does not add too much extra computation and should handle quaternion ambiguity well shortest_path = True # Simple conversion for one interpolation point, otherwise use batched process if n == 1 : wxyz_interp = rt . quaternion_slerp ( q1_wxyz , q2_wxyz , pct [ 0 ], shortest_path ) return wxyz_to_xyzw ( wxyz_interp ) else : wxyz_quats = brt . quaternion_slerp_batch ( q1_wxyz , q2_wxyz , pct , shortest_path ) xyzw_quats = np . zeros_like ( wxyz_quats ) xyzw_quats [:, : 3 ] = wxyz_quats [:, 1 :] # qx, qy, qz xyzw_quats [:, - 1 ] = wxyz_quats [:, 0 ] # qw return xyzw_quats # (n, 4) def quaternion_dist ( q1 : npt . ArrayLike , q2 : npt . ArrayLike ) -> float : \"\"\"Computes the distance between two quaternions Args: q1 (npt.ArrayLike): XYZW quaternion, shape (4,) q2 (npt.ArrayLike): A second XYZW quaternion, shape (4,) Returns: float: Distance between the two quaternions \"\"\" wxyz_1 = xyzw_to_wxyz ( q1 ) wxyz_2 = xyzw_to_wxyz ( q2 ) return rt . quaternion_dist ( wxyz_1 , wxyz_2 ) def quaternion_diff ( q1 : npt . ArrayLike , q2 : npt . ArrayLike ) -> np . ndarray : \"\"\"Gives the quaternion representing the rotation from q1 -> q2 Args: q1 (npt.ArrayLike): Starting XYZW quaternion, shape (4,) q2 (npt.ArrayLike): Ending XYZW quaternion, shape (4,) Returns: np.ndarray: XYZW quaternion, shape (4,) \"\"\" return combine_quaternions ( q2 , conjugate ( q1 )) def quaternion_angular_error ( q : npt . ArrayLike , q_des : npt . ArrayLike ) -> np . ndarray : \"\"\"Gives the instantaneous angular error between two quaternions (q w.r.t q_des) - This is similar (but not the same) as a difference between fixed-XYZ conventions (for small angles, these are very close). - This error is defined in WORLD frame, not the robot's body-fixed frame Args: q (npt.ArrayLike): Current XYZW quaternion, shape (4,) q_des (npt.ArrayLike): Desired XYZW quaternion, shape (4,) Returns: np.ndarray: Instantaneous angular error, shape (3,) \"\"\" q = check_quaternion ( q ) q_des = check_quaternion ( q_des ) x , y , z , w = q return 2 * np . array ([[ - w , z , - y , x ], [ - z , - w , x , y ], [ y , - x , - w , z ]]) @ q_des def exponential_map ( v : npt . ArrayLike ) -> np . ndarray : \"\"\"Exponential map: Lie algebra to quaternion Args: v (npt.ArrayLike): Vector on the Lie algebra, shape (3,) Returns: np.ndarray: XYZW quaternion, shape (4,) \"\"\" wxyz = rt . quaternion_from_compact_axis_angle ( v ) return wxyz_to_xyzw ( wxyz ) def log_map ( q : npt . ArrayLike ) -> np . ndarray : \"\"\"Logarithmic map: XYZW quaternion to Lie algebra Args: q (npt.ArrayLike): XYZW quaternion to map Returns: np.ndarray: Vector on the Lie algebra, shape (3,) \"\"\" return rt . compact_axis_angle_from_quaternion ( xyzw_to_wxyz ( q )) def pure ( v : npt . ArrayLike ) -> np . ndarray : \"\"\"Convert a vector component into a pure XYZW quaternion (no scalar component) NOTE: The quaternion returned WILL NOT be normalized in general. But, it is often useful to use this construction so that we can compose multiplications with angular velocity, for instance Args: v (npt.ArrayLike): Vector component, shape (3,) Returns: np.ndarray: XYZW quaternion (NOT NORMALIZED), shape (4,) \"\"\" if len ( v ) != 3 : raise ValueError ( \"Invalid vector component of pure quaternion. Must be shape (3,)\" ) return np . array ([ * v , 0 ]) # Alternatively, can implement this with pytransform's concatenate_quaternions function def multiply ( q1 : npt . ArrayLike , q2 : npt . ArrayLike ) -> np . ndarray : \"\"\"Multiply two XYZW quaternions Args: q1 (npt.ArrayLike): First XYZW quaternion q2 (npt.ArrayLike): Second XYZW quaternion Returns: np.ndarray: XYZW quaternion, shape (4,) \"\"\" x1 , y1 , z1 , w1 = q1 x2 , y2 , z2 , w2 = q2 return np . array ( [ w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2 , w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2 , w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2 , w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2 , ] ) def rotate ( p : npt . ArrayLike , q : npt . ArrayLike ) -> np . ndarray : \"\"\"Rotates a point p by a quaternion q, using p' = qpq* Args: p (npt.ArrayLike): Point to rotate, shape (3,) q (npt.ArrayLike): XYZW quaternion describing the rotation, shape (4,) Returns: np.ndarray: Rotated point, shape (3,) \"\"\" return ( multiply ( multiply ( q , pure ( p )), conjugate ( q )))[: 3 ]","title":"Module pyastrobee.utils.quaternions"},{"location":"reference/pyastrobee/utils/quaternions/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/utils/quaternions/#check_quaternion","text":"def check_quaternion ( quat : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Checks that a quaternion is of the correct shape and returns a normalized quat Parameters: Name Type Description Default quat npt.ArrayLike Quaternion (XYZW or WXYZ), shape (4,) None Returns: Type Description np.ndarray Normalized quaternion, shape (4,) Raises: Type Description ValueError If the input is not a valid quaternion View Source def check_quaternion ( quat : npt . ArrayLike ) -> np . ndarray : \"\"\"Checks that a quaternion is of the correct shape and returns a normalized quat Args: quat (npt.ArrayLike): Quaternion (XYZW or WXYZ), shape (4,) Raises: ValueError: If the input is not a valid quaternion Returns: np.ndarray: Normalized quaternion, shape (4,) \"\"\" quat = np . ravel ( quat ) if len ( quat ) != 4 : raise ValueError ( f \"Invalid quaternion ({quat}):\\nNot of length 4!\" ) return normalize ( quat )","title":"check_quaternion"},{"location":"reference/pyastrobee/utils/quaternions/#combine_quaternions","text":"def combine_quaternions ( q1 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], q2 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Combines the angular representation of two quaternions Parameters: Name Type Description Default q1 npt.ArrayLike First XYZW quaternion, shape (4,) if passing in an array None q2 npt.ArrayLike Second XYZW quaternion, shape (4,) if passing in an array None Returns: Type Description np.ndarray Combined XYZW quaternion, shape (4,) View Source def combine_quaternions ( q1 : npt . ArrayLike , q2 : npt . ArrayLike ) -> np . ndarray : \"\"\"Combines the angular representation of two quaternions Args: q1 (npt.ArrayLike): First XYZW quaternion, shape (4,) if passing in an array q2 (npt.ArrayLike): Second XYZW quaternion, shape (4,) if passing in an array Returns: np.ndarray: Combined XYZW quaternion, shape (4,) \"\"\" wxyz = rt . concatenate_quaternions ( xyzw_to_wxyz ( q1 ), xyzw_to_wxyz ( q2 )) return wxyz_to_xyzw ( wxyz )","title":"combine_quaternions"},{"location":"reference/pyastrobee/utils/quaternions/#conjugate","text":"def conjugate ( quat : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Conjugate of an XYZW quaternion (same scalar part but flipped imaginary components) Parameters: Name Type Description Default quat npt.ArrayLike XYZW quaternion, shape (4,) None Returns: Type Description np.ndarray Conjugate XYZW quaternion, shape (4,) View Source def conjugate ( quat : npt . ArrayLike ) -> np . ndarray : \"\"\"Conjugate of an XYZW quaternion (same scalar part but flipped imaginary components) Args: quat (npt.ArrayLike): XYZW quaternion, shape (4,) Returns: np.ndarray: Conjugate XYZW quaternion, shape (4,) \"\"\" x , y , z , w = quat return np . array ([ - x , - y , - z , w ])","title":"conjugate"},{"location":"reference/pyastrobee/utils/quaternions/#exponential_map","text":"def exponential_map ( v : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Exponential map: Lie algebra to quaternion Parameters: Name Type Description Default v npt.ArrayLike Vector on the Lie algebra, shape (3,) None Returns: Type Description np.ndarray XYZW quaternion, shape (4,) View Source def exponential_map ( v : npt . ArrayLike ) -> np . ndarray : \"\"\"Exponential map: Lie algebra to quaternion Args: v (npt.ArrayLike): Vector on the Lie algebra, shape (3,) Returns: np.ndarray: XYZW quaternion, shape (4,) \"\"\" wxyz = rt . quaternion_from_compact_axis_angle ( v ) return wxyz_to_xyzw ( wxyz )","title":"exponential_map"},{"location":"reference/pyastrobee/utils/quaternions/#get_closest_heading_quat","text":"def get_closest_heading_quat ( q0 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], heading : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Gives the quaternion closest to q0 that has its x-axis aligned with the heading Parameters: Name Type Description Default q0 npt.ArrayLike Initial (reference) XYZW quaternion, shape (4,) None heading npt.ArrayLike Desired XYZ vector parallel to the new frame's x-axis, shape (3,) None Returns: Type Description np.ndarray XYZW quaternion, shape (4,) View Source def get_closest_heading_quat ( q0 : npt . ArrayLike , heading : npt . ArrayLike ) -> np . ndarray : \"\"\"Gives the quaternion closest to q0 that has its x-axis aligned with the heading Args: q0 (npt.ArrayLike): Initial (reference) XYZW quaternion, shape (4,) heading (npt.ArrayLike): Desired XYZ vector parallel to the new frame' s x - axis , shape ( 3 ,) Returns : np . ndarray : XYZW quaternion , shape ( 4 ,) \"\"\" # We want the x axis to point along the heading axis # So, a rotation between these two axes can be defined by an axis-angle rotation # We can then apply this rotation transformation via quaternion concatenation rmat1 = quat_to_rmat(q0) orig_x_axis = rmat1[:, 0] rotation_quat = quaternion_between_two_vectors(orig_x_axis, heading) return combine_quaternions(rotation_quat, q0)","title":"get_closest_heading_quat"},{"location":"reference/pyastrobee/utils/quaternions/#log_map","text":"def log_map ( q : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Logarithmic map: XYZW quaternion to Lie algebra Parameters: Name Type Description Default q npt.ArrayLike XYZW quaternion to map None Returns: Type Description np.ndarray Vector on the Lie algebra, shape (3,) View Source def log_map ( q : npt . ArrayLike ) -> np . ndarray : \"\"\"Logarithmic map: XYZW quaternion to Lie algebra Args: q (npt.ArrayLike): XYZW quaternion to map Returns: np.ndarray: Vector on the Lie algebra, shape (3,) \"\"\" return rt . compact_axis_angle_from_quaternion ( xyzw_to_wxyz ( q ))","title":"log_map"},{"location":"reference/pyastrobee/utils/quaternions/#multiply","text":"def multiply ( q1 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], q2 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Multiply two XYZW quaternions Parameters: Name Type Description Default q1 npt.ArrayLike First XYZW quaternion None q2 npt.ArrayLike Second XYZW quaternion None Returns: Type Description np.ndarray XYZW quaternion, shape (4,) View Source def multiply ( q1 : npt . ArrayLike , q2 : npt . ArrayLike ) -> np . ndarray : \"\"\"Multiply two XYZW quaternions Args: q1 (npt.ArrayLike): First XYZW quaternion q2 (npt.ArrayLike): Second XYZW quaternion Returns: np.ndarray: XYZW quaternion, shape (4,) \"\"\" x1 , y1 , z1 , w1 = q1 x2 , y2 , z2 , w2 = q2 return np . array ( [ w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2 , w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2 , w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2 , w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2 , ] )","title":"multiply"},{"location":"reference/pyastrobee/utils/quaternions/#pure","text":"def pure ( v : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Convert a vector component into a pure XYZW quaternion (no scalar component) NOTE: The quaternion returned WILL NOT be normalized in general. But, it is often useful to use this construction so that we can compose multiplications with angular velocity, for instance Parameters: Name Type Description Default v npt.ArrayLike Vector component, shape (3,) None Returns: Type Description np.ndarray XYZW quaternion (NOT NORMALIZED), shape (4,) View Source def pure ( v : npt . ArrayLike ) -> np . ndarray : \"\"\"Convert a vector component into a pure XYZW quaternion (no scalar component) NOTE: The quaternion returned WILL NOT be normalized in general. But, it is often useful to use this construction so that we can compose multiplications with angular velocity, for instance Args: v (npt.ArrayLike): Vector component, shape (3,) Returns: np.ndarray: XYZW quaternion (NOT NORMALIZED), shape (4,) \"\"\" if len ( v ) != 3 : raise ValueError ( \"Invalid vector component of pure quaternion. Must be shape (3,)\" ) return np . array ([ * v , 0 ])","title":"pure"},{"location":"reference/pyastrobee/utils/quaternions/#quaternion_angular_error","text":"def quaternion_angular_error ( q : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], q_des : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Gives the instantaneous angular error between two quaternions (q w.r.t q_des) This is similar (but not the same) as a difference between fixed-XYZ conventions (for small angles, these are very close). This error is defined in WORLD frame, not the robot's body-fixed frame Parameters: Name Type Description Default q npt.ArrayLike Current XYZW quaternion, shape (4,) None q_des npt.ArrayLike Desired XYZW quaternion, shape (4,) None Returns: Type Description np.ndarray Instantaneous angular error, shape (3,) View Source def quaternion_angular_error(q: npt.ArrayLike, q_des: npt.ArrayLike) -> np.ndarray: \"\"\"Gives the instantaneous angular error between two quaternions (q w.r.t q_des) - This is similar (but not the same) as a difference between fixed-XYZ conventions (for small angles, these are very close). - This error is defined in WORLD frame, not the robot's body-fixed frame Args: q (npt.ArrayLike): Current XYZW quaternion, shape (4,) q_des (npt.ArrayLike): Desired XYZW quaternion, shape (4,) Returns: np.ndarray: Instantaneous angular error, shape (3,) \"\"\" q = check_quaternion(q) q_des = check_quaternion(q_des) x, y, z, w = q return 2 * np.array([[-w, z, -y, x], [-z, -w, x, y], [y, -x, -w, z]]) @ q_des","title":"quaternion_angular_error"},{"location":"reference/pyastrobee/utils/quaternions/#quaternion_between_two_vectors","text":"def quaternion_between_two_vectors ( v1 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], v2 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Gives the quaternion rotation that would rotate vector v1 to align with v2 (magnitude-independent) Parameters: Name Type Description Default v1 npt.ArrayLike (3,) Starting vector/direction None v2 npt.ArrayLike (3,) Ending vector/direction None Returns: Type Description np.ndarray (4,) XYZW quaternion View Source def quaternion_between_two_vectors ( v1 : npt . ArrayLike , v2 : npt . ArrayLike ) -> np . ndarray : \"\"\"Gives the quaternion rotation that would rotate vector v1 to align with v2 (magnitude-independent) Args: v1 (npt.ArrayLike): (3,) Starting vector/direction v2 (npt.ArrayLike): (3,) Ending vector/direction Returns: np.ndarray: (4,) XYZW quaternion \"\"\" axis , angle = axis_angle_between_two_vectors ( v1 , v2 ) return axis_angle_to_quat ( axis , angle )","title":"quaternion_between_two_vectors"},{"location":"reference/pyastrobee/utils/quaternions/#quaternion_derivative","text":"def quaternion_derivative ( q : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], omega : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Quaternion derivative for a given world-frame angular velocity Parameters: Name Type Description Default q npt.ArrayLike XYZW quaternion, shape (4,) None omega npt.ArrayLike Angular velocity (wx, wy, wz) in world frame, shape (3,) None Returns: Type Description np.ndarray Quaternion derivative, shape (4,) View Source def quaternion_derivative(q: npt.ArrayLike, omega: npt.ArrayLike) -> np.ndarray: \"\"\"Quaternion derivative for a given world-frame angular velocity Args: q (npt.ArrayLike): XYZW quaternion, shape (4,) omega (npt.ArrayLike): Angular velocity (wx, wy, wz) in world frame, shape (3,) Returns: np.ndarray: Quaternion derivative, shape (4,) \"\"\" q = check_quaternion(q) x, y, z, w = q GT = np.array([[w, z, -y], [-z, w, x], [y, -x, w], [-x, -y, -z]]) return (1 / 2) * GT @ omega","title":"quaternion_derivative"},{"location":"reference/pyastrobee/utils/quaternions/#quaternion_diff","text":"def quaternion_diff ( q1 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], q2 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Gives the quaternion representing the rotation from q1 -> q2 Parameters: Name Type Description Default q1 npt.ArrayLike Starting XYZW quaternion, shape (4,) None q2 npt.ArrayLike Ending XYZW quaternion, shape (4,) None Returns: Type Description np.ndarray XYZW quaternion, shape (4,) View Source def quaternion_diff ( q1 : npt . ArrayLike , q2 : npt . ArrayLike ) -> np . ndarray : \"\"\"Gives the quaternion representing the rotation from q1 -> q2 Args: q1 (npt.ArrayLike): Starting XYZW quaternion, shape (4,) q2 (npt.ArrayLike): Ending XYZW quaternion, shape (4,) Returns: np.ndarray: XYZW quaternion, shape (4,) \"\"\" return combine_quaternions ( q2 , conjugate ( q1 ))","title":"quaternion_diff"},{"location":"reference/pyastrobee/utils/quaternions/#quaternion_dist","text":"def quaternion_dist ( q1 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], q2 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> float Computes the distance between two quaternions Parameters: Name Type Description Default q1 npt.ArrayLike XYZW quaternion, shape (4,) None q2 npt.ArrayLike A second XYZW quaternion, shape (4,) None Returns: Type Description float Distance between the two quaternions View Source def quaternion_dist ( q1 : npt . ArrayLike , q2 : npt . ArrayLike ) -> float : \"\"\"Computes the distance between two quaternions Args: q1 (npt.ArrayLike): XYZW quaternion, shape (4,) q2 (npt.ArrayLike): A second XYZW quaternion, shape (4,) Returns: float: Distance between the two quaternions \"\"\" wxyz_1 = xyzw_to_wxyz ( q1 ) wxyz_2 = xyzw_to_wxyz ( q2 ) return rt . quaternion_dist ( wxyz_1 , wxyz_2 )","title":"quaternion_dist"},{"location":"reference/pyastrobee/utils/quaternions/#quaternion_integration","text":"def quaternion_integration ( q : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], w : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], dt : float ) -> numpy . ndarray Propagate a quaternion forward one timestep based on the current angular velocity Parameters: Name Type Description Default q npt.ArrayLike Initial XYZW quaternion, shape (4,) None w npt.ArrayLike Angular velocity (wx, wy, wz), shape (3,) None dt float Timestep duration (seconds) None Returns: Type Description np.ndarray Next XYZW quaternion, q(t + dt), shape (4,) View Source def quaternion_integration(q: npt.ArrayLike, w: npt.ArrayLike, dt: float) -> np.ndarray: \"\"\"Propagate a quaternion forward one timestep based on the current angular velocity Args: q (npt.ArrayLike): Initial XYZW quaternion, shape (4,) w (npt.ArrayLike): Angular velocity (wx, wy, wz), shape (3,) dt (float): Timestep duration (seconds) Returns: np.ndarray: Next XYZW quaternion, q(t + dt), shape (4,) \"\"\" q = check_quaternion(q) return normalize(q + dt * quaternion_derivative(q, w))","title":"quaternion_integration"},{"location":"reference/pyastrobee/utils/quaternions/#quaternion_slerp","text":"def quaternion_slerp ( q1 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], q2 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], pct : Union [ float , numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Interpolates between two quaternions via SLERP (spherical linear interpolation) To interpolate at multiple points, pass in pcts as an array of interpolation percentages Parameters: Name Type Description Default q1 npt.ArrayLike Starting XYZW quaternion, shape (4,) None q2 npt.ArrayLike Ending XYZW quaternion, shape (4,) None pct Union[float, npt.ArrayLike] Percent(s) between start -> end, expressed as float(s) in [0, 1] None Returns: Type Description np.ndarray The interpolated XYZW quaternion(s), shape = (4,) or (n, 4) if interpolating at multiple points View Source def quaternion_slerp ( q1 : npt . ArrayLike , q2 : npt . ArrayLike , pct : Union [ float , npt . ArrayLike ], ) -> np . ndarray : \"\"\"Interpolates between two quaternions via SLERP (spherical linear interpolation) To interpolate at multiple points, pass in pcts as an array of interpolation percentages Args: q1 (npt.ArrayLike): Starting XYZW quaternion, shape (4,) q2 (npt.ArrayLike): Ending XYZW quaternion, shape (4,) pct (Union[float, npt.ArrayLike]): Percent(s) between start -> end, expressed as float(s) in [0, 1] Returns: np.ndarray: The interpolated XYZW quaternion(s), shape = (4,) or (n, 4) if interpolating at multiple points \"\"\" pct = np . atleast_1d ( pct ) n = len ( pct ) # Number of interpolation points if not ( np . all ( pct >= 0 ) and np . all ( pct <= 1 )): raise ValueError ( f \"Interpolation percentage(s) must be between 0 and 1.\\nGot: {pct}\" ) q1_wxyz = xyzw_to_wxyz ( q1 ) q2_wxyz = xyzw_to_wxyz ( q2 ) # The shortest path parameter does not add too much extra computation and should handle quaternion ambiguity well shortest_path = True # Simple conversion for one interpolation point , otherwise use batched process if n == 1 : wxyz_interp = rt . quaternion_slerp ( q1_wxyz , q2_wxyz , pct [ 0 ], shortest_path ) return wxyz_to_xyzw ( wxyz_interp ) else : wxyz_quats = brt . quaternion_slerp_batch ( q1_wxyz , q2_wxyz , pct , shortest_path ) xyzw_quats = np . zeros_like ( wxyz_quats ) xyzw_quats [:, : 3 ] = wxyz_quats [:, 1 :] # qx , qy , qz xyzw_quats [:, - 1 ] = wxyz_quats [:, 0 ] # qw return xyzw_quats # ( n , 4 )","title":"quaternion_slerp"},{"location":"reference/pyastrobee/utils/quaternions/#quats_to_angular_velocities","text":"def quats_to_angular_velocities ( quats : numpy . ndarray , dt : Union [ float , numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Determines the angular velocities of a sequence of quaternions, for a given sampling time These angular velocities are defined in WORLD frame, not the robot's body-fixed frame For more info on frames, refer to https://github.com/dfki-ric/pytransform3d/discussions/249 Parameters: Name Type Description Default quats np.ndarray Sequence of XYZW quaternions, shape (n, 4) None dt Union[float, np.ndarray] Sampling time(s). If passing in an array of sampling times, this must be of length n None Returns: Type Description np.ndarray Angular velocities (wx, wy, wz), shape (n, 3) View Source def quats_to_angular_velocities ( quats : np . ndarray , dt : Union [ float , npt . ArrayLike ] ) -> np . ndarray : \"\"\"Determines the angular velocities of a sequence of quaternions, for a given sampling time - These angular velocities are defined in WORLD frame, not the robot's body-fixed frame - For more info on frames, refer to https://github.com/dfki-ric/pytransform3d/discussions/249 Args: quats (np.ndarray): Sequence of XYZW quaternions, shape (n, 4) dt (Union[float, np.ndarray]): Sampling time(s). If passing in an array of sampling times, this must be of length n Returns: np.ndarray: Angular velocities (wx, wy, wz), shape (n, 3) \"\"\" # Convert XYZW to WXYZ for pytransform3d compatibility wxyz_quats = xyzw_to_wxyz ( quats ) # Determine gradients based on timestep format (fixed timestep vs variable array) if np . ndim ( dt ) == 0 : grads = rt . quaternion_gradient ( wxyz_quats , dt ) else : grads = rt . quaternion_gradient ( wxyz_quats , 1 ) grads = grads / np . reshape ( dt , ( - 1 , 1 )) return grads","title":"quats_to_angular_velocities"},{"location":"reference/pyastrobee/utils/quaternions/#random_quaternion","text":"def random_quaternion ( ) -> numpy . ndarray Generate a random, normalized quaternion Returns: Type Description np.ndarray XYZW quaternion, shape (4,) View Source def random_quaternion () -> np . ndarray : \"\"\"Generate a random, normalized quaternion Returns: np.ndarray: XYZW quaternion, shape (4,) \"\"\" q = np . random . rand ( 4 ) return q / np . linalg . norm ( q )","title":"random_quaternion"},{"location":"reference/pyastrobee/utils/quaternions/#rotate","text":"def rotate ( p : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], q : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Rotates a point p by a quaternion q, using p' = qpq* Parameters: Name Type Description Default p npt.ArrayLike Point to rotate, shape (3,) None q npt.ArrayLike XYZW quaternion describing the rotation, shape (4,) None Returns: Type Description np.ndarray Rotated point, shape (3,) View Source def rotate ( p : npt . ArrayLike , q : npt . ArrayLike ) -> np . ndarray : \"\"\"Rotates a point p by a quaternion q, using p' = qpq * Args : p ( npt . ArrayLike ) : Point to rotate , shape ( 3 ,) q ( npt . ArrayLike ) : XYZW quaternion describing the rotation , shape ( 4 ,) Returns : np . ndarray : Rotated point , shape ( 3 ,) \"\"\" return (multiply(multiply(q, pure(p)), conjugate(q)))[:3]","title":"rotate"},{"location":"reference/pyastrobee/utils/quaternions/#wxyz_to_xyzw","text":"def wxyz_to_xyzw ( quats : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Converts a WXYZ quaternion or array of quaternions to XYZW Parameters: Name Type Description Default quats npt.ArrayLike WXYZ quaternion(s), shape (4,) or (n, 4) None Returns: Type Description np.ndarray XYZW quaternions, shape (4,) or (n, 4) (same shape as input) View Source def wxyz_to_xyzw ( quats : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts a WXYZ quaternion or array of quaternions to XYZW Args: quats (npt.ArrayLike): WXYZ quaternion(s), shape (4,) or (n, 4) Returns: np.ndarray: XYZW quaternions, shape (4,) or (n, 4) (same shape as input) \"\"\" quats = np . asarray ( quats ) if quats . shape [ -1 ] != 4 : raise ValueError ( \"Invalid quaternion array: Must be of shape (4,) or (n, 4)\" ) idx = np . array ( [ 1, 2, 3, 0 ] ) if np . ndim ( quats ) == 1 : return quats [ idx ] else : return quats [ :, idx ]","title":"wxyz_to_xyzw"},{"location":"reference/pyastrobee/utils/quaternions/#xyzw_to_wxyz","text":"def xyzw_to_wxyz ( quats : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Converts a XYZW quaternion or array of quaternions to WXYZ Parameters: Name Type Description Default quats npt.ArrayLike XYZW quaternion(s), shape (4,) or (n, 4) None Returns: Type Description np.ndarray WXYZ quaternions, shape (4,) or (n, 4) (same shape as input) View Source def xyzw_to_wxyz ( quats : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts a XYZW quaternion or array of quaternions to WXYZ Args: quats (npt.ArrayLike): XYZW quaternion(s), shape (4,) or (n, 4) Returns: np.ndarray: WXYZ quaternions, shape (4,) or (n, 4) (same shape as input) \"\"\" quats = np . asarray ( quats ) if quats . shape [ -1 ] != 4 : raise ValueError ( \"Invalid quaternion array: Must be of shape (4,) or (n, 4)\" ) idx = np . array ( [ 3, 0, 1, 2 ] ) if np . ndim ( quats ) == 1 : return quats [ idx ] else : return quats [ :, idx ]","title":"xyzw_to_wxyz"},{"location":"reference/pyastrobee/utils/rotations/","text":"Module pyastrobee.utils.rotations Helper functions associated with rotations Notation for rotation matrices: A R B describes the orientation of frame B with respect to frame A. AKA \"B in A\", or \"B to A\" In code, this can be described as R_B_in_A or R_B2A The columns of this matrix are the unit vectors of B expressed in the coordinates A The rows of this matrix are the unit vectors of A expressed in the coordinates of B Operator vs mapping example, with Rx(theta) As an operator: Rx @ P will rotate point P by theta about the X axis As a mapping: Gives R_B_in_A (R_B2A), where frame B is rotated theta radians about A's X axis Composing rotations: A A B C R = R R R D B C D e.g. R_D2A = R_B2A @ R_C2B @ R_D2C Conventions: - Euler angles are in XYZ convention - Euler angles correspond to \"intrinsic\" convention in pytransform3d - Fixed angles are also XYZ convention - Fixed angles correspond to \"extrinsic\" convention in pytransform3d - Quaternions are in XYZW - Who uses XYZW? - NASA - ROS - Bullet/Pybullet - Who uses WXYZ? - Pytransform3d - Mujoco - We'll need to convert XYZW -> WXYZ for pytransform3d All angles are in radians View Source \"\"\"Helper functions associated with rotations Notation for rotation matrices: A R B describes the orientation of frame B with respect to frame A. AKA \" B in A \", or \" B to A \" In code, this can be described as R_B_in_A or R_B2A The columns of this matrix are the unit vectors of B expressed in the coordinates A The rows of this matrix are the unit vectors of A expressed in the coordinates of B Operator vs mapping example, with Rx(theta) As an operator: Rx @ P will rotate point P by theta about the X axis As a mapping: Gives R_B_in_A (R_B2A), where frame B is rotated theta radians about A's X axis Composing rotations: A A B C R = R R R D B C D e.g. R_D2A = R_B2A @ R_C2B @ R_D2C Conventions: - Euler angles are in XYZ convention - Euler angles correspond to \" intrinsic \" convention in pytransform3d - Fixed angles are also XYZ convention - Fixed angles correspond to \" extrinsic \" convention in pytransform3d - Quaternions are in XYZW - Who uses XYZW? - NASA - ROS - Bullet/Pybullet - Who uses WXYZ? - Pytransform3d - Mujoco - We'll need to convert XYZW -> WXYZ for pytransform3d All angles are in radians \"\"\" import numpy as np import numpy . typing as npt import pytransform3d . rotations as rt # Parameters to clarify meaning of pytransform3d inputs _ EULER = 0 _ FIXED = 1 _ X = 0 _ Y = 1 _ Z = 2 def Rx ( theta : float ) -> np . ndarray : \"\"\"Rotation matrix for a rotation by theta radians about the X axis Args: theta (float): Rotation angle about the X axis (radians) Returns: np.ndarray: The associated (3,3) rotation matrix \"\"\" return rt . matrix_from_euler ([ theta , 0 , 0 ], _ X , _ Y , _ Z , _ EULER ) def Ry ( theta : float ) -> np . ndarray : \"\"\"Rotation matrix for a rotation by theta radians about the Y axis Args: theta (float): Rotation angle about the Y axis (radians) Returns: np.ndarray: The associated (3,3) rotation matrix \"\"\" return rt . matrix_from_euler ([ 0 , theta , 0 ], _ X , _ Y , _ Z , _ EULER ) def Rz ( theta : float ) -> np . ndarray : \"\"\"Rotation matrix for a rotation by theta radians about the Z axis Args: theta (float): Rotation angle about the Z axis (radians) Returns: np.ndarray: The associated (3,3) rotation matrix \"\"\" return rt . matrix_from_euler ([ 0 , 0 , theta ], _ X , _ Y , _ Z , _ EULER ) def euler_xyz_to_rmat ( angles : npt . ArrayLike ) -> np . ndarray : \"\"\"Euler XYZ 3-angle rotation matrix Operations will be in the following order: 1) Starting with frame A, rotate by the first angle about X_A to obtain intermediate frame B' 2) Rotate by the second angle about Y_B' to obtain intermediate frame B'' 3) Rotate by the third angle about Z_B'' to obtain B Args: angles (npt.ArrayLike): Three angles (radians) corresponding to the XYZ rotations Returns: np.ndarray: R_B2A, where frame B is composed by three rotations in XYZ order starting from frame A \"\"\" if len ( angles ) ! = 3 : raise ValueError ( f \"Must provide 3 angles.\\nGot:{angles}\" ) return rt . matrix_from_euler ( angles , _ X , _ Y , _ Z , _ EULER ) def fixed_xyz_to_rmat ( angles : npt . ArrayLike ) -> np . ndarray : \"\"\"Fixed XYZ 3-angle rotation matrix Operations will be in the following order: 1) Rotate by the first angle about X_A 2) Rotate by the second angle about Y_A 3) Rotate by the third angle about Z_A (This differs from Euler angles, as the rotation is not about the intermediate frames) Args: angles (npt.ArrayLike): Three angles (radians) corresponding to the XYZ rotations Returns: np.ndarray: R_B2A, where frame B is composed by three rotations in XYZ order starting from frame A \"\"\" return rt . matrix_from_euler ( angles , _ X , _ Y , _ Z , _ FIXED ) def rmat_to_axis_angle ( rmat : np . ndarray ) -> tuple [ np . ndarray , float ] : \"\"\"Converts a rotation matrix into an axis-angle representation Args: rmat (np.ndarray): (3, 3) rotation matrix Returns: tuple[np.ndarray, float]: np.ndarray: Axis of rotation. Shape (3,) float: Rotation angle, in radians \"\"\" axis_and_angle = rt . axis_angle_from_matrix ( rmat ) axis = axis_and_angle [ : 3 ] angle = axis_and_angle [ 3 ] return axis , angle def axis_angle_to_rmat ( axis : list [ float ], angle : float ) -> np . ndarray : \"\"\"Converts an axis-angle representation to a rotation matrix Args: axis (list[float]): Axis to rotate around: [x, y, z] angle (float): Angle to rotate (radians) Returns: np.ndarray: Rotation matrix equivalent for the axis-angle representation \"\"\" axis_and_angle = np . concatenate ([ axis , [ angle ]]) return rt . matrix_from_axis_angle ( axis_and_angle ) def custom_euler_to_rmat ( convention : str , angles : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts euler angles of a specified convention (like 'zyx') to a rotation matrix Use this if a convention other than XYZ is needed Args: convention (str): Axis order for the three rotations: Must be some length=3 permutation of 'xyz' - e.g. 'zyx', 'yxy', ... angles (npt.ArrayLike): Rotation angles, length = 3 Raises: ValueError: If the convention or the angles are not of length 3, or if the convention does not strictly contain just \" x \", \" y \", or \" z \" Returns: np.ndarray: (3, 3) rotation matrix \"\"\" if not len ( convention ) == 3 : raise ValueError ( f \"Convention should be length 3.\\nGot: {convention}\" ) if not len ( angles ) == 3 : raise ValueError ( f \"Angles should be length 3.\\nGot: {angles}\" ) convention = convention . lower () if not all ( c in { \"x\" , \"y\" , \"z\" } for c in convention ) : raise ValueError ( f \"Convention must only include x, y, and z.\\nGot: {convention}\" ) ax_to_ind = { \"x\" : 0 , \"y\" : 1 , \"z\" : 2 } inds = [ ax_to_ind [ convention [ i ]] for i in range ( 3 )] return rt . matrix_from_euler ( angles , * inds , _ EULER ) def custom_fixed_to_rmat ( convention : str , angles : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts fixed angles of a specified convention (like 'zyx') to a rotation matrix Use this if a convention other than XYZ is needed Args: convention (str): Axis order for the three rotations: Must be some length=3 permutation of 'xyz' - e.g. 'zyx', 'yxy', ... angles (npt.ArrayLike): Rotation angles, length = 3 Raises: ValueError: If the convention or the angles are not of length 3, or if the convention does not strictly contain just \" x \", \" y \", or \" z \" Returns: np.ndarray: (3, 3) rotation matrix \"\"\" return custom_euler_to_rmat ( convention [ ::- 1 ], angles [ ::- 1 ]) def rmat_to_euler_xyz ( rmat : np . ndarray ) -> tuple [ float , float , float ] : \"\"\"Converts a rotation matrix to Euler XYZ angles Args: rmat (np.ndarray): (3,3) rotation matrix Returns: tuple[float, float, float]: XYZ Euler angles \"\"\" return rt . euler_from_matrix ( rmat , _ X , _ Y , _ Z , _ EULER ) def rmat_to_fixed_xyz ( rmat : np . ndarray ) -> tuple [ float , float , float ] : \"\"\"Converts a rotation matrix to Fixed XYZ angles Args: rmat (np.ndarray): (3,3) rotation matrix Returns: tuple[float, float, float]: XYZ Fixed angles \"\"\" return rt . euler_from_matrix ( rmat , _ X , _ Y , _ Z , _ FIXED ) def rmat_to_fixed_zyx ( rmat : np . ndarray ) -> tuple [ float , float , float ] : \"\"\"Converts a rotation matrix to Fixed ZYX angles Args: rmat (np.ndarray): (3,3) rotation matrix Returns: tuple[float, float, float]: ZYX Fixed angles \"\"\" return rt . euler_from_matrix ( rmat , _ Z , _ Y , _ X , _ FIXED ) def check_rotation_mat ( R : np . ndarray ) -> bool : \"\"\"Determines if a rotation matrix is valid (3x3, orthogonal, and determinant = 1) Args: R (np.ndarray): A rotation matrix Returns: bool: Whether or not R is a valid rotation matrix \"\"\" try : rt . check_matrix ( R , strict_check = True ) return True except ValueError : return False def quat_to_rmat ( quat : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts XYZW quaternions to a rotation matrix Args: quat (npt.ArrayLike): XYZW quaternion, shape (4,) Returns: np.ndarray: (3,3) rotation matrix \"\"\" return rt . matrix_from_quaternion ( xyzw_to_wxyz ( quat )) def rmat_to_quat ( rmat : np . ndarray ) -> np . ndarray : \"\"\"Converts a rotation matrix into XYZW quaternions NOTE: When computing a quaternion from the rotation matrix there is a sign ambiguity: q and -q represent the same rotation. (TODO: add a reference quaternion input to see which quaternion is closer, choose the sign accordingly?) Args: rmat (np.ndarray): (3,3) rotation matrix Returns: np.ndarray: XYZW quaternion, shape (4,) \"\"\" wxyz = rt . quaternion_from_matrix ( rmat ) return wxyz_to_xyzw ( wxyz ) def euler_xyz_to_quat ( angles : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts Euler XYZ angles to XYZW quaternions Args: angles (npt.ArrayLike): Angles (radians), length=3 Returns: np.ndarray: XYZW quaternion, shape (4,) \"\"\" if len ( angles ) ! = 3 : raise ValueError ( f \"Must provide 3 angles.\\nGot: {angles}\" ) wxyz = rt . quaternion_from_euler ( angles , _ X , _ Y , _ Z , _ EULER ) return wxyz_to_xyzw ( wxyz ) def fixed_xyz_to_quat ( angles : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts Fixed XYZ angles to XYZW quaternions Args: angles (npt.ArrayLike): Angles (radians), length=3 Returns: np.ndarray: XYZW quaternion, shape (4,) \"\"\" if len ( angles ) ! = 3 : raise ValueError ( f \"Must provide 3 angles.\\nGot: {angles}\" ) wxyz = rt . quaternion_from_euler ( angles , _ X , _ Y , _ Z , _ FIXED ) return wxyz_to_xyzw ( wxyz ) def quat_to_euler_xyz ( quat : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts XYZW quaternions to Euler XYZ angles Args: quat (npt.ArrayLike): XYZW quaternion, shape (4,) Returns: np.ndarray: (3,) Euler XYZ angles \"\"\" return rt . euler_from_quaternion ( xyzw_to_wxyz ( quat ), _ X , _ Y , _ Z , _ EULER ) def quat_to_fixed_xyz ( quat : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts XYZW quaternions to Fixed XYZ angles Args: quat (npt.ArrayLike): XYZW quaternion, shape (4,) Returns: np.ndarray: (3,) Fixed XYZ angles \"\"\" return rt . euler_from_quaternion ( xyzw_to_wxyz ( quat ), _ X , _ Y , _ Z , _ FIXED ) def axis_angle_between_two_vectors ( v1 : npt . ArrayLike , v2 : npt . ArrayLike ) -> tuple [ np . ndarray , float ] : \"\"\"Gives the axis/angle rotation that would rotate vector v1 to align with v2 (magnitude-independent) Args: v1 (npt.ArrayLike): (3,) Starting vector/direction v2 (npt.ArrayLike): (3,) Ending vector/direction Returns: tuple[np.ndarray, float]: np.ndarray: Axis of rotation. Shape (3,) float: Rotation angle, in radians \"\"\" axis_and_angle = rt . axis_angle_from_two_directions ( v1 , v2 ) return axis_and_angle [ : 3 ], axis_and_angle [ 3 ] def axis_angle_to_quat ( axis : npt . ArrayLike , angle : float ) -> np . ndarray : \"\"\"Converts an axis/angle rotation representation to XYZW quaternion Args: axis (npt.ArrayLike): Axis of rotation. Shape (3,) angle (float): Rotation angle, in radians Returns: np.ndarray: XYZW quaternion, shape (4,) \"\"\" wxyz = rt . quaternion_from_axis_angle ([ * axis , angle ]) return wxyz_to_xyzw ( wxyz ) def quat_to_axis_angle ( quat : npt . ArrayLike , ) -> tuple [ np . ndarray , float ] : \"\"\"Converts an XYZW quaternion to an axis/angle representation Args: quat (npt.ArrayLike): XYZW quaternion, shape (4,) Returns: tuple[np.ndarray, float]: np.ndarray: Axis of rotation. Shape (3,) float: Rotation angle, in radians \"\"\" axis_and_angle = rt . axis_angle_from_quaternion ( xyzw_to_wxyz ( quat )) axis = axis_and_angle [ : 3 ] angle = axis_and_angle [ 3 ] return axis , angle def compact_axis_angle ( axis : npt . ArrayLike , angle : float ) -> np . ndarray : \"\"\"Converts an axis/angle rotation into compact form (axis vector with a norm of the angle) Args: axis (npt.ArrayLike): Axis of rotation. Shape (3,) angle (float): Rotation angle, in radians Returns: np.ndarray: Compact axis/angle representation, shape (3,) \"\"\" axis = np . asarray ( axis ) if np . size ( axis ) ! = 3 or np . ndim ( angle ) ! = 0 : raise ValueError ( f \"Invalid axis/angle representation: {axis}, {angle}\" ) return ( angle / np . linalg . norm ( axis )) * axis # Quaternion helper functions copied here to prevent circular import def xyzw_to_wxyz ( quats : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts a XYZW quaternion or array of quaternions to WXYZ Args: quats (npt.ArrayLike): XYZW quaternion(s), shape (4,) or (n, 4) Returns: np.ndarray: WXYZ quaternions, shape (4,) or (n, 4) (same shape as input) \"\"\" quats = np . asarray ( quats ) if quats . shape [ - 1 ] ! = 4 : raise ValueError ( \"Invalid quaternion array: Must be of shape (4,) or (n, 4)\" ) idx = np . array ([ 3 , 0 , 1 , 2 ]) if np . ndim ( quats ) == 1 : return quats [ idx ] else : return quats [ : , idx ] def wxyz_to_xyzw ( quats : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts a WXYZ quaternion or array of quaternions to XYZW Args: quats (npt.ArrayLike): WXYZ quaternion(s), shape (4,) or (n, 4) Returns: np.ndarray: XYZW quaternions, shape (4,) or (n, 4) (same shape as input) \"\"\" quats = np . asarray ( quats ) if quats . shape [ - 1 ] ! = 4 : raise ValueError ( \"Invalid quaternion array: Must be of shape (4,) or (n, 4)\" ) idx = np . array ([ 1 , 2 , 3 , 0 ]) if np . ndim ( quats ) == 1 : return quats [ idx ] else : return quats [ : , idx ] Functions Rx def Rx ( theta : float ) -> numpy . ndarray Rotation matrix for a rotation by theta radians about the X axis Parameters: Name Type Description Default theta float Rotation angle about the X axis (radians) None Returns: Type Description np.ndarray The associated (3,3) rotation matrix View Source def Rx ( theta : float ) -> np . ndarray : \"\"\"Rotation matrix for a rotation by theta radians about the X axis Args: theta (float): Rotation angle about the X axis (radians) Returns: np.ndarray: The associated (3,3) rotation matrix \"\"\" return rt . matrix_from_euler ([ theta , 0 , 0 ], _X , _Y , _Z , _EULER ) Ry def Ry ( theta : float ) -> numpy . ndarray Rotation matrix for a rotation by theta radians about the Y axis Parameters: Name Type Description Default theta float Rotation angle about the Y axis (radians) None Returns: Type Description np.ndarray The associated (3,3) rotation matrix View Source def Ry ( theta : float ) -> np . ndarray : \"\"\"Rotation matrix for a rotation by theta radians about the Y axis Args: theta (float): Rotation angle about the Y axis (radians) Returns: np.ndarray: The associated (3,3) rotation matrix \"\"\" return rt . matrix_from_euler ([ 0 , theta , 0 ], _X , _Y , _Z , _EULER ) Rz def Rz ( theta : float ) -> numpy . ndarray Rotation matrix for a rotation by theta radians about the Z axis Parameters: Name Type Description Default theta float Rotation angle about the Z axis (radians) None Returns: Type Description np.ndarray The associated (3,3) rotation matrix View Source def Rz ( theta : float ) -> np . ndarray : \"\"\"Rotation matrix for a rotation by theta radians about the Z axis Args: theta (float): Rotation angle about the Z axis (radians) Returns: np.ndarray: The associated (3,3) rotation matrix \"\"\" return rt . matrix_from_euler ([ 0 , 0 , theta ], _X , _Y , _Z , _EULER ) axis_angle_between_two_vectors def axis_angle_between_two_vectors ( v1 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], v2 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> tuple [ numpy . ndarray , float ] Gives the axis/angle rotation that would rotate vector v1 to align with v2 (magnitude-independent) Parameters: Name Type Description Default v1 npt.ArrayLike (3,) Starting vector/direction None v2 npt.ArrayLike (3,) Ending vector/direction None Returns: Type Description tuple[np.ndarray, float] np.ndarray: Axis of rotation. Shape (3,) float: Rotation angle, in radians View Source def axis_angle_between_two_vectors ( v1 : npt . ArrayLike , v2 : npt . ArrayLike ) -> tuple [ np . ndarray , float ] : \"\"\"Gives the axis/angle rotation that would rotate vector v1 to align with v2 (magnitude-independent) Args: v1 (npt.ArrayLike): (3,) Starting vector/direction v2 (npt.ArrayLike): (3,) Ending vector/direction Returns: tuple[np.ndarray, float]: np.ndarray: Axis of rotation. Shape (3,) float: Rotation angle, in radians \"\"\" axis_and_angle = rt . axis_angle_from_two_directions ( v1 , v2 ) return axis_and_angle [ : 3 ], axis_and_angle [ 3 ] axis_angle_to_quat def axis_angle_to_quat ( axis : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], angle : float ) -> numpy . ndarray Converts an axis/angle rotation representation to XYZW quaternion Parameters: Name Type Description Default axis npt.ArrayLike Axis of rotation. Shape (3,) None angle float Rotation angle, in radians None Returns: Type Description np.ndarray XYZW quaternion, shape (4,) View Source def axis_angle_to_quat(axis: npt.ArrayLike, angle: float) -> np.ndarray: \"\"\"Converts an axis/angle rotation representation to XYZW quaternion Args: axis (npt.ArrayLike): Axis of rotation. Shape (3,) angle (float): Rotation angle, in radians Returns: np.ndarray: XYZW quaternion, shape (4,) \"\"\" wxyz = rt.quaternion_from_axis_angle([*axis, angle]) return wxyz_to_xyzw(wxyz) axis_angle_to_rmat def axis_angle_to_rmat ( axis : list [ float ], angle : float ) -> numpy . ndarray Converts an axis-angle representation to a rotation matrix Parameters: Name Type Description Default axis list[float] Axis to rotate around: [x, y, z] None angle float Angle to rotate (radians) None Returns: Type Description np.ndarray Rotation matrix equivalent for the axis-angle representation View Source def axis_angle_to_rmat ( axis : list [ float ] , angle : float ) -> np . ndarray : \"\"\"Converts an axis-angle representation to a rotation matrix Args: axis (list[float]): Axis to rotate around: [x, y, z] angle (float): Angle to rotate (radians) Returns: np.ndarray: Rotation matrix equivalent for the axis-angle representation \"\"\" axis_and_angle = np . concatenate ( [ axis, [angle ] ] ) return rt . matrix_from_axis_angle ( axis_and_angle ) check_rotation_mat def check_rotation_mat ( R : numpy . ndarray ) -> bool Determines if a rotation matrix is valid (3x3, orthogonal, and determinant = 1) Parameters: Name Type Description Default R np.ndarray A rotation matrix None Returns: Type Description bool Whether or not R is a valid rotation matrix View Source def check_rotation_mat ( R : np . ndarray ) -> bool : \"\"\"Determines if a rotation matrix is valid (3x3, orthogonal, and determinant = 1) Args: R (np.ndarray): A rotation matrix Returns: bool: Whether or not R is a valid rotation matrix \"\"\" try : rt . check_matrix ( R , strict_check = True ) return True except ValueError : return False compact_axis_angle def compact_axis_angle ( axis : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], angle : float ) -> numpy . ndarray Converts an axis/angle rotation into compact form (axis vector with a norm of the angle) Parameters: Name Type Description Default axis npt.ArrayLike Axis of rotation. Shape (3,) None angle float Rotation angle, in radians None Returns: Type Description np.ndarray Compact axis/angle representation, shape (3,) View Source def compact_axis_angle(axis: npt.ArrayLike, angle: float) -> np.ndarray: \"\"\"Converts an axis/angle rotation into compact form (axis vector with a norm of the angle) Args: axis (npt.ArrayLike): Axis of rotation. Shape (3,) angle (float): Rotation angle, in radians Returns: np.ndarray: Compact axis/angle representation, shape (3,) \"\"\" axis = np.asarray(axis) if np.size(axis) != 3 or np.ndim(angle) != 0: raise ValueError(f\"Invalid axis/angle representation: {axis}, {angle}\") return (angle / np.linalg.norm(axis)) * axis custom_euler_to_rmat def custom_euler_to_rmat ( convention : str , angles : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Converts euler angles of a specified convention (like 'zyx') to a rotation matrix Use this if a convention other than XYZ is needed Parameters: Name Type Description Default convention str Axis order for the three rotations: Must be some length=3 permutation of 'xyz' - e.g. 'zyx', 'yxy', ... None angles npt.ArrayLike Rotation angles, length = 3 None Returns: Type Description np.ndarray (3, 3) rotation matrix Raises: Type Description ValueError If the convention or the angles are not of length 3, or if the convention does not strictly contain just \"x\", \"y\", or \"z\" View Source def custom_euler_to_rmat ( convention : str , angles : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts euler angles of a specified convention (like 'zyx') to a rotation matrix Use this if a convention other than XYZ is needed Args: convention (str): Axis order for the three rotations: Must be some length=3 permutation of 'xyz' - e.g. 'zyx', 'yxy', ... angles (npt.ArrayLike): Rotation angles, length = 3 Raises: ValueError: If the convention or the angles are not of length 3, or if the convention does not strictly contain just \" x \", \" y \", or \" z \" Returns: np.ndarray: (3, 3) rotation matrix \"\"\" if not len ( convention ) == 3 : raise ValueError ( f \"Convention should be length 3.\\nGot: {convention}\" ) if not len ( angles ) == 3 : raise ValueError ( f \"Angles should be length 3.\\nGot: {angles}\" ) convention = convention . lower () if not all ( c in { \"x\" , \"y\" , \"z\" } for c in convention ) : raise ValueError ( f \"Convention must only include x, y, and z.\\nGot: {convention}\" ) ax_to_ind = { \"x\" : 0 , \"y\" : 1 , \"z\" : 2 } inds = [ ax_to_ind[convention[i ] ] for i in range ( 3 ) ] return rt . matrix_from_euler ( angles , * inds , _EULER ) custom_fixed_to_rmat def custom_fixed_to_rmat ( convention : str , angles : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Converts fixed angles of a specified convention (like 'zyx') to a rotation matrix Use this if a convention other than XYZ is needed Parameters: Name Type Description Default convention str Axis order for the three rotations: Must be some length=3 permutation of 'xyz' - e.g. 'zyx', 'yxy', ... None angles npt.ArrayLike Rotation angles, length = 3 None Returns: Type Description np.ndarray (3, 3) rotation matrix Raises: Type Description ValueError If the convention or the angles are not of length 3, or if the convention does not strictly contain just \"x\", \"y\", or \"z\" View Source def custom_fixed_to_rmat ( convention : str , angles : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts fixed angles of a specified convention (like 'zyx') to a rotation matrix Use this if a convention other than XYZ is needed Args: convention (str): Axis order for the three rotations: Must be some length=3 permutation of 'xyz' - e.g. 'zyx', 'yxy', ... angles (npt.ArrayLike): Rotation angles, length = 3 Raises: ValueError: If the convention or the angles are not of length 3, or if the convention does not strictly contain just \" x \", \" y \", or \" z \" Returns: np.ndarray: (3, 3) rotation matrix \"\"\" return custom_euler_to_rmat ( convention [ ::- 1 ], angles [ ::- 1 ]) euler_xyz_to_quat def euler_xyz_to_quat ( angles : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Converts Euler XYZ angles to XYZW quaternions Parameters: Name Type Description Default angles npt.ArrayLike Angles (radians), length=3 None Returns: Type Description np.ndarray XYZW quaternion, shape (4,) View Source def euler_xyz_to_quat ( angles : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts Euler XYZ angles to XYZW quaternions Args: angles (npt.ArrayLike): Angles (radians), length=3 Returns: np.ndarray: XYZW quaternion, shape (4,) \"\"\" if len ( angles ) != 3 : raise ValueError ( f \"Must provide 3 angles.\\nGot: {angles}\" ) wxyz = rt . quaternion_from_euler ( angles , _X , _Y , _Z , _EULER ) return wxyz_to_xyzw ( wxyz ) euler_xyz_to_rmat def euler_xyz_to_rmat ( angles : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Euler XYZ 3-angle rotation matrix Operations will be in the following order: 1) Starting with frame A, rotate by the first angle about X_A to obtain intermediate frame B' 2) Rotate by the second angle about Y_B' to obtain intermediate frame B'' 3) Rotate by the third angle about Z_B'' to obtain B Parameters: Name Type Description Default angles npt.ArrayLike Three angles (radians) corresponding to the XYZ rotations None Returns: Type Description np.ndarray R_B2A, where frame B is composed by three rotations in XYZ order starting from frame A View Source def euler_xyz_to_rmat ( angles : npt . ArrayLike ) -> np . ndarray : \"\"\"Euler XYZ 3-angle rotation matrix Operations will be in the following order: 1) Starting with frame A, rotate by the first angle about X_A to obtain intermediate frame B' 2 ) Rotate by the second angle about Y_B ' to obtain intermediate frame B'' 3) Rotate by the third angle about Z_B'' to obtain B Args: angles (npt.ArrayLike): Three angles (radians) corresponding to the XYZ rotations Returns: np.ndarray: R_B2A, where frame B is composed by three rotations in XYZ order starting from frame A \"\"\" if len ( angles ) != 3 : raise ValueError ( f \"Must provide 3 angles.\\nGot:{angles}\" ) return rt . matrix_from_euler ( angles , _X , _Y , _Z , _EULER ) fixed_xyz_to_quat def fixed_xyz_to_quat ( angles : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Converts Fixed XYZ angles to XYZW quaternions Parameters: Name Type Description Default angles npt.ArrayLike Angles (radians), length=3 None Returns: Type Description np.ndarray XYZW quaternion, shape (4,) View Source def fixed_xyz_to_quat ( angles : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts Fixed XYZ angles to XYZW quaternions Args: angles (npt.ArrayLike): Angles (radians), length=3 Returns: np.ndarray: XYZW quaternion, shape (4,) \"\"\" if len ( angles ) != 3 : raise ValueError ( f \"Must provide 3 angles.\\nGot: {angles}\" ) wxyz = rt . quaternion_from_euler ( angles , _X , _Y , _Z , _FIXED ) return wxyz_to_xyzw ( wxyz ) fixed_xyz_to_rmat def fixed_xyz_to_rmat ( angles : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Fixed XYZ 3-angle rotation matrix Operations will be in the following order: 1) Rotate by the first angle about X_A 2) Rotate by the second angle about Y_A 3) Rotate by the third angle about Z_A (This differs from Euler angles, as the rotation is not about the intermediate frames) Parameters: Name Type Description Default angles npt.ArrayLike Three angles (radians) corresponding to the XYZ rotations None Returns: Type Description np.ndarray R_B2A, where frame B is composed by three rotations in XYZ order starting from frame A View Source def fixed_xyz_to_rmat ( angles : npt . ArrayLike ) -> np . ndarray : \"\"\"Fixed XYZ 3-angle rotation matrix Operations will be in the following order: 1) Rotate by the first angle about X_A 2) Rotate by the second angle about Y_A 3) Rotate by the third angle about Z_A (This differs from Euler angles, as the rotation is not about the intermediate frames) Args: angles (npt.ArrayLike): Three angles (radians) corresponding to the XYZ rotations Returns: np.ndarray: R_B2A, where frame B is composed by three rotations in XYZ order starting from frame A \"\"\" return rt . matrix_from_euler ( angles , _X , _Y , _Z , _FIXED ) quat_to_axis_angle def quat_to_axis_angle ( quat : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> tuple [ numpy . ndarray , float ] Converts an XYZW quaternion to an axis/angle representation Parameters: Name Type Description Default quat npt.ArrayLike XYZW quaternion, shape (4,) None Returns: Type Description tuple[np.ndarray, float] np.ndarray: Axis of rotation. Shape (3,) float: Rotation angle, in radians View Source def quat_to_axis_angle ( quat : npt . ArrayLike , ) -> tuple [ np . ndarray , float ] : \"\"\"Converts an XYZW quaternion to an axis/angle representation Args: quat (npt.ArrayLike): XYZW quaternion, shape (4,) Returns: tuple[np.ndarray, float]: np.ndarray: Axis of rotation. Shape (3,) float: Rotation angle, in radians \"\"\" axis_and_angle = rt . axis_angle_from_quaternion ( xyzw_to_wxyz ( quat )) axis = axis_and_angle [ : 3 ] angle = axis_and_angle [ 3 ] return axis , angle quat_to_euler_xyz def quat_to_euler_xyz ( quat : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Converts XYZW quaternions to Euler XYZ angles Parameters: Name Type Description Default quat npt.ArrayLike XYZW quaternion, shape (4,) None Returns: Type Description np.ndarray (3,) Euler XYZ angles View Source def quat_to_euler_xyz ( quat : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts XYZW quaternions to Euler XYZ angles Args: quat (npt.ArrayLike): XYZW quaternion, shape (4,) Returns: np.ndarray: (3,) Euler XYZ angles \"\"\" return rt . euler_from_quaternion ( xyzw_to_wxyz ( quat ), _X , _Y , _Z , _EULER ) quat_to_fixed_xyz def quat_to_fixed_xyz ( quat : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Converts XYZW quaternions to Fixed XYZ angles Parameters: Name Type Description Default quat npt.ArrayLike XYZW quaternion, shape (4,) None Returns: Type Description np.ndarray (3,) Fixed XYZ angles View Source def quat_to_fixed_xyz ( quat : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts XYZW quaternions to Fixed XYZ angles Args: quat (npt.ArrayLike): XYZW quaternion, shape (4,) Returns: np.ndarray: (3,) Fixed XYZ angles \"\"\" return rt . euler_from_quaternion ( xyzw_to_wxyz ( quat ), _X , _Y , _Z , _FIXED ) quat_to_rmat def quat_to_rmat ( quat : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Converts XYZW quaternions to a rotation matrix Parameters: Name Type Description Default quat npt.ArrayLike XYZW quaternion, shape (4,) None Returns: Type Description np.ndarray (3,3) rotation matrix View Source def quat_to_rmat ( quat : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts XYZW quaternions to a rotation matrix Args: quat (npt.ArrayLike): XYZW quaternion, shape (4,) Returns: np.ndarray: (3,3) rotation matrix \"\"\" return rt . matrix_from_quaternion ( xyzw_to_wxyz ( quat )) rmat_to_axis_angle def rmat_to_axis_angle ( rmat : numpy . ndarray ) -> tuple [ numpy . ndarray , float ] Converts a rotation matrix into an axis-angle representation Parameters: Name Type Description Default rmat np.ndarray (3, 3) rotation matrix None Returns: Type Description tuple[np.ndarray, float] np.ndarray: Axis of rotation. Shape (3,) float: Rotation angle, in radians View Source def rmat_to_axis_angle ( rmat : np . ndarray ) -> tuple [ np . ndarray , float ] : \"\"\"Converts a rotation matrix into an axis-angle representation Args: rmat (np.ndarray): (3, 3) rotation matrix Returns: tuple[np.ndarray, float]: np.ndarray: Axis of rotation. Shape (3,) float: Rotation angle, in radians \"\"\" axis_and_angle = rt . axis_angle_from_matrix ( rmat ) axis = axis_and_angle [ : 3 ] angle = axis_and_angle [ 3 ] return axis , angle rmat_to_euler_xyz def rmat_to_euler_xyz ( rmat : numpy . ndarray ) -> tuple [ float , float , float ] Converts a rotation matrix to Euler XYZ angles Parameters: Name Type Description Default rmat np.ndarray (3,3) rotation matrix None Returns: Type Description tuple[float, float, float] XYZ Euler angles View Source def rmat_to_euler_xyz ( rmat : np . ndarray ) -> tuple [ float , float , float ] : \"\"\"Converts a rotation matrix to Euler XYZ angles Args: rmat (np.ndarray): (3,3) rotation matrix Returns: tuple[float, float, float]: XYZ Euler angles \"\"\" return rt . euler_from_matrix ( rmat , _X , _Y , _Z , _EULER ) rmat_to_fixed_xyz def rmat_to_fixed_xyz ( rmat : numpy . ndarray ) -> tuple [ float , float , float ] Converts a rotation matrix to Fixed XYZ angles Parameters: Name Type Description Default rmat np.ndarray (3,3) rotation matrix None Returns: Type Description tuple[float, float, float] XYZ Fixed angles View Source def rmat_to_fixed_xyz ( rmat : np . ndarray ) -> tuple [ float , float , float ] : \"\"\"Converts a rotation matrix to Fixed XYZ angles Args: rmat (np.ndarray): (3,3) rotation matrix Returns: tuple[float, float, float]: XYZ Fixed angles \"\"\" return rt . euler_from_matrix ( rmat , _X , _Y , _Z , _FIXED ) rmat_to_fixed_zyx def rmat_to_fixed_zyx ( rmat : numpy . ndarray ) -> tuple [ float , float , float ] Converts a rotation matrix to Fixed ZYX angles Parameters: Name Type Description Default rmat np.ndarray (3,3) rotation matrix None Returns: Type Description tuple[float, float, float] ZYX Fixed angles View Source def rmat_to_fixed_zyx ( rmat : np . ndarray ) -> tuple [ float , float , float ] : \"\"\"Converts a rotation matrix to Fixed ZYX angles Args: rmat (np.ndarray): (3,3) rotation matrix Returns: tuple[float, float, float]: ZYX Fixed angles \"\"\" return rt . euler_from_matrix ( rmat , _Z , _Y , _X , _FIXED ) rmat_to_quat def rmat_to_quat ( rmat : numpy . ndarray ) -> numpy . ndarray Converts a rotation matrix into XYZW quaternions NOTE: When computing a quaternion from the rotation matrix there is a sign ambiguity: q and -q represent the same rotation. (TODO: add a reference quaternion input to see which quaternion is closer, choose the sign accordingly?) Parameters: Name Type Description Default rmat np.ndarray (3,3) rotation matrix None Returns: Type Description np.ndarray XYZW quaternion, shape (4,) View Source def rmat_to_quat ( rmat : np . ndarray ) -> np . ndarray : \"\"\"Converts a rotation matrix into XYZW quaternions NOTE: When computing a quaternion from the rotation matrix there is a sign ambiguity: q and -q represent the same rotation. (TODO: add a reference quaternion input to see which quaternion is closer, choose the sign accordingly?) Args: rmat (np.ndarray): (3,3) rotation matrix Returns: np.ndarray: XYZW quaternion, shape (4,) \"\"\" wxyz = rt . quaternion_from_matrix ( rmat ) return wxyz_to_xyzw ( wxyz ) wxyz_to_xyzw def wxyz_to_xyzw ( quats : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Converts a WXYZ quaternion or array of quaternions to XYZW Parameters: Name Type Description Default quats npt.ArrayLike WXYZ quaternion(s), shape (4,) or (n, 4) None Returns: Type Description np.ndarray XYZW quaternions, shape (4,) or (n, 4) (same shape as input) View Source def wxyz_to_xyzw ( quats : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts a WXYZ quaternion or array of quaternions to XYZW Args: quats (npt.ArrayLike): WXYZ quaternion(s), shape (4,) or (n, 4) Returns: np.ndarray: XYZW quaternions, shape (4,) or (n, 4) (same shape as input) \"\"\" quats = np . asarray ( quats ) if quats . shape [ -1 ] != 4 : raise ValueError ( \"Invalid quaternion array: Must be of shape (4,) or (n, 4)\" ) idx = np . array ( [ 1, 2, 3, 0 ] ) if np . ndim ( quats ) == 1 : return quats [ idx ] else : return quats [ :, idx ] xyzw_to_wxyz def xyzw_to_wxyz ( quats : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Converts a XYZW quaternion or array of quaternions to WXYZ Parameters: Name Type Description Default quats npt.ArrayLike XYZW quaternion(s), shape (4,) or (n, 4) None Returns: Type Description np.ndarray WXYZ quaternions, shape (4,) or (n, 4) (same shape as input) View Source def xyzw_to_wxyz ( quats : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts a XYZW quaternion or array of quaternions to WXYZ Args: quats (npt.ArrayLike): XYZW quaternion(s), shape (4,) or (n, 4) Returns: np.ndarray: WXYZ quaternions, shape (4,) or (n, 4) (same shape as input) \"\"\" quats = np . asarray ( quats ) if quats . shape [ -1 ] != 4 : raise ValueError ( \"Invalid quaternion array: Must be of shape (4,) or (n, 4)\" ) idx = np . array ( [ 3, 0, 1, 2 ] ) if np . ndim ( quats ) == 1 : return quats [ idx ] else : return quats [ :, idx ]","title":"Rotations"},{"location":"reference/pyastrobee/utils/rotations/#module-pyastrobeeutilsrotations","text":"Helper functions associated with rotations Notation for rotation matrices: A R B describes the orientation of frame B with respect to frame A. AKA \"B in A\", or \"B to A\" In code, this can be described as R_B_in_A or R_B2A The columns of this matrix are the unit vectors of B expressed in the coordinates A The rows of this matrix are the unit vectors of A expressed in the coordinates of B Operator vs mapping example, with Rx(theta) As an operator: Rx @ P will rotate point P by theta about the X axis As a mapping: Gives R_B_in_A (R_B2A), where frame B is rotated theta radians about A's X axis Composing rotations: A A B C R = R R R D B C D e.g. R_D2A = R_B2A @ R_C2B @ R_D2C Conventions: - Euler angles are in XYZ convention - Euler angles correspond to \"intrinsic\" convention in pytransform3d - Fixed angles are also XYZ convention - Fixed angles correspond to \"extrinsic\" convention in pytransform3d - Quaternions are in XYZW - Who uses XYZW? - NASA - ROS - Bullet/Pybullet - Who uses WXYZ? - Pytransform3d - Mujoco - We'll need to convert XYZW -> WXYZ for pytransform3d All angles are in radians View Source \"\"\"Helper functions associated with rotations Notation for rotation matrices: A R B describes the orientation of frame B with respect to frame A. AKA \" B in A \", or \" B to A \" In code, this can be described as R_B_in_A or R_B2A The columns of this matrix are the unit vectors of B expressed in the coordinates A The rows of this matrix are the unit vectors of A expressed in the coordinates of B Operator vs mapping example, with Rx(theta) As an operator: Rx @ P will rotate point P by theta about the X axis As a mapping: Gives R_B_in_A (R_B2A), where frame B is rotated theta radians about A's X axis Composing rotations: A A B C R = R R R D B C D e.g. R_D2A = R_B2A @ R_C2B @ R_D2C Conventions: - Euler angles are in XYZ convention - Euler angles correspond to \" intrinsic \" convention in pytransform3d - Fixed angles are also XYZ convention - Fixed angles correspond to \" extrinsic \" convention in pytransform3d - Quaternions are in XYZW - Who uses XYZW? - NASA - ROS - Bullet/Pybullet - Who uses WXYZ? - Pytransform3d - Mujoco - We'll need to convert XYZW -> WXYZ for pytransform3d All angles are in radians \"\"\" import numpy as np import numpy . typing as npt import pytransform3d . rotations as rt # Parameters to clarify meaning of pytransform3d inputs _ EULER = 0 _ FIXED = 1 _ X = 0 _ Y = 1 _ Z = 2 def Rx ( theta : float ) -> np . ndarray : \"\"\"Rotation matrix for a rotation by theta radians about the X axis Args: theta (float): Rotation angle about the X axis (radians) Returns: np.ndarray: The associated (3,3) rotation matrix \"\"\" return rt . matrix_from_euler ([ theta , 0 , 0 ], _ X , _ Y , _ Z , _ EULER ) def Ry ( theta : float ) -> np . ndarray : \"\"\"Rotation matrix for a rotation by theta radians about the Y axis Args: theta (float): Rotation angle about the Y axis (radians) Returns: np.ndarray: The associated (3,3) rotation matrix \"\"\" return rt . matrix_from_euler ([ 0 , theta , 0 ], _ X , _ Y , _ Z , _ EULER ) def Rz ( theta : float ) -> np . ndarray : \"\"\"Rotation matrix for a rotation by theta radians about the Z axis Args: theta (float): Rotation angle about the Z axis (radians) Returns: np.ndarray: The associated (3,3) rotation matrix \"\"\" return rt . matrix_from_euler ([ 0 , 0 , theta ], _ X , _ Y , _ Z , _ EULER ) def euler_xyz_to_rmat ( angles : npt . ArrayLike ) -> np . ndarray : \"\"\"Euler XYZ 3-angle rotation matrix Operations will be in the following order: 1) Starting with frame A, rotate by the first angle about X_A to obtain intermediate frame B' 2) Rotate by the second angle about Y_B' to obtain intermediate frame B'' 3) Rotate by the third angle about Z_B'' to obtain B Args: angles (npt.ArrayLike): Three angles (radians) corresponding to the XYZ rotations Returns: np.ndarray: R_B2A, where frame B is composed by three rotations in XYZ order starting from frame A \"\"\" if len ( angles ) ! = 3 : raise ValueError ( f \"Must provide 3 angles.\\nGot:{angles}\" ) return rt . matrix_from_euler ( angles , _ X , _ Y , _ Z , _ EULER ) def fixed_xyz_to_rmat ( angles : npt . ArrayLike ) -> np . ndarray : \"\"\"Fixed XYZ 3-angle rotation matrix Operations will be in the following order: 1) Rotate by the first angle about X_A 2) Rotate by the second angle about Y_A 3) Rotate by the third angle about Z_A (This differs from Euler angles, as the rotation is not about the intermediate frames) Args: angles (npt.ArrayLike): Three angles (radians) corresponding to the XYZ rotations Returns: np.ndarray: R_B2A, where frame B is composed by three rotations in XYZ order starting from frame A \"\"\" return rt . matrix_from_euler ( angles , _ X , _ Y , _ Z , _ FIXED ) def rmat_to_axis_angle ( rmat : np . ndarray ) -> tuple [ np . ndarray , float ] : \"\"\"Converts a rotation matrix into an axis-angle representation Args: rmat (np.ndarray): (3, 3) rotation matrix Returns: tuple[np.ndarray, float]: np.ndarray: Axis of rotation. Shape (3,) float: Rotation angle, in radians \"\"\" axis_and_angle = rt . axis_angle_from_matrix ( rmat ) axis = axis_and_angle [ : 3 ] angle = axis_and_angle [ 3 ] return axis , angle def axis_angle_to_rmat ( axis : list [ float ], angle : float ) -> np . ndarray : \"\"\"Converts an axis-angle representation to a rotation matrix Args: axis (list[float]): Axis to rotate around: [x, y, z] angle (float): Angle to rotate (radians) Returns: np.ndarray: Rotation matrix equivalent for the axis-angle representation \"\"\" axis_and_angle = np . concatenate ([ axis , [ angle ]]) return rt . matrix_from_axis_angle ( axis_and_angle ) def custom_euler_to_rmat ( convention : str , angles : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts euler angles of a specified convention (like 'zyx') to a rotation matrix Use this if a convention other than XYZ is needed Args: convention (str): Axis order for the three rotations: Must be some length=3 permutation of 'xyz' - e.g. 'zyx', 'yxy', ... angles (npt.ArrayLike): Rotation angles, length = 3 Raises: ValueError: If the convention or the angles are not of length 3, or if the convention does not strictly contain just \" x \", \" y \", or \" z \" Returns: np.ndarray: (3, 3) rotation matrix \"\"\" if not len ( convention ) == 3 : raise ValueError ( f \"Convention should be length 3.\\nGot: {convention}\" ) if not len ( angles ) == 3 : raise ValueError ( f \"Angles should be length 3.\\nGot: {angles}\" ) convention = convention . lower () if not all ( c in { \"x\" , \"y\" , \"z\" } for c in convention ) : raise ValueError ( f \"Convention must only include x, y, and z.\\nGot: {convention}\" ) ax_to_ind = { \"x\" : 0 , \"y\" : 1 , \"z\" : 2 } inds = [ ax_to_ind [ convention [ i ]] for i in range ( 3 )] return rt . matrix_from_euler ( angles , * inds , _ EULER ) def custom_fixed_to_rmat ( convention : str , angles : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts fixed angles of a specified convention (like 'zyx') to a rotation matrix Use this if a convention other than XYZ is needed Args: convention (str): Axis order for the three rotations: Must be some length=3 permutation of 'xyz' - e.g. 'zyx', 'yxy', ... angles (npt.ArrayLike): Rotation angles, length = 3 Raises: ValueError: If the convention or the angles are not of length 3, or if the convention does not strictly contain just \" x \", \" y \", or \" z \" Returns: np.ndarray: (3, 3) rotation matrix \"\"\" return custom_euler_to_rmat ( convention [ ::- 1 ], angles [ ::- 1 ]) def rmat_to_euler_xyz ( rmat : np . ndarray ) -> tuple [ float , float , float ] : \"\"\"Converts a rotation matrix to Euler XYZ angles Args: rmat (np.ndarray): (3,3) rotation matrix Returns: tuple[float, float, float]: XYZ Euler angles \"\"\" return rt . euler_from_matrix ( rmat , _ X , _ Y , _ Z , _ EULER ) def rmat_to_fixed_xyz ( rmat : np . ndarray ) -> tuple [ float , float , float ] : \"\"\"Converts a rotation matrix to Fixed XYZ angles Args: rmat (np.ndarray): (3,3) rotation matrix Returns: tuple[float, float, float]: XYZ Fixed angles \"\"\" return rt . euler_from_matrix ( rmat , _ X , _ Y , _ Z , _ FIXED ) def rmat_to_fixed_zyx ( rmat : np . ndarray ) -> tuple [ float , float , float ] : \"\"\"Converts a rotation matrix to Fixed ZYX angles Args: rmat (np.ndarray): (3,3) rotation matrix Returns: tuple[float, float, float]: ZYX Fixed angles \"\"\" return rt . euler_from_matrix ( rmat , _ Z , _ Y , _ X , _ FIXED ) def check_rotation_mat ( R : np . ndarray ) -> bool : \"\"\"Determines if a rotation matrix is valid (3x3, orthogonal, and determinant = 1) Args: R (np.ndarray): A rotation matrix Returns: bool: Whether or not R is a valid rotation matrix \"\"\" try : rt . check_matrix ( R , strict_check = True ) return True except ValueError : return False def quat_to_rmat ( quat : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts XYZW quaternions to a rotation matrix Args: quat (npt.ArrayLike): XYZW quaternion, shape (4,) Returns: np.ndarray: (3,3) rotation matrix \"\"\" return rt . matrix_from_quaternion ( xyzw_to_wxyz ( quat )) def rmat_to_quat ( rmat : np . ndarray ) -> np . ndarray : \"\"\"Converts a rotation matrix into XYZW quaternions NOTE: When computing a quaternion from the rotation matrix there is a sign ambiguity: q and -q represent the same rotation. (TODO: add a reference quaternion input to see which quaternion is closer, choose the sign accordingly?) Args: rmat (np.ndarray): (3,3) rotation matrix Returns: np.ndarray: XYZW quaternion, shape (4,) \"\"\" wxyz = rt . quaternion_from_matrix ( rmat ) return wxyz_to_xyzw ( wxyz ) def euler_xyz_to_quat ( angles : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts Euler XYZ angles to XYZW quaternions Args: angles (npt.ArrayLike): Angles (radians), length=3 Returns: np.ndarray: XYZW quaternion, shape (4,) \"\"\" if len ( angles ) ! = 3 : raise ValueError ( f \"Must provide 3 angles.\\nGot: {angles}\" ) wxyz = rt . quaternion_from_euler ( angles , _ X , _ Y , _ Z , _ EULER ) return wxyz_to_xyzw ( wxyz ) def fixed_xyz_to_quat ( angles : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts Fixed XYZ angles to XYZW quaternions Args: angles (npt.ArrayLike): Angles (radians), length=3 Returns: np.ndarray: XYZW quaternion, shape (4,) \"\"\" if len ( angles ) ! = 3 : raise ValueError ( f \"Must provide 3 angles.\\nGot: {angles}\" ) wxyz = rt . quaternion_from_euler ( angles , _ X , _ Y , _ Z , _ FIXED ) return wxyz_to_xyzw ( wxyz ) def quat_to_euler_xyz ( quat : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts XYZW quaternions to Euler XYZ angles Args: quat (npt.ArrayLike): XYZW quaternion, shape (4,) Returns: np.ndarray: (3,) Euler XYZ angles \"\"\" return rt . euler_from_quaternion ( xyzw_to_wxyz ( quat ), _ X , _ Y , _ Z , _ EULER ) def quat_to_fixed_xyz ( quat : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts XYZW quaternions to Fixed XYZ angles Args: quat (npt.ArrayLike): XYZW quaternion, shape (4,) Returns: np.ndarray: (3,) Fixed XYZ angles \"\"\" return rt . euler_from_quaternion ( xyzw_to_wxyz ( quat ), _ X , _ Y , _ Z , _ FIXED ) def axis_angle_between_two_vectors ( v1 : npt . ArrayLike , v2 : npt . ArrayLike ) -> tuple [ np . ndarray , float ] : \"\"\"Gives the axis/angle rotation that would rotate vector v1 to align with v2 (magnitude-independent) Args: v1 (npt.ArrayLike): (3,) Starting vector/direction v2 (npt.ArrayLike): (3,) Ending vector/direction Returns: tuple[np.ndarray, float]: np.ndarray: Axis of rotation. Shape (3,) float: Rotation angle, in radians \"\"\" axis_and_angle = rt . axis_angle_from_two_directions ( v1 , v2 ) return axis_and_angle [ : 3 ], axis_and_angle [ 3 ] def axis_angle_to_quat ( axis : npt . ArrayLike , angle : float ) -> np . ndarray : \"\"\"Converts an axis/angle rotation representation to XYZW quaternion Args: axis (npt.ArrayLike): Axis of rotation. Shape (3,) angle (float): Rotation angle, in radians Returns: np.ndarray: XYZW quaternion, shape (4,) \"\"\" wxyz = rt . quaternion_from_axis_angle ([ * axis , angle ]) return wxyz_to_xyzw ( wxyz ) def quat_to_axis_angle ( quat : npt . ArrayLike , ) -> tuple [ np . ndarray , float ] : \"\"\"Converts an XYZW quaternion to an axis/angle representation Args: quat (npt.ArrayLike): XYZW quaternion, shape (4,) Returns: tuple[np.ndarray, float]: np.ndarray: Axis of rotation. Shape (3,) float: Rotation angle, in radians \"\"\" axis_and_angle = rt . axis_angle_from_quaternion ( xyzw_to_wxyz ( quat )) axis = axis_and_angle [ : 3 ] angle = axis_and_angle [ 3 ] return axis , angle def compact_axis_angle ( axis : npt . ArrayLike , angle : float ) -> np . ndarray : \"\"\"Converts an axis/angle rotation into compact form (axis vector with a norm of the angle) Args: axis (npt.ArrayLike): Axis of rotation. Shape (3,) angle (float): Rotation angle, in radians Returns: np.ndarray: Compact axis/angle representation, shape (3,) \"\"\" axis = np . asarray ( axis ) if np . size ( axis ) ! = 3 or np . ndim ( angle ) ! = 0 : raise ValueError ( f \"Invalid axis/angle representation: {axis}, {angle}\" ) return ( angle / np . linalg . norm ( axis )) * axis # Quaternion helper functions copied here to prevent circular import def xyzw_to_wxyz ( quats : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts a XYZW quaternion or array of quaternions to WXYZ Args: quats (npt.ArrayLike): XYZW quaternion(s), shape (4,) or (n, 4) Returns: np.ndarray: WXYZ quaternions, shape (4,) or (n, 4) (same shape as input) \"\"\" quats = np . asarray ( quats ) if quats . shape [ - 1 ] ! = 4 : raise ValueError ( \"Invalid quaternion array: Must be of shape (4,) or (n, 4)\" ) idx = np . array ([ 3 , 0 , 1 , 2 ]) if np . ndim ( quats ) == 1 : return quats [ idx ] else : return quats [ : , idx ] def wxyz_to_xyzw ( quats : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts a WXYZ quaternion or array of quaternions to XYZW Args: quats (npt.ArrayLike): WXYZ quaternion(s), shape (4,) or (n, 4) Returns: np.ndarray: XYZW quaternions, shape (4,) or (n, 4) (same shape as input) \"\"\" quats = np . asarray ( quats ) if quats . shape [ - 1 ] ! = 4 : raise ValueError ( \"Invalid quaternion array: Must be of shape (4,) or (n, 4)\" ) idx = np . array ([ 1 , 2 , 3 , 0 ]) if np . ndim ( quats ) == 1 : return quats [ idx ] else : return quats [ : , idx ]","title":"Module pyastrobee.utils.rotations"},{"location":"reference/pyastrobee/utils/rotations/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/utils/rotations/#rx","text":"def Rx ( theta : float ) -> numpy . ndarray Rotation matrix for a rotation by theta radians about the X axis Parameters: Name Type Description Default theta float Rotation angle about the X axis (radians) None Returns: Type Description np.ndarray The associated (3,3) rotation matrix View Source def Rx ( theta : float ) -> np . ndarray : \"\"\"Rotation matrix for a rotation by theta radians about the X axis Args: theta (float): Rotation angle about the X axis (radians) Returns: np.ndarray: The associated (3,3) rotation matrix \"\"\" return rt . matrix_from_euler ([ theta , 0 , 0 ], _X , _Y , _Z , _EULER )","title":"Rx"},{"location":"reference/pyastrobee/utils/rotations/#ry","text":"def Ry ( theta : float ) -> numpy . ndarray Rotation matrix for a rotation by theta radians about the Y axis Parameters: Name Type Description Default theta float Rotation angle about the Y axis (radians) None Returns: Type Description np.ndarray The associated (3,3) rotation matrix View Source def Ry ( theta : float ) -> np . ndarray : \"\"\"Rotation matrix for a rotation by theta radians about the Y axis Args: theta (float): Rotation angle about the Y axis (radians) Returns: np.ndarray: The associated (3,3) rotation matrix \"\"\" return rt . matrix_from_euler ([ 0 , theta , 0 ], _X , _Y , _Z , _EULER )","title":"Ry"},{"location":"reference/pyastrobee/utils/rotations/#rz","text":"def Rz ( theta : float ) -> numpy . ndarray Rotation matrix for a rotation by theta radians about the Z axis Parameters: Name Type Description Default theta float Rotation angle about the Z axis (radians) None Returns: Type Description np.ndarray The associated (3,3) rotation matrix View Source def Rz ( theta : float ) -> np . ndarray : \"\"\"Rotation matrix for a rotation by theta radians about the Z axis Args: theta (float): Rotation angle about the Z axis (radians) Returns: np.ndarray: The associated (3,3) rotation matrix \"\"\" return rt . matrix_from_euler ([ 0 , 0 , theta ], _X , _Y , _Z , _EULER )","title":"Rz"},{"location":"reference/pyastrobee/utils/rotations/#axis_angle_between_two_vectors","text":"def axis_angle_between_two_vectors ( v1 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], v2 : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> tuple [ numpy . ndarray , float ] Gives the axis/angle rotation that would rotate vector v1 to align with v2 (magnitude-independent) Parameters: Name Type Description Default v1 npt.ArrayLike (3,) Starting vector/direction None v2 npt.ArrayLike (3,) Ending vector/direction None Returns: Type Description tuple[np.ndarray, float] np.ndarray: Axis of rotation. Shape (3,) float: Rotation angle, in radians View Source def axis_angle_between_two_vectors ( v1 : npt . ArrayLike , v2 : npt . ArrayLike ) -> tuple [ np . ndarray , float ] : \"\"\"Gives the axis/angle rotation that would rotate vector v1 to align with v2 (magnitude-independent) Args: v1 (npt.ArrayLike): (3,) Starting vector/direction v2 (npt.ArrayLike): (3,) Ending vector/direction Returns: tuple[np.ndarray, float]: np.ndarray: Axis of rotation. Shape (3,) float: Rotation angle, in radians \"\"\" axis_and_angle = rt . axis_angle_from_two_directions ( v1 , v2 ) return axis_and_angle [ : 3 ], axis_and_angle [ 3 ]","title":"axis_angle_between_two_vectors"},{"location":"reference/pyastrobee/utils/rotations/#axis_angle_to_quat","text":"def axis_angle_to_quat ( axis : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], angle : float ) -> numpy . ndarray Converts an axis/angle rotation representation to XYZW quaternion Parameters: Name Type Description Default axis npt.ArrayLike Axis of rotation. Shape (3,) None angle float Rotation angle, in radians None Returns: Type Description np.ndarray XYZW quaternion, shape (4,) View Source def axis_angle_to_quat(axis: npt.ArrayLike, angle: float) -> np.ndarray: \"\"\"Converts an axis/angle rotation representation to XYZW quaternion Args: axis (npt.ArrayLike): Axis of rotation. Shape (3,) angle (float): Rotation angle, in radians Returns: np.ndarray: XYZW quaternion, shape (4,) \"\"\" wxyz = rt.quaternion_from_axis_angle([*axis, angle]) return wxyz_to_xyzw(wxyz)","title":"axis_angle_to_quat"},{"location":"reference/pyastrobee/utils/rotations/#axis_angle_to_rmat","text":"def axis_angle_to_rmat ( axis : list [ float ], angle : float ) -> numpy . ndarray Converts an axis-angle representation to a rotation matrix Parameters: Name Type Description Default axis list[float] Axis to rotate around: [x, y, z] None angle float Angle to rotate (radians) None Returns: Type Description np.ndarray Rotation matrix equivalent for the axis-angle representation View Source def axis_angle_to_rmat ( axis : list [ float ] , angle : float ) -> np . ndarray : \"\"\"Converts an axis-angle representation to a rotation matrix Args: axis (list[float]): Axis to rotate around: [x, y, z] angle (float): Angle to rotate (radians) Returns: np.ndarray: Rotation matrix equivalent for the axis-angle representation \"\"\" axis_and_angle = np . concatenate ( [ axis, [angle ] ] ) return rt . matrix_from_axis_angle ( axis_and_angle )","title":"axis_angle_to_rmat"},{"location":"reference/pyastrobee/utils/rotations/#check_rotation_mat","text":"def check_rotation_mat ( R : numpy . ndarray ) -> bool Determines if a rotation matrix is valid (3x3, orthogonal, and determinant = 1) Parameters: Name Type Description Default R np.ndarray A rotation matrix None Returns: Type Description bool Whether or not R is a valid rotation matrix View Source def check_rotation_mat ( R : np . ndarray ) -> bool : \"\"\"Determines if a rotation matrix is valid (3x3, orthogonal, and determinant = 1) Args: R (np.ndarray): A rotation matrix Returns: bool: Whether or not R is a valid rotation matrix \"\"\" try : rt . check_matrix ( R , strict_check = True ) return True except ValueError : return False","title":"check_rotation_mat"},{"location":"reference/pyastrobee/utils/rotations/#compact_axis_angle","text":"def compact_axis_angle ( axis : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]], angle : float ) -> numpy . ndarray Converts an axis/angle rotation into compact form (axis vector with a norm of the angle) Parameters: Name Type Description Default axis npt.ArrayLike Axis of rotation. Shape (3,) None angle float Rotation angle, in radians None Returns: Type Description np.ndarray Compact axis/angle representation, shape (3,) View Source def compact_axis_angle(axis: npt.ArrayLike, angle: float) -> np.ndarray: \"\"\"Converts an axis/angle rotation into compact form (axis vector with a norm of the angle) Args: axis (npt.ArrayLike): Axis of rotation. Shape (3,) angle (float): Rotation angle, in radians Returns: np.ndarray: Compact axis/angle representation, shape (3,) \"\"\" axis = np.asarray(axis) if np.size(axis) != 3 or np.ndim(angle) != 0: raise ValueError(f\"Invalid axis/angle representation: {axis}, {angle}\") return (angle / np.linalg.norm(axis)) * axis","title":"compact_axis_angle"},{"location":"reference/pyastrobee/utils/rotations/#custom_euler_to_rmat","text":"def custom_euler_to_rmat ( convention : str , angles : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Converts euler angles of a specified convention (like 'zyx') to a rotation matrix Use this if a convention other than XYZ is needed Parameters: Name Type Description Default convention str Axis order for the three rotations: Must be some length=3 permutation of 'xyz' - e.g. 'zyx', 'yxy', ... None angles npt.ArrayLike Rotation angles, length = 3 None Returns: Type Description np.ndarray (3, 3) rotation matrix Raises: Type Description ValueError If the convention or the angles are not of length 3, or if the convention does not strictly contain just \"x\", \"y\", or \"z\" View Source def custom_euler_to_rmat ( convention : str , angles : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts euler angles of a specified convention (like 'zyx') to a rotation matrix Use this if a convention other than XYZ is needed Args: convention (str): Axis order for the three rotations: Must be some length=3 permutation of 'xyz' - e.g. 'zyx', 'yxy', ... angles (npt.ArrayLike): Rotation angles, length = 3 Raises: ValueError: If the convention or the angles are not of length 3, or if the convention does not strictly contain just \" x \", \" y \", or \" z \" Returns: np.ndarray: (3, 3) rotation matrix \"\"\" if not len ( convention ) == 3 : raise ValueError ( f \"Convention should be length 3.\\nGot: {convention}\" ) if not len ( angles ) == 3 : raise ValueError ( f \"Angles should be length 3.\\nGot: {angles}\" ) convention = convention . lower () if not all ( c in { \"x\" , \"y\" , \"z\" } for c in convention ) : raise ValueError ( f \"Convention must only include x, y, and z.\\nGot: {convention}\" ) ax_to_ind = { \"x\" : 0 , \"y\" : 1 , \"z\" : 2 } inds = [ ax_to_ind[convention[i ] ] for i in range ( 3 ) ] return rt . matrix_from_euler ( angles , * inds , _EULER )","title":"custom_euler_to_rmat"},{"location":"reference/pyastrobee/utils/rotations/#custom_fixed_to_rmat","text":"def custom_fixed_to_rmat ( convention : str , angles : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Converts fixed angles of a specified convention (like 'zyx') to a rotation matrix Use this if a convention other than XYZ is needed Parameters: Name Type Description Default convention str Axis order for the three rotations: Must be some length=3 permutation of 'xyz' - e.g. 'zyx', 'yxy', ... None angles npt.ArrayLike Rotation angles, length = 3 None Returns: Type Description np.ndarray (3, 3) rotation matrix Raises: Type Description ValueError If the convention or the angles are not of length 3, or if the convention does not strictly contain just \"x\", \"y\", or \"z\" View Source def custom_fixed_to_rmat ( convention : str , angles : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts fixed angles of a specified convention (like 'zyx') to a rotation matrix Use this if a convention other than XYZ is needed Args: convention (str): Axis order for the three rotations: Must be some length=3 permutation of 'xyz' - e.g. 'zyx', 'yxy', ... angles (npt.ArrayLike): Rotation angles, length = 3 Raises: ValueError: If the convention or the angles are not of length 3, or if the convention does not strictly contain just \" x \", \" y \", or \" z \" Returns: np.ndarray: (3, 3) rotation matrix \"\"\" return custom_euler_to_rmat ( convention [ ::- 1 ], angles [ ::- 1 ])","title":"custom_fixed_to_rmat"},{"location":"reference/pyastrobee/utils/rotations/#euler_xyz_to_quat","text":"def euler_xyz_to_quat ( angles : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Converts Euler XYZ angles to XYZW quaternions Parameters: Name Type Description Default angles npt.ArrayLike Angles (radians), length=3 None Returns: Type Description np.ndarray XYZW quaternion, shape (4,) View Source def euler_xyz_to_quat ( angles : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts Euler XYZ angles to XYZW quaternions Args: angles (npt.ArrayLike): Angles (radians), length=3 Returns: np.ndarray: XYZW quaternion, shape (4,) \"\"\" if len ( angles ) != 3 : raise ValueError ( f \"Must provide 3 angles.\\nGot: {angles}\" ) wxyz = rt . quaternion_from_euler ( angles , _X , _Y , _Z , _EULER ) return wxyz_to_xyzw ( wxyz )","title":"euler_xyz_to_quat"},{"location":"reference/pyastrobee/utils/rotations/#euler_xyz_to_rmat","text":"def euler_xyz_to_rmat ( angles : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Euler XYZ 3-angle rotation matrix Operations will be in the following order: 1) Starting with frame A, rotate by the first angle about X_A to obtain intermediate frame B' 2) Rotate by the second angle about Y_B' to obtain intermediate frame B'' 3) Rotate by the third angle about Z_B'' to obtain B Parameters: Name Type Description Default angles npt.ArrayLike Three angles (radians) corresponding to the XYZ rotations None Returns: Type Description np.ndarray R_B2A, where frame B is composed by three rotations in XYZ order starting from frame A View Source def euler_xyz_to_rmat ( angles : npt . ArrayLike ) -> np . ndarray : \"\"\"Euler XYZ 3-angle rotation matrix Operations will be in the following order: 1) Starting with frame A, rotate by the first angle about X_A to obtain intermediate frame B' 2 ) Rotate by the second angle about Y_B ' to obtain intermediate frame B'' 3) Rotate by the third angle about Z_B'' to obtain B Args: angles (npt.ArrayLike): Three angles (radians) corresponding to the XYZ rotations Returns: np.ndarray: R_B2A, where frame B is composed by three rotations in XYZ order starting from frame A \"\"\" if len ( angles ) != 3 : raise ValueError ( f \"Must provide 3 angles.\\nGot:{angles}\" ) return rt . matrix_from_euler ( angles , _X , _Y , _Z , _EULER )","title":"euler_xyz_to_rmat"},{"location":"reference/pyastrobee/utils/rotations/#fixed_xyz_to_quat","text":"def fixed_xyz_to_quat ( angles : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Converts Fixed XYZ angles to XYZW quaternions Parameters: Name Type Description Default angles npt.ArrayLike Angles (radians), length=3 None Returns: Type Description np.ndarray XYZW quaternion, shape (4,) View Source def fixed_xyz_to_quat ( angles : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts Fixed XYZ angles to XYZW quaternions Args: angles (npt.ArrayLike): Angles (radians), length=3 Returns: np.ndarray: XYZW quaternion, shape (4,) \"\"\" if len ( angles ) != 3 : raise ValueError ( f \"Must provide 3 angles.\\nGot: {angles}\" ) wxyz = rt . quaternion_from_euler ( angles , _X , _Y , _Z , _FIXED ) return wxyz_to_xyzw ( wxyz )","title":"fixed_xyz_to_quat"},{"location":"reference/pyastrobee/utils/rotations/#fixed_xyz_to_rmat","text":"def fixed_xyz_to_rmat ( angles : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Fixed XYZ 3-angle rotation matrix Operations will be in the following order: 1) Rotate by the first angle about X_A 2) Rotate by the second angle about Y_A 3) Rotate by the third angle about Z_A (This differs from Euler angles, as the rotation is not about the intermediate frames) Parameters: Name Type Description Default angles npt.ArrayLike Three angles (radians) corresponding to the XYZ rotations None Returns: Type Description np.ndarray R_B2A, where frame B is composed by three rotations in XYZ order starting from frame A View Source def fixed_xyz_to_rmat ( angles : npt . ArrayLike ) -> np . ndarray : \"\"\"Fixed XYZ 3-angle rotation matrix Operations will be in the following order: 1) Rotate by the first angle about X_A 2) Rotate by the second angle about Y_A 3) Rotate by the third angle about Z_A (This differs from Euler angles, as the rotation is not about the intermediate frames) Args: angles (npt.ArrayLike): Three angles (radians) corresponding to the XYZ rotations Returns: np.ndarray: R_B2A, where frame B is composed by three rotations in XYZ order starting from frame A \"\"\" return rt . matrix_from_euler ( angles , _X , _Y , _Z , _FIXED )","title":"fixed_xyz_to_rmat"},{"location":"reference/pyastrobee/utils/rotations/#quat_to_axis_angle","text":"def quat_to_axis_angle ( quat : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> tuple [ numpy . ndarray , float ] Converts an XYZW quaternion to an axis/angle representation Parameters: Name Type Description Default quat npt.ArrayLike XYZW quaternion, shape (4,) None Returns: Type Description tuple[np.ndarray, float] np.ndarray: Axis of rotation. Shape (3,) float: Rotation angle, in radians View Source def quat_to_axis_angle ( quat : npt . ArrayLike , ) -> tuple [ np . ndarray , float ] : \"\"\"Converts an XYZW quaternion to an axis/angle representation Args: quat (npt.ArrayLike): XYZW quaternion, shape (4,) Returns: tuple[np.ndarray, float]: np.ndarray: Axis of rotation. Shape (3,) float: Rotation angle, in radians \"\"\" axis_and_angle = rt . axis_angle_from_quaternion ( xyzw_to_wxyz ( quat )) axis = axis_and_angle [ : 3 ] angle = axis_and_angle [ 3 ] return axis , angle","title":"quat_to_axis_angle"},{"location":"reference/pyastrobee/utils/rotations/#quat_to_euler_xyz","text":"def quat_to_euler_xyz ( quat : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Converts XYZW quaternions to Euler XYZ angles Parameters: Name Type Description Default quat npt.ArrayLike XYZW quaternion, shape (4,) None Returns: Type Description np.ndarray (3,) Euler XYZ angles View Source def quat_to_euler_xyz ( quat : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts XYZW quaternions to Euler XYZ angles Args: quat (npt.ArrayLike): XYZW quaternion, shape (4,) Returns: np.ndarray: (3,) Euler XYZ angles \"\"\" return rt . euler_from_quaternion ( xyzw_to_wxyz ( quat ), _X , _Y , _Z , _EULER )","title":"quat_to_euler_xyz"},{"location":"reference/pyastrobee/utils/rotations/#quat_to_fixed_xyz","text":"def quat_to_fixed_xyz ( quat : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Converts XYZW quaternions to Fixed XYZ angles Parameters: Name Type Description Default quat npt.ArrayLike XYZW quaternion, shape (4,) None Returns: Type Description np.ndarray (3,) Fixed XYZ angles View Source def quat_to_fixed_xyz ( quat : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts XYZW quaternions to Fixed XYZ angles Args: quat (npt.ArrayLike): XYZW quaternion, shape (4,) Returns: np.ndarray: (3,) Fixed XYZ angles \"\"\" return rt . euler_from_quaternion ( xyzw_to_wxyz ( quat ), _X , _Y , _Z , _FIXED )","title":"quat_to_fixed_xyz"},{"location":"reference/pyastrobee/utils/rotations/#quat_to_rmat","text":"def quat_to_rmat ( quat : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Converts XYZW quaternions to a rotation matrix Parameters: Name Type Description Default quat npt.ArrayLike XYZW quaternion, shape (4,) None Returns: Type Description np.ndarray (3,3) rotation matrix View Source def quat_to_rmat ( quat : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts XYZW quaternions to a rotation matrix Args: quat (npt.ArrayLike): XYZW quaternion, shape (4,) Returns: np.ndarray: (3,3) rotation matrix \"\"\" return rt . matrix_from_quaternion ( xyzw_to_wxyz ( quat ))","title":"quat_to_rmat"},{"location":"reference/pyastrobee/utils/rotations/#rmat_to_axis_angle","text":"def rmat_to_axis_angle ( rmat : numpy . ndarray ) -> tuple [ numpy . ndarray , float ] Converts a rotation matrix into an axis-angle representation Parameters: Name Type Description Default rmat np.ndarray (3, 3) rotation matrix None Returns: Type Description tuple[np.ndarray, float] np.ndarray: Axis of rotation. Shape (3,) float: Rotation angle, in radians View Source def rmat_to_axis_angle ( rmat : np . ndarray ) -> tuple [ np . ndarray , float ] : \"\"\"Converts a rotation matrix into an axis-angle representation Args: rmat (np.ndarray): (3, 3) rotation matrix Returns: tuple[np.ndarray, float]: np.ndarray: Axis of rotation. Shape (3,) float: Rotation angle, in radians \"\"\" axis_and_angle = rt . axis_angle_from_matrix ( rmat ) axis = axis_and_angle [ : 3 ] angle = axis_and_angle [ 3 ] return axis , angle","title":"rmat_to_axis_angle"},{"location":"reference/pyastrobee/utils/rotations/#rmat_to_euler_xyz","text":"def rmat_to_euler_xyz ( rmat : numpy . ndarray ) -> tuple [ float , float , float ] Converts a rotation matrix to Euler XYZ angles Parameters: Name Type Description Default rmat np.ndarray (3,3) rotation matrix None Returns: Type Description tuple[float, float, float] XYZ Euler angles View Source def rmat_to_euler_xyz ( rmat : np . ndarray ) -> tuple [ float , float , float ] : \"\"\"Converts a rotation matrix to Euler XYZ angles Args: rmat (np.ndarray): (3,3) rotation matrix Returns: tuple[float, float, float]: XYZ Euler angles \"\"\" return rt . euler_from_matrix ( rmat , _X , _Y , _Z , _EULER )","title":"rmat_to_euler_xyz"},{"location":"reference/pyastrobee/utils/rotations/#rmat_to_fixed_xyz","text":"def rmat_to_fixed_xyz ( rmat : numpy . ndarray ) -> tuple [ float , float , float ] Converts a rotation matrix to Fixed XYZ angles Parameters: Name Type Description Default rmat np.ndarray (3,3) rotation matrix None Returns: Type Description tuple[float, float, float] XYZ Fixed angles View Source def rmat_to_fixed_xyz ( rmat : np . ndarray ) -> tuple [ float , float , float ] : \"\"\"Converts a rotation matrix to Fixed XYZ angles Args: rmat (np.ndarray): (3,3) rotation matrix Returns: tuple[float, float, float]: XYZ Fixed angles \"\"\" return rt . euler_from_matrix ( rmat , _X , _Y , _Z , _FIXED )","title":"rmat_to_fixed_xyz"},{"location":"reference/pyastrobee/utils/rotations/#rmat_to_fixed_zyx","text":"def rmat_to_fixed_zyx ( rmat : numpy . ndarray ) -> tuple [ float , float , float ] Converts a rotation matrix to Fixed ZYX angles Parameters: Name Type Description Default rmat np.ndarray (3,3) rotation matrix None Returns: Type Description tuple[float, float, float] ZYX Fixed angles View Source def rmat_to_fixed_zyx ( rmat : np . ndarray ) -> tuple [ float , float , float ] : \"\"\"Converts a rotation matrix to Fixed ZYX angles Args: rmat (np.ndarray): (3,3) rotation matrix Returns: tuple[float, float, float]: ZYX Fixed angles \"\"\" return rt . euler_from_matrix ( rmat , _Z , _Y , _X , _FIXED )","title":"rmat_to_fixed_zyx"},{"location":"reference/pyastrobee/utils/rotations/#rmat_to_quat","text":"def rmat_to_quat ( rmat : numpy . ndarray ) -> numpy . ndarray Converts a rotation matrix into XYZW quaternions NOTE: When computing a quaternion from the rotation matrix there is a sign ambiguity: q and -q represent the same rotation. (TODO: add a reference quaternion input to see which quaternion is closer, choose the sign accordingly?) Parameters: Name Type Description Default rmat np.ndarray (3,3) rotation matrix None Returns: Type Description np.ndarray XYZW quaternion, shape (4,) View Source def rmat_to_quat ( rmat : np . ndarray ) -> np . ndarray : \"\"\"Converts a rotation matrix into XYZW quaternions NOTE: When computing a quaternion from the rotation matrix there is a sign ambiguity: q and -q represent the same rotation. (TODO: add a reference quaternion input to see which quaternion is closer, choose the sign accordingly?) Args: rmat (np.ndarray): (3,3) rotation matrix Returns: np.ndarray: XYZW quaternion, shape (4,) \"\"\" wxyz = rt . quaternion_from_matrix ( rmat ) return wxyz_to_xyzw ( wxyz )","title":"rmat_to_quat"},{"location":"reference/pyastrobee/utils/rotations/#wxyz_to_xyzw","text":"def wxyz_to_xyzw ( quats : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Converts a WXYZ quaternion or array of quaternions to XYZW Parameters: Name Type Description Default quats npt.ArrayLike WXYZ quaternion(s), shape (4,) or (n, 4) None Returns: Type Description np.ndarray XYZW quaternions, shape (4,) or (n, 4) (same shape as input) View Source def wxyz_to_xyzw ( quats : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts a WXYZ quaternion or array of quaternions to XYZW Args: quats (npt.ArrayLike): WXYZ quaternion(s), shape (4,) or (n, 4) Returns: np.ndarray: XYZW quaternions, shape (4,) or (n, 4) (same shape as input) \"\"\" quats = np . asarray ( quats ) if quats . shape [ -1 ] != 4 : raise ValueError ( \"Invalid quaternion array: Must be of shape (4,) or (n, 4)\" ) idx = np . array ( [ 1, 2, 3, 0 ] ) if np . ndim ( quats ) == 1 : return quats [ idx ] else : return quats [ :, idx ]","title":"wxyz_to_xyzw"},{"location":"reference/pyastrobee/utils/rotations/#xyzw_to_wxyz","text":"def xyzw_to_wxyz ( quats : Union [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]], numpy . _typing . _nested_sequence . _NestedSequence [ numpy . _typing . _array_like . _SupportsArray [ numpy . dtype [ Any ]]], bool , int , float , complex , str , bytes , numpy . _typing . _nested_sequence . _NestedSequence [ Union [ bool , int , float , complex , str , bytes ]]] ) -> numpy . ndarray Converts a XYZW quaternion or array of quaternions to WXYZ Parameters: Name Type Description Default quats npt.ArrayLike XYZW quaternion(s), shape (4,) or (n, 4) None Returns: Type Description np.ndarray WXYZ quaternions, shape (4,) or (n, 4) (same shape as input) View Source def xyzw_to_wxyz ( quats : npt . ArrayLike ) -> np . ndarray : \"\"\"Converts a XYZW quaternion or array of quaternions to WXYZ Args: quats (npt.ArrayLike): XYZW quaternion(s), shape (4,) or (n, 4) Returns: np.ndarray: WXYZ quaternions, shape (4,) or (n, 4) (same shape as input) \"\"\" quats = np . asarray ( quats ) if quats . shape [ -1 ] != 4 : raise ValueError ( \"Invalid quaternion array: Must be of shape (4,) or (n, 4)\" ) idx = np . array ( [ 3, 0, 1, 2 ] ) if np . ndim ( quats ) == 1 : return quats [ idx ] else : return quats [ :, idx ]","title":"xyzw_to_wxyz"},{"location":"reference/pyastrobee/utils/transformations/","text":"Module pyastrobee.utils.transformations Helper functions associated with transformations (rotations + translations) Notation for transformation matrices: A T B describes the frame B with respect to frame A. AKA \"B in A\", or \"B to A\" In code, this can be described as T_B_in_A or T_B2A Composing transformations: A A B C T = T T T D B C D e.g. T_D2A = T_B2A @ T_C2B @ T_D2C All angles are in radians View Source \"\"\"Helper functions associated with transformations (rotations + translations) Notation for transformation matrices: A T B describes the frame B with respect to frame A. AKA \"B in A\", or \"B to A\" In code, this can be described as T_B_in_A or T_B2A Composing transformations: A A B C T = T T T D B C D e.g. T_D2A = T_B2A @ T_C2B @ T_D2C All angles are in radians \"\"\" from typing import Union import numpy as np import pytransform3d.transformations as tr def make_transform_mat ( rot : np . ndarray , trans : np . ndarray ) -> np . ndarray : \"\"\"Creates a transformation matrix from a rotation matrix and translation vector Args: rot (np.ndarray): (3,3) rotation matrix trans (np.ndarray): (3,) translation vector Returns: np.ndarray: Transformation matrix, shape (4, 4) \"\"\" return tr . transform_from ( rot , trans ) def check_transform_mat ( T : np . ndarray ) -> bool : \"\"\"Checks to see if a transformation matrix is valid Args: T (np.ndarray): (4, 4) transformation matrix Returns: bool: Whether or not the transformation matrix is valid \"\"\" try : tr . check_transform ( T , strict_check = True ) return True except ValueError : return False def invert_transform_mat ( T : np . ndarray ) -> np . ndarray : \"\"\"Inverts a transformation matrix Example: T_B2A = invert_transform_mat(T_A2B) Args: T (np.ndarray): (4, 4) transformation matrix Returns: np.ndarray: (4, 4) matrix representing the inverse transform of T \"\"\" return tr . invert_transform ( T ) def transform_point ( tmat : np . ndarray , point : Union [ list [ float ], np . ndarray ] ) -> np . ndarray : \"\"\"Applies a transformation to a point As a mapping: Changes the description of the point between frames Example: point_in_B = transform_point(T_A2B, point_in_A) As an operator: Moves a point within the same frame Example: new_point = transform_point(transform, orig_point) NOTE: pytransform3d has a function for this but it handles the dimensions of the point strangely Args: tmat (np.ndarray): (4, 4) transformation matrix point (Union[list[float], np.ndarray]): (3,) point to transform Returns: np.ndarray: (3,) transformed point \"\"\" # TODO: validate inputs? p = np . append ( point , 1 ) # Convert to (4,) array return ( tmat @ p )[: 3 ] Functions check_transform_mat def check_transform_mat ( T : numpy . ndarray ) -> bool Checks to see if a transformation matrix is valid Parameters: Name Type Description Default T np.ndarray (4, 4) transformation matrix None Returns: Type Description bool Whether or not the transformation matrix is valid View Source def check_transform_mat ( T : np . ndarray ) -> bool : \"\"\"Checks to see if a transformation matrix is valid Args: T (np.ndarray): (4, 4) transformation matrix Returns: bool: Whether or not the transformation matrix is valid \"\"\" try : tr . check_transform ( T , strict_check = True ) return True except ValueError : return False invert_transform_mat def invert_transform_mat ( T : numpy . ndarray ) -> numpy . ndarray Inverts a transformation matrix Example: T_B2A = invert_transform_mat(T_A2B) Parameters: Name Type Description Default T np.ndarray (4, 4) transformation matrix None Returns: Type Description np.ndarray (4, 4) matrix representing the inverse transform of T View Source def invert_transform_mat ( T : np . ndarray ) -> np . ndarray : \"\"\"Inverts a transformation matrix Example: T_B2A = invert_transform_mat(T_A2B) Args: T (np.ndarray): (4, 4) transformation matrix Returns: np.ndarray: (4, 4) matrix representing the inverse transform of T \"\"\" return tr . invert_transform ( T ) make_transform_mat def make_transform_mat ( rot : numpy . ndarray , trans : numpy . ndarray ) -> numpy . ndarray Creates a transformation matrix from a rotation matrix and translation vector Parameters: Name Type Description Default rot np.ndarray (3,3) rotation matrix None trans np.ndarray (3,) translation vector None Returns: Type Description np.ndarray Transformation matrix, shape (4, 4) View Source def make_transform_mat ( rot : np . ndarray , trans : np . ndarray ) -> np . ndarray : \"\"\"Creates a transformation matrix from a rotation matrix and translation vector Args: rot (np.ndarray): (3,3) rotation matrix trans (np.ndarray): (3,) translation vector Returns: np.ndarray: Transformation matrix, shape (4, 4) \"\"\" return tr . transform_from ( rot , trans ) transform_point def transform_point ( tmat : numpy . ndarray , point : Union [ list [ float ], numpy . ndarray ] ) -> numpy . ndarray Applies a transformation to a point As a mapping: Changes the description of the point between frames Example: point_in_B = transform_point(T_A2B, point_in_A) As an operator: Moves a point within the same frame Example: new_point = transform_point(transform, orig_point) NOTE: pytransform3d has a function for this but it handles the dimensions of the point strangely Parameters: Name Type Description Default tmat np.ndarray (4, 4) transformation matrix None point Union[list[float], np.ndarray] (3,) point to transform None Returns: Type Description np.ndarray (3,) transformed point View Source def transform_point ( tmat : np . ndarray , point : Union [ list[float ] , np . ndarray ] ) -> np . ndarray : \"\"\"Applies a transformation to a point As a mapping: Changes the description of the point between frames Example: point_in_B = transform_point(T_A2B, point_in_A) As an operator: Moves a point within the same frame Example: new_point = transform_point(transform, orig_point) NOTE: pytransform3d has a function for this but it handles the dimensions of the point strangely Args: tmat (np.ndarray): (4, 4) transformation matrix point (Union[list[float], np.ndarray]): (3,) point to transform Returns: np.ndarray: (3,) transformed point \"\"\" # TODO : validate inputs ? p = np . append ( point , 1 ) # Convert to ( 4 ,) array return ( tmat @ p ) [ :3 ]","title":"Transformations"},{"location":"reference/pyastrobee/utils/transformations/#module-pyastrobeeutilstransformations","text":"Helper functions associated with transformations (rotations + translations) Notation for transformation matrices: A T B describes the frame B with respect to frame A. AKA \"B in A\", or \"B to A\" In code, this can be described as T_B_in_A or T_B2A Composing transformations: A A B C T = T T T D B C D e.g. T_D2A = T_B2A @ T_C2B @ T_D2C All angles are in radians View Source \"\"\"Helper functions associated with transformations (rotations + translations) Notation for transformation matrices: A T B describes the frame B with respect to frame A. AKA \"B in A\", or \"B to A\" In code, this can be described as T_B_in_A or T_B2A Composing transformations: A A B C T = T T T D B C D e.g. T_D2A = T_B2A @ T_C2B @ T_D2C All angles are in radians \"\"\" from typing import Union import numpy as np import pytransform3d.transformations as tr def make_transform_mat ( rot : np . ndarray , trans : np . ndarray ) -> np . ndarray : \"\"\"Creates a transformation matrix from a rotation matrix and translation vector Args: rot (np.ndarray): (3,3) rotation matrix trans (np.ndarray): (3,) translation vector Returns: np.ndarray: Transformation matrix, shape (4, 4) \"\"\" return tr . transform_from ( rot , trans ) def check_transform_mat ( T : np . ndarray ) -> bool : \"\"\"Checks to see if a transformation matrix is valid Args: T (np.ndarray): (4, 4) transformation matrix Returns: bool: Whether or not the transformation matrix is valid \"\"\" try : tr . check_transform ( T , strict_check = True ) return True except ValueError : return False def invert_transform_mat ( T : np . ndarray ) -> np . ndarray : \"\"\"Inverts a transformation matrix Example: T_B2A = invert_transform_mat(T_A2B) Args: T (np.ndarray): (4, 4) transformation matrix Returns: np.ndarray: (4, 4) matrix representing the inverse transform of T \"\"\" return tr . invert_transform ( T ) def transform_point ( tmat : np . ndarray , point : Union [ list [ float ], np . ndarray ] ) -> np . ndarray : \"\"\"Applies a transformation to a point As a mapping: Changes the description of the point between frames Example: point_in_B = transform_point(T_A2B, point_in_A) As an operator: Moves a point within the same frame Example: new_point = transform_point(transform, orig_point) NOTE: pytransform3d has a function for this but it handles the dimensions of the point strangely Args: tmat (np.ndarray): (4, 4) transformation matrix point (Union[list[float], np.ndarray]): (3,) point to transform Returns: np.ndarray: (3,) transformed point \"\"\" # TODO: validate inputs? p = np . append ( point , 1 ) # Convert to (4,) array return ( tmat @ p )[: 3 ]","title":"Module pyastrobee.utils.transformations"},{"location":"reference/pyastrobee/utils/transformations/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/utils/transformations/#check_transform_mat","text":"def check_transform_mat ( T : numpy . ndarray ) -> bool Checks to see if a transformation matrix is valid Parameters: Name Type Description Default T np.ndarray (4, 4) transformation matrix None Returns: Type Description bool Whether or not the transformation matrix is valid View Source def check_transform_mat ( T : np . ndarray ) -> bool : \"\"\"Checks to see if a transformation matrix is valid Args: T (np.ndarray): (4, 4) transformation matrix Returns: bool: Whether or not the transformation matrix is valid \"\"\" try : tr . check_transform ( T , strict_check = True ) return True except ValueError : return False","title":"check_transform_mat"},{"location":"reference/pyastrobee/utils/transformations/#invert_transform_mat","text":"def invert_transform_mat ( T : numpy . ndarray ) -> numpy . ndarray Inverts a transformation matrix Example: T_B2A = invert_transform_mat(T_A2B) Parameters: Name Type Description Default T np.ndarray (4, 4) transformation matrix None Returns: Type Description np.ndarray (4, 4) matrix representing the inverse transform of T View Source def invert_transform_mat ( T : np . ndarray ) -> np . ndarray : \"\"\"Inverts a transformation matrix Example: T_B2A = invert_transform_mat(T_A2B) Args: T (np.ndarray): (4, 4) transformation matrix Returns: np.ndarray: (4, 4) matrix representing the inverse transform of T \"\"\" return tr . invert_transform ( T )","title":"invert_transform_mat"},{"location":"reference/pyastrobee/utils/transformations/#make_transform_mat","text":"def make_transform_mat ( rot : numpy . ndarray , trans : numpy . ndarray ) -> numpy . ndarray Creates a transformation matrix from a rotation matrix and translation vector Parameters: Name Type Description Default rot np.ndarray (3,3) rotation matrix None trans np.ndarray (3,) translation vector None Returns: Type Description np.ndarray Transformation matrix, shape (4, 4) View Source def make_transform_mat ( rot : np . ndarray , trans : np . ndarray ) -> np . ndarray : \"\"\"Creates a transformation matrix from a rotation matrix and translation vector Args: rot (np.ndarray): (3,3) rotation matrix trans (np.ndarray): (3,) translation vector Returns: np.ndarray: Transformation matrix, shape (4, 4) \"\"\" return tr . transform_from ( rot , trans )","title":"make_transform_mat"},{"location":"reference/pyastrobee/utils/transformations/#transform_point","text":"def transform_point ( tmat : numpy . ndarray , point : Union [ list [ float ], numpy . ndarray ] ) -> numpy . ndarray Applies a transformation to a point As a mapping: Changes the description of the point between frames Example: point_in_B = transform_point(T_A2B, point_in_A) As an operator: Moves a point within the same frame Example: new_point = transform_point(transform, orig_point) NOTE: pytransform3d has a function for this but it handles the dimensions of the point strangely Parameters: Name Type Description Default tmat np.ndarray (4, 4) transformation matrix None point Union[list[float], np.ndarray] (3,) point to transform None Returns: Type Description np.ndarray (3,) transformed point View Source def transform_point ( tmat : np . ndarray , point : Union [ list[float ] , np . ndarray ] ) -> np . ndarray : \"\"\"Applies a transformation to a point As a mapping: Changes the description of the point between frames Example: point_in_B = transform_point(T_A2B, point_in_A) As an operator: Moves a point within the same frame Example: new_point = transform_point(transform, orig_point) NOTE: pytransform3d has a function for this but it handles the dimensions of the point strangely Args: tmat (np.ndarray): (4, 4) transformation matrix point (Union[list[float], np.ndarray]): (3,) point to transform Returns: np.ndarray: (3,) transformed point \"\"\" # TODO : validate inputs ? p = np . append ( point , 1 ) # Convert to ( 4 ,) array return ( tmat @ p ) [ :3 ]","title":"transform_point"},{"location":"reference/pyastrobee/utils/video_concatenation/","text":"Module pyastrobee.utils.video_concatenation Concatenating a sequence of recorded videos together View Source \"\"\"Concatenating a sequence of recorded videos together\"\"\" from typing import Union import os import re from pathlib import Path # Files created during the concatenation process SORTING_FILE = \"join_video.txt\" OUTPUT_VIDEO_FILE = \"concatenated.mp4\" def concatenate_videos ( directory : Union [ str , Path ], cleanup : bool = False ) -> None : \"\"\"Concatenates a sequence of videos into a single video - FFMPEG must be installed first - All videos must have the same streams (same codecs, same time base, etc.) - All videos in the directory should be named in alphanumeric order to match the order that they will be concatenated: e.g. \"0.mp4\", \"1.mp4\", \"2.mp4\", ... - The videos to concatenate should be the only items in the directory Args: directory (Union[str, Path]): Directory containing the videos to concatenate cleanup (bool, optional): Whether to delete the individual videos after concatenation. Defaults to False. \"\"\" if isinstance ( directory , str ): directory = Path ( directory ) if not directory . exists (): raise ValueError ( f \"Directory: { str ( directory ) } not recognized\" ) video_order = _get_videos ( directory ) _ffmpeg_concat ( directory , video_order ) print ( f \"Concatenated video saved to { str ( Path ( directory , OUTPUT_VIDEO_FILE )) } \" ) if cleanup : _cleanup ( directory , video_order ) ## Helper functions below ## # https://stackoverflow.com/questions/4813061/non-alphanumeric-list-order-from-os-listdir def _sorted_alphanumeric ( data : list [ str ]) -> list [ str ]: \"\"\"Sort a list of strings via alphanumeric order Args: data (list[str]): Strings to sort Returns: list[str]: Alphanumerically-sorted data \"\"\" convert = lambda text : int ( text ) if text . isdigit () else text . lower () alphanum_key = lambda key : [ convert ( c ) for c in re . split ( \"([0-9]+)\" , key )] return sorted ( data , key = alphanum_key ) def _get_videos ( directory : Path ) -> list [ str ]: \"\"\"Get a sorted list of video files in concatenation order, within the given directory Args: directory (Path): Directory of the videos to concatenate Raises: RuntimeError: If the files are named improperly (must be alphanumeric for sorting, and MP4 format) Returns: list[str]: Video names in the order of concatenation \"\"\" for filename in os . listdir ( str ( directory )): p = Path ( directory , filename ) if p . name == SORTING_FILE : p . unlink () continue if p . name == OUTPUT_VIDEO_FILE : input ( \"WARNING: Video appears to be already concatenated. Press Enter to overwrite\" ) p . unlink () continue if p . suffix != \".mp4\" : raise RuntimeError ( \"Invalid file extension: \" , p . suffix , \". Expected .mp4\" ) if not p . stem . isnumeric (): raise RuntimeError ( \"Unrecognized file naming. Expect files named with their alphanumeric order\" ) return _sorted_alphanumeric ( os . listdir ( str ( directory ))) def _ffmpeg_concat ( directory : Path , order : list [ str ]): \"\"\"Run FFMPEG concatenation process Args: directory (Path): Directory of the videos to concatenate order (list[str]): Video names in the order of concatenation \"\"\" # FFMPEG needs to create a txt file to store the order of the videos first vid_order_file = str ( Path ( directory , SORTING_FILE )) with open ( vid_order_file , \"w\" ) as f : for vid in order : f . write ( \"file \" + str ( Path ( directory , vid ) . resolve ()) + \" \\n \" ) output_file = str ( Path ( directory , OUTPUT_VIDEO_FILE )) # Run the FFMPEG command os . system ( f \"ffmpeg -f concat -safe 0 -i { vid_order_file } -c copy { output_file } \" ) def _cleanup ( directory : Path , videos : list [ str ]): \"\"\"Delete all of the individual pre-concatenation videos, and the text file generated for video sorting Args: directory (Path): Directory containing the concatenated video files videos (list[str]): Video names to delete \"\"\" for vid in videos : p = Path ( directory , vid ) p . unlink () Path ( directory , SORTING_FILE ) . unlink () def _main (): \"\"\"Run as a script from user input\"\"\" while True : dir_str = input ( \"Provide a directory of videos to concatenate: \\n \" ) dir_path = Path ( dir_str ) if dir_path . exists (): break print ( \"Directory not recognized, try again\" ) video_order = _get_videos ( dir_path ) _ffmpeg_concat ( dir_path , video_order ) input ( \"Press Enter to clean up\" ) _cleanup ( dir_path , video_order ) if __name__ == \"__main__\" : _main () Variables OUTPUT_VIDEO_FILE SORTING_FILE Functions concatenate_videos def concatenate_videos ( directory : Union [ str , pathlib . Path ], cleanup : bool = False ) -> None Concatenates a sequence of videos into a single video FFMPEG must be installed first All videos must have the same streams (same codecs, same time base, etc.) All videos in the directory should be named in alphanumeric order to match the order that they will be concatenated: e.g. \"0.mp4\", \"1.mp4\", \"2.mp4\", ... The videos to concatenate should be the only items in the directory Parameters: Name Type Description Default directory Union[str, Path] Directory containing the videos to concatenate None cleanup bool Whether to delete the individual videos after concatenation. Defaults to False. False View Source def concatenate_videos ( directory : Union [ str , Path ], cleanup : bool = False ) -> None : \"\"\"Concatenates a sequence of videos into a single video - FFMPEG must be installed first - All videos must have the same streams (same codecs, same time base, etc.) - All videos in the directory should be named in alphanumeric order to match the order that they will be concatenated: e.g. \" 0. mp4 \", \" 1. mp4 \", \" 2. mp4 \", ... - The videos to concatenate should be the only items in the directory Args: directory (Union[str, Path]): Directory containing the videos to concatenate cleanup (bool, optional): Whether to delete the individual videos after concatenation. Defaults to False. \"\"\" if isinstance ( directory , str ) : directory = Path ( directory ) if not directory . exists () : raise ValueError ( f \"Directory: {str(directory)} not recognized\" ) video_order = _get_videos ( directory ) _ffmpeg_concat ( directory , video_order ) print ( f \"Concatenated video saved to {str(Path(directory, OUTPUT_VIDEO_FILE))}\" ) if cleanup : _cleanup ( directory , video_order )","title":"Video Concatenation"},{"location":"reference/pyastrobee/utils/video_concatenation/#module-pyastrobeeutilsvideo_concatenation","text":"Concatenating a sequence of recorded videos together View Source \"\"\"Concatenating a sequence of recorded videos together\"\"\" from typing import Union import os import re from pathlib import Path # Files created during the concatenation process SORTING_FILE = \"join_video.txt\" OUTPUT_VIDEO_FILE = \"concatenated.mp4\" def concatenate_videos ( directory : Union [ str , Path ], cleanup : bool = False ) -> None : \"\"\"Concatenates a sequence of videos into a single video - FFMPEG must be installed first - All videos must have the same streams (same codecs, same time base, etc.) - All videos in the directory should be named in alphanumeric order to match the order that they will be concatenated: e.g. \"0.mp4\", \"1.mp4\", \"2.mp4\", ... - The videos to concatenate should be the only items in the directory Args: directory (Union[str, Path]): Directory containing the videos to concatenate cleanup (bool, optional): Whether to delete the individual videos after concatenation. Defaults to False. \"\"\" if isinstance ( directory , str ): directory = Path ( directory ) if not directory . exists (): raise ValueError ( f \"Directory: { str ( directory ) } not recognized\" ) video_order = _get_videos ( directory ) _ffmpeg_concat ( directory , video_order ) print ( f \"Concatenated video saved to { str ( Path ( directory , OUTPUT_VIDEO_FILE )) } \" ) if cleanup : _cleanup ( directory , video_order ) ## Helper functions below ## # https://stackoverflow.com/questions/4813061/non-alphanumeric-list-order-from-os-listdir def _sorted_alphanumeric ( data : list [ str ]) -> list [ str ]: \"\"\"Sort a list of strings via alphanumeric order Args: data (list[str]): Strings to sort Returns: list[str]: Alphanumerically-sorted data \"\"\" convert = lambda text : int ( text ) if text . isdigit () else text . lower () alphanum_key = lambda key : [ convert ( c ) for c in re . split ( \"([0-9]+)\" , key )] return sorted ( data , key = alphanum_key ) def _get_videos ( directory : Path ) -> list [ str ]: \"\"\"Get a sorted list of video files in concatenation order, within the given directory Args: directory (Path): Directory of the videos to concatenate Raises: RuntimeError: If the files are named improperly (must be alphanumeric for sorting, and MP4 format) Returns: list[str]: Video names in the order of concatenation \"\"\" for filename in os . listdir ( str ( directory )): p = Path ( directory , filename ) if p . name == SORTING_FILE : p . unlink () continue if p . name == OUTPUT_VIDEO_FILE : input ( \"WARNING: Video appears to be already concatenated. Press Enter to overwrite\" ) p . unlink () continue if p . suffix != \".mp4\" : raise RuntimeError ( \"Invalid file extension: \" , p . suffix , \". Expected .mp4\" ) if not p . stem . isnumeric (): raise RuntimeError ( \"Unrecognized file naming. Expect files named with their alphanumeric order\" ) return _sorted_alphanumeric ( os . listdir ( str ( directory ))) def _ffmpeg_concat ( directory : Path , order : list [ str ]): \"\"\"Run FFMPEG concatenation process Args: directory (Path): Directory of the videos to concatenate order (list[str]): Video names in the order of concatenation \"\"\" # FFMPEG needs to create a txt file to store the order of the videos first vid_order_file = str ( Path ( directory , SORTING_FILE )) with open ( vid_order_file , \"w\" ) as f : for vid in order : f . write ( \"file \" + str ( Path ( directory , vid ) . resolve ()) + \" \\n \" ) output_file = str ( Path ( directory , OUTPUT_VIDEO_FILE )) # Run the FFMPEG command os . system ( f \"ffmpeg -f concat -safe 0 -i { vid_order_file } -c copy { output_file } \" ) def _cleanup ( directory : Path , videos : list [ str ]): \"\"\"Delete all of the individual pre-concatenation videos, and the text file generated for video sorting Args: directory (Path): Directory containing the concatenated video files videos (list[str]): Video names to delete \"\"\" for vid in videos : p = Path ( directory , vid ) p . unlink () Path ( directory , SORTING_FILE ) . unlink () def _main (): \"\"\"Run as a script from user input\"\"\" while True : dir_str = input ( \"Provide a directory of videos to concatenate: \\n \" ) dir_path = Path ( dir_str ) if dir_path . exists (): break print ( \"Directory not recognized, try again\" ) video_order = _get_videos ( dir_path ) _ffmpeg_concat ( dir_path , video_order ) input ( \"Press Enter to clean up\" ) _cleanup ( dir_path , video_order ) if __name__ == \"__main__\" : _main ()","title":"Module pyastrobee.utils.video_concatenation"},{"location":"reference/pyastrobee/utils/video_concatenation/#variables","text":"OUTPUT_VIDEO_FILE SORTING_FILE","title":"Variables"},{"location":"reference/pyastrobee/utils/video_concatenation/#functions","text":"","title":"Functions"},{"location":"reference/pyastrobee/utils/video_concatenation/#concatenate_videos","text":"def concatenate_videos ( directory : Union [ str , pathlib . Path ], cleanup : bool = False ) -> None Concatenates a sequence of videos into a single video FFMPEG must be installed first All videos must have the same streams (same codecs, same time base, etc.) All videos in the directory should be named in alphanumeric order to match the order that they will be concatenated: e.g. \"0.mp4\", \"1.mp4\", \"2.mp4\", ... The videos to concatenate should be the only items in the directory Parameters: Name Type Description Default directory Union[str, Path] Directory containing the videos to concatenate None cleanup bool Whether to delete the individual videos after concatenation. Defaults to False. False View Source def concatenate_videos ( directory : Union [ str , Path ], cleanup : bool = False ) -> None : \"\"\"Concatenates a sequence of videos into a single video - FFMPEG must be installed first - All videos must have the same streams (same codecs, same time base, etc.) - All videos in the directory should be named in alphanumeric order to match the order that they will be concatenated: e.g. \" 0. mp4 \", \" 1. mp4 \", \" 2. mp4 \", ... - The videos to concatenate should be the only items in the directory Args: directory (Union[str, Path]): Directory containing the videos to concatenate cleanup (bool, optional): Whether to delete the individual videos after concatenation. Defaults to False. \"\"\" if isinstance ( directory , str ) : directory = Path ( directory ) if not directory . exists () : raise ValueError ( f \"Directory: {str(directory)} not recognized\" ) video_order = _get_videos ( directory ) _ffmpeg_concat ( directory , video_order ) print ( f \"Concatenated video saved to {str(Path(directory, OUTPUT_VIDEO_FILE))}\" ) if cleanup : _cleanup ( directory , video_order )","title":"concatenate_videos"}]}